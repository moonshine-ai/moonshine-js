var extendStatics=function(e,t){return extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])},extendStatics(e,t)};function __extends(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function r(){this.constructor=e}extendStatics(e,t),e.prototype=null===t?Object.create(t):(r.prototype=t.prototype,new r)}var __assign=function(){return __assign=Object.assign||function(e){for(var t,r=1,n=arguments.length;r<n;r++)for(var a in t=arguments[r])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e},__assign.apply(this,arguments)};function __awaiter(e,t,r,n){return new(r||(r=Promise))((function(a,o){function i(e){try{l(n.next(e))}catch(e){o(e)}}function s(e){try{l(n.throw(e))}catch(e){o(e)}}function l(e){var t;e.done?a(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(i,s)}l((n=n.apply(e,t||[])).next())}))}function __generator(e,t){var r,n,a,o={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]},i=Object.create(("function"==typeof Iterator?Iterator:Object).prototype);return i.next=s(0),i.throw=s(1),i.return=s(2),"function"==typeof Symbol&&(i[Symbol.iterator]=function(){return this}),i;function s(s){return function(l){return function(s){if(r)throw new TypeError("Generator is already executing.");for(;i&&(i=0,s[0]&&(o=0)),o;)try{if(r=1,n&&(a=2&s[0]?n.return:s[0]?n.throw||((a=n.return)&&a.call(n),0):n.next)&&!(a=a.call(n,s[1])).done)return a;switch(n=0,a&&(s=[2&s[0],a.value]),s[0]){case 0:case 1:a=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,n=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(a=o.trys,(a=a.length>0&&a[a.length-1])||6!==s[0]&&2!==s[0])){o=0;continue}if(3===s[0]&&(!a||s[1]>a[0]&&s[1]<a[3])){o.label=s[1];break}if(6===s[0]&&o.label<a[1]){o.label=a[1],a=s;break}if(a&&o.label<a[2]){o.label=a[2],o.ops.push(s);break}a[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],n=0}finally{r=a=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,l])}}}"function"==typeof SuppressedError&&SuppressedError;
/*!
 * ONNX Runtime Web v1.22.0-dev.20250306-ccf8fdd9ea
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var Un=Object.defineProperty,Af=Object.getOwnPropertyDescriptor,kf=Object.getOwnPropertyNames,Ef=Object.prototype.hasOwnProperty,Nn=(e=function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')},typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):e),e,W=(e,t)=>()=>(e&&(t=e(e=0)),t),Zt=(e,t)=>{for(var r in t)Un(e,r,{get:t[r],enumerable:!0})},Pf=(e,t,r,n)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let a of kf(t))!Ef.call(e,a)&&a!==r&&Un(e,a,{get:()=>t[a],enumerable:!(n=Af(t,a))||n.enumerable});return e},br=e=>Pf(Un({},"__esModule",{value:!0}),e),_r,Tt,Ct,zf,Wa,Vn=W((()=>{_r=new Map,Tt=[],Ct=(e,t,r)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{let n=_r.get(e);if(void 0===n)_r.set(e,{backend:t,priority:r});else{if(n.priority>r)return;if(n.priority===r&&n.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){let t=Tt.indexOf(e);-1!==t&&Tt.splice(t,1);for(let t=0;t<Tt.length;t++)if(_r.get(Tt[t]).priority<=r)return void Tt.splice(t,0,e);Tt.push(e)}}},zf=async e=>{let t=_r.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{let r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return r||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},Wa=async e=>{let t,r=e.executionProviders||[],n=r.map((e=>"string"==typeof e?e:e.name)),a=0===n.length?Tt:n,o=[],i=new Set;for(let e of a){let r=await zf(e);"string"==typeof r?o.push({name:e,err:r}):(t||(t=r),t===r&&i.add(e))}if(!t)throw new Error(`no available backend found. ERR: ${o.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`);for(let{name:e,err:t}of o)n.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let s=r.filter((e=>i.has("string"==typeof e?e:e.name)));return[t,new Proxy(e,{get:(e,t)=>"executionProviders"===t?s:Reflect.get(e,t)})]}})),La=W((()=>{Vn()})),Ga,Ha=W((()=>{Ga="1.22.0-dev.20250306-aafa8d170a"})),Fa,Ue,Wn=W((()=>{Ha(),Fa="warning",Ue={wasm:{},webgl:{},webgpu:{},versions:{common:Ga},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);Fa=e}},get logLevel(){return Fa}},Object.defineProperty(Ue,"logLevel",{enumerable:!0})})),we,qa=W((()=>{Wn(),we=Ue})),Ka,ja,Za=W((()=>{Ka=(e,t)=>{let r=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let n=r.getContext("2d");if(null!=n){let a,o;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],o=e.dims[3]):(a=e.dims[3],o=e.dims[2]);let i,s,l=void 0!==t?.format?t.format:"RGB",d=t?.norm;void 0===d||void 0===d.mean?i=[255,255,255,255]:"number"==typeof d.mean?i=[d.mean,d.mean,d.mean,d.mean]:(i=[d.mean[0],d.mean[1],d.mean[2],0],void 0!==d.mean[3]&&(i[3]=d.mean[3])),void 0===d||void 0===d.bias?s=[0,0,0,0]:"number"==typeof d.bias?s=[d.bias,d.bias,d.bias,d.bias]:(s=[d.bias[0],d.bias[1],d.bias[2],0],void 0!==d.bias[3]&&(s[3]=d.bias[3]));let u=o*a,c=0,p=u,g=2*u,A=-1;"RGBA"===l?(c=0,p=u,g=2*u,A=3*u):"RGB"===l?(c=0,p=u,g=2*u):"RBG"===l&&(c=0,g=u,p=2*u);for(let t=0;t<o;t++)for(let r=0;r<a;r++){let a=(e.data[c++]-s[0])*i[0],o=(e.data[p++]-s[1])*i[1],l=(e.data[g++]-s[2])*i[2],d=-1===A?255:(e.data[A++]-s[3])*i[3];n.fillStyle="rgba("+a+","+o+","+l+","+d+")",n.fillRect(r,t,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},ja=(e,t)=>{let r,n=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null==n)throw new Error("Can not access image data");{let a,o,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],o=e.dims[1],i=e.dims[3]):(a=e.dims[3],o=e.dims[2],i=e.dims[1]);let s,l,d=void 0!==t&&void 0!==t.format?t.format:"RGB",u=t?.norm;void 0===u||void 0===u.mean?s=[255,255,255,255]:"number"==typeof u.mean?s=[u.mean,u.mean,u.mean,u.mean]:(s=[u.mean[0],u.mean[1],u.mean[2],255],void 0!==u.mean[3]&&(s[3]=u.mean[3])),void 0===u||void 0===u.bias?l=[0,0,0,0]:"number"==typeof u.bias?l=[u.bias,u.bias,u.bias,u.bias]:(l=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(l[3]=u.bias[3]));let c=o*a;if(void 0!==t&&(void 0!==t.format&&4===i&&"RGBA"!==t.format||3===i&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");let p=4,g=0,A=1,h=2,B=3,m=0,C=c,w=2*c,b=-1;"RGBA"===d?(m=0,C=c,w=2*c,b=3*c):"RGB"===d?(m=0,C=c,w=2*c):"RBG"===d&&(m=0,w=c,C=2*c),r=n.createImageData(a,o);for(let t=0;t<o*a;g+=p,A+=p,h+=p,B+=p,t++)r.data[g]=(e.data[m++]-l[0])*s[0],r.data[A]=(e.data[C++]-l[1])*s[1],r.data[h]=(e.data[w++]-l[2])*s[2],r.data[B]=-1===b?255:(e.data[b++]-l[3])*s[3]}return r}})),Ln,Qa,Ya,Xa,Ja,es,ts=W((()=>{wr(),Ln=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");let r,n,{height:a,width:o}=t,i=t.norm??{mean:255,bias:0};r="number"==typeof i.mean?[i.mean,i.mean,i.mean,i.mean]:[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],n="number"==typeof i.bias?[i.bias,i.bias,i.bias,i.bias]:[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];let s=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",d=a*o,u="RGBA"===l?new Float32Array(4*d):new Float32Array(3*d),c=4,p=0,g=1,A=2,h=3,B=0,m=d,C=2*d,w=-1;"RGB"===s&&(c=3,p=0,g=1,A=2,h=-1),"RGBA"===l?w=3*d:"RBG"===l?(B=0,C=d,m=2*d):"BGR"===l&&(C=0,m=d,B=2*d);for(let t=0;t<d;t++,p+=c,A+=c,g+=c,h+=c)u[B++]=(e[p]+n[0])/r[0],u[m++]=(e[g]+n[1])/r[1],u[C++]=(e[A]+n[2])/r[2],-1!==w&&-1!==h&&(u[w++]=(e[h]+n[3])/r[3]);return new Be("float32",u,"RGBA"===l?[1,4,a,o]:[1,3,a,o])},Qa=async(e,t)=>{let r,n=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,o=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,i="string"==typeof e,s=t??{},l=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},d=e=>typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(n){let n=l();n.width=e.width,n.height=e.height;let a=d(n);if(null==a)throw new Error("Can not access image data");{let n=e.height,o=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,o=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=n,s.width=o}else s.tensorFormat="RGBA",s.height=n,s.width=o;a.drawImage(e,0,0),r=a.getImageData(0,0,o,n).data}}else{if(!a){if(o){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");let n=l();n.width=e.width,n.height=e.height;let a=d(n);if(null!=a){let t=e.height,n=e.width;return a.drawImage(e,0,0,n,t),r=a.getImageData(0,0,n,t).data,s.height=t,s.width=n,Ln(r,s)}throw new Error("Can not access image data")}if(i)return new Promise(((t,r)=>{let n=l(),a=d(n);if(!e||!a)return r();let o=new Image;o.crossOrigin="Anonymous",o.src=e,o.onload=()=>{n.width=o.width,n.height=o.height,a.drawImage(o,0,0,n.width,n.height);let e=a.getImageData(0,0,n.width,n.height);s.height=n.height,s.width=n.width,t(Ln(e.data,s))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let n,a;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,a=t.resizedWidth):(n=e.height,a=e.width),void 0!==t&&(s=t),s.format="RGBA",s.height=n,s.width=a,void 0!==t){let t=l();t.width=a,t.height=n;let o=d(t);if(null==o)throw new Error("Can not access image data");o.putImageData(e,0,0),r=o.getImageData(0,0,a,n).data}else r=e.data}}if(void 0!==r)return Ln(r,s);throw new Error("Input data provided is not supported - aborted tensor creation")},Ya=(e,t)=>{let{width:r,height:n,download:a,dispose:o}=t;return new Be({location:"texture",type:"float32",texture:e,dims:[1,n,r,4],download:a,dispose:o})},Xa=(e,t)=>{let{dataType:r,dims:n,download:a,dispose:o}=t;return new Be({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:n,download:a,dispose:o})},Ja=(e,t)=>{let{dataType:r,dims:n,download:a,dispose:o}=t;return new Be({location:"ml-tensor",type:r??"float32",mlTensor:e,dims:n,download:a,dispose:o})},es=(e,t,r)=>new Be({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})})),It,Qt,rs,ns,os=W((()=>{It=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Qt=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),rs=!1,ns=()=>{if(!rs){rs=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,t=typeof BigUint64Array<"u"&&BigUint64Array.from,r=globalThis.Float16Array,n=typeof r<"u"&&r.from;e&&(It.set("int64",BigInt64Array),Qt.set(BigInt64Array,"int64")),t&&(It.set("uint64",BigUint64Array),Qt.set(BigUint64Array,"uint64")),n?(It.set("float16",r),Qt.set(r,"float16")):It.set("float16",Uint16Array)}}})),is,as,ss=W((()=>{wr(),is=e=>{let t=1;for(let r=0;r<e.length;r++){let n=e[r];if("number"!=typeof n||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},as=(e,t)=>{switch(e.location){case"cpu":return new Be(e.type,e.data,t);case"cpu-pinned":return new Be({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Be({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Be({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new Be({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}})),Be,wr=W((()=>{Za(),ts(),os(),ss(),Be=class{constructor(e,t,r){let n,a;if(ns(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,n=e.type,a=e.dims,e.location){case"cpu-pinned":{let t=It.get(n);if(!t)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==n)throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint8"!==n&&"bool"!==n&&"uint4"!==n&&"int4"!==n)throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint64"!==n&&"int8"!==n&&"uint8"!==n&&"bool"!==n&&"uint4"!==n&&"int4"!==n)throw new TypeError(`unsupported type "${n}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,i;if("string"==typeof e)if(n=e,i=r,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");o=t}else{let r=It.get(e);if(void 0===r)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&r===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${r.name} as data.`);o="uint64"===e||"int64"===e?r.from(t,BigInt):r.from(t)}else if(t instanceof r)o=t;else if(t instanceof Uint8ClampedArray){if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");o=Uint8Array.from(t)}else{if(!("float16"===e&&t instanceof Uint16Array&&r!==Uint16Array))throw new TypeError(`A ${n} tensor's data must be type of ${r}`);o=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length)}}else if(i=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)n="string",o=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);n="bool",o=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)n="uint8",o=Uint8Array.from(e);else{let t=Qt.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=t,o=e}if(void 0===i)i=[o.length];else if(!Array.isArray(i))throw new TypeError("A tensor's dims must be a number array");a=i,this.cpuData=o,this.dataLocation="cpu"}let o=is(a);if(this.cpuData&&o!==this.cpuData.length&&("uint4"!==n&&"int4"!==n||Math.ceil(o/2)!==this.cpuData.length))throw new Error(`Tensor's size(${o}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=a,this.size=o}static async fromImage(e,t){return Qa(e,t)}static fromTexture(e,t){return Ya(e,t)}static fromGpuBuffer(e,t){return Xa(e,t)}static fromMLTensor(e,t){return Ja(e,t)}static fromPinnedBuffer(e,t,r){return es(e,t,r)}toDataURL(e){return Ka(this,e)}toImageData(e){return ja(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return as(this,e)}}})),qe,Gn=W((()=>{wr(),qe=Be})),vr,us,Ne,De,Hn=W((()=>{Wn(),vr=(e,t)=>{(typeof Ue.trace>"u"?!Ue.wasm.trace:!Ue.trace)||console.timeStamp(`${e}::ORT::${t}`)},us=(e,t)=>{let r=(new Error).stack?.split(/\r\n|\r|\n/g)||[],n=!1;for(let a=0;a<r.length;a++){if(n&&!r[a].includes("TRACE_FUNC")){let n=`FUNC_${e}::${r[a].trim().split(" ")[1]}`;return t&&(n+=`::${t}`),void vr("CPU",n)}r[a].includes("TRACE_FUNC")&&(n=!0)}},Ne=e=>{(typeof Ue.trace>"u"?!Ue.wasm.trace:!Ue.trace)||us("BEGIN",e)},De=e=>{(typeof Ue.trace>"u"?!Ue.wasm.trace:!Ue.trace)||us("END",e)}})),$r,ds=W((()=>{Vn(),Gn(),Hn(),$r=class e{constructor(e){this.handler=e}async run(e,t,r){Ne();let n={},a={};if("object"!=typeof e||null===e||e instanceof qe||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof qe)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(let e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if("object"==typeof r&&null!==r)a=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else{let e=!1,i=Object.getOwnPropertyNames(t);for(let r of this.outputNames)if(-1!==i.indexOf(r)){let a=t[r];(null===a||a instanceof qe)&&(e=!0,o=!1,n[r]=a)}if(e){if("object"==typeof r&&null!==r)a=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else a=t}}else if(typeof t<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(typeof e[t]>"u")throw new Error(`input '${t}' is missing in 'feeds'.`);if(o)for(let e of this.outputNames)n[e]=null;let i=await this.handler.run(e,n,a),s={};for(let e in i)if(Object.hasOwnProperty.call(i,e)){let t=i[e];s[e]=t instanceof qe?t:new qe(t.type,t.data,t.dims)}return De(),s}async release(){return this.handler.dispose()}static async create(t,r,n,a){Ne();let o,i={};if("string"==typeof t){if(o=t,"object"==typeof r&&null!==r)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(o=t,"object"==typeof r&&null!==r)i=r;else if(typeof r<"u")throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{let e=t,s=0,l=t.byteLength;if("object"==typeof r&&null!==r)i=r;else if("number"==typeof r){if(s=r,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(l=t.byteLength-s,"number"==typeof n){if(l=n,!Number.isSafeInteger(l))throw new RangeError("'byteLength' must be an integer.");if(l<=0||s+l>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-s}].`);if("object"==typeof a&&null!==a)i=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else if(typeof n<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof r<"u")throw new TypeError("'options' must be an object.");o=new Uint8Array(e,s,l)}}let[s,l]=await Wa(i),d=await s.createInferenceSessionHandler(o,l);return De(),new e(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}})),Of,ls=W((()=>{ds(),Of=$r})),cs=W((()=>{})),ps=W((()=>{})),ms=W((()=>{})),fs=W((()=>{})),Fn={};Zt(Fn,{InferenceSession:()=>Of,TRACE:()=>vr,TRACE_FUNC_BEGIN:()=>Ne,TRACE_FUNC_END:()=>De,Tensor:()=>qe,env:()=>we,registerBackend:()=>Ct});var Ge=W((()=>{La(),qa(),ls(),Gn(),cs(),ps(),Hn(),ms(),fs()})),xr=W((()=>{})),bs={};Zt(bs,{default:()=>Bf});var gs,ys,Bf,_s=W((()=>{qn(),bt(),Sr(),gs="ort-wasm-proxy-worker",(ys=globalThis.self?.name===gs)&&(self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":Tr(r.wasm).then((()=>{Cr(r).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}))}),(e=>{postMessage({type:t,err:e})}));break;case"init-ep":{let{epName:e,env:n}=r;Ir(n,e).then((()=>{postMessage({type:t})}),(e=>{postMessage({type:t,err:e})}));break}case"copy-from":{let{buffer:e}=r,n=Yt(e);postMessage({type:t,out:n});break}case"create":{let{model:e,options:n}=r;Ar(e,n).then((e=>{postMessage({type:t,out:e})}),(e=>{postMessage({type:t,err:e})}));break}case"release":kr(r),postMessage({type:t});break;case"run":{let{sessionId:e,inputIndices:n,inputs:a,outputIndices:o,options:i}=r;Er(e,n,a,o,new Array(o.length).fill(null),i).then((e=>{e.some((e=>"cpu"!==e[3]))?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},zr([...a,...e]))}),(e=>{postMessage({type:t,err:e})}));break}case"end-profiling":Pr(r),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),Bf=ys?null:e=>new Worker(e??Ve,{type:"module",name:gs})})),vs={};Zt(vs,{default:()=>Df});var Kn,ws,Df,Mf,$s=W((()=>{Kn=import.meta.url,ws=async function(e={}){var t,r,n=e,a=new Promise(((e,n)=>{t=e,r=n})),o="object"==typeof window,i=typeof WorkerGlobalScope<"u",s=i&&self.name?.startsWith("em-pthread");n.mountExternalData=(e,t)=>{e.startsWith("./")&&(e=e.substring(2)),(n.Bd||(n.Bd=new Map)).set(e,t)},n.unmountExternalData=()=>{delete n.Bd};var l=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor;let d=()=>{let e=(e,t,r)=>(...n)=>{let a=Pt,o=t?.();n=e(...n);let i=t?.();return o!==i&&(e=i,r(o),t=r=null),Pt!=a?new Promise(((e,t)=>{er={resolve:e,reject:t}})):n},t=e=>async(...t)=>{try{if(n.Cd)throw Error("Session already started");let r=n.Cd={be:t[0],errors:[]},a=await e(...t);if(n.Cd!==r)throw Error("Session mismatch");n.Dd?.flush();let o=r.errors;if(0<o.length){let e=await Promise.all(o);if(e=e.filter((e=>e)),0<e.length)throw Error(e.join("\n"))}return a}finally{n.Cd=null}};n._OrtCreateSession=e(n._OrtCreateSession,(()=>n._OrtCreateSession),(e=>n._OrtCreateSession=e)),n._OrtRun=t(e(n._OrtRun,(()=>n._OrtRun),(e=>n._OrtRun=e))),n._OrtRunWithBinding=t(e(n._OrtRunWithBinding,(()=>n._OrtRunWithBinding),(e=>n._OrtRunWithBinding=e))),n._OrtBindInput=e(n._OrtBindInput,(()=>n._OrtBindInput),(e=>n._OrtBindInput=e)),d=void 0};n.jsepInit=(e,t)=>{if(d?.(),"webgpu"===e){[n.Dd,n.Rd,n.Vd,n.Hd,n.Ud,n.hc,n.Wd,n.Zd,n.Sd,n.Td,n.Xd]=t;let e=n.Dd;n.jsepRegisterBuffer=(t,r,n,a)=>e.registerBuffer(t,r,n,a),n.jsepGetBuffer=t=>e.getBuffer(t),n.jsepCreateDownloader=(t,r,n)=>e.createDownloader(t,r,n),n.jsepOnCreateSession=t=>{e.onCreateSession(t)},n.jsepOnReleaseSession=t=>{e.onReleaseSession(t)},n.jsepOnRunStart=t=>e.onRunStart(t),n.$d=(t,r)=>{e.upload(t,r)}}else if("webnn"===e){[n.Dd,n.Yd,n.Id,n.jsepEnsureTensor,n.Jd,n.jsepDownloadTensor]=t,n.jsepReleaseTensorId=n.Id,n.jsepUploadTensor=n.Jd;let e=n.Dd;n.jsepOnRunStart=t=>e.onRunStart(t),n.jsepOnRunEnd=e.onRunEnd.bind(e),n.jsepRegisterMLContext=(t,r)=>{e.registerMLContext(t,r)},n.jsepOnReleaseSession=t=>{e.onReleaseSession(t)},n.jsepCreateMLTensorDownloader=(t,r)=>e.createMLTensorDownloader(t,r),n.jsepRegisterMLTensor=(t,r,n,a)=>e.registerMLTensor(t,r,n,a),n.jsepCreateMLContext=t=>e.createMLContext(t),n.jsepRegisterMLConstant=(t,r,a,o,i)=>e.registerMLConstant(t,r,a,o,i,n.Bd),n.jsepRegisterGraphInput=e.registerGraphInput.bind(e),n.jsepIsGraphInput=e.isGraphInput.bind(e),n.jsepCreateTemporaryTensor=e.createTemporaryTensor.bind(e)}};var u,c,p=Object.assign({},n),g=(e,t)=>{throw t},A="";(o||i)&&(i?A=self.location.href:typeof document<"u"&&document.currentScript&&(A=document.currentScript.src),Kn&&(A=Kn),A=A.startsWith("blob:")?"":A.slice(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1),i&&(c=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),u=async e=>{if(T(e))return new Promise(((t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r(n.status)},n.onerror=r,n.send(null)}));var t=await fetch(e,{credentials:"same-origin"});if(t.ok)return t.arrayBuffer();throw Error(t.status+" : "+t.url)});var h=console.log.bind(console),B=console.error.bind(console),m=h,C=B;Object.assign(n,p),p=null;var w,b,K,f,Q,W,F,_,y,v,E,G,R,x=n.wasmBinary,S=!1,T=e=>e.startsWith("file://");function Z(){return w.buffer!=f.buffer&&U(),f}function X(){return w.buffer!=f.buffer&&U(),Q}function V(){return w.buffer!=f.buffer&&U(),W}function k(){return w.buffer!=f.buffer&&U(),F}function M(){return w.buffer!=f.buffer&&U(),_}function H(){return w.buffer!=f.buffer&&U(),y}function Y(){return w.buffer!=f.buffer&&U(),v}function L(){return w.buffer!=f.buffer&&U(),R}if(s){let e=function(t){try{var r=t.data,a=r.yd;if("load"===a){let t=[];self.onmessage=e=>t.push(e),self.startWorker=()=>{postMessage({yd:"loaded"});for(let r of t)e(r);self.onmessage=e};for(let e of r.Od)n[e]&&!n[e].proxy||(n[e]=(...t)=>{postMessage({yd:"callHandler",Nd:e,args:t})},"print"==e&&(m=n[e]),"printErr"==e&&(C=n[e]));w=r.he,U(),N(r.ie)}else if("run"===a){we(r.xd),Qn(r.xd,0,0,1,0,0),Be(),Tt(r.xd),I||(Cn(),I=!0);try{be(r.de,r.Fd)}catch(e){if("unwind"!=e)throw e}}else"setimmediate"!==r.target&&("checkMailbox"===a?I&&Zt():a&&(C(`worker: received unknown command ${a}`),C(r)))}catch(e){throw Wn(),e}};var N,I=!1;C=function(...e){e=e.join(" "),console.error(e)},self.alert=function(...e){postMessage({yd:"alert",text:e.join(" "),fe:wn()})},self.onunhandledrejection=e=>{throw e.reason||e},self.onmessage=e}function U(){var e=w.buffer;n.HEAP8=f=new Int8Array(e),n.HEAP16=W=new Int16Array(e),n.HEAPU8=Q=new Uint8Array(e),n.HEAPU16=F=new Uint16Array(e),n.HEAP32=_=new Int32Array(e),n.HEAPU32=y=new Uint32Array(e),n.HEAPF32=v=new Float32Array(e),n.HEAPF64=R=new Float64Array(e),n.HEAP64=E=new BigInt64Array(e),n.HEAPU64=G=new BigUint64Array(e)}function D(){s?startWorker(n):hn.Bb()}s||(w=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0}),U());var J,P=0,O=null;function z(){if(0==--P&&O){var e=O;O=null,e()}}function j(e){throw C(e="Aborted("+e+")"),S=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),r(e),e}function $(){return{a:{Ta:te,Va:ee,W:fe,la:We,b:ve,u:Ee,R:Ge,Za:Re,d:xe,pb:Te,g:_e,T:ke,Ga:Me,lb:Le,nb:Ne,Ha:Ie,Ea:Ue,wb:De,Da:Je,pa:Pe,mb:Oe,jb:ze,Fa:je,kb:$e,Ma:tt,za:st,eb:dt,cb:mt,ya:wt,V:bt,N:Kt,db:ft,ma:Gt,fb:Rt,zb:xt,hb:Xt,qb:kt,ab:Mt,Aa:Ht,yb:Tt,Ja:Yt,S:It,Wa:Ut,$:nr,H:or,E:lr,l:pt,F:ur,B:Ar,X:hr,J:Br,v:mr,O:Cr,D:wr,t:br,A:Kr,z:fr,w:Qr,r:Wr,tb:Fr,ub:Er,vb:Gr,rb:Rr,sb:xr,bb:Zr,Oa:Xr,La:kr,y:Yr,ja:Lr,Ba:Nr,Ka:Vr,qa:Ir,Ia:Ur,ib:Dr,U:Tr,fa:Jr,Sa:Pr,gb:Or,Qa:qr,Pa:en,Ab:an,Ca:on,ob:ue,aa:sn,oa:ln,xb:dn,na:cn,$a:ao,ia:Co,sa:Qo,ga:ro,da:co,ua:Ko,p:eo,e:ka,c:Xa,ea:lo,f:Ma,n:Ya,k:za,Y:Na,ka:ja,j:to,wa:so,Ra:_o,ca:Bo,Ua:Fo,P:uo,K:Ua,_:ho,Q:no,Z:wo,x:Ia,m:Va,va:Ao,i:Za,h:La,ra:Wo,ta:fo,o:Ha,q:Da,s:Pa,I:Oa,C:qa,L:$a,xa:io,_a:oo,G:mo,Ya:po,ba:bo,M:Ja,Xa:go,ha:pn,a:w,Na:le}}}var q={1320978:()=>typeof wasmOffsetConverter<"u",1321035:(e,t,r,a,o)=>{if(void 0===n||!n.Bd)return 1;if((e=Ve(Number(e>>>0))).startsWith("./")&&(e=e.substring(2)),!(e=n.Bd.get(e)))return 2;if(t=Number(t>>>0),r=Number(r>>>0),a=Number(a>>>0),t+r>e.byteLength)return 3;try{let i=e.subarray(t,t+r);switch(o){case 0:X().set(i,a>>>0);break;case 1:n.$d(a,i);break;default:return 4}return 0}catch{return 4}},1321750:(e,t,r)=>{n.Jd(e,X().subarray(t>>>0,t+r>>>0))},1321813:()=>n.Yd(),1321854:e=>{n.Id(e)},1321890:()=>{n.Sd()},1321921:()=>{n.Td()},1321950:()=>{n.Xd()},1321975:e=>n.Rd(e),1322008:e=>n.Vd(e),1322040:(e,t,r)=>{n.Hd(Number(e),Number(t),Number(r),!0)},1322103:(e,t,r)=>{n.Hd(Number(e),Number(t),Number(r))},1322160:e=>{n.hc("Abs",e,void 0)},1322211:e=>{n.hc("Neg",e,void 0)},1322262:e=>{n.hc("Floor",e,void 0)},1322315:e=>{n.hc("Ceil",e,void 0)},1322367:e=>{n.hc("Reciprocal",e,void 0)},1322425:e=>{n.hc("Sqrt",e,void 0)},1322477:e=>{n.hc("Exp",e,void 0)},1322528:e=>{n.hc("Erf",e,void 0)},1322579:e=>{n.hc("Sigmoid",e,void 0)},1322634:(e,t,r)=>{n.hc("HardSigmoid",e,{alpha:t,beta:r})},1322713:e=>{n.hc("Log",e,void 0)},1322764:e=>{n.hc("Sin",e,void 0)},1322815:e=>{n.hc("Cos",e,void 0)},1322866:e=>{n.hc("Tan",e,void 0)},1322917:e=>{n.hc("Asin",e,void 0)},1322969:e=>{n.hc("Acos",e,void 0)},1323021:e=>{n.hc("Atan",e,void 0)},1323073:e=>{n.hc("Sinh",e,void 0)},1323125:e=>{n.hc("Cosh",e,void 0)},1323177:e=>{n.hc("Asinh",e,void 0)},1323230:e=>{n.hc("Acosh",e,void 0)},1323283:e=>{n.hc("Atanh",e,void 0)},1323336:e=>{n.hc("Tanh",e,void 0)},1323388:e=>{n.hc("Not",e,void 0)},1323439:(e,t,r)=>{n.hc("Clip",e,{min:t,max:r})},1323508:e=>{n.hc("Clip",e,void 0)},1323560:(e,t)=>{n.hc("Elu",e,{alpha:t})},1323618:e=>{n.hc("Gelu",e,void 0)},1323670:e=>{n.hc("Relu",e,void 0)},1323722:(e,t)=>{n.hc("LeakyRelu",e,{alpha:t})},1323786:(e,t)=>{n.hc("ThresholdedRelu",e,{alpha:t})},1323856:(e,t)=>{n.hc("Cast",e,{to:t})},1323914:e=>{n.hc("Add",e,void 0)},1323965:e=>{n.hc("Sub",e,void 0)},1324016:e=>{n.hc("Mul",e,void 0)},1324067:e=>{n.hc("Div",e,void 0)},1324118:e=>{n.hc("Pow",e,void 0)},1324169:e=>{n.hc("Equal",e,void 0)},1324222:e=>{n.hc("Greater",e,void 0)},1324277:e=>{n.hc("GreaterOrEqual",e,void 0)},1324339:e=>{n.hc("Less",e,void 0)},1324391:e=>{n.hc("LessOrEqual",e,void 0)},1324450:(e,t,r,a,o)=>{n.hc("ReduceMean",e,{keepDims:!!t,noopWithEmptyAxes:!!r,axes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1324625:(e,t,r,a,o)=>{n.hc("ReduceMax",e,{keepDims:!!t,noopWithEmptyAxes:!!r,axes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1324799:(e,t,r,a,o)=>{n.hc("ReduceMin",e,{keepDims:!!t,noopWithEmptyAxes:!!r,axes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1324973:(e,t,r,a,o)=>{n.hc("ReduceProd",e,{keepDims:!!t,noopWithEmptyAxes:!!r,axes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1325148:(e,t,r,a,o)=>{n.hc("ReduceSum",e,{keepDims:!!t,noopWithEmptyAxes:!!r,axes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1325322:(e,t,r,a,o)=>{n.hc("ReduceL1",e,{keepDims:!!t,noopWithEmptyAxes:!!r,axes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1325495:(e,t,r,a,o)=>{n.hc("ReduceL2",e,{keepDims:!!t,noopWithEmptyAxes:!!r,axes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1325668:(e,t,r,a,o)=>{n.hc("ReduceLogSum",e,{keepDims:!!t,noopWithEmptyAxes:!!r,axes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1325845:(e,t,r,a,o)=>{n.hc("ReduceSumSquare",e,{keepDims:!!t,noopWithEmptyAxes:!!r,axes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1326025:(e,t,r,a,o)=>{n.hc("ReduceLogSumExp",e,{keepDims:!!t,noopWithEmptyAxes:!!r,axes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1326205:e=>{n.hc("Where",e,void 0)},1326258:(e,t,r)=>{n.hc("Transpose",e,{perm:t?Array.from(M().subarray(Number(t)>>>0,Number(r)>>>0)):[]})},1326382:(e,t,r,a)=>{n.hc("DepthToSpace",e,{blocksize:t,mode:Ve(r),format:a?"NHWC":"NCHW"})},1326515:(e,t,r,a)=>{n.hc("DepthToSpace",e,{blocksize:t,mode:Ve(r),format:a?"NHWC":"NCHW"})},1326648:(e,t,r,a,o,i,s,l,d,u,c,p,g,A,h)=>{n.hc("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:t,dilations:[r],group:a,kernelShape:[o],pads:[i,s],strides:[l],wIsConst:()=>!!Z()[u>>>0],outputPadding:c?Array.from(M().subarray(Number(c)>>>0,Number(p)>>>0)):[],outputShape:g?Array.from(M().subarray(Number(g)>>>0,Number(A)>>>0)):[],activation:Ve(h)})},1327081:(e,t,r,a,o,i,s,l,d,u,c,p,g,A)=>{n.hc("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:Array.from(M().subarray(Number(r)>>>0,2+(Number(r)>>>0)>>>0)),group:a,kernelShape:Array.from(M().subarray(Number(o)>>>0,2+(Number(o)>>>0)>>>0)),pads:Array.from(M().subarray(Number(i)>>>0,4+(Number(i)>>>0)>>>0)),strides:Array.from(M().subarray(Number(s)>>>0,2+(Number(s)>>>0)>>>0)),wIsConst:()=>!!Z()[d>>>0],outputPadding:u?Array.from(M().subarray(Number(u)>>>0,Number(c)>>>0)):[],outputShape:p?Array.from(M().subarray(Number(p)>>>0,Number(g)>>>0)):[],activation:Ve(A)})},1327742:(e,t,r,a,o,i,s,l,d,u,c,p,g,A,h)=>{n.hc("ConvTranspose",e,{format:d?"NHWC":"NCHW",autoPad:t,dilations:[r],group:a,kernelShape:[o],pads:[i,s],strides:[l],wIsConst:()=>!!Z()[u>>>0],outputPadding:c?Array.from(M().subarray(Number(c)>>>0,Number(p)>>>0)):[],outputShape:g?Array.from(M().subarray(Number(g)>>>0,Number(A)>>>0)):[],activation:Ve(h)})},1328175:(e,t,r,a,o,i,s,l,d,u,c,p,g,A)=>{n.hc("ConvTranspose",e,{format:l?"NHWC":"NCHW",autoPad:t,dilations:Array.from(M().subarray(Number(r)>>>0,2+(Number(r)>>>0)>>>0)),group:a,kernelShape:Array.from(M().subarray(Number(o)>>>0,2+(Number(o)>>>0)>>>0)),pads:Array.from(M().subarray(Number(i)>>>0,4+(Number(i)>>>0)>>>0)),strides:Array.from(M().subarray(Number(s)>>>0,2+(Number(s)>>>0)>>>0)),wIsConst:()=>!!Z()[d>>>0],outputPadding:u?Array.from(M().subarray(Number(u)>>>0,Number(c)>>>0)):[],outputShape:p?Array.from(M().subarray(Number(p)>>>0,Number(g)>>>0)):[],activation:Ve(A)})},1328836:(e,t)=>{n.hc("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},1328927:(e,t,r,a,o,i,s,l,d,u,c,p,g,A)=>{n.hc("AveragePool",e,{format:A?"NHWC":"NCHW",auto_pad:t,ceil_mode:r,count_include_pad:a,storage_order:o,dilations:i?Array.from(M().subarray(Number(i)>>>0,Number(s)>>>0)):[],kernel_shape:l?Array.from(M().subarray(Number(l)>>>0,Number(d)>>>0)):[],pads:u?Array.from(M().subarray(Number(u)>>>0,Number(c)>>>0)):[],strides:p?Array.from(M().subarray(Number(p)>>>0,Number(g)>>>0)):[]})},1329406:(e,t)=>{n.hc("GlobalAveragePool",e,{format:t?"NHWC":"NCHW"})},1329497:(e,t,r,a,o,i,s,l,d,u,c,p,g,A)=>{n.hc("AveragePool",e,{format:A?"NHWC":"NCHW",auto_pad:t,ceil_mode:r,count_include_pad:a,storage_order:o,dilations:i?Array.from(M().subarray(Number(i)>>>0,Number(s)>>>0)):[],kernel_shape:l?Array.from(M().subarray(Number(l)>>>0,Number(d)>>>0)):[],pads:u?Array.from(M().subarray(Number(u)>>>0,Number(c)>>>0)):[],strides:p?Array.from(M().subarray(Number(p)>>>0,Number(g)>>>0)):[]})},1329976:(e,t)=>{n.hc("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},1330063:(e,t,r,a,o,i,s,l,d,u,c,p,g,A)=>{n.hc("MaxPool",e,{format:A?"NHWC":"NCHW",auto_pad:t,ceil_mode:r,count_include_pad:a,storage_order:o,dilations:i?Array.from(M().subarray(Number(i)>>>0,Number(s)>>>0)):[],kernel_shape:l?Array.from(M().subarray(Number(l)>>>0,Number(d)>>>0)):[],pads:u?Array.from(M().subarray(Number(u)>>>0,Number(c)>>>0)):[],strides:p?Array.from(M().subarray(Number(p)>>>0,Number(g)>>>0)):[]})},1330538:(e,t)=>{n.hc("GlobalMaxPool",e,{format:t?"NHWC":"NCHW"})},1330625:(e,t,r,a,o,i,s,l,d,u,c,p,g,A)=>{n.hc("MaxPool",e,{format:A?"NHWC":"NCHW",auto_pad:t,ceil_mode:r,count_include_pad:a,storage_order:o,dilations:i?Array.from(M().subarray(Number(i)>>>0,Number(s)>>>0)):[],kernel_shape:l?Array.from(M().subarray(Number(l)>>>0,Number(d)>>>0)):[],pads:u?Array.from(M().subarray(Number(u)>>>0,Number(c)>>>0)):[],strides:p?Array.from(M().subarray(Number(p)>>>0,Number(g)>>>0)):[]})},1331100:(e,t,r,a,o)=>{n.hc("Gemm",e,{alpha:t,beta:r,transA:a,transB:o})},1331204:e=>{n.hc("MatMul",e,void 0)},1331258:(e,t,r,a)=>{n.hc("ArgMax",e,{keepDims:!!t,selectLastIndex:!!r,axis:a})},1331366:(e,t,r,a)=>{n.hc("ArgMin",e,{keepDims:!!t,selectLastIndex:!!r,axis:a})},1331474:(e,t)=>{n.hc("Softmax",e,{axis:t})},1331537:(e,t)=>{n.hc("Concat",e,{axis:t})},1331597:(e,t,r,a,o)=>{n.hc("Split",e,{axis:t,numOutputs:r,splitSizes:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1331753:e=>{n.hc("Expand",e,void 0)},1331807:(e,t)=>{n.hc("Gather",e,{axis:Number(t)})},1331878:(e,t)=>{n.hc("GatherElements",e,{axis:Number(t)})},1331957:(e,t)=>{n.hc("GatherND",e,{batch_dims:Number(t)})},1332036:(e,t,r,a,o,i,s,l,d,u,c)=>{n.hc("Resize",e,{antialias:t,axes:r?Array.from(M().subarray(Number(r)>>>0,Number(a)>>>0)):[],coordinateTransformMode:Ve(o),cubicCoeffA:i,excludeOutside:s,extrapolationValue:l,keepAspectRatioPolicy:Ve(d),mode:Ve(u),nearestMode:Ve(c)})},1332398:(e,t,r,a,o,i,s)=>{n.hc("Slice",e,{starts:t?Array.from(M().subarray(Number(t)>>>0,Number(r)>>>0)):[],ends:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[],axes:i?Array.from(M().subarray(Number(i)>>>0,Number(s)>>>0)):[]})},1332662:e=>{n.hc("Tile",e,void 0)},1332714:(e,t,r)=>{n.hc("InstanceNormalization",e,{epsilon:t,format:r?"NHWC":"NCHW"})},1332828:(e,t,r)=>{n.hc("InstanceNormalization",e,{epsilon:t,format:r?"NHWC":"NCHW"})},1332942:e=>{n.hc("Range",e,void 0)},1332995:(e,t)=>{n.hc("Einsum",e,{equation:Ve(t)})},1333076:(e,t,r,a,o)=>{n.hc("Pad",e,{mode:t,value:r,pads:a?Array.from(M().subarray(Number(a)>>>0,Number(o)>>>0)):[]})},1333219:(e,t,r,a,o,i)=>{n.hc("BatchNormalization",e,{epsilon:t,momentum:r,spatial:!!o,trainingMode:!!a,format:i?"NHWC":"NCHW"})},1333388:(e,t,r,a,o,i)=>{n.hc("BatchNormalization",e,{epsilon:t,momentum:r,spatial:!!o,trainingMode:!!a,format:i?"NHWC":"NCHW"})},1333557:(e,t,r)=>{n.hc("CumSum",e,{exclusive:Number(t),reverse:Number(r)})},1333654:(e,t,r)=>{n.hc("DequantizeLinear",e,{axis:t,blockSize:r})},1333744:(e,t,r,a,o)=>{n.hc("GridSample",e,{align_corners:t,mode:Ve(r),padding_mode:Ve(a),format:o?"NHWC":"NCHW"})},1333914:(e,t,r,a,o)=>{n.hc("GridSample",e,{align_corners:t,mode:Ve(r),padding_mode:Ve(a),format:o?"NHWC":"NCHW"})},1334084:(e,t)=>{n.hc("ScatterND",e,{reduction:Ve(t)})},1334169:(e,t,r,a,o,i,s,l,d)=>{n.hc("Attention",e,{numHeads:t,isUnidirectional:r,maskFilterValue:a,scale:o,doRotary:i,qkvHiddenSizes:s?Array.from(M().subarray(Number(l)>>>0,Number(l)+s>>>0)):[],pastPresentShareBuffer:!!d})},1334441:e=>{n.hc("BiasAdd",e,void 0)},1334496:e=>{n.hc("BiasSplitGelu",e,void 0)},1334557:e=>{n.hc("FastGelu",e,void 0)},1334613:(e,t,r,a,o,i,s,l,d,u,c,p,g,A,h,B)=>{n.hc("Conv",e,{format:p?"NHWC":"NCHW",auto_pad:t,dilations:r?Array.from(M().subarray(Number(r)>>>0,Number(a)>>>0)):[],group:o,kernel_shape:i?Array.from(M().subarray(Number(i)>>>0,Number(s)>>>0)):[],pads:l?Array.from(M().subarray(Number(l)>>>0,Number(d)>>>0)):[],strides:u?Array.from(M().subarray(Number(u)>>>0,Number(c)>>>0)):[],w_is_const:()=>!!Z()[Number(g)>>>0],activation:Ve(A),activation_params:h?Array.from(Y().subarray(Number(h)>>>0,Number(B)>>>0)):[]})},1335197:e=>{n.hc("Gelu",e,void 0)},1335249:(e,t,r,a,o,i,s,l,d)=>{n.hc("GroupQueryAttention",e,{numHeads:t,kvNumHeads:r,scale:a,softcap:o,doRotary:i,rotaryInterleaved:s,smoothSoftmax:l,localWindowSize:d})},1335466:(e,t,r,a)=>{n.hc("LayerNormalization",e,{axis:t,epsilon:r,simplified:!!a})},1335577:(e,t,r,a)=>{n.hc("LayerNormalization",e,{axis:t,epsilon:r,simplified:!!a})},1335688:(e,t,r,a,o,i)=>{n.hc("MatMulNBits",e,{k:t,n:r,accuracyLevel:a,bits:o,blockSize:i})},1335815:(e,t,r,a,o,i)=>{n.hc("MultiHeadAttention",e,{numHeads:t,isUnidirectional:r,maskFilterValue:a,scale:o,doRotary:i})},1335974:(e,t)=>{n.hc("QuickGelu",e,{alpha:t})},1336038:(e,t,r,a,o)=>{n.hc("RotaryEmbedding",e,{interleaved:!!t,numHeads:r,rotaryEmbeddingDim:a,scale:o})},1336177:(e,t,r)=>{n.hc("SkipLayerNormalization",e,{epsilon:t,simplified:!!r})},1336279:(e,t,r)=>{n.hc("SkipLayerNormalization",e,{epsilon:t,simplified:!!r})},1336381:(e,t,r,a)=>{n.hc("GatherBlockQuantized",e,{gatherAxis:t,quantizeAxis:r,blockSize:a})},1336502:e=>{n.Wd(e)},1336536:(e,t)=>n.Zd(Number(e),Number(t),n.Cd.be,n.Cd.errors)};function ee(e,t,r){return rr((async()=>{await n.Ud(Number(e),Number(t),Number(r))}))}function te(){return typeof wasmOffsetConverter<"u"}class re{name="ExitStatus";constructor(e){this.message=`Program terminated with exit(${e})`,this.status=e}}var ne=e=>{e.terminate(),e.onmessage=()=>{}},ae=[],oe=e=>{0==ce.length&&(Ce(),me(ce[0]));var t=ce.pop();if(!t)return 6;pe.push(t),Ae[e.xd]=t,t.xd=e.xd;var r={yd:"run",de:e.ce,Fd:e.Fd,xd:e.xd};return t.postMessage(r,e.Ld),0},ie=0,se=(e,t,...r)=>{for(var n=2*r.length,a=Zn(),o=Tn(8*n),i=o>>>3,s=0;s<r.length;s++){var l=r[s];"bigint"==typeof l?(E[i+2*s]=1n,E[i+2*s+1]=l):(E[i+2*s]=0n,L()[i+2*s+1>>>0]=l)}return e=Fn(e,0,n,o,t),Sn(a),e};function le(e){if(s)return se(0,1,e);if(K=e,!(0<ie)){for(var t of pe)ne(t);for(t of ce)ne(t);ce=[],pe=[],Ae={},S=!0}g(0,new re(e))}function de(e){if(s)return se(1,0,e);ue(e)}var ue=e=>{if(K=e,s)throw de(e),"unwind";le(e)},ce=[],pe=[],ge=[],Ae={},he=e=>{var t=e.xd;delete Ae[t],ce.push(e),pe.splice(pe.indexOf(e),1),e.xd=0,_n(t)};function Be(){ge.forEach((e=>e()))}var me=e=>new Promise((t=>{e.onmessage=r=>{var a=(r=r.data).yd;if(r.Ed&&r.Ed!=wn()){var o=Ae[r.Ed];o?o.postMessage(r,r.Ld):C(`Internal error! Worker sent a message "${a}" to target pthread ${r.Ed}, but that thread no longer exists!`)}else"checkMailbox"===a?Zt():"spawnThread"===a?oe(r):"cleanupThread"===a?he(Ae[r.ee]):"loaded"===a?(e.loaded=!0,t(e)):"alert"===a?alert(`Thread ${r.fe}: ${r.text}`):"setimmediate"===r.target?e.postMessage(r):"callHandler"===a?n[r.Nd](...r.args):a&&C(`worker sent an unknown command ${a}`)},e.onerror=e=>{throw C(`worker sent an error! ${e.filename}:${e.lineno}: ${e.message}`),e};var r,a=[];for(r of[])n.propertyIsEnumerable(r)&&a.push(r);e.postMessage({yd:"load",Od:a,he:w,ie:b})}));function Ce(){var e=new Worker((()=>{let e=URL;return import.meta.url>"file:"&&import.meta.url<"file;"?new e("ort.bundle.min.mjs",import.meta.url):new URL(import.meta.url)})(),{type:"module",workerData:"em-pthread",name:"em-pthread"});ce.push(e)}var we=e=>{U();var t=H()[e+52>>>2>>>0];e=H()[e+56>>>2>>>0],xn(t,t-e),Sn(t)},be=(e,t)=>{ie=0,e=Ln(e,t),0<ie?K=e:yn(e)},Ke=[];function fe(e){var t=new Fe(e>>>=0);if(0==Z()[t.wd+12>>>0]){var r=1;Z()[t.wd+12>>>0]=r}return r=0,Z()[t.wd+13>>>0]=r,Ke.push(t),Vn(e),Mn(e)}var Qe=0,We=()=>{Gn(0,0);var e=Ke.pop();Xn(e.Gd),Qe=0};class Fe{constructor(e){this.Gd=e,this.wd=e-24}}function _e(e){throw Qe||=e>>>0,Qe}var ye=e=>{var t=Qe;if(!t)return Rn(0),0;var r=new Fe(t);H()[r.wd+16>>>2>>>0]=t;var n=H()[r.wd+4>>>2>>>0];if(!n)return Rn(0),t;for(var a of e){if(0===a||a===n)break;if(kn(a,n,r.wd+16))return Rn(a),t}return Rn(n),t};function ve(){return ye([])}function Ee(e){return ye([e>>>0])}function Ge(e,t){return ye([e>>>0,t>>>0])}var Re=()=>{var e=Ke.pop();e||j("no exception to throw");var t=e.Gd;if(0==Z()[e.wd+13>>>0]){Ke.push(e);var r=1;Z()[e.wd+13>>>0]=r,r=0,Z()[e.wd+12>>>0]=r}throw Qe=t};function xe(e,t,r){var n=new Fe(e>>>=0);throw t>>>=0,r>>>=0,H()[n.wd+16>>>2>>>0]=0,H()[n.wd+4>>>2>>>0]=t,H()[n.wd+8>>>2>>>0]=r,Qe=e}function Se(e,t,r,n){return s?se(2,1,e,t,r,n):Te(e,t,r,n)}function Te(e,t,r,n){if(e>>>=0,r>>>=0,n>>>=0,void 0===l)return 6;var a=[];return s&&0===a.length?Se(e,t>>>=0,r,n):(e={ce:r,xd:e,Fd:n,Ld:a},s?(e.yd="spawnThread",postMessage(e,a),0):oe(e))}var Ze=typeof TextDecoder<"u"?new TextDecoder:void 0,Xe=(e,t=0,r=NaN)=>{var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&Ze)return Ze.decode(e.buffer instanceof ArrayBuffer?e.subarray(t,r):e.slice(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n},Ve=(e,t)=>(e>>>=0)?Xe(X(),e,t):"";function ke(e,t,r){return s?se(3,1,e,t,r):0}function Me(e,t){if(s)return se(4,1,e,t)}var He=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t},Ye=(e,t,r)=>{var n=X();if(t>>>=0,0<r){var a=t;r=t+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(t>=r)break;n[t++>>>0]=i}else{if(2047>=i){if(t+1>=r)break;n[t++>>>0]=192|i>>6}else{if(65535>=i){if(t+2>=r)break;n[t++>>>0]=224|i>>12}else{if(t+3>=r)break;n[t++>>>0]=240|i>>18,n[t++>>>0]=128|i>>12&63}n[t++>>>0]=128|i>>6&63}n[t++>>>0]=128|63&i}}n[t>>>0]=0,e=t-a}else e=0;return e};function Le(e,t){if(s)return se(5,1,e,t)}function Ne(e,t,r){if(s)return se(6,1,e,t,r)}function Ie(e,t,r){return s?se(7,1,e,t,r):0}function Ue(e,t){if(s)return se(8,1,e,t)}function De(e,t,r){if(s)return se(9,1,e,t,r)}function Je(e,t,r,n){if(s)return se(10,1,e,t,r,n)}function Pe(e,t,r,n){if(s)return se(11,1,e,t,r,n)}function Oe(e,t,r,n){if(s)return se(12,1,e,t,r,n)}function ze(e){if(s)return se(13,1,e)}function je(e,t){if(s)return se(14,1,e,t)}function $e(e,t,r){if(s)return se(15,1,e,t,r)}var qe,et,tt=()=>j(""),rt=e=>{for(var t="";X()[e>>>0];)t+=qe[X()[e++>>>0]];return t},nt={},at={};function ot(e,t,r={}){return function(e,t,r={}){var n=t.name;if(!e)throw new et(`type "${n}" must have a positive integer typeid pointer`);if(at.hasOwnProperty(e)){if(r.Pd)return;throw new et(`Cannot register type '${n}' twice`)}at[e]=t,nt.hasOwnProperty(e)&&(t=nt[e],delete nt[e],t.forEach((e=>e())))}(e,t,r)}var it=(e,t,r)=>{switch(t){case 1:return r?e=>Z()[e>>>0]:e=>X()[e>>>0];case 2:return r?e=>V()[e>>>1>>>0]:e=>k()[e>>>1>>>0];case 4:return r?e=>M()[e>>>2>>>0]:e=>H()[e>>>2>>>0];case 8:return r?e=>E[e>>>3]:e=>G[e>>>3];default:throw new TypeError(`invalid integer width (${t}): ${e}`)}};function st(e,t,r){r>>>=0,ot(e>>>=0,{name:t=rt(t>>>0),fromWireType:e=>e,toWireType:function(e,t){if("bigint"!=typeof t&&"number"!=typeof t)throw t=null===t?"null":"object"==(e=typeof t)||"array"===e||"function"===e?t.toString():""+t,new TypeError(`Cannot convert "${t}" to ${this.name}`);return"number"==typeof t&&(t=BigInt(t)),t},zd:lt,readValueFromPointer:it(t,r,-1==t.indexOf("u")),Ad:null})}var lt=8;function dt(e,t,r,n){ot(e>>>=0,{name:t=rt(t>>>0),fromWireType:function(e){return!!e},toWireType:function(e,t){return t?r:n},zd:lt,readValueFromPointer:function(e){return this.fromWireType(X()[e>>>0])},Ad:null})}var ut=[],ct=[];function pt(e){9<(e>>>=0)&&0==--ct[e+1]&&(ct[e]=void 0,ut.push(e))}var gt=e=>{if(!e)throw new et("Cannot use deleted val. handle = "+e);return ct[e]},At=e=>{switch(e){case void 0:return 2;case null:return 4;case!0:return 6;case!1:return 8;default:let t=ut.pop()||ct.length;return ct[t]=e,ct[t+1]=1,t}};function ht(e){return this.fromWireType(H()[e>>>2>>>0])}var Bt={name:"emscripten::val",fromWireType:e=>{var t=gt(e);return pt(e),t},toWireType:(e,t)=>At(t),zd:lt,readValueFromPointer:ht,Ad:null};function mt(e){return ot(e>>>0,Bt)}var Ct=(e,t)=>{switch(t){case 4:return function(e){return this.fromWireType(Y()[e>>>2>>>0])};case 8:return function(e){return this.fromWireType(L()[e>>>3>>>0])};default:throw new TypeError(`invalid float width (${t}): ${e}`)}};function wt(e,t,r){r>>>=0,ot(e>>>=0,{name:t=rt(t>>>0),fromWireType:e=>e,toWireType:(e,t)=>t,zd:lt,readValueFromPointer:Ct(t,r),Ad:null})}function bt(e,t,r,n,a){if(e>>>=0,r>>>=0,t=rt(t>>>0),-1===a&&(a=4294967295),a=e=>e,0===n){var o=32-8*r;a=e=>e<<o>>>o}var i=t.includes("unsigned")?function(e,t){return t>>>0}:function(e,t){return t};ot(e,{name:t,fromWireType:a,toWireType:i,zd:lt,readValueFromPointer:it(t,r,0!==n),Ad:null})}function Kt(e,t,r){function n(e){var t=H()[e>>>2>>>0];return e=H()[e+4>>>2>>>0],new a(Z().buffer,e,t)}var a=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array][t];ot(e>>>=0,{name:r=rt(r>>>0),fromWireType:n,zd:lt,readValueFromPointer:n},{Pd:!0})}function ft(e,t){ot(e>>>=0,{name:t=rt(t>>>0),fromWireType:function(e){for(var t,r=H()[e>>>2>>>0],n=e+4,a=n,o=0;o<=r;++o){var i=n+o;o!=r&&0!=X()[i>>>0]||(a=Ve(a,i-a),void 0===t?t=a:(t+="\0",t+=a),a=i+1)}return bn(e),t},toWireType:function(e,t){t instanceof ArrayBuffer&&(t=new Uint8Array(t));var r="string"==typeof t;if(!(r||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof Int8Array))throw new et("Cannot pass non-string to std::string");var n=r?He(t):t.length,a=fn(4+n+1),o=a+4;if(H()[a>>>2>>>0]=n,r)Ye(t,o,n+1);else if(r)for(r=0;r<n;++r){var i=t.charCodeAt(r);if(255<i)throw bn(a),new et("String has UTF-16 code units that do not fit in 8 bits");X()[o+r>>>0]=i}else for(r=0;r<n;++r)X()[o+r>>>0]=t[r];return null!==e&&e.push(bn,a),a},zd:lt,readValueFromPointer:ht,Ad(e){bn(e)}})}var Qt=typeof TextDecoder<"u"?new TextDecoder("utf-16le"):void 0,Wt=(e,t)=>{for(var r=e>>1,n=r+t/2;!(r>=n)&&k()[r>>>0];)++r;if(32<(r<<=1)-e&&Qt)return Qt.decode(X().slice(e,r));for(r="",n=0;!(n>=t/2);++n){var a=V()[e+2*n>>>1>>>0];if(0==a)break;r+=String.fromCharCode(a)}return r},Ft=(e,t,r)=>{if(r??=2147483647,2>r)return 0;var n=t;r=(r-=2)<2*e.length?r/2:e.length;for(var a=0;a<r;++a){var o=e.charCodeAt(a);V()[t>>>1>>>0]=o,t+=2}return V()[t>>>1>>>0]=0,t-n},_t=e=>2*e.length,yt=(e,t)=>{for(var r=0,n="";!(r>=t/4);){var a=M()[e+4*r>>>2>>>0];if(0==a)break;++r,65536<=a?(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a)):n+=String.fromCharCode(a)}return n},vt=(e,t,r)=>{if(t>>>=0,r??=2147483647,4>r)return 0;var n=t;r=n+r-4;for(var a=0;a<e.length;++a){var o=e.charCodeAt(a);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&e.charCodeAt(++a)),M()[t>>>2>>>0]=o,(t+=4)+4>r)break}return M()[t>>>2>>>0]=0,t-n},Et=e=>{for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);55296<=n&&57343>=n&&++r,t+=4}return t};function Gt(e,t,r){if(e>>>=0,t>>>=0,r=rt(r>>>=0),2===t)var n=Wt,a=Ft,o=_t,i=e=>k()[e>>>1>>>0];else 4===t&&(n=yt,a=vt,o=Et,i=e=>H()[e>>>2>>>0]);ot(e,{name:r,fromWireType:e=>{for(var r,a=H()[e>>>2>>>0],o=e+4,s=0;s<=a;++s){var l=e+4+s*t;s!=a&&0!=i(l)||(o=n(o,l-o),void 0===r?r=o:(r+="\0",r+=o),o=l+t)}return bn(e),r},toWireType:(e,n)=>{if("string"!=typeof n)throw new et(`Cannot pass non-string to C++ string type ${r}`);var i=o(n),s=fn(4+i+t);return H()[s>>>2>>>0]=i/t,a(n,s+4,i+t),null!==e&&e.push(bn,s),s},zd:lt,readValueFromPointer:ht,Ad(e){bn(e)}})}function Rt(e,t){ot(e>>>=0,{Qd:!0,name:t=rt(t>>>0),zd:0,fromWireType:()=>{},toWireType:()=>{}})}function xt(e){Qn(e>>>0,!i,1,!o,131072,!1),Be()}var St=e=>{if(!S)try{if(e(),!(0<ie))try{s?yn(K):ue(K)}catch(e){e instanceof re||"unwind"==e||g(0,e)}}catch(e){e instanceof re||"unwind"==e||g(0,e)}};function Tt(e){e>>>=0,"function"==typeof Atomics.ge&&(Atomics.ge(M(),e>>>2,e).value.then(Zt),e+=128,Atomics.store(M(),e>>>2,1))}var Zt=()=>{var e=wn();e&&(Tt(e),St(En))};function Xt(e,t){(e>>>=0)==t>>>0?setTimeout(Zt):s?postMessage({Ed:e,yd:"checkMailbox"}):(e=Ae[e])&&e.postMessage({yd:"checkMailbox"})}var Vt=[];function kt(e,t,r,n,a){for(t>>>=0,n/=2,Vt.length=n,r=a>>>0>>>3,a=0;a<n;a++)Vt[a]=E[r+2*a]?E[r+2*a+1]:L()[r+2*a+1>>>0];return(t?q[t]:Bn[e])(...Vt)}var Mt=()=>{ie=0};function Ht(e){e>>>=0,s?postMessage({yd:"cleanupThread",ee:e}):he(Ae[e])}function Yt(e){}var Lt=(e,t)=>{var r=at[e];if(void 0===r)throw e=mn(e),r=rt(e),bn(e),new et(`${t} has unknown type ${r}`);return r},Nt=(e,t,r)=>{var n=[];return e=e.toWireType(n,r),n.length&&(H()[t>>>2>>>0]=At(n)),e};function It(e,t,r){return t>>>=0,r>>>=0,e=gt(e>>>0),t=Lt(t,"emval::as"),Nt(t,r,e)}function Ut(e,t){return t>>>=0,e=gt(e>>>0),(t=Lt(t,"emval::as")).toWireType(null,e)}var Dt=e=>{try{e()}catch(e){j(e)}},Jt=0,Pt=null,Ot=0,zt=[],jt={},$t={},qt=0,er=null,tr=[];function rr(e){return function(){if(!S){if(0===Jt){var t=!1,r=!1;(t=>{e().then(t)})(((e=0)=>{if(!S&&(Ot=e,t=!0,r)){Jt=2,Dt((()=>Sa(Pt))),typeof MainLoop<"u"&&MainLoop.Md&&MainLoop.resume(),e=!1;try{var n=(i=M()[Pt+8>>>2>>>0],i=hn[$t[i]],--ie,i())}catch(i){n=i,e=!0}var a=!1;if(!Pt){var o=er;o&&(er=null,(e?o.reject:o.resolve)(n),a=!0)}if(e&&!a)throw n}var i})),r=!0,t||(Jt=1,Pt=function(){var e=fn(65548),t=e+12;H()[e>>>2>>>0]=t,H()[e+4>>>2>>>0]=t+65536,t=zt[0];var r=jt[t];return void 0===r&&(r=qt++,jt[t]=r,$t[r]=t),t=r,M()[e+8>>>2>>>0]=t,e}(),typeof MainLoop<"u"&&MainLoop.Md&&MainLoop.pause(),Dt((()=>Ra(Pt))))}else 2===Jt?(Jt=0,Dt(Ta),bn(Pt),Pt=null,tr.forEach(St)):j(`invalid state: ${Jt}`);return Ot}}()}function nr(e){return e>>>=0,rr((async()=>{var t=await gt(e);return At(t)}))}var ar=[];function or(e,t,r,n){return r>>>=0,n>>>=0,(e=ar[e>>>0])(null,t=gt(t>>>0),r,n)}var ir={},sr=e=>{var t=ir[e];return void 0===t?rt(e):t};function lr(e,t,r,n,a){return r>>>=0,n>>>=0,a>>>=0,(e=ar[e>>>0])(t=gt(t>>>0),t[r=sr(r)],n,a)}var dr=()=>"object"==typeof globalThis?globalThis:Function("return this")();function ur(e){return 0==(e>>>=0)?At(dr()):(e=sr(e),At(dr()[e]))}var cr=e=>{var t=ar.length;return ar.push(e),t},pr=(e,t)=>{for(var r=Array(e),n=0;n<e;++n)r[n]=Lt(H()[t+4*n>>>2>>>0],"parameter "+n);return r},gr=(e,t)=>Object.defineProperty(t,"name",{value:e});function Ar(e,t,r){var n=(t=pr(e,t>>>0)).shift();e--;var a="return function (obj, func, destructorsRef, args) {\n",o=0,i=[];0===r&&i.push("obj");for(var s=["retType"],l=[n],d=0;d<e;++d)i.push("arg"+d),s.push("argType"+d),l.push(t[d]),a+=`  var arg${d} = argType${d}.readValueFromPointer(args${o?"+"+o:""});\n`,o+=t[d].zd;return a+=`  var rv = ${1===r?"new func":"func.call"}(${i.join(", ")});\n`,n.Qd||(s.push("emval_returnValue"),l.push(Nt),a+="  return emval_returnValue(retType, destructorsRef, rv);\n"),s.push(a+"};\n"),e=function(e){var t=Function;if(!(t instanceof Function))throw new TypeError(`new_ called with constructor type ${typeof t} which is not a function`);var r=gr(t.name||"unknownFunctionName",(function(){}));return r.prototype=t.prototype,r=new r,(e=t.apply(r,e))instanceof Object?e:r}(s)(...l),r=`methodCaller<(${t.map((e=>e.name)).join(", ")}) => ${n.name}>`,cr(gr(r,e))}function hr(e){return e=sr(e>>>0),At(n[e])}function Br(e,t){return t>>>=0,e=gt(e>>>0),t=gt(t),At(e[t])}function mr(e){9<(e>>>=0)&&(ct[e+1]+=1)}function Cr(){return At([])}function wr(e){e=gt(e>>>0);for(var t=Array(e.length),r=0;r<e.length;r++)t[r]=e[r];return At(t)}function br(e){return At(sr(e>>>0))}function Kr(){return At({})}function fr(e){for(var t=gt(e>>>=0);t.length;){var r=t.pop();t.pop()(r)}pt(e)}function Qr(e,t,r){t>>>=0,r>>>=0,e=gt(e>>>0),t=gt(t),r=gt(r),e[t]=r}function Wr(e,t){return t>>>=0,e=(e=Lt(e>>>0,"_emval_take_value")).readValueFromPointer(t),At(e)}function Fr(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),M()[t>>>2>>>0]=e.getUTCSeconds(),M()[t+4>>>2>>>0]=e.getUTCMinutes(),M()[t+8>>>2>>>0]=e.getUTCHours(),M()[t+12>>>2>>>0]=e.getUTCDate(),M()[t+16>>>2>>>0]=e.getUTCMonth(),M()[t+20>>>2>>>0]=e.getUTCFullYear()-1900,M()[t+24>>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,M()[t+28>>>2>>>0]=e}var _r=e=>e%4==0&&(e%100!=0||e%400==0),yr=[0,31,60,91,121,152,182,213,244,274,305,335],vr=[0,31,59,90,120,151,181,212,243,273,304,334];function Er(e,t){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),t>>>=0,e=new Date(1e3*e),M()[t>>>2>>>0]=e.getSeconds(),M()[t+4>>>2>>>0]=e.getMinutes(),M()[t+8>>>2>>>0]=e.getHours(),M()[t+12>>>2>>>0]=e.getDate(),M()[t+16>>>2>>>0]=e.getMonth(),M()[t+20>>>2>>>0]=e.getFullYear()-1900,M()[t+24>>>2>>>0]=e.getDay();var r=(_r(e.getFullYear())?yr:vr)[e.getMonth()]+e.getDate()-1|0;M()[t+28>>>2>>>0]=r,M()[t+36>>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset();var n=new Date(e.getFullYear(),0,1).getTimezoneOffset();e=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r)),M()[t+32>>>2>>>0]=e}function Gr(e){e>>>=0;var t=new Date(M()[e+20>>>2>>>0]+1900,M()[e+16>>>2>>>0],M()[e+12>>>2>>>0],M()[e+8>>>2>>>0],M()[e+4>>>2>>>0],M()[e>>>2>>>0],0),r=M()[e+32>>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),6,1).getTimezoneOffset(),o=new Date(t.getFullYear(),0,1).getTimezoneOffset(),i=Math.min(o,a);return 0>r?M()[e+32>>>2>>>0]=+(a!=o&&i==n):0<r!=(i==n)&&(a=Math.max(o,a),t.setTime(t.getTime()+6e4*((0<r?i:a)-n))),M()[e+24>>>2>>>0]=t.getDay(),r=(_r(t.getFullYear())?yr:vr)[t.getMonth()]+t.getDate()-1|0,M()[e+28>>>2>>>0]=r,M()[e>>>2>>>0]=t.getSeconds(),M()[e+4>>>2>>>0]=t.getMinutes(),M()[e+8>>>2>>>0]=t.getHours(),M()[e+12>>>2>>>0]=t.getDate(),M()[e+16>>>2>>>0]=t.getMonth(),M()[e+20>>>2>>>0]=t.getYear(),e=t.getTime(),BigInt(isNaN(e)?-1:e/1e3)}function Rr(e,t,r,n,a,o,i){return s?se(16,1,e,t,r,n,a,o,i):-52}function xr(e,t,r,n,a,o){if(s)return se(17,1,e,t,r,n,a,o)}var Sr={},Tr=()=>performance.timeOrigin+performance.now();function Zr(e,t){if(s)return se(18,1,e,t);if(Sr[e]&&(clearTimeout(Sr[e].id),delete Sr[e]),!t)return 0;var r=setTimeout((()=>{delete Sr[e],St((()=>vn(e,performance.timeOrigin+performance.now())))}),t);return Sr[e]={id:r,ke:t},0}function Xr(e,t,r,n){e>>>=0,t>>>=0,r>>>=0,n>>>=0;var a=(new Date).getFullYear(),o=new Date(a,0,1).getTimezoneOffset();a=new Date(a,6,1).getTimezoneOffset();var i=Math.max(o,a);H()[e>>>2>>>0]=60*i,M()[t>>>2>>>0]=+(o!=a),e=(t=e=>{var t=Math.abs(e);return`UTC${0<=e?"-":"+"}${String(Math.floor(t/60)).padStart(2,"0")}${String(t%60).padStart(2,"0")}`})(o),t=t(a),a<o?(Ye(e,r,17),Ye(t,n,17)):(Ye(e,n,17),Ye(t,r,17))}var Vr=()=>Date.now();function kr(e,t,r){return 0<=e&&3>=e?(e=0===e?Date.now():performance.timeOrigin+performance.now(),E[r>>>0>>>3]=BigInt(Math.round(1e6*e)),0):28}var Mr=[],Hr=(e,t)=>{Mr.length=0;for(var r;r=X()[e++>>>0];){var n=105!=r;t+=(n&=112!=r)&&t%8?4:0,Mr.push(112==r?H()[t>>>2>>>0]:106==r?E[t>>>3]:105==r?M()[t>>>2>>>0]:L()[t>>>3>>>0]),t+=n?8:4}return Mr};function Yr(e,t,r){return e>>>=0,t=Hr(t>>>0,r>>>0),q[e](...t)}function Lr(e,t,r){return e>>>=0,t=Hr(t>>>0,r>>>0),q[e](...t)}var Nr=()=>{};function Ir(e,t){return C(Ve(e>>>0,t>>>0))}var Ur=()=>{throw ie+=1,"unwind"};function Dr(){return 4294901760}var Jr=()=>navigator.hardwareConcurrency;function Pr(){return j("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Or(e){e>>>=0;var t=X().length;if(e<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);e:{n=(Math.min(4294901760,65536*Math.ceil(Math.max(e,n)/65536))-w.buffer.byteLength+65535)/65536|0;try{w.grow(n),U();var a=1;break e}catch{}a=void 0}if(a)return!0}return!1}var zr=()=>(j("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),jr={},$r=e=>{e.forEach((e=>{zr()}))};function qr(){var e=Error().stack.toString().split("\n");return"Error"==e[0]&&e.shift(),$r(e),jr.Kd=zr(),jr.ae=e,jr.Kd}function en(e,t,r){if(e>>>=0,t>>>=0,jr.Kd==e)var n=jr.ae;else"Error"==(n=Error().stack.toString().split("\n"))[0]&&n.shift(),$r(n);for(var a=3;n[a]&&zr()!=e;)++a;for(e=0;e<r&&n[e+a];++e)M()[t+4*e>>>2>>>0]=zr();return e}var tn,rn={},nn=()=>{if(!tn){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:"./this.program"};for(e in rn)void 0===rn[e]?delete t[e]:t[e]=rn[e];var r=[];for(e in t)r.push(`${e}=${t[e]}`);tn=r}return tn};function an(e,t){if(s)return se(19,1,e,t);e>>>=0,t>>>=0;var r=0;return nn().forEach(((n,a)=>{var o=t+r;for(a=H()[e+4*a>>>2>>>0]=o,o=0;o<n.length;++o)Z()[a++>>>0]=n.charCodeAt(o);Z()[a>>>0]=0,r+=n.length+1})),0}function on(e,t){if(s)return se(20,1,e,t);e>>>=0,t>>>=0;var r=nn();H()[e>>>2>>>0]=r.length;var n=0;return r.forEach((e=>n+=e.length+1)),H()[t>>>2>>>0]=n,0}function sn(e){return s?se(21,1,e):52}function ln(e,t,r,n){return s?se(22,1,e,t,r,n):52}function dn(e,t,r,n){return s?se(23,1,e,t,r,n):70}var un=[null,[],[]];function cn(e,t,r,n){if(s)return se(24,1,e,t,r,n);t>>>=0,r>>>=0,n>>>=0;for(var a=0,o=0;o<r;o++){var i=H()[t>>>2>>>0],l=H()[t+4>>>2>>>0];t+=8;for(var d=0;d<l;d++){var u=X()[i+d>>>0],c=un[e];0===u||10===u?((1===e?m:C)(Xe(c)),c.length=0):c.push(u)}a+=l}return H()[n>>>2>>>0]=a,0}function pn(e){return e>>>0}s||function(){for(var e=n.numThreads-1;e--;)Ce();ae.unshift((()=>{var e;P++,e=()=>z(),s?e():Promise.all(ce.map(me)).then(e)}))}();for(var gn=Array(256),An=0;256>An;++An)gn[An]=String.fromCharCode(An);qe=gn,et=n.BindingError=class extends Error{constructor(e){super(e),this.name="BindingError"}},n.InternalError=class extends Error{constructor(e){super(e),this.name="InternalError"}},ct.push(0,1,void 0,1,null,1,!0,1,!1,1),n.count_emval_handles=()=>ct.length/2-5-ut.length;var hn,Bn=[le,de,Se,ke,Me,Le,Ne,Ie,Ue,De,Je,Pe,Oe,ze,je,$e,Rr,xr,Zr,an,on,sn,ln,dn,cn];!async function(){function e(e,t){return hn=e.exports,hn=function(){var e=hn,t={};for(let[r,n]of Object.entries(e))t[r]="function"==typeof n?(...e)=>{zt.push(r);try{return n(...e)}finally{S||(zt.pop(),Pt&&1===Jt&&0===zt.length&&(Jt=0,ie+=1,Dt(xa),typeof Fibers<"u"&&Fibers.le()))}}:n;return t}(),r=hn,n=e=>t=>e(t)>>>0,a=e=>()=>e()>>>0,(r=Object.assign({},r)).Cb=n(r.Cb),r.fc=a(r.fc),r.ic=n(r.ic),r.vc=n(r.vc),r.wc=a(r.wc),r.Ac=n(r.Ac),hn=r,ge.push(hn.jc),b=t,z(),hn;var r,n,a}P++;var t=$();if(n.instantiateWasm)return new Promise((r=>{n.instantiateWasm(t,((t,n)=>{e(t,n),r(t.exports)}))}));if(s)return new Promise((t=>{N=r=>{var n=new WebAssembly.Instance(r,$());t(e(n,r))}}));J??=n.locateFile?n.locateFile?n.locateFile("ort-wasm-simd-threaded.jsep.wasm",A):A+"ort-wasm-simd-threaded.jsep.wasm":new URL("ort-wasm-simd-threaded.jsep.wasm",import.meta.url).href;try{var a=await async function(e){var t=J;if(!x&&"function"==typeof WebAssembly.instantiateStreaming&&!T(t))try{var r=fetch(t,{credentials:"same-origin"});return await WebAssembly.instantiateStreaming(r,e)}catch(e){C(`wasm streaming compile failed: ${e}`),C("falling back to ArrayBuffer instantiation")}return async function(e,t){try{var r=await async function(e){if(!x)try{var t=await u(e);return new Uint8Array(t)}catch{}if(e==J&&x)e=new Uint8Array(x);else{if(!c)throw"both async and sync fetching of the wasm failed";e=c(e)}return e}(e);return await WebAssembly.instantiate(r,t)}catch(e){C(`failed to asynchronously prepare wasm: ${e}`),j(e)}}(t,e)}(t);return e(a.instance,a.module)}catch(e){return r(e),Promise.reject(e)}}();var mn=e=>(mn=hn.Cb)(e),Cn=()=>(Cn=hn.Db)();n._OrtInit=(e,t)=>(n._OrtInit=hn.Eb)(e,t),n._OrtGetLastError=(e,t)=>(n._OrtGetLastError=hn.Fb)(e,t),n._OrtCreateSessionOptions=(e,t,r,a,o,i,s,l,d,u)=>(n._OrtCreateSessionOptions=hn.Gb)(e,t,r,a,o,i,s,l,d,u),n._OrtAppendExecutionProvider=(e,t)=>(n._OrtAppendExecutionProvider=hn.Hb)(e,t),n._OrtAddFreeDimensionOverride=(e,t,r)=>(n._OrtAddFreeDimensionOverride=hn.Ib)(e,t,r),n._OrtAddSessionConfigEntry=(e,t,r)=>(n._OrtAddSessionConfigEntry=hn.Jb)(e,t,r),n._OrtReleaseSessionOptions=e=>(n._OrtReleaseSessionOptions=hn.Kb)(e),n._OrtCreateSession=(e,t,r)=>(n._OrtCreateSession=hn.Lb)(e,t,r),n._OrtReleaseSession=e=>(n._OrtReleaseSession=hn.Mb)(e),n._OrtGetInputOutputCount=(e,t,r)=>(n._OrtGetInputOutputCount=hn.Nb)(e,t,r),n._OrtGetInputName=(e,t)=>(n._OrtGetInputName=hn.Ob)(e,t),n._OrtGetOutputName=(e,t)=>(n._OrtGetOutputName=hn.Pb)(e,t),n._OrtFree=e=>(n._OrtFree=hn.Qb)(e),n._OrtCreateTensor=(e,t,r,a,o,i)=>(n._OrtCreateTensor=hn.Rb)(e,t,r,a,o,i),n._OrtGetTensorData=(e,t,r,a,o)=>(n._OrtGetTensorData=hn.Sb)(e,t,r,a,o),n._OrtReleaseTensor=e=>(n._OrtReleaseTensor=hn.Tb)(e),n._OrtCreateRunOptions=(e,t,r,a)=>(n._OrtCreateRunOptions=hn.Ub)(e,t,r,a),n._OrtAddRunConfigEntry=(e,t,r)=>(n._OrtAddRunConfigEntry=hn.Vb)(e,t,r),n._OrtReleaseRunOptions=e=>(n._OrtReleaseRunOptions=hn.Wb)(e),n._OrtCreateBinding=e=>(n._OrtCreateBinding=hn.Xb)(e),n._OrtBindInput=(e,t,r)=>(n._OrtBindInput=hn.Yb)(e,t,r),n._OrtBindOutput=(e,t,r,a)=>(n._OrtBindOutput=hn.Zb)(e,t,r,a),n._OrtClearBoundOutputs=e=>(n._OrtClearBoundOutputs=hn._b)(e),n._OrtReleaseBinding=e=>(n._OrtReleaseBinding=hn.$b)(e),n._OrtRunWithBinding=(e,t,r,a,o)=>(n._OrtRunWithBinding=hn.ac)(e,t,r,a,o),n._OrtRun=(e,t,r,a,o,i,s,l)=>(n._OrtRun=hn.bc)(e,t,r,a,o,i,s,l),n._OrtEndProfiling=e=>(n._OrtEndProfiling=hn.cc)(e),n._JsepOutput=(e,t,r)=>(n._JsepOutput=hn.dc)(e,t,r),n._JsepGetNodeName=e=>(n._JsepGetNodeName=hn.ec)(e);var wn=()=>(wn=hn.fc)(),bn=n._free=e=>(bn=n._free=hn.gc)(e),fn=n._malloc=e=>(fn=n._malloc=hn.ic)(e),Qn=(e,t,r,n,a,o)=>(Qn=hn.kc)(e,t,r,n,a,o),Wn=()=>(Wn=hn.lc)(),Fn=(e,t,r,n,a)=>(Fn=hn.mc)(e,t,r,n,a),_n=e=>(_n=hn.nc)(e),yn=e=>(yn=hn.oc)(e),vn=(e,t)=>(vn=hn.pc)(e,t),En=()=>(En=hn.qc)(),Gn=(e,t)=>(Gn=hn.rc)(e,t),Rn=e=>(Rn=hn.sc)(e),xn=(e,t)=>(xn=hn.tc)(e,t),Sn=e=>(Sn=hn.uc)(e),Tn=e=>(Tn=hn.vc)(e),Zn=()=>(Zn=hn.wc)(),Xn=e=>(Xn=hn.xc)(e),Vn=e=>(Vn=hn.yc)(e),kn=(e,t,r)=>(kn=hn.zc)(e,t,r),Mn=e=>(Mn=hn.Ac)(e),Hn=n.dynCall_iii=(e,t,r)=>(Hn=n.dynCall_iii=hn.Bc)(e,t,r),Yn=n.dynCall_vi=(e,t)=>(Yn=n.dynCall_vi=hn.Cc)(e,t),Ln=n.dynCall_ii=(e,t)=>(Ln=n.dynCall_ii=hn.Dc)(e,t),Nn=n.dynCall_vii=(e,t,r)=>(Nn=n.dynCall_vii=hn.Ec)(e,t,r),In=n.dynCall_iiii=(e,t,r,a)=>(In=n.dynCall_iiii=hn.Fc)(e,t,r,a),Un=n.dynCall_viii=(e,t,r,a)=>(Un=n.dynCall_viii=hn.Gc)(e,t,r,a),Dn=n.dynCall_iiiii=(e,t,r,a,o)=>(Dn=n.dynCall_iiiii=hn.Hc)(e,t,r,a,o),Jn=n.dynCall_viiii=(e,t,r,a,o)=>(Jn=n.dynCall_viiii=hn.Ic)(e,t,r,a,o),Pn=n.dynCall_viiiiii=(e,t,r,a,o,i,s)=>(Pn=n.dynCall_viiiiii=hn.Jc)(e,t,r,a,o,i,s),On=n.dynCall_viiiiiii=(e,t,r,a,o,i,s,l)=>(On=n.dynCall_viiiiiii=hn.Kc)(e,t,r,a,o,i,s,l),zn=n.dynCall_ji=(e,t)=>(zn=n.dynCall_ji=hn.Lc)(e,t),jn=n.dynCall_v=e=>(jn=n.dynCall_v=hn.Mc)(e),$n=n.dynCall_viiiii=(e,t,r,a,o,i)=>($n=n.dynCall_viiiii=hn.Nc)(e,t,r,a,o,i),qn=n.dynCall_i=e=>(qn=n.dynCall_i=hn.Oc)(e),ea=n.dynCall_fii=(e,t,r)=>(ea=n.dynCall_fii=hn.Pc)(e,t,r),ta=n.dynCall_viiiiiiii=(e,t,r,a,o,i,s,l,d)=>(ta=n.dynCall_viiiiiiii=hn.Qc)(e,t,r,a,o,i,s,l,d),ra=n.dynCall_viiiiiiiiii=(e,t,r,a,o,i,s,l,d,u,c)=>(ra=n.dynCall_viiiiiiiiii=hn.Rc)(e,t,r,a,o,i,s,l,d,u,c),na=n.dynCall_jiii=(e,t,r,a)=>(na=n.dynCall_jiii=hn.Sc)(e,t,r,a),aa=n.dynCall_dii=(e,t,r)=>(aa=n.dynCall_dii=hn.Tc)(e,t,r),oa=n.dynCall_viiiiiiiii=(e,t,r,a,o,i,s,l,d,u)=>(oa=n.dynCall_viiiiiiiii=hn.Uc)(e,t,r,a,o,i,s,l,d,u),ia=n.dynCall_viiiiiiiiiii=(e,t,r,a,o,i,s,l,d,u,c,p)=>(ia=n.dynCall_viiiiiiiiiii=hn.Vc)(e,t,r,a,o,i,s,l,d,u,c,p),sa=n.dynCall_iiiiii=(e,t,r,a,o,i)=>(sa=n.dynCall_iiiiii=hn.Wc)(e,t,r,a,o,i),la=n.dynCall_iij=(e,t,r)=>(la=n.dynCall_iij=hn.Xc)(e,t,r),da=n.dynCall_iiiiiiiiii=(e,t,r,a,o,i,s,l,d,u)=>(da=n.dynCall_iiiiiiiiii=hn.Yc)(e,t,r,a,o,i,s,l,d,u),ua=n.dynCall_iiiiiiiiiii=(e,t,r,a,o,i,s,l,d,u,c)=>(ua=n.dynCall_iiiiiiiiiii=hn.Zc)(e,t,r,a,o,i,s,l,d,u,c),ca=n.dynCall_vij=(e,t,r)=>(ca=n.dynCall_vij=hn._c)(e,t,r),pa=n.dynCall_iiif=(e,t,r,a)=>(pa=n.dynCall_iiif=hn.$c)(e,t,r,a),ga=n.dynCall_iiij=(e,t,r,a)=>(ga=n.dynCall_iiij=hn.ad)(e,t,r,a),Aa=n.dynCall_fiii=(e,t,r,a)=>(Aa=n.dynCall_fiii=hn.bd)(e,t,r,a),ha=n.dynCall_viiiiiiiiiiiii=(e,t,r,a,o,i,s,l,d,u,c,p,g,A)=>(ha=n.dynCall_viiiiiiiiiiiii=hn.cd)(e,t,r,a,o,i,s,l,d,u,c,p,g,A),Ba=n.dynCall_vjiii=(e,t,r,a,o)=>(Ba=n.dynCall_vjiii=hn.dd)(e,t,r,a,o),ma=n.dynCall_vif=(e,t,r)=>(ma=n.dynCall_vif=hn.ed)(e,t,r),Ca=n.dynCall_iiiiiii=(e,t,r,a,o,i,s)=>(Ca=n.dynCall_iiiiiii=hn.fd)(e,t,r,a,o,i,s),wa=n.dynCall_iiiij=(e,t,r,a,o)=>(wa=n.dynCall_iiiij=hn.gd)(e,t,r,a,o),ba=n.dynCall_iiiiiiii=(e,t,r,a,o,i,s,l)=>(ba=n.dynCall_iiiiiiii=hn.hd)(e,t,r,a,o,i,s,l),Ka=n.dynCall_viiiiiiiiiiii=(e,t,r,a,o,i,s,l,d,u,c,p,g)=>(Ka=n.dynCall_viiiiiiiiiiii=hn.id)(e,t,r,a,o,i,s,l,d,u,c,p,g),fa=n.dynCall_diii=(e,t,r,a)=>(fa=n.dynCall_diii=hn.jd)(e,t,r,a),Qa=n.dynCall_jiiii=(e,t,r,a,o)=>(Qa=n.dynCall_jiiii=hn.kd)(e,t,r,a,o),Wa=n.dynCall_viiij=(e,t,r,a,o)=>(Wa=n.dynCall_viiij=hn.ld)(e,t,r,a,o),Fa=n.dynCall_fiiii=(e,t,r,a,o)=>(Fa=n.dynCall_fiiii=hn.md)(e,t,r,a,o),_a=n.dynCall_viiif=(e,t,r,a,o)=>(_a=n.dynCall_viiif=hn.nd)(e,t,r,a,o),ya=n.dynCall_diiii=(e,t,r,a,o)=>(ya=n.dynCall_diiii=hn.od)(e,t,r,a,o),va=n.dynCall_viiid=(e,t,r,a,o)=>(va=n.dynCall_viiid=hn.pd)(e,t,r,a,o),Ea=n.dynCall_iiiijii=(e,t,r,a,o,i,s)=>(Ea=n.dynCall_iiiijii=hn.qd)(e,t,r,a,o,i,s),Ga=n.dynCall_iiiiiij=(e,t,r,a,o,i,s)=>(Ga=n.dynCall_iiiiiij=hn.rd)(e,t,r,a,o,i,s),Ra=e=>(Ra=hn.sd)(e),xa=()=>(xa=hn.td)(),Sa=e=>(Sa=hn.ud)(e),Ta=()=>(Ta=hn.vd)();function Za(e,t,r){var n=Zn();try{Nn(e,t,r)}catch(e){if(Sn(n),e!==e+0)throw e;Gn(1,0)}}function Xa(e,t,r){var n=Zn();try{return Hn(e,t,r)}catch(e){if(Sn(n),e!==e+0)throw e;Gn(1,0)}}function Va(e,t){var r=Zn();try{Yn(e,t)}catch(e){if(Sn(r),e!==e+0)throw e;Gn(1,0)}}function ka(e,t){var r=Zn();try{return Ln(e,t)}catch(e){if(Sn(r),e!==e+0)throw e;Gn(1,0)}}function Ma(e,t,r,n){var a=Zn();try{return In(e,t,r,n)}catch(e){if(Sn(a),e!==e+0)throw e;Gn(1,0)}}function Ha(e,t,r,n,a){var o=Zn();try{Jn(e,t,r,n,a)}catch(e){if(Sn(o),e!==e+0)throw e;Gn(1,0)}}function Ya(e,t,r,n,a){var o=Zn();try{return Dn(e,t,r,n,a)}catch(e){if(Sn(o),e!==e+0)throw e;Gn(1,0)}}function La(e,t,r,n){var a=Zn();try{Un(e,t,r,n)}catch(e){if(Sn(a),e!==e+0)throw e;Gn(1,0)}}function Na(e,t,r,n,a,o,i){var s=Zn();try{return Ca(e,t,r,n,a,o,i)}catch(e){if(Sn(s),e!==e+0)throw e;Gn(1,0)}}function Ia(e){var t=Zn();try{jn(e)}catch(e){if(Sn(t),e!==e+0)throw e;Gn(1,0)}}function Ua(e,t,r){var n=Zn();try{return la(e,t,r)}catch(e){if(Sn(n),e!==e+0)throw e;Gn(1,0)}}function Da(e,t,r,n,a,o){var i=Zn();try{$n(e,t,r,n,a,o)}catch(e){if(Sn(i),e!==e+0)throw e;Gn(1,0)}}function Ja(e,t,r){var n=Zn();try{ca(e,t,r)}catch(e){if(Sn(n),e!==e+0)throw e;Gn(1,0)}}function Pa(e,t,r,n,a,o,i){var s=Zn();try{Pn(e,t,r,n,a,o,i)}catch(e){if(Sn(s),e!==e+0)throw e;Gn(1,0)}}function Oa(e,t,r,n,a,o,i,s){var l=Zn();try{On(e,t,r,n,a,o,i,s)}catch(e){if(Sn(l),e!==e+0)throw e;Gn(1,0)}}function za(e,t,r,n,a,o){var i=Zn();try{return sa(e,t,r,n,a,o)}catch(e){if(Sn(i),e!==e+0)throw e;Gn(1,0)}}function ja(e,t,r,n,a,o,i,s){var l=Zn();try{return ba(e,t,r,n,a,o,i,s)}catch(e){if(Sn(l),e!==e+0)throw e;Gn(1,0)}}function $a(e,t,r,n,a,o,i,s,l,d){var u=Zn();try{oa(e,t,r,n,a,o,i,s,l,d)}catch(e){if(Sn(u),e!==e+0)throw e;Gn(1,0)}}function qa(e,t,r,n,a,o,i,s,l){var d=Zn();try{ta(e,t,r,n,a,o,i,s,l)}catch(e){if(Sn(d),e!==e+0)throw e;Gn(1,0)}}function eo(e){var t=Zn();try{return qn(e)}catch(e){if(Sn(t),e!==e+0)throw e;Gn(1,0)}}function to(e,t,r,n,a,o,i,s,l,d){var u=Zn();try{return da(e,t,r,n,a,o,i,s,l,d)}catch(e){if(Sn(u),e!==e+0)throw e;Gn(1,0)}}function ro(e,t,r){var n=Zn();try{return ea(e,t,r)}catch(e){if(Sn(n),e!==e+0)throw e;Gn(1,0)}}function no(e,t,r,n){var a=Zn();try{return na(e,t,r,n)}catch(e){if(Sn(a),e!==e+0)throw e;return Gn(1,0),0n}}function ao(e,t,r){var n=Zn();try{return aa(e,t,r)}catch(e){if(Sn(n),e!==e+0)throw e;Gn(1,0)}}function oo(e,t,r,n,a,o,i,s,l,d,u,c){var p=Zn();try{ia(e,t,r,n,a,o,i,s,l,d,u,c)}catch(e){if(Sn(p),e!==e+0)throw e;Gn(1,0)}}function io(e,t,r,n,a,o,i,s,l,d,u){var c=Zn();try{ra(e,t,r,n,a,o,i,s,l,d,u)}catch(e){if(Sn(c),e!==e+0)throw e;Gn(1,0)}}function so(e,t,r,n,a,o,i,s,l,d,u){var c=Zn();try{return ua(e,t,r,n,a,o,i,s,l,d,u)}catch(e){if(Sn(c),e!==e+0)throw e;Gn(1,0)}}function lo(e,t,r,n){var a=Zn();try{return pa(e,t,r,n)}catch(e){if(Sn(a),e!==e+0)throw e;Gn(1,0)}}function uo(e,t,r,n){var a=Zn();try{return ga(e,t,r,n)}catch(e){if(Sn(a),e!==e+0)throw e;Gn(1,0)}}function co(e,t,r,n){var a=Zn();try{return Aa(e,t,r,n)}catch(e){if(Sn(a),e!==e+0)throw e;Gn(1,0)}}function po(e,t,r,n,a,o,i,s,l,d,u,c,p,g){var A=Zn();try{ha(e,t,r,n,a,o,i,s,l,d,u,c,p,g)}catch(e){if(Sn(A),e!==e+0)throw e;Gn(1,0)}}function go(e,t,r,n,a){var o=Zn();try{Ba(e,t,r,n,a)}catch(e){if(Sn(o),e!==e+0)throw e;Gn(1,0)}}function Ao(e,t,r){var n=Zn();try{ma(e,t,r)}catch(e){if(Sn(n),e!==e+0)throw e;Gn(1,0)}}function ho(e,t){var r=Zn();try{return zn(e,t)}catch(e){if(Sn(r),e!==e+0)throw e;return Gn(1,0),0n}}function Bo(e,t,r,n,a){var o=Zn();try{return wa(e,t,r,n,a)}catch(e){if(Sn(o),e!==e+0)throw e;Gn(1,0)}}function mo(e,t,r,n,a,o,i,s,l,d,u,c,p){var g=Zn();try{Ka(e,t,r,n,a,o,i,s,l,d,u,c,p)}catch(e){if(Sn(g),e!==e+0)throw e;Gn(1,0)}}function Co(e,t,r,n){var a=Zn();try{return fa(e,t,r,n)}catch(e){if(Sn(a),e!==e+0)throw e;Gn(1,0)}}function wo(e,t,r,n,a){var o=Zn();try{return Qa(e,t,r,n,a)}catch(e){if(Sn(o),e!==e+0)throw e;return Gn(1,0),0n}}function bo(e,t,r,n,a){var o=Zn();try{Wa(e,t,r,n,a)}catch(e){if(Sn(o),e!==e+0)throw e;Gn(1,0)}}function Ko(e,t,r,n,a){var o=Zn();try{return Fa(e,t,r,n,a)}catch(e){if(Sn(o),e!==e+0)throw e;Gn(1,0)}}function fo(e,t,r,n,a){var o=Zn();try{_a(e,t,r,n,a)}catch(e){if(Sn(o),e!==e+0)throw e;Gn(1,0)}}function Qo(e,t,r,n,a){var o=Zn();try{return ya(e,t,r,n,a)}catch(e){if(Sn(o),e!==e+0)throw e;Gn(1,0)}}function Wo(e,t,r,n,a){var o=Zn();try{va(e,t,r,n,a)}catch(e){if(Sn(o),e!==e+0)throw e;Gn(1,0)}}function Fo(e,t,r,n,a,o,i){var s=Zn();try{return Ea(e,t,r,n,a,o,i)}catch(e){if(Sn(s),e!==e+0)throw e;Gn(1,0)}}function _o(e,t,r,n,a,o,i){var s=Zn();try{return Ga(e,t,r,n,a,o,i)}catch(e){if(Sn(s),e!==e+0)throw e;Gn(1,0)}}return n.stackSave=()=>Zn(),n.stackRestore=e=>Sn(e),n.stackAlloc=e=>Tn(e),n.setValue=function(e,t,r="i8"){switch(r.endsWith("*")&&(r="*"),r){case"i1":case"i8":Z()[e>>>0]=t;break;case"i16":V()[e>>>1>>>0]=t;break;case"i32":M()[e>>>2>>>0]=t;break;case"i64":E[e>>>3]=BigInt(t);break;case"float":Y()[e>>>2>>>0]=t;break;case"double":L()[e>>>3>>>0]=t;break;case"*":H()[e>>>2>>>0]=t;break;default:j(`invalid type for setValue: ${r}`)}},n.getValue=function(e,t="i8"){switch(t.endsWith("*")&&(t="*"),t){case"i1":case"i8":return Z()[e>>>0];case"i16":return V()[e>>>1>>>0];case"i32":return M()[e>>>2>>>0];case"i64":return E[e>>>3];case"float":return Y()[e>>>2>>>0];case"double":return L()[e>>>3>>>0];case"*":return H()[e>>>2>>>0];default:j(`invalid type for getValue: ${t}`)}},n.UTF8ToString=Ve,n.stringToUTF8=Ye,n.lengthBytesUTF8=He,function e(){if(0<P)O=e;else if(s)t(n),D();else{for(;0<ae.length;)ae.shift()(n);0<P?O=e:(n.calledRun=!0,S||(D(),t(n)))}}(),n.PTR_SIZE=4,a},Df=ws,Mf=globalThis.self?.name?.startsWith("em-pthread"),Mf&&ws()})),Ts,Zn,Rf,Ve,Cs,jn,Uf,Nf,Is,Vf,xs,As,Ss,ks,Sr=W((()=>{xr(),Ts=typeof location>"u"?void 0:location.origin,Zn=import.meta.url>"file:"&&import.meta.url<"file;",Rf=()=>{if(Zn){let e=URL;return new URL(new e("ort.bundle.min.mjs",import.meta.url).href,Ts).href}return import.meta.url},Ve=Rf(),Cs=()=>{if(Ve&&!Ve.startsWith("blob:"))return Ve.substring(0,Ve.lastIndexOf("/")+1)},jn=(e,t)=>{try{let r=t??Ve;return(r?new URL(e,r):new URL(e)).origin===Ts}catch{return!1}},Uf=(e,t)=>{let r=t??Ve;try{return(r?new URL(e,r):new URL(e)).href}catch{return}},Nf=(e,t)=>`${t??"./"}${e}`,Is=async e=>{let t=await(await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},Vf=async e=>(await import(e)).default,xs=(_s(),br(bs)).default,As=async()=>{if(!Ve)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(jn(Ve))return[void 0,xs()];let e=await Is(Ve);return[e,xs(e)]},Ss=($s(),br(vs)).default,ks=async(e,t,r)=>{if(!e&&!t&&Ss&&Ve&&jn(Ve))return[void 0,Ss];{let n="ort-wasm-simd-threaded.jsep.mjs",a=e??Uf(n,t),o=r&&a&&!jn(a,t),i=o?await Is(a):a??Nf(n,t);return[o?i:void 0,await Vf(i)]}}})),Qn,Yn,Or,Es,Wf,Lf,Tr,Ie,bt=W((()=>{Sr(),Yn=!1,Or=!1,Es=!1,Wf=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Lf=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},Tr=async e=>{if(Yn)return Promise.resolve();if(Or)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(Es)throw new Error("previous call to 'initializeWebAssembly()' failed.");Or=!0;let t=e.initTimeout,r=e.numThreads;if(!Lf())throw new Error("WebAssembly SIMD is not supported in the current environment.");let n=Wf();r>1&&!n&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=r=1);let a=e.wasmPaths,o="string"==typeof a?a:void 0,i=a?.mjs,s=i?.href??i,l=a?.wasm,d=l?.href??l,u=e.wasmBinary,[c,p]=await ks(s,o,r>1),g=!1,A=[];if(t>0&&A.push(new Promise((e=>{setTimeout((()=>{g=!0,e()}),t)}))),A.push(new Promise(((e,t)=>{let n={numThreads:r};if(u)n.wasmBinary=u;else if(d||o)n.locateFile=e=>d??o+e;else if(s&&0!==s.indexOf("blob:"))n.locateFile=e=>new URL(e,s).href;else if(c){let e=Cs();e&&(n.locateFile=t=>e+t)}p(n).then((t=>{Or=!1,Yn=!0,Qn=t,e(),c&&URL.revokeObjectURL(c)}),(e=>{Or=!1,Es=!0,t(e)}))}))),await Promise.race(A),g)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Ie=()=>{if(Yn&&Qn)return Qn;throw new Error("WebAssembly is not initialized yet.")}})),Pe,Xt,he,Br=W((()=>{bt(),Pe=(e,t)=>{let r=Ie(),n=r.lengthBytesUTF8(e)+1,a=r._malloc(n);return r.stringToUTF8(e,a,n),t.push(a),a},Xt=(e,t,r,n)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,a])=>{let o=t?t+e:e;if("object"==typeof a)Xt(a,o+".",r,n);else if("string"==typeof a||"number"==typeof a)n(o,a.toString());else{if("boolean"!=typeof a)throw new Error("Can't handle extra config type: "+typeof a);n(o,a?"1":"0")}}))},he=e=>{let t=Ie(),r=t.stackSave();try{let r=t.PTR_SIZE,n=t.stackAlloc(2*r);t._OrtGetLastError(n,n+r);let a=Number(t.getValue(n,4===r?"i32":"i64")),o=t.getValue(n+r,"*"),i=o?t.UTF8ToString(o):"";throw new Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(r)}}})),Ps,zs=W((()=>{bt(),Br(),Ps=e=>{let t=Ie(),r=0,n=[],a=e||{};try{if(void 0===e?.logSeverityLevel)a.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===e?.logVerbosityLevel)a.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===e?.terminate&&(a.terminate=!1);let o=0;return void 0!==e?.tag&&(o=Pe(e.tag,n)),r=t._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,o),0===r&&he("Can't create run options."),void 0!==e?.extra&&Xt(e.extra,"",new WeakSet,((e,a)=>{let o=Pe(e,n),i=Pe(a,n);0!==t._OrtAddRunConfigEntry(r,o,i)&&he(`Can't set a run config entry: ${e} - ${a}.`)})),[r,n]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),n.forEach((e=>t._free(e))),e}}})),Gf,Hf,Ff,qf,Os,Bs=W((()=>{bt(),Br(),Gf=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},Hf=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Ff=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)},qf=(e,t,r)=>{for(let n of t){let t="string"==typeof n?n:n.name;switch(t){case"webnn":if(t="WEBNN","string"!=typeof n){let t=n?.deviceType;if(t){let n=Pe("deviceType",r),a=Pe(t,r);0!==Ie()._OrtAddSessionConfigEntry(e,n,a)&&he(`Can't set a session config entry: 'deviceType' - ${t}.`)}}break;case"webgpu":if(t="JS","string"!=typeof n){let t=n;if(t?.preferredLayout){if("NCHW"!==t.preferredLayout&&"NHWC"!==t.preferredLayout)throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${t.preferredLayout}`);let n=Pe("preferredLayout",r),a=Pe(t.preferredLayout,r);0!==Ie()._OrtAddSessionConfigEntry(e,n,a)&&he(`Can't set a session config entry: 'preferredLayout' - ${t.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${t}`)}let a=Pe(t,r);0!==Ie()._OrtAppendExecutionProvider(e,a)&&he(`Can't append execution provider: ${t}.`)}},Os=e=>{let t=Ie(),r=0,n=[],a=e||{};Ff(a);try{let e=Gf(a.graphOptimizationLevel??"all"),o=Hf(a.executionMode??"sequential"),i="string"==typeof a.logId?Pe(a.logId,n):0,s=a.logSeverityLevel??2;if(!Number.isInteger(s)||s<0||s>4)throw new Error(`log serverity level is not valid: ${s}`);let l=a.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw new Error(`log verbosity level is not valid: ${l}`);let d="string"==typeof a.optimizedModelFilePath?Pe(a.optimizedModelFilePath,n):0;if(r=t._OrtCreateSessionOptions(e,!!a.enableCpuMemArena,!!a.enableMemPattern,o,!!a.enableProfiling,0,i,s,l,d),0===r&&he("Can't create session options."),a.executionProviders&&qf(r,a.executionProviders,n),void 0!==a.enableGraphCapture){if("boolean"!=typeof a.enableGraphCapture)throw new Error(`enableGraphCapture must be a boolean value: ${a.enableGraphCapture}`);let e=Pe("enableGraphCapture",n),o=Pe(a.enableGraphCapture.toString(),n);0!==t._OrtAddSessionConfigEntry(r,e,o)&&he(`Can't set a session config entry: 'enableGraphCapture' - ${a.enableGraphCapture}.`)}if(a.freeDimensionOverrides)for(let[e,o]of Object.entries(a.freeDimensionOverrides)){if("string"!=typeof e)throw new Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof o||!Number.isInteger(o)||o<0)throw new Error(`free dimension override value must be a non-negative integer: ${o}`);let a=Pe(e,n);0!==t._OrtAddFreeDimensionOverride(r,a,o)&&he(`Can't set a free dimension override: ${e} - ${o}.`)}return void 0!==a.extra&&Xt(a.extra,"",new WeakSet,((e,a)=>{let o=Pe(e,n),i=Pe(a,n);0!==t._OrtAddSessionConfigEntry(r,o,i)&&he(`Can't set a session config entry: ${e} - ${a}.`)})),[r,n]}catch(e){throw 0!==r&&0!==t._OrtReleaseSessionOptions(r)&&he("Can't release session options."),n.forEach((e=>t._free(e))),e}}})),Rt,_t,wt,Dr,Jt,Mr,Rr,Xn,te=W((()=>{Rt=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},_t=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},wt=(e,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],n="number"==typeof t?t:t.reduce(((e,t)=>e*t),1);return r>0?Math.ceil(n*r):void 0},Dr=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Jt=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},Mr=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,Rr=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,Xn=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}})),er,Jn=W((()=>{xr(),er=async e=>{if("string"==typeof e){let t=await fetch(e);if(!t.ok)throw new Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),n=r?parseInt(r,10):0;if(n<1073741824)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let r,a=t.body.getReader();try{r=new ArrayBuffer(n)}catch(e){if(!(e instanceof RangeError))throw e;{let e=Math.ceil(n/65536);r=new WebAssembly.Memory({initial:e,maximum:e}).buffer}}let o=0;for(;;){let{done:e,value:t}=await a.read();if(e)break;let n=t.byteLength;new Uint8Array(r,o,n).set(t),o+=n}return new Uint8Array(r,0,n)}}return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}})),Kf,jf,Ds,Ms,Ur,Zf,pe,tt=W((()=>{te(),Kf=["V","I","W","E","F"],jf=(e,t)=>{console.log(`[${Kf[e]},${(new Date).toISOString()}]${t}`)},Ur=(e,t)=>{Ds=e,Ms=t},Zf=(e,t)=>{let r=Jt(e);r>=Jt(Ds)&&jf(r,"function"==typeof t?t():t)},pe=(...e)=>{Ms&&Zf(...e)}})),Nr,eo=W((()=>{te(),Nr=(e,t)=>new(Dr(t))(e)})),Vr=W((()=>{})),Rs,to,ro,Qf,Yf,Us,oo,no,Vs,Ws=W((()=>{tt(),Vr(),Rs=new Map([[64,250],[128,200],[256,200],[512,200],[2048,230],[4096,200],[8192,50],[16384,50],[32768,50],[65536,50],[131072,50],[262144,50],[524288,50],[1048576,50],[2097152,30],[4194304,20],[8388608,10],[12582912,10],[16777216,10],[26214400,15],[33554432,22],[44236800,2],[58982400,6],[67108864,6],[134217728,6],[167772160,6]]),to=[],ro=e=>16*Math.ceil(Number(e)/16),Qf=e=>{for(let t=0;t<to.length;t++){let r=to[t];if(e<=r)return r}return 16*Math.ceil(e/16)},Yf=1,Us=()=>Yf++,oo=async(e,t,r,n)=>{let a=ro(r),o=e.device.createBuffer({size:a,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});try{let i=e.getCommandEncoder();e.endComputePass(),i.copyBufferToBuffer(t,0,o,0,a),e.flush(),await o.mapAsync(GPUMapMode.READ);let s=o.getMappedRange();if(n){let e=n();return e.set(new Uint8Array(s,0,r)),e}return new Uint8Array(s.slice(0,r))}finally{o.destroy()}},no=class{constructor(e){this.backend=e,this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.buffersPending=[],this.capturedPendingBuffers=new Map;for(let[e]of Rs)to.push(e),this.freeBuffers.set(e,[]),this.freeUniformBuffers.set(e,[]);this.sessionCount=0}upload(e,t){let r=t.buffer,n=t.byteOffset,a=t.byteLength,o=ro(a),i=this.storageCache.get(e);if(!i)throw new Error("gpu data for uploading does not exist");if(Number(i.originalSize)!==a)throw new Error(`inconsistent data size. gpu data size=${i.originalSize}, data size=${a}`);let s=this.backend.device.createBuffer({mappedAtCreation:!0,size:o,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC}),l=s.getMappedRange();new Uint8Array(l).set(new Uint8Array(r,n,a)),s.unmap();let d=this.backend.device.createCommandEncoder();d.copyBufferToBuffer(s,0,i.gpuData.buffer,0,o),this.backend.device.queue.submit([d.finish()]),s.destroy(),pe("verbose",(()=>`[WebGPU] GpuDataManager.upload(id=${e})`))}memcpy(e,t){let r=this.storageCache.get(e);if(!r)throw new Error("source gpu data for memcpy does not exist");let n=this.storageCache.get(t);if(!n)throw new Error("destination gpu data for memcpy does not exist");if(r.originalSize!==n.originalSize)throw new Error("inconsistent source and destination gpu data size");let a=ro(r.originalSize),o=this.backend.getCommandEncoder();this.backend.endComputePass(),o.copyBufferToBuffer(r.gpuData.buffer,0,n.gpuData.buffer,0,a)}registerExternalBuffer(e,t,r){let n;if(r){if(n=r[0],e===r[1])return pe("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${n}, buffer is the same, skip.`)),n;if(this.backend.capturedCommandList.has(this.backend.currentSessionId))throw new Error("Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!")}else n=Us();return this.storageCache.set(n,{gpuData:{id:n,type:0,buffer:e},originalSize:t}),pe("verbose",(()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${t}) => id=${n}, registered.`)),n}unregisterExternalBuffer(e){void 0!==e&&(this.storageCache.delete(e),pe("verbose",(()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${e}`)))}create(e,t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST){let r,n=Qf(e),a=(t&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE,o=(t&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM;if(a||o){let e=(a?this.freeBuffers:this.freeUniformBuffers).get(n);r=e&&e.length>0?e.pop():this.backend.device.createBuffer({size:n,usage:t})}else r=this.backend.device.createBuffer({size:n,usage:t});let i={id:Us(),type:0,buffer:r};return this.storageCache.set(i.id,{gpuData:i,originalSize:Number(e)}),pe("verbose",(()=>`[WebGPU] GpuDataManager.create(size=${e}) => id=${i.id}`)),i}get(e){return this.storageCache.get(e)?.gpuData}release(e){let t="bigint"==typeof e?Number(e):e,r=this.storageCache.get(t);if(!r){if(0===this.storageCache.size)return 0;throw new Error("releasing data does not exist")}return pe("verbose",(()=>`[WebGPU] GpuDataManager.release(id=${t}), gpuDataId=${r.gpuData.id}`)),this.storageCache.delete(t),this.buffersPending.push(r.gpuData.buffer),r.originalSize}async download(e,t){let r=this.storageCache.get(Number(e));if(!r)throw new Error("data does not exist");await oo(this.backend,r.gpuData.buffer,r.originalSize,t)}refreshPendingBuffers(){if(0!==this.buffersPending.length)if("default"===this.backend.sessionStatus){for(let e of this.buffersPending){let t=Rs.get(e.size);if((e.usage&GPUBufferUsage.STORAGE)===GPUBufferUsage.STORAGE){let r=this.freeBuffers.get(e.size)||[];void 0===t||r.length>=t?e.destroy():r.push(e)}else if((e.usage&GPUBufferUsage.UNIFORM)===GPUBufferUsage.UNIFORM){let r=this.freeUniformBuffers.get(e.size)||[];void 0===t||r.length>=t?e.destroy():r.push(e)}else e.destroy()}this.buffersPending=[]}else{let e=this.capturedPendingBuffers.get(this.backend.currentSessionId);e||(e=[],this.capturedPendingBuffers.set(this.backend.currentSessionId,e));for(let t of this.buffersPending)e.push(t);this.buffersPending=[]}}dispose(){this.freeBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.freeUniformBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.capturedPendingBuffers.forEach((e=>{e.forEach((e=>{e.destroy()}))})),this.storageCache=new Map,this.freeBuffers=new Map,this.freeUniformBuffers=new Map,this.capturedPendingBuffers=new Map}onCreateSession(){this.sessionCount+=1}onReleaseSession(e){let t=this.capturedPendingBuffers.get(e);t&&(t.forEach((e=>{e.destroy()})),this.capturedPendingBuffers.delete(e)),this.sessionCount-=1,0===this.sessionCount&&(pe("warning",(()=>"[WebGPU] Clearing webgpu buffer cache")),this.storageCache.forEach((e=>{e.gpuData.buffer.destroy()})),this.storageCache=new Map)}},Vs=(...e)=>new no(...e)})),io,re,Ce=W((()=>{io=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this.key}},re=e=>new io(e)})),ao,rt,E,kt,Wr,Ls,Gs,ae=W((()=>{ao=class{static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}},rt=class{static calcShape(e,t,r=!1){let n=e.length,a=t.length;if(0===n)return t;if(0===a)return e;let o=Math.max(e.length,t.length),i=new Array(o);if(r){if(n<2||a<2)return;let r=ao.calcMatMulShape([e[n-2],e[n-1]],[t[a-2],t[a-1]]);if(void 0===r)return;[i[o-2],i[o-1]]=r}for(let s=r?3:1;s<=o;s++){let r=n-s<0?1:e[n-s],l=a-s<0?1:t[a-s];if(r!==l&&r>1&&l>1)return;let d=Math.max(r,l);if(r&&l)i[o-s]=Math.max(r,l);else{if(d>1)return;i[o-s]=0}}return i}static isValidBroadcast(e,t){let r=e.length,n=t.length;if(r>n)return!1;for(let a=1;a<=r;a++)if(1!==e[r-a]&&e[r-a]!==t[n-a])return!1;return!0}},E=class e{static size(t){return e.getSizeFromDimensionRange(t,0,t.length)}static convertShape(e,t=4){let r=e.length;if(0===r)return[];let n=new Array(r),a=r-1;for(;a>=0;){if(e[a]%t==0){n[a]=e[a]/t;break}if(t%e[a]!=0)throw new Error("cannot convert shape");n[a]=1,t/=e[a],a--}for(a--;a>=0;a--)n[a]=e[a];return n}static sizeFromDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,r,t.length)}static sizeToDimension(t,r){if(r<0||r>t.length)throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);return e.getSizeFromDimensionRange(t,0,r)}static getSizeFromDimensionRange(e,t,r){let n=1;for(let a=t;a<r;a++){if(e[a]<0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains negative values in them.");n*=Number(e[a])}return n}static computeStrides(e){let t=e.length;if(0===t)return[];if(1===t)return[1];let r=new Array(t);r[t-1]=1,r[t-2]=e[t-1];for(let n=t-3;n>=0;--n)r[n]=r[n+1]*e[n+1];return r}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((r=>this.normalizeAxis(r,t??e.length)))}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){let r=e.length;return e.map(((e,n)=>e+t[n]+t[n+r]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,r)=>e===t[r]))}},kt=class e{static adjustPoolAttributes(e,t,r,n,a,o){if(!e&&r.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=r.length?r.push(t[e+2]):r[e]=t[e+2];for(let e=0;e<r.length;e++)if(e<n.length){if(n[e]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let e=0;e<r.length;e++)if(e<a.length){if(a[e]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let e=0;e<2*r.length;e++)if(e<o.length){if(o[e]<0)throw new Error("pad should be greater than or equal to 1")}else o.push(0);for(let e=0;e<r.length;e++){if(r[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(o[e]>=r[e]||o[e+r.length]>=r[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(t,r,n,a,o,i,s){if(s){if(o.length!==2*(t.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(r.length!==t.length-2)throw new Error("length of strides should be the length of data dimensions");if(a.length!==t.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let l=0;l<t.length-2;l++)e.adjustPadAndReturnShape(t[l+(i?1:2)],r[l],n[l],a[l],o,l,l+t.length-2,s)}}static computePoolOutputShape(t,r,n,a,o,i,s){if(r.length<=0)throw new Error("input shape must be of size greater than 0");let l=[r[0],r[1]];return e.computeShapeHelper(t,r,l,n,a,o,i,s),l}static computeConvOutputShape(t,r,n,a,o,i,s){if(t.length<=0||r.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let l=[t[0],r[0]];return e.computeShapeHelper(!1,t,l,n,a,o,i,s),l}static computeShapeHelper(t,r,n,a,o,i,s,l){if(t)for(let e=0;e<r.length-2;e++)n.push(1);else for(let t=0;t<r.length-2;t++)n.push(e.adjustPadAndReturnShape(r[t+2],a[t],o[t],i[t],s,t,t+r.length-2,l))}static adjustPadAndReturnShape(e,t,r,n,a,o,i,s){let l=r*(n-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+a[o]+a[i]-l)/t+1);switch(s){case"VALID":return a[o]=0,a[i]=0,Math.floor((e-l)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==r)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let r=((e+t-1)/t-1)*t+n-e;return a[o]=Math.floor("SAME_LOWER"===s?(r+1)/2:r/2),a[i]=r-a[o],Math.floor((e+r-n)/t+1)}default:throw new Error("Unsupported AutoPad type")}}},Wr=class{static getShapeOfGemmResult(e,t,r,n,a){if(2!==e.length||2!==r.length)throw new Error("shape need to be of size 2");let o,i,s;t?(o=e[1],i=e[0]):(o=e[0],i=e[1]);let l=-1;if(n?(s=r[0],l=1):(s=r[1],l=0),r[l]!==i)throw new Error("dimension mismatch");if(o<=0||s<=0||i<=0)throw new Error("invalid shape specified");if(a&&!rt.isValidBroadcast(a,[o,s]))throw new Error("gemm: invalid bias shape for broadcast");return[o,s,i]}},Ls=-34028234663852886e22,Gs=34028234663852886e22})),Et,uo,_e,ze,G,ge,lo,Pt,Ke,j,Lr,P,N,Hs,Gr,so,Fs,ce=W((()=>{te(),ae(),Et=64,uo=(e,t)=>{if(3===t)throw new Error("vec3 has same alignment as vec4, use vec4 instead");switch(Number(e)){case 10:return t>1?`vec${t}<f16>`:"f16";case 1:return t>1?`vec${t}<f32>`:"f32";case 6:return t>1?`vec${t}<i32>`:"i32";case 12:return t>1?`vec${t}<u32>`:"u32";case 7:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","i32"];case 13:if(t>1)throw new Error("currently not supported vecX of uint64 yet");return["vec2<u32>","u32"];case 9:if(4!==t)throw new Error("bool must be vec4");return["u32","vec4<bool>"];case 22:return"i32";case 21:return"u32";default:throw new Error(`Unknown data type: ${e}`)}},_e=(e,t=1)=>{let r=uo(e,t);return"string"==typeof r?r:r[0]},ze=(e,t=1)=>{let r=uo(e,t);return"string"==typeof r?r:r[1]},G=(...e)=>{let t=[];return e.forEach((e=>{0!==e.length&&t.push({type:12,data:e},{type:12,data:E.computeStrides(e)})})),t},ge=e=>e%4==0?4:e%2==0?2:1,lo=(e="f32",t,r="0")=>t&&1!==t?`vec${t}<${e}>(${r})`:`${e}(${r})`,Pt=(e,t,r)=>"f32"===e?r:1===t?`f32(${r})`:`vec${t}<f32>(${r})`,Ke=(e,t)=>4===t?`(${e}.x + ${e}.y + ${e}.z + ${e}.w)`:2===t?`(${e}.x + ${e}.y)`:3===t?`(${e}.x + ${e}.y + ${e}.z)`:e,j=(e,t,r,n)=>e.startsWith("uniforms.")&&r>4?"string"==typeof t?"f16"===n?`${e}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]`:`${e}[(${t}) / 4][(${t}) % 4]`:"f16"===n?`${e}[${Math.floor(t/8)}][${Math.floor(t%8/4)}][${t%8%4}]`:`${e}[${Math.floor(t/4)}][${t%4}]`:r>1?`${e}[${t}]`:e,Lr=(e,t,r,n,a)=>{let o="number"==typeof r,i=o?r:r.length,s=[...new Array(i).keys()],l=i<2?"u32":i<=4?`vec${i}<u32>`:`array<u32, ${i}>`,d=uo(t,a),u="string"==typeof d?d:d[1],c="string"==typeof d?d:d[0],p={indices:l,value:u,storage:c,tensor:t},g=e=>"string"==typeof e?e:`${e}u`,A={offsetToIndices:!1,indicesToOffset:!1,broadcastedIndicesToOffset:!1,set:!1,setByIndices:!1,get:!1,getByIndices:!1},h=o?"uniforms.":"",B=`${h}${e}_shape`,m=`${h}${e}_strides`,C="";for(let e=0;e<i-1;e++)C+=`\n    let dim${e} = current / ${j(m,e,i)};\n    let rest${e} = current % ${j(m,e,i)};\n    indices[${e}] = dim${e};\n    current = rest${e};\n    `;C+=`indices[${i-1}] = current;`;let w=i<2?"":`\n  fn o2i_${e}(offset: u32) -> ${p.indices} {\n    var indices: ${p.indices};\n    var current = offset;\n    ${C}\n    return indices;\n  }`,b=[];if(i>=2)for(let e=i-1;e>=0;e--)b.push(`${j(m,e,i)} * (indices[${e}])`);let K=i<2?"":`\n  fn i2o_${e}(indices: ${p.indices}) -> u32 {\n    return ${b.join("+")};\n  }`,f=(...e)=>0===i?"0u":`${p.indices}(${e.map(g).join(",")})`,Q=(e,t)=>i<2?`${e}`:`${j(e,t,i)}`,W={},F=(t,r)=>(()=>{if(p.storage===p.value)return`${e}[${t}]=${r};`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${r}), select(0u, 0xFFFFFFFFu, ${r} < 0));`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`${e}[${t}]=vec2<u32>(u32(${r}), 0u);`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`${e}[${t}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${r}));`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),_=t=>(()=>{if(p.storage===p.value)return`${e}[${t}]`;if("vec2<u32>"===p.storage&&"i32"===p.value)return`i32(${e}[${t}].x)`;if("vec2<u32>"===p.storage&&"u32"===p.value)return`u32(${e}[${t}].x)`;if("u32"===p.storage&&"vec4<bool>"===p.value)return`vec4<bool>(bool(${e}[${t}] & 0xFFu), bool(${e}[${t}] & 0xFF00u), bool(${e}[${t}] & 0xFF0000u), bool(${e}[${t}] & 0xFF000000u))`;throw new Error(`not supported combination of storage type ${p.storage} and value type ${p.value} yet`)})(),y=i<2?"":`\n  fn get_${e}ByIndices(indices: ${p.indices}) -> ${u} {\n    return ${_(`i2o_${e}(indices)`)};\n  }`,v=i<2?"":(()=>{let t=s.map((e=>`d${e}: u32`)).join(", "),r=s.map((e=>`d${e}`)).join(", ");return`\n  fn get_${e}(${t}) -> ${u} {\n    return get_${e}ByIndices(${f(r)});\n  }`})(),G=i<2?"":`\n  fn set_${e}ByIndices(indices: ${p.indices}, value: ${u}) {\n    ${F(`i2o_${e}(indices)`,"value")}\n  }`,R=i<2?"":(()=>{let t=s.map((e=>`d${e}: u32`)).join(", "),r=s.map((e=>`d${e}`)).join(", ");return`\n  fn set_${e}(${t}, value: ${u}) {\n    set_${e}ByIndices(${f(r)}, value);\n  }`})();return{impl:()=>{let e=[],t=!1;return A.offsetToIndices&&(e.push(w),t=!0),A.indicesToOffset&&(e.push(K),t=!0),A.broadcastedIndicesToOffset&&(Object.values(W).forEach((t=>e.push(t))),t=!0),A.set&&(e.push(R),t=!0),A.setByIndices&&(e.push(G),t=!0),A.get&&(e.push(v),t=!0),A.getByIndices&&(e.push(y),t=!0),!o&&t&&e.unshift(`const ${B} = ${p.indices}(${r.join(",")});`,`const ${m} = ${p.indices}(${E.computeStrides(r).join(",")});`),e.join("\n")},type:p,offsetToIndices:t=>(A.offsetToIndices=!0,i<2?t:`o2i_${e}(${t})`),indicesToOffset:t=>(A.indicesToOffset=!0,i<2?t:`i2o_${e}(${t})`),broadcastedIndicesToOffset:(t,r)=>{A.broadcastedIndicesToOffset=!0;let n=`${r.name}broadcastedIndicesTo${e}Offset`;if(n in W)return`${n}(${t})`;let a=[];for(let e=i-1;e>=0;e--){let t=r.indicesGet("outputIndices",e+r.rank-i);a.push(`${Q(m,e)} * (${t} % ${Q(B,e)})`)}return W[n]=`fn ${n}(outputIndices: ${r.type.indices}) -> u32 {\n             return ${a.length>0?a.join("+"):"0u"};\n           }`,`${n}(${t})`},indices:f,indicesGet:Q,indicesSet:(e,t,r)=>i<2?`${e}=${r};`:`${j(e,t,i)}=${r};`,set:(...t)=>{if(t.length!==i+1)throw new Error(`indices length must be ${i}`);let r=t[i];if("string"!=typeof r)throw new Error("value must be string");let n=t.slice(0,i).map(g).join(",");return 0===i?F("0u",r):1===i?F(n[0],r):(A.set=!0,A.setByIndices=!0,A.indicesToOffset=!0,`set_${e}(${n}, ${r})`)},setByOffset:F,setByIndices:(t,r)=>i<2?F(t,r):(A.setByIndices=!0,A.indicesToOffset=!0,`set_${e}ByIndices(${t}, ${r});`),get:(...t)=>{if(t.length!==i)throw new Error(`indices length must be ${i}`);let r=t.map(g).join(",");return 0===i?_("0u"):1===i?_(r[0]):(A.get=!0,A.getByIndices=!0,A.indicesToOffset=!0,`get_${e}(${r})`)},getByOffset:_,getByIndices:t=>i<2?_(t):(A.getByIndices=!0,A.indicesToOffset=!0,`get_${e}ByIndices(${t})`),usage:n,name:e,strides:m,shape:B,rank:i}},P=(e,t,r,n=1)=>Lr(e,t,r,"input",n),N=(e,t,r,n=1)=>Lr(e,t,r,"output",n),Hs=(e,t,r)=>Lr(e,t,r,"atomicOutput",1),Gr=(e,t,r,n=1)=>Lr(e,t,r,"internal",n),so=class{constructor(e,t){this.normalizedDispatchGroup=e,this.limits=t,this.internalVariables=[],this.variables=[],this.uniforms=[],this.variableIndex=0}guardAgainstOutOfBoundsWorkgroupSizes(e){return`if (global_idx >= ${"number"==typeof e?`${e}u`:e}) { return; }`}mainStart(e=Et){let t="number"==typeof e?e:e[0],r="number"==typeof e?1:e[1],n="number"==typeof e?1:e[2];if(t>this.limits.maxComputeWorkgroupSizeX||r>this.limits.maxComputeWorkgroupSizeY||n>this.limits.maxComputeWorkgroupSizeZ)throw new Error(`workgroup size [${t}, ${r}, ${n}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);if(t*r*n>this.limits.maxComputeInvocationsPerWorkgroup)throw new Error(`workgroup size [${t}, ${r}, ${n}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);let a=1===this.normalizedDispatchGroup[1]&&1===this.normalizedDispatchGroup[2];return`@compute @workgroup_size(${t}, ${r}, ${n})\n  fn main(${a?"@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>":"@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>"}) {\n    ${a?"let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;":`let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${t*r*n}u + local_idx;`}\n  `}appendVariableUniforms(e){0!==e.rank&&(e.shape.startsWith("uniforms.")&&this.uniforms.push({name:e.shape.replace("uniforms.",""),type:"u32",length:e.rank}),e.strides.startsWith("uniforms.")&&this.uniforms.push({name:e.strides.replace("uniforms.",""),type:"u32",length:e.rank}))}declareVariable(e,t){if("internal"===e.usage)throw new Error("cannot use internal variable with declareVariable(). use registerInternalVariables() instead.");this.variables.push(e),this.appendVariableUniforms(e);let r="input"===e.usage?"read":"read_write",n="atomicOutput"===e.usage?"atomic<i32>":e.type.storage;return`@group(0) @binding(${t}) var<storage, ${r}> ${e.name}: array<${n}>;`}declareVariables(...e){return e.map((e=>this.declareVariable(e,this.variableIndex++))).join("\n")}registerInternalVariable(e){if("internal"!==e.usage)throw new Error("cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.");this.internalVariables.push(e),this.appendVariableUniforms(e)}registerInternalVariables(...e){return e.forEach((e=>this.registerInternalVariable(e))),this}registerUniform(e,t,r=1){return this.uniforms.push({name:e,type:t,length:r}),this}registerUniforms(e){return this.uniforms=this.uniforms.concat(e),this}uniformDeclaration(){if(0===this.uniforms.length)return"";let e=[];for(let{name:t,type:r,length:n}of this.uniforms)if(n&&n>4)"f16"===r?e.push(`@align(16) ${t}:array<mat2x4<${r}>, ${Math.ceil(n/8)}>`):e.push(`${t}:array<vec4<${r}>, ${Math.ceil(n/4)}>`);else{let a=null==n||1===n?r:`vec${n}<${r}>`;e.push(`${t}:${a}`)}return`\n      struct Uniforms { ${e.join(", ")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`}get additionalImplementations(){return this.uniformDeclaration()+this.variables.map((e=>e.impl())).join("\n")+this.internalVariables.map((e=>e.impl())).join("\n")}get variablesInfo(){if(0===this.uniforms.length)return;let e=e=>[12,10,1,6][["u32","f16","f32","i32"].indexOf(e)];return this.uniforms.map((t=>[e(t.type),t.length??1]))}},Fs=(e,t)=>new so(e,t)})),Xf,qs,Jf,eh,th,rh,Oe,Ks,js,ct=W((()=>{te(),ae(),Ce(),ce(),Xf=(e,t)=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if(0!==t.length&&t.length!==e[0].dims.length)throw new Error(`perm size ${t.length} does not match input rank ${e[0].dims.length}`)},qs=(e,t)=>0!==t.length?t:[...new Array(e).keys()].reverse(),Jf=(e,t)=>E.sortBasedOnPerm(e,qs(e.length,t)),eh=(e,t,r,n)=>{let a=`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`;for(let r=0;r<t;++r)a+=`a[${e[r]}]=i[${r}];`;return a+"return a;}"},th=(e,t)=>{let r=[],n=[];for(let a=0;a<e.length;++a)1!==e[a]&&r.push(e[a]),1!==e[t[a]]&&n.push(t[a]);return{newShape:r,newPerm:n}},rh=(e,t)=>{let r=0;for(let n=0;n<e.length;++n)if(1!==t[e[n]]){if(e[n]<r)return!1;r=e[n]}return!0},Oe=(e,t)=>{let r,n=e.dataType,a=e.dims.length,o=qs(a,t),i=Jf(e.dims,o),s=e.dims,l=i;if(a<2||rh(o,e.dims))return r=e=>{let t=P("input",n,s,4),r=N("output",n,l,4);return`\n  ${e.registerUniform("output_size","u32").declareVariables(t,r)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    output[global_idx] = input[global_idx];\n  }`},{name:"TransposeCopy",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let t=E.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64/4)},programUniforms:[{type:12,data:Math.ceil(t/4)}]}},getShaderSource:r};let{newShape:d,newPerm:u}=th(e.dims,o),c=E.areEqual(u,[2,3,1]),p=E.areEqual(u,[3,1,2]);if(2===d.length||c||p){s=c?[d[0],d[1]*d[2]]:p?[d[0]*d[1],d[2]]:d,l=[s[1],s[0]];let t=16;return r=e=>{let r=P("a",n,s.length),a=N("output",n,l.length);return`\n  ${e.registerUniform("output_size","u32").declareVariables(r,a)}\n  var<workgroup> tile : array<array<${a.type.value}, ${t+1}>, ${t}>;\n  ${e.mainStart([t,t,1])}\n    let stride = (uniforms.output_shape[1] - 1) / ${t} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${t}u + local_id.x;\n    let input_row = workgroup_id_x * ${t}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${r.getByIndices(`${r.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${t}u + local_id.x;\n    let output_row = workgroup_id_y * ${t}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${a.setByIndices(`${a.type.indices}(output_row, output_col)`,"tile[local_id.x][local_id.y]")}\n    }\n  }`},{name:"TransposeShared",shaderCache:{inputDependencies:["type"]},getRunData:()=>{let r=E.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(l[1]/t),y:Math.ceil(l[0]/t)},programUniforms:[{type:12,data:r},...G(s,l)]}},getShaderSource:r}}return r=e=>{let t=P("a",n,s.length),r=N("output",n,l.length);return`\n  ${e.registerUniform("output_size","u32").declareVariables(t,r)}\n\n  ${eh(o,a,t,r)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${r.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${r.setByOffset("global_idx",t.getByIndices("aIndices"))}\n  }`},{name:"Transpose",shaderCache:{hint:`${t}`,inputDependencies:["rank"]},getRunData:()=>{let t=E.size(i);return{outputs:[{dims:i,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:[{type:12,data:t},...G(s,l)]}},getShaderSource:r}},Ks=(e,t)=>{Xf(e.inputs,t.perm),e.compute(Oe(e.inputs[0],t.perm))},js=e=>re({perm:e.perm})})),nh,oh,ih,ah,sh,uh,dh,lh,ch,ph,nt,Zs,Qs,Ys,Xs,Js,eu,tu,ru,nu,ou,iu=W((()=>{te(),ae(),ce(),Hr(),ct(),nh={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate * candidate",logSumExp:"bestValue + exp(candidate)",l1:"bestValue + abs(candidate)",l2:"bestValue + candidate * candidate",logSum:"bestValue + candidate"},oh={max:"select(bestValue, candidate, candidate > bestValue)",min:"select(bestValue, candidate, candidate < bestValue)",mean:"bestValue + candidate",sum:"bestValue + candidate",prod:"bestValue * candidate",sumSquare:"bestValue + candidate",logSumExp:"bestValue + candidate",l1:"bestValue + candidate",l2:"bestValue + candidate",logSum:"bestValue + candidate"},ih={max:"_A[offset]",min:"_A[offset]",mean:"0",sum:"0",prod:"1",sumSquare:"0",logSumExp:"0",l1:"0",l2:"0",logSum:"0"},ah={max:"bestValue",min:"bestValue",sum:"bestValue",prod:"bestValue",sumSquare:"bestValue",logSumExp:"log(bestValue)",l1:"bestValue",l2:"sqrt(bestValue)",logSum:"log(bestValue)"},sh=(e,t)=>{let r=[];for(let n=t-e;n<t;++n)r.push(n);return r},uh=(e,t)=>{let r=[],n=e.length;for(let a=0;a<n;a++)-1===t.indexOf(a)&&r.push(e[a]);return[r,t.map((t=>e[t]))]},dh=(e,t)=>{let r=e.length+t.length,n=[],a=0;for(let o=0;o<r;o++)-1===t.indexOf(o)?n.push(e[a++]):n.push(1);return n},lh=(e,t)=>{for(let r=0;r<e.length;++r)if(e[e.length-r-1]!==t-1-r)return!1;return!0},ch=(e,t)=>{let r=[];if(!lh(e,t)){for(let n=0;n<t;++n)-1===e.indexOf(n)&&r.push(n);e.forEach((e=>r.push(e)))}return r},ph=(e,t,r,n,a,o,i)=>{let s=r[0].dims,l=E.size(o),d=E.size(i),u=P("_A",r[0].dataType,s),c=N("output",a,o),p=64;1===l&&(p=256);let g=`\n          var<workgroup> aBestValues : array<f32, ${p}>;\n       `;return{name:e,shaderCache:{hint:`${t};${p}`,inputDependencies:["type"]},getShaderSource:e=>`\n        ${e.registerUniform("reduceSize","u32").declareVariables(u,c)}\n        ${g}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${e.mainStart(p)}\n\n          let outputIndex = global_idx / ${p};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${ih[n]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${p}) {\n           let candidate = f32(${u.getByOffset("offset + k")});\n           bestValue = ${nh[n]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${p}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${oh[n]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${c.setByOffset("outputIndex",""+("mean"===n?`${c.type.storage}(bestValue / f32(uniforms.reduceSize))`:`${c.type.storage}(${ah[n]})`))};\n         }\n        }`,getRunData:()=>({outputs:[{dims:o,dataType:a}],dispatchGroup:{x:l},programUniforms:[{type:12,data:d}]})}},nt=(e,t,r,n)=>{let a=1===e.inputs.length?r:co(e.inputs,r),o=a.axes;0===o.length&&!a.noopWithEmptyAxes&&(o=e.inputs[0].dims.map(((e,t)=>t)));let i=E.normalizeAxes(o,e.inputs[0].dims.length),s=i,l=e.inputs[0],d=ch(s,e.inputs[0].dims.length);d.length>0&&(l=e.compute(Oe(e.inputs[0],d),{inputs:[0],outputs:[-1]})[0],s=sh(s.length,l.dims.length));let[u,c]=uh(l.dims,s),p=u;a.keepDims&&(p=dh(u,i)),e.compute(ph(t,a.cacheKey,[l],n,e.inputs[0].dataType,p,c),{inputs:[l]})},Zs=(e,t)=>{nt(e,"ReduceMeanShared",t,"mean")},Qs=(e,t)=>{nt(e,"ReduceL1Shared",t,"l1")},Ys=(e,t)=>{nt(e,"ReduceL2Shared",t,"l2")},Xs=(e,t)=>{nt(e,"ReduceLogSumExpShared",t,"logSumExp")},Js=(e,t)=>{nt(e,"ReduceMaxShared",t,"max")},eu=(e,t)=>{nt(e,"ReduceMinShared",t,"min")},tu=(e,t)=>{nt(e,"ReduceProdShared",t,"prod")},ru=(e,t)=>{nt(e,"ReduceSumShared",t,"sum")},nu=(e,t)=>{nt(e,"ReduceSumSquareShared",t,"sumSquare")},ou=(e,t)=>{nt(e,"ReduceLogSumShared",t,"logSum")}})),ot,mh,Fr,co,it,fh,hh,gh,yh,bh,_h,wh,vh,$h,xh,at,au,su,uu,du,lu,cu,pu,mu,fu,hu,Hr=W((()=>{te(),ae(),Ce(),ce(),iu(),ot=e=>{if(!e||0===e.length||e.length>2)throw new Error("Reduce op requires 1 or 2 inputs.");if(2===e.length&&1!==e[1].dims.length)throw new Error("Invalid axes input dims.")},mh=e=>["","",`var value = ${e.getByIndices("input_indices")};`,""],Fr=(e,t,r,n,a,o,i=!1,s=!1)=>{let l=[],d=r[0].dims,u=d.length,c=E.normalizeAxes(a,u),p=!s&&0===c.length;d.forEach(((e,t)=>{p||c.indexOf(t)>=0?i&&l.push(1):l.push(e)}));let g=l.length,A=E.size(l);return{name:e,shaderCache:t,getShaderSource:e=>{let t=[],a=P("_A",r[0].dataType,u),s=N("output",o,g),l=n(a,s,c),A=l[2];for(let e=0,r=0;e<u;e++)p||c.indexOf(e)>=0?(i&&r++,A=`for(var j${e}: u32 = 0; j${e} < ${d[e]}; j${e}++) {\n                  ${l[2].includes("last_index")?`let last_index = j${e};`:""}\n                  ${a.indicesSet("input_indices",e,`j${e}`)}\n                  ${A}\n                }`):(t.push(`${a.indicesSet("input_indices",e,s.indicesGet("output_indices",r))};`),r++);return`\n\n        ${e.registerUniform("output_size","u32").declareVariables(a,s)}\n\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          var input_indices: ${a.type.indices};\n          let output_indices = ${s.offsetToIndices("global_idx")};\n\n          ${t.join("\n")}\n          ${l[0]}       // init ops for reduce max/min\n          ${l[1]}\n          ${A}\n          ${l[3]}\n          ${4===l.length?s.setByOffset("global_idx","value"):l.slice(4).join("\n")}\n        }`},getRunData:()=>({outputs:[{dims:l,dataType:o}],dispatchGroup:{x:Math.ceil(A/64)},programUniforms:[{type:12,data:A},...G(d,l)]})}},co=(e,t)=>{let r=[];return e[1].dims[0]>0&&e[1].getBigInt64Array().forEach((e=>r.push(Number(e)))),re({axes:r,keepDims:t.keepDims,noopWithEmptyAxes:t.noopWithEmptyAxes})},it=(e,t,r,n)=>{let a=e.inputs,o=1===a.length?r:co(a,r);e.compute(Fr(t,{hint:o.cacheKey,inputDependencies:["rank"]},[a[0]],o.noopWithEmptyAxes&&0===o.axes.length?mh:n,o.axes,a[0].dataType,o.keepDims,o.noopWithEmptyAxes),{inputs:[0]})},fh=(e,t)=>{ot(e.inputs),it(e,"ReduceLogSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,"value = log(value);"]))},hh=(e,t)=>{ot(e.inputs),it(e,"ReduceL1",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += abs(${e.getByIndices("input_indices")});`,""]))},gh=(e,t)=>{ot(e.inputs),it(e,"ReduceL2",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += (t * t);`,"value = sqrt(value);"]))},yh=(e,t)=>{ot(e.inputs),it(e,"ReduceLogSumExp",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += exp(${e.getByIndices("input_indices")});`,"value = log(value);"]))},bh=(e,t)=>{ot(e.inputs),it(e,"ReduceMax",t,((e,t,r)=>{let n=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&n.push(e.indicesSet("input_indices",t,0));return[`${n.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = max(value, ${e.getByIndices("input_indices")});`,""]}))},_h=(e,t)=>{ot(e.inputs),it(e,"ReduceMean",t,((t,r,n)=>{let a=1;for(let r=0;r<t.rank;r++)(n.indexOf(r)>=0||0===n.length)&&(a*=e.inputs[0].dims[r]);return["var sum = f32(0);","",`sum += f32(${t.getByIndices("input_indices")});`,`let value = ${r.type.value}(sum / ${a});`]}))},wh=(e,t)=>{ot(e.inputs),it(e,"ReduceMin",t,((e,t,r)=>{let n=[];for(let t=0;t<e.rank;t++)(r.indexOf(t)>=0||0===r.length)&&n.push(`input_indices[${t}] = 0;`);return[`${n.join("\n")}`,`var value = ${e.getByIndices("input_indices")};`,`value = min(value, ${e.getByIndices("input_indices")});`,""]}))},vh=(e,t)=>{ot(e.inputs),it(e,"ReduceProd",t,((e,t)=>[`var value = ${t.type.storage}(1);`,"",`value *= ${e.getByIndices("input_indices")};`,""]))},$h=(e,t)=>{ot(e.inputs),it(e,"ReduceSum",t,((e,t)=>[`var value = ${t.type.storage}(0);`,"",`value += ${e.getByIndices("input_indices")};`,""]))},xh=(e,t)=>{ot(e.inputs),it(e,"ReduceSumSquare",t,((e,t)=>[`var t = ${t.type.value}(0); var value = ${t.type.value}(0);`,"",`t = ${e.getByIndices("input_indices")}; value += t * t;`,""]))},at=(e,t,r)=>{if(0===t.length)return r;let n=1,a=1;for(let r=0;r<t.length;r++)-1===t.indexOf(r)?n*=e[r]:a*=e[r];return a<32&&n>1024},au=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?_h(e,t):Zs(e,t)},su=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?hh(e,t):Qs(e,t)},uu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?gh(e,t):Ys(e,t)},du=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?yh(e,t):Xs(e,t)},lu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?bh(e,t):Js(e,t)},cu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?wh(e,t):eu(e,t)},pu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?vh(e,t):tu(e,t)},mu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?$h(e,t):ru(e,t)},fu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?xh(e,t):nu(e,t)},hu=(e,t)=>{at(e.inputs[0].dims,t.axes,t.noopWithEmptyAxes)?fh(e,t):ou(e,t)}})),gu,yu,bu,po,_u=W((()=>{te(),Ce(),Hr(),gu=e=>{if(!e||0===e.length||e.length>2)throw new Error("ArgMinMaxOp op requires 1 or 2 inputs.");if(1!==e[0].dataType)throw new Error("Invalid input type.")},yu=(e,t)=>{gu(e.inputs);e.compute(Fr("ArgMin",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,r,n)=>{let a=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&a.push(`input_indices[${t}] = 0;`);return[`${a.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?"<=":"<"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",r.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},bu=(e,t)=>{gu(e.inputs);e.compute(Fr("argMax",{hint:t.cacheKey,inputDependencies:["rank"]},[e.inputs[0]],((e,r,n)=>{let a=[];for(let t=0;t<e.rank;t++)(n.indexOf(t)>=0||0===n.length)&&a.push(`input_indices[${t}] = 0;`);return[`${a.join("\n")}`,`var value = ${e.getByIndices("input_indices")};\nvar best_index : i32 = 0;`,`if (${e.getByIndices("input_indices")} ${t.selectLastIndex>0?">=":">"} value) {\n         value = ${e.getByIndices("input_indices")};\n         best_index = i32(last_index);\n       }`,"",r.setByOffset("global_idx","best_index")]}),[t.axis],7,t.keepDims),{inputs:[0]})},po=e=>re(e)})),Sh,mo,Th,Ch,Ih,Ut,Ah,wu,qr=W((()=>{te(),ae(),Vr(),ce(),Sh=(e,t)=>{let r=e[0],n=e[1],a=e[2],o=e[3],i=e[4],s=e[5];if(i&&s)throw new Error("Attention cannot have both past and attention_bias");if(3!==r.dims.length)throw new Error('Input "input" must have 3 dimensions');let l=r.dims[0],d=r.dims[1],u=r.dims[2];if(1!==a.dims.length)throw new Error('Input "bias" is expected to have 1 dimensions');if(2!==n.dims.length)throw new Error('Input "weights" is expected to have 2 dimensions');if(n.dims[0]!==u)throw new Error("Input 1 dimension 0 should have same length as dimension 2 of input 0");if(a.dims[0]!==n.dims[1])throw new Error('Input "bias" dimension 0 should have same length as dimension 1 of input "weights"');let c=a.dims[0]/3,p=c,g=p;if(t.qkvHiddenSizes.length>0){if(3!==t.qkvHiddenSizes.length)throw new Error("qkv_hidden_sizes attribute should have 3 elements");for(let e of t.qkvHiddenSizes)if(e%t.numHeads!=0)throw new Error("qkv_hidden_sizes should be divisible by num_heads");c=t.qkvHiddenSizes[0],p=t.qkvHiddenSizes[1],g=t.qkvHiddenSizes[2]}let A=d;if(c!==p)throw new Error("qkv_hidden_sizes first element should be same as the second");if(a.dims[0]!==c+p+g)throw new Error('Input "bias" dimension 0 should have same length as sum of Q/K/V hidden sizes');let h=0;if(i){if(p!==g)throw new Error('Input "past" expect k_hidden_size == v_hidden_size');if(5!==i.dims.length)throw new Error('Input "past" must have 5 dimensions');if(2!==i.dims[0])throw new Error('Input "past" first dimension must be 2');if(i.dims[1]!==l)throw new Error('Input "past" second dimension must be batch_size');if(i.dims[2]!==t.numHeads)throw new Error('Input "past" third dimension must be num_heads');if(i.dims[4]!==p/t.numHeads)throw new Error('Input "past" fifth dimension must be k_hidden_size / num_heads');t.pastPresentShareBuffer||(h=i.dims[3])}let B=A+h;if(o)throw new Error("Mask not supported");if(i)throw new Error("past is not supported");if(s){if(4!==s.dims.length)throw new Error('Input "attention_bias" must have 4 dimensions');if(s.dims[0]!==l||s.dims[1]!==t.numHeads||s.dims[2]!==d||s.dims[3]!==B)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:l,sequenceLength:d,pastSequenceLength:h,kvSequenceLength:A,totalSequenceLength:B,maxSequenceLength:-1,inputHiddenSize:u,hiddenSize:c,vHiddenSize:g,headSize:Math.floor(c/t.numHeads),vHeadSize:Math.floor(g/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:!1,qkvFormat:1}},mo=(e,t,r)=>t&&e?`\n      let total_sequence_length_input = u32(${t.getByOffset("0")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e?.getByOffset("batchIdx")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       `:`\n    ${r?"let past_sequence_length = uniforms.past_sequence_length":""};\n    let present_sequence_length = total_sequence_length;\n    `,Th=(e,t,r,n,a,o,i,s)=>{let l=ge(i?1:o),d=64,u=o/l;u<d&&(d=32);let c=Math.ceil(o/l/d),p=[{type:12,data:t},{type:12,data:r},{type:12,data:n},{type:12,data:a},{type:12,data:u},{type:12,data:c}],g=_e(e.dataType,l),A=ze(1,l),h=["type"];i&&h.push("type"),s&&h.push("type");return{name:"AttentionProbsSoftmax",shaderCache:{hint:`${d};${g};${l}`,inputDependencies:h},getShaderSource:t=>{let r=N("x",e.dataType,e.dims,l),n=[r],a=i?P("seq_lens",i.dataType,i.dims):void 0;a&&n.push(a);let o=s?P("total_sequence_length_input",s.dataType,s.dims):void 0;o&&n.push(o);let u=ze(e.dataType);return`\n  var<workgroup> thread_max: array<f32, ${d}>;\n  var<workgroup> thread_sum: array<f32, ${d}>;\n  ${t.registerUniforms([{name:"batch_size",type:"u32"},{name:"num_heads",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"sequence_length",type:"u32"},{name:"total_sequence_length",type:"u32"},{name:"elements_per_thread",type:"u32"}]).declareVariables(...n)}\n  ${t.mainStart([d,1,1])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${mo(a,o,!1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${d}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${i?"u32(past_sequence_length + workgroup_id.y + 1)":"total_sequence_length"};\n    var thread_max_vector = ${A}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${A}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{switch(l){case 1:return"thread_max_vector";case 2:return"max(thread_max_vector.x, thread_max_vector.y)";case 4:return"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${d}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${A}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${A}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{switch(l){case 1:return"sum_vector";case 2:return"sum_vector.x + sum_vector.y";case 4:return"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w";default:throw new Error(`Unsupported components: ${l}`)}})()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${d}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${r.type.value}(${u}(1.0) / ${u}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${A}(x[offset + i]);\n        x[offset + i] = ${r.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${i?`\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${r.type.value}(${u}(0));\n        }`:""};\n  }`},getRunData:()=>({outputs:[],dispatchGroup:{x:1,y:a,z:t*r},programUniforms:p})}},Ch=(e,t,r,n,a,o,i,s,l)=>{let d=i+o.kvSequenceLength,u=[o.batchSize,o.numHeads,o.sequenceLength,d],c=e>1&&n,p=o.kvNumHeads?o.kvNumHeads:o.numHeads,g=c?[o.batchSize,p,d,o.headSize]:void 0,A=o.nReps?o.nReps:1,h=0===o.scale?1/Math.sqrt(o.headSize):o.scale,B=ge(o.headSize),m=o.headSize/B,C=12,w={x:Math.ceil(d/C),y:Math.ceil(o.sequenceLength/C),z:o.batchSize*o.numHeads},b=[{type:12,data:o.sequenceLength},{type:12,data:m},{type:12,data:d},{type:12,data:o.numHeads},{type:12,data:o.headSize},{type:1,data:h},{type:12,data:i},{type:12,data:o.kvSequenceLength},{type:12,data:A}],K=c&&n&&E.size(n.dims)>0,f=["type","type"];K&&f.push("type"),a&&f.push("type"),s&&f.push("type"),l&&f.push("type");let Q=[{dims:u,dataType:t.dataType,gpuDataType:0}];c&&Q.push({dims:g,dataType:t.dataType,gpuDataType:0});return{name:"AttentionProbs",shaderCache:{hint:`${B};${void 0!==a};${void 0!==n};${e}`,inputDependencies:f},getRunData:()=>({outputs:Q,dispatchGroup:w,programUniforms:b}),getShaderSource:e=>{let o=P("q",t.dataType,t.dims,B),i=[o,P("key",r.dataType,r.dims,B)];if(K){let e=P("past_key",n.dataType,n.dims,B);i.push(e)}a&&i.push(P("attention_bias",a.dataType,a.dims));let d=s?P("seq_lens",s.dataType,s.dims):void 0;d&&i.push(d);let p=l?P("total_sequence_length_input",l.dataType,l.dims):void 0;p&&i.push(p);let h=N("output",t.dataType,u),m=[h];c&&m.push(N("present_key",t.dataType,g,B));let w=ze(1,B);return`\n  const TILE_SIZE = 12u;\n\n  var<workgroup> tileQ: array<${o.type.storage}, 144>;\n  var<workgroup> tileK: array<${o.type.storage}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"alpha",type:"f32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...i,...m)}\n  ${e.mainStart([C,C,1])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${1===A?"headIdx":"headIdx / uniforms.n_reps"};\n    let kv_num_heads = ${1===A?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${mo(d,p,!0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${K&&c?"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;":""};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${c?"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;":""}\n    var value = ${w}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${K&&c?"\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }":"\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }"}\n      ${c?"if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }":""}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${w}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{switch(B){case 1:return"value";case 2:return"value.x + value.y";case 4:return"value.x + value.y + value.z + value.w";default:throw new Error(`Unsupported components: ${B}`)}})()};\n        output[outputIdx] = ${h.type.value} (sum * uniforms.alpha) + ${a?"attention_bias[outputIdx]":"0.0"};\n    }\n  }`}}},Ih=(e,t,r,n,a,o,i=void 0,s=void 0)=>{let l=o+a.kvSequenceLength,d=a.nReps?a.nReps:1,u=a.vHiddenSize*d,c=e>1&&n,p=a.kvNumHeads?a.kvNumHeads:a.numHeads,g=c?[a.batchSize,p,l,a.headSize]:void 0,A=[a.batchSize,a.sequenceLength,u],h=12,B={x:Math.ceil(a.vHeadSize/h),y:Math.ceil(a.sequenceLength/h),z:a.batchSize*a.numHeads},m=[{type:12,data:a.sequenceLength},{type:12,data:l},{type:12,data:a.vHeadSize},{type:12,data:a.numHeads},{type:12,data:a.headSize},{type:12,data:u},{type:12,data:o},{type:12,data:a.kvSequenceLength},{type:12,data:d}],C=c&&n&&E.size(n.dims)>0,w=["type","type"];C&&w.push("type"),i&&w.push("type"),s&&w.push("type");let b=[{dims:A,dataType:t.dataType,gpuDataType:0}];c&&b.push({dims:g,dataType:t.dataType,gpuDataType:0});return{name:"AttentionScore",shaderCache:{hint:`${void 0!==n};${e}`,inputDependencies:w},getRunData:()=>({outputs:b,dispatchGroup:B,programUniforms:m}),getShaderSource:e=>{let a=P("probs",t.dataType,t.dims),o=[a,P("v",r.dataType,r.dims)];C&&o.push(P("past_value",n.dataType,n.dims));let l=i?P("seq_lens",i.dataType,i.dims):void 0;i&&o.push(l);let u=s?P("total_sequence_length_input",s.dataType,s.dims):void 0;s&&o.push(u);let p=[N("output",t.dataType,A)];c&&p.push(N("present_value",t.dataType,g));return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileQ: array<${a.type.value}, 144>;\n  var<workgroup> tileV: array<${a.type.value}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"v_hidden_size",type:"u32"},{name:"past_sequence_length",type:"u32"},{name:"kv_sequence_length",type:"u32"},{name:"n_reps",type:"u32"}]).declareVariables(...o,...p)}\n  ${e.mainStart([h,h,1])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${1===d?"headIdx":"headIdx / uniforms.n_reps"};\n   let kv_num_heads = ${1===d?"uniforms.num_heads":"uniforms.num_heads / uniforms.n_reps"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${mo(l,u,!0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${C&&c?"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;":""};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${c?"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;":""}\n   var value = ${a.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${C&&c?"\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      ":"\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }"}\n        ${c?"\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }":""}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`}}},Ut=(e,t,r,n,a,o,i,s,l,d,u=void 0,c=void 0)=>{let p=Math.min(e.outputCount,1+(i?1:0)+(s?1:0)),g=p>1?d.pastSequenceLength:0,A=g+d.kvSequenceLength,h=l&&E.size(l.dims)>0?l:void 0,B=[t,r];p>1&&i&&E.size(i.dims)>0&&B.push(i),h&&B.push(h),u&&B.push(u),c&&B.push(c);let m=e.compute(Ch(p,t,r,i,h,d,g,u,c),{inputs:B,outputs:p>1?[-1,1]:[-1]})[0];e.compute(Th(m,d.batchSize,d.numHeads,g,d.sequenceLength,A,u,c),{inputs:u&&c?[m,u,c]:[m],outputs:[]});let C=[m,n];p>1&&s&&E.size(s.dims)>0&&C.push(s),u&&C.push(u),c&&C.push(c),e.compute(Ih(p,m,n,s,d,g,u,c),{inputs:C,outputs:p>1?[0,2]:[0]})},Ah=(e,t)=>{let r=[t.batchSize,t.numHeads,t.sequenceLength,t.headSize],n=t.sequenceLength,a=t.inputHiddenSize,o=t.headSize,i=12,s={x:Math.ceil(t.headSize/i),y:Math.ceil(t.sequenceLength/i),z:t.batchSize*t.numHeads},l=[e.inputs[0],e.inputs[1],e.inputs[2]],d=[{type:12,data:n},{type:12,data:a},{type:12,data:o},{type:12,data:t.numHeads},{type:12,data:t.headSize},{type:12,data:t.hiddenSize},{type:12,data:t.hiddenSize+t.hiddenSize+t.vHiddenSize}];return e.compute({name:"AttentionPrepare",shaderCache:{inputDependencies:["type","type","type"]},getRunData:()=>({outputs:[{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0},{dims:r,dataType:e.inputs[0].dataType,gpuDataType:0}],dispatchGroup:s,programUniforms:d}),getShaderSource:e=>{let t=N("output_q",l[0].dataType,r),n=N("output_k",l[0].dataType,r),a=N("output_v",l[0].dataType,r),o=P("input",l[0].dataType,l[0].dims),s=P("weight",l[1].dataType,l[1].dims),d=P("bias",l[2].dataType,l[2].dims),u=o.type.storage;return`\n  const TILE_SIZE = 12u;\n  var<workgroup> tileInput: array<${u}, 144>;\n  var<workgroup> tileWeightQ: array<${u}, 144>;\n  var<workgroup> tileWeightK: array<${u}, 144>;\n  var<workgroup> tileWeightV: array<${u}, 144>;\n  ${e.registerUniforms([{name:"M",type:"u32"},{name:"K",type:"u32"},{name:"N",type:"u32"},{name:"num_heads",type:"u32"},{name:"head_size",type:"u32"},{name:"hidden_size",type:"u32"},{name:"ldb",type:"u32"}]).declareVariables(o,s,d,t,n,a)}\n  ${e.mainStart([i,i,1])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${u}(0);\n    var valueK = ${u}(0);\n    var valueV = ${u}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`}},{inputs:l,outputs:[-1,-1,-1]})},wu=(e,t)=>{let r=Sh(e.inputs,t),[n,a,o]=Ah(e,r);return Ut(e,n,a,o,e.inputs[4],void 0,void 0,void 0,e.inputs[5],r)}})),kh,Eh,Ph,vu,$u=W((()=>{Ge(),te(),ae(),Ce(),ce(),kh=(e,t)=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs");let r=(e,t,r)=>{let n=t.length;if(n!==e.length)throw new Error(`${r}: num dimensions != ${n}`);t.forEach(((t,n)=>{if(t!==e[n])throw new Error(`${r}: dim[${n}] do not match`)}))};if(e[0].dims.length>1){let n="NHWC"===t.format?t.spatial?e[0].dims.slice(-1):e[0].dims.slice(-1).concat(e[0].dims.slice(1,e[0].dims.length-1)):e[0].dims.slice(1,t.spatial?2:void 0);r(e[1].dims,n,"Invalid input scale"),r(e[2].dims,n,"Invalid input B"),r(e[3].dims,n,"Invalid input mean"),r(e[4].dims,n,"Invalid input var")}else r(e[1].dims,[1],"Invalid input scale"),r(e[2].dims,[1],"Invalid input B"),r(e[3].dims,[1],"Invalid input mean"),r(e[4].dims,[1],"Invalid input var")},Eh=(e,t)=>{let{epsilon:r,spatial:n,format:a}=t,o=e[0].dims,i=n?ge(o[o.length-1]):1,s="NHWC"===a&&o.length>1?i:1,l=E.size(o)/i,d=n,u=d?o.length:o,c=P("x",e[0].dataType,e[0].dims,i),p=P("scale",e[1].dataType,e[1].dims,s),g=P("bias",e[2].dataType,e[2].dims,s),A=P("inputMean",e[3].dataType,e[3].dims,s),h=P("inputVar",e[4].dataType,e[4].dims,s),B=N("y",e[0].dataType,u,i);return{name:"BatchNormalization",shaderCache:{hint:`${t.epsilon}_${t.format}_${n}_${i}`,inputDependencies:d?["rank","type","type","type","type"]:void 0},getShaderSource:e=>`\n  const epsilon = ${r};\n  ${e.registerUniform("outputSize","u32").declareVariables(c,p,g,A,h,B)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n    var outputIndices = ${B.offsetToIndices(`global_idx * ${i}`)};\n    ${(()=>{let e="";if(n)e=`let cOffset = ${1===o.length?"0u":"NHWC"===a?`outputIndices[${o.length-1}] / ${i}`:"outputIndices[1]"};`;else if("NCHW"===a)e=`\n            ${B.indicesSet("outputIndices","0","0")}\n            let cOffset = ${B.indicesToOffset("outputIndices")};`;else{e=`var cIndices = ${p.type.indices}(0);\n                       cIndices[0] = outputIndices[${o.length-1}];`;for(let t=1;t<p.rank;t++)e+=`cIndices[${t}] = outputIndices[${t}];`;e+=`let cOffset = ${p.indicesToOffset("cIndices")};`}return e})()}\n    let scale = ${p.getByOffset("cOffset")};\n    let bias = ${g.getByOffset("cOffset")};\n    let inputMean = ${A.getByOffset("cOffset")};\n    let inputVar = ${h.getByOffset("cOffset")};\n    let x = ${c.getByOffset("global_idx")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${B.setByOffset("global_idx","value")}\n  }`,getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d?[{type:12,data:l},...G(o)]:[{type:12,data:l}]})}},Ph=e=>re(e),vu=(e,t)=>{let{inputs:r,outputCount:n}=e,a=Ph({...t,outputCount:n});if(we.webgpu.validateInputContent&&kh(r,a),t.trainingMode)throw new Error("BatchNormalization trainingMode is not supported yet.");e.compute(Eh(r,a))}})),zh,Oh,xu,Su=W((()=>{ae(),ce(),zh=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![320,640,1280].includes(e[0].dims[2]))throw new Error("number of channels should be 320, 640 or 1280");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Oh=e=>{let t=e[0].dims,r=e[0].dims[2],n=E.size(t)/4,a=e[0].dataType,o=P("input",a,t,4),i=P("bias",a,[r],4),s=P("residual",a,t,4),l=N("output",a,t,4);return{name:"BiasAdd",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(n/64)}}),getShaderSource:e=>`\n  const channels = ${r}u / 4;\n  ${e.declareVariables(o,i,s,l)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let value = ${o.getByOffset("global_idx")}\n      + ${i.getByOffset("global_idx % channels")} + ${s.getByOffset("global_idx")};\n    ${l.setByOffset("global_idx","value")}\n  }`}},xu=e=>{zh(e.inputs),e.compute(Oh(e.inputs))}})),Bh,ye,Tu,Cu,Iu,Au,ku,Eu,Pu,zu,Ou,Dh,Bu,Du,Mu,Ru,tr,Uu,Kr,Nu,Vu,Wu,Lu,Gu,Hu,Fu,qu,Ku,ju,Zu,Qu,Yu,Xu,Ju,ed,td,rd,fo,ho,nd,od,id,Mh,Rh,ad,jr=W((()=>{te(),ae(),Ce(),ce(),Bh=(e,t,r,n,a,o,i)=>{let s=Math.ceil(t/4),l="";l="string"==typeof a?`${a}(a)`:a("a");let d=P("inputData",r,[s],4),u=N("outputData",n,[s],4),c=[{name:"vec_size",type:"u32"}];return i&&c.push(...i),`\n      ${e.registerUniforms(c).declareVariables(d,u)}\n\n  ${o??""}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n\n    let a = ${d.getByOffset("global_idx")};\n    ${u.setByOffset("global_idx",l)}\n  }`},ye=(e,t,r,n,a,o=e.dataType,i,s)=>{let l=[{type:12,data:Math.ceil(E.size(e.dims)/4)}];return i&&l.push(...i),{name:t,shaderCache:{hint:a,inputDependencies:["type"]},getShaderSource:t=>Bh(t,E.size(e.dims),e.dataType,o,r,n,s),getRunData:t=>({outputs:[{dims:e.dims,dataType:o}],dispatchGroup:{x:Math.ceil(E.size(t[0].dims)/64/4)},programUniforms:l})}},Tu=e=>{e.compute(ye(e.inputs[0],"Abs","abs"))},Cu=e=>{e.compute(ye(e.inputs[0],"Acos","acos"))},Iu=e=>{e.compute(ye(e.inputs[0],"Acosh","acosh"))},Au=e=>{e.compute(ye(e.inputs[0],"Asin","asin"))},ku=e=>{e.compute(ye(e.inputs[0],"Asinh","asinh"))},Eu=e=>{e.compute(ye(e.inputs[0],"Atan","atan"))},Pu=e=>{e.compute(ye(e.inputs[0],"Atanh","atanh"))},zu=e=>re(e),Ou=(e,t)=>{let r;switch(t.to){case 10:r="vec4<f16>";break;case 1:r="vec4<f32>";break;case 12:r="vec4<u32>";break;case 6:r="vec4<i32>";break;case 9:r="vec4<bool>";break;default:throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`)}e.compute(ye(e.inputs[0],"Cast",r,void 0,t.cacheKey,t.to))},Dh=e=>{let t,r,n=e.length>=2&&0!==e[1].data,a=e.length>=3&&0!==e[2].data;switch(e[0].dataType){case 1:t=n?e[1].getFloat32Array()[0]:-34028234663852886e22,r=a?e[2].getFloat32Array()[0]:34028234663852886e22;break;case 10:t=n?e[1].getUint16Array()[0]:64511,r=a?e[2].getUint16Array()[0]:31743;break;default:throw new Error("Unsupport data type")}return re({min:t,max:r})},Bu=(e,t)=>{let r=t||Dh(e.inputs),n=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],"Clip",(e=>`clamp(${e}, vec4<${n}>(uniforms.min), vec4<${n}>(uniforms.max))`),void 0,r.cacheKey,void 0,[{type:e.inputs[0].dataType,data:r.min},{type:e.inputs[0].dataType,data:r.max}],[{name:"min",type:n},{name:"max",type:n}]),{inputs:[0]})},Du=e=>{e.compute(ye(e.inputs[0],"Ceil","ceil"))},Mu=e=>{e.compute(ye(e.inputs[0],"Cos","cos"))},Ru=e=>{e.compute(ye(e.inputs[0],"Cosh","cosh"))},tr=e=>re(e),Uu=(e,t)=>{let r=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],"Elu",(e=>`elu_vf32(${e})`),`\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`,t.cacheKey))},Kr=(e="f32")=>`\nconst r0: ${e} = 0.3275911;\nconst r1: ${e} = 0.254829592;\nconst r2: ${e} = -0.284496736;\nconst r3: ${e} = 1.421413741;\nconst r4: ${e} = -1.453152027;\nconst r5: ${e} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e}>) -> vec4<${e}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`,Nu=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],"Erf",(e=>`erf_vf32(${e})`),Kr(t)))},Vu=e=>{e.compute(ye(e.inputs[0],"Exp","exp"))},Wu=e=>{e.compute(ye(e.inputs[0],"Floor","floor"))},Lu=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],"Gelu",(e=>`0.5 * ${e} * (1.0 + erf_vf32(${e} * 0.7071067811865475))`),Kr(t)))},Gu=(e,t)=>{let r=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],"LeakyRelu",(e=>`select(leaky_relu_alpha_ * ${e}, ${e}, ${e} >= vec4<${r}>(0.0))`),`const leaky_relu_alpha_ = ${r}(${t.alpha});`,t.cacheKey))},Hu=e=>{e.compute(ye(e.inputs[0],"Not",(e=>`!${e}`)))},Fu=e=>{e.compute(ye(e.inputs[0],"Neg",(e=>`-${e}`)))},qu=e=>{e.compute(ye(e.inputs[0],"Reciprocal",(e=>`1.0/${e}`)))},Ku=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],"Relu",(e=>`select(vec4<${t}>(0.0), ${e}, ${e} > vec4<${t}>(0.0))`)))},ju=e=>{e.compute(ye(e.inputs[0],"Sigmoid",(e=>`(1.0 / (1.0 + exp(-${e})))`)))},Zu=e=>re(e),Qu=(e,t)=>{let r=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],"HardSigmoid",(e=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${e} + vec4<${r}>(${t.beta})))`),void 0,t.cacheKey))},Yu=e=>{e.compute(ye(e.inputs[0],"Sin","sin"))},Xu=e=>{e.compute(ye(e.inputs[0],"Sinh","sinh"))},Ju=e=>{e.compute(ye(e.inputs[0],"Sqrt","sqrt"))},ed=e=>{e.compute(ye(e.inputs[0],"Tan","tan"))},td=e=>`sign(${e}) * (1 - exp(-2 * abs(${e}))) / (1 + exp(-2 * abs(${e})))`,rd=e=>{e.compute(ye(e.inputs[0],"Tanh",td))},fo=(e="f32")=>`\nconst fast_gelu_a: ${e} = 0.5;\nconst fast_gelu_b: ${e} = 0.7978845608028654;\nconst fast_gelu_c: ${e} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e}>) -> vec4<${e}> {\n  return ${td("v")};\n}\n`,ho=e=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e} * (fast_gelu_c * ${e} * ${e} + fast_gelu_b))) * ${e}`,nd=e=>{let t=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],"FastGelu",ho,fo(t),void 0,e.inputs[0].dataType))},od=(e,t)=>{let r=ze(e.inputs[0].dataType);return e.compute(ye(e.inputs[0],"ThresholdedRelu",(e=>`select(vec4<${r}>(0.0), ${e}, ${e} > thresholded_relu_alpha_)`),`const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`,t.cacheKey)),0},id=e=>{e.compute(ye(e.inputs[0],"Log","log"))},Mh=(e,t)=>`\nconst alpha = vec4<${e}>(${t});\nconst one = ${e}(1.0);\nconst zero = ${e}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e}>) -> vec4<${e}> {\n  let v = x *alpha;\n  var x1 : vec4<${e}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`,Rh=e=>`quick_gelu_impl(${e})`,ad=(e,t)=>{let r=ze(e.inputs[0].dataType);e.compute(ye(e.inputs[0],"QuickGelu",Rh,Mh(r,t.alpha),t.cacheKey,e.inputs[0].dataType))}})),Uh,Nh,ud,dd=W((()=>{ae(),ce(),jr(),Uh=e=>{if(3!==e[0].dims.length)throw new Error("input should have 3 dimensions");if(![2560,5120,10240].includes(e[0].dims[2]))throw new Error("hidden state should be 2560, 5120 or 10240");if(1!==e[1].dims.length)throw new Error("bias is expected to have 1 dimensions");if(e[0].dims[2]!==e[1].dims[0])throw new Error("last dimension of input and bias are not the same")},Nh=e=>{let t=e[0].dims.slice();t[2]=t[2]/2;let r=P("input",e[0].dataType,e[0].dims,4),n=P("bias",e[0].dataType,[e[0].dims[2]],4),a=N("output",e[0].dataType,t,4),o=E.size(t)/4,i=_e(e[0].dataType);return{name:"BiasSplitGelu",getRunData:()=>({outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)}}),getShaderSource:t=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e[0].dims[2]/4/2}u;\n\n  ${t.declareVariables(r,n,a)}\n\n  ${Kr(i)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes(o)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${a.setByOffset("global_idx","valueLeft * geluRight")}\n  }`}},ud=e=>{Uh(e.inputs),e.compute(Nh(e.inputs))}})),Vh,Wh,st,ld,cd,pd,md,fd,hd,gd,yd,bd,_d,wd=W((()=>{te(),ae(),ce(),Vh=(e,t,r,n,a,o,i,s,l,d,u,c)=>{let p,g;"string"==typeof s?p=g=(e,t)=>`${s}((${e}),(${t}))`:"function"==typeof s?p=g=s:(p=s.scalar,g=s.vector);let A,h=N("outputData",u,n.length,4),B=P("aData",l,t.length,4),m=P("bData",d,r.length,4);if(a)if(o){let e=1===E.size(t),n=1===E.size(r),a=t.length>0&&t[t.length-1]%4==0,o=r.length>0&&r[r.length-1]%4==0;A=e||n?h.setByOffset("global_idx",g(e?`${B.type.value}(${B.getByOffset("0")}.x)`:B.getByOffset("global_idx"),n?`${m.type.value}(${m.getByOffset("0")}.x)`:m.getByOffset("global_idx"))):`\n            let outputIndices = ${h.offsetToIndices("global_idx * 4u")};\n            let offsetA = ${B.broadcastedIndicesToOffset("outputIndices",h)};\n            let offsetB = ${m.broadcastedIndicesToOffset("outputIndices",h)};\n            ${h.setByOffset("global_idx",g(i||a?B.getByOffset("offsetA / 4u"):`${B.type.value}(${B.getByOffset("offsetA / 4u")}[offsetA % 4u])`,i||o?m.getByOffset("offsetB / 4u"):`${m.type.value}(${m.getByOffset("offsetB / 4u")}[offsetB % 4u])`))}\n          `}else A=h.setByOffset("global_idx",g(B.getByOffset("global_idx"),m.getByOffset("global_idx")));else{if(!o)throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");let e=(e,t,r="")=>{let n=`aData[indexA${t}][componentA${t}]`,a=`bData[indexB${t}][componentB${t}]`;return`\n            let outputIndices${t} = ${h.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offsetA${t} = ${B.broadcastedIndicesToOffset(`outputIndices${t}`,h)};\n            let offsetB${t} = ${m.broadcastedIndicesToOffset(`outputIndices${t}`,h)};\n            let indexA${t} = offsetA${t} / 4u;\n            let indexB${t} = offsetB${t} / 4u;\n            let componentA${t} = offsetA${t} % 4u;\n            let componentB${t} = offsetB${t} % 4u;\n            ${e}[${t}] = ${r}(${p(n,a)});\n          `};A=9===u?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("outputData[global_idx]",0)}\n            ${e("outputData[global_idx]",1)}\n            ${e("outputData[global_idx]",2)}\n            ${e("outputData[global_idx]",3)}\n          `}return`\n        ${e.registerUniform("vec_size","u32").declareVariables(B,m,h)}\n\n        ${c??""}\n\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${A}\n      }`},Wh=(e,t,r,n,a,o,i=r.dataType)=>{let s=r.dims.map((e=>Number(e)??1)),l=n.dims.map((e=>Number(e)??1)),d=!E.areEqual(s,l),u=s,c=E.size(s),p=!1,g=!1,A=[d];if(d){let e=rt.calcShape(s,l,!1);if(!e)throw new Error("Can't perform binary op on the given tensors");u=e.slice(),c=E.size(u);let t=1===E.size(s),r=1===E.size(l),n=s.length>0&&s[s.length-1]%4==0,a=l.length>0&&l[l.length-1]%4==0;A.push(t),A.push(r),A.push(n),A.push(a);let o=1;for(let e=1;e<u.length;e++){let t=s[s.length-e];if(t!==l[l.length-e])break;o*=t}o%4==0?(g=!0,p=!0):(t||r||n||a)&&(p=!0)}else p=!0;return A.push(p),{name:e,shaderCache:{hint:t+A.map((e=>e.toString())).join("_"),inputDependencies:["rank","rank"]},getShaderSource:e=>Vh(e,s,l,u,p,d,g,a,r.dataType,n.dataType,i,o),getRunData:()=>({outputs:[{dims:u,dataType:i}],dispatchGroup:{x:Math.ceil(c/64/4)},programUniforms:[{type:12,data:Math.ceil(E.size(u)/4)},...G(s,l,u)]})}},st=(e,t,r,n,a,o)=>{e.compute(Wh(t,a??"",e.inputs[0],e.inputs[1],r,n,o))},ld=e=>{st(e,"Add",((e,t)=>`${e}+${t}`))},cd=e=>{st(e,"Div",((e,t)=>`${e}/${t}`))},pd=e=>{st(e,"Equal",{scalar:(e,t)=>`u32(${e}==${t})`,vector:(e,t)=>`vec4<u32>(${e}==${t})`},void 0,void 0,9)},md=e=>{st(e,"Mul",((e,t)=>`${e}*${t}`))},fd=e=>{let t=P("input",e.inputs[0].dataType,e.inputs[0].dims).type.value;st(e,"Pow",{scalar:(e,t)=>`pow_custom(${e},${t})`,vector:(e,t)=>`pow_vector_custom(${e},${t})`},`\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${"i32"===t?"round":""}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `)},hd=e=>{st(e,"Sub",((e,t)=>`${e}-${t}`))},gd=e=>{st(e,"Greater",{scalar:(e,t)=>`u32(${e}>${t})`,vector:(e,t)=>`vec4<u32>(${e}>${t})`},void 0,void 0,9)},yd=e=>{st(e,"Less",{scalar:(e,t)=>`u32(${e}<${t})`,vector:(e,t)=>`vec4<u32>(${e}<${t})`},void 0,void 0,9)},bd=e=>{st(e,"GreaterOrEqual",{scalar:(e,t)=>`u32(${e}>=${t})`,vector:(e,t)=>`vec4<u32>(${e}>=${t})`},void 0,void 0,9)},_d=e=>{st(e,"LessOrEqual",{scalar:(e,t)=>`u32(${e}<=${t})`,vector:(e,t)=>`vec4<u32>(${e}<=${t})`},void 0,void 0,9)}})),Gh,Hh,Fh,qh,vd,$d,xd=W((()=>{te(),ae(),Ce(),ce(),Gh=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");let r=e[0],n=r.dataType,a=r.dims.length;e.forEach(((e,o)=>{if(0!==o){if(e.dataType!==n)throw new Error("input tensors should be one type");if(e.dims.length!==a)throw new Error("input tensors should have the same shape");e.dims.forEach(((e,n)=>{if(n!==t&&e!==r.dims[n])throw new Error("non concat dimensions must match")}))}}))},Hh=(e,t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e}u>(${t});\n    for (var i: u32 = 0u; i < ${e}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e}u;\n  }`,Fh=(e,t)=>{let r=e.length,n=[];for(let a=0;a<r;++a){let o=t.setByOffset("global_idx",e[a].getByIndices("indices"));1===r?n.push(o):0===a?n.push(`if (inputIndex == ${a}u) { ${o} }`):a===r-1?n.push(`else { ${o} }`):n.push(`else if (inputIndex == ${a}) { ${o} }`)}return n.join("\n")},qh=(e,t,r,n)=>{let a=E.size(r),o=new Array(e.length),i=new Array(e.length),s=0,l=[],d=[],u=[{type:12,data:a}];for(let r=0;r<e.length;++r)s+=e[r].dims[t],o[r]=s,d.push(e[r].dims.length),i[r]=P(`input${r}`,n,d[r]),l.push("rank"),u.push({type:12,data:o[r]});for(let t=0;t<e.length;++t)u.push(...G(e[t].dims));u.push(...G(r));let c=N("output",n,r.length),p=c.indicesGet("indices",t),g=Array.from(Array(o.length).keys()).map((e=>`uniforms.sizeInConcatAxis${e}`)).join(",");return{name:"Concat",shaderCache:{hint:`${t}`,inputDependencies:l},getRunData:()=>({outputs:[{dims:r,dataType:n}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:u}),getShaderSource:t=>`\n\n  ${(()=>{t.registerUniform("outputSize","u32");for(let r=0;r<e.length;r++)t.registerUniform(`sizeInConcatAxis${r}`,"u32");return t.declareVariables(...i,c)})()}\n\n  ${Hh(o.length,g)}\n\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n    var indices = ${c.offsetToIndices("global_idx")};\n\n    let inputIndex = calculateInputIndex(${p});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${o.length}u>(${g});\n      ${p} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${Fh(i,c)}\n  }`}},vd=(e,t)=>{let r=e.inputs,n=r[0].dims,a=E.normalizeAxis(t.axis,n.length);Gh(r,a);let o=n.slice();o[a]=r.reduce(((e,t)=>e+(t.dims.length>a?t.dims[a]:0)),0);let i=r.filter((e=>E.size(e.dims)>0));e.compute(qh(i,a,o,r[0].dataType),{inputs:i})},$d=e=>re({axis:e.axis})})),je,Ze,Qe,Zr,vt=W((()=>{te(),ae(),je=(e,t,r="f32")=>{switch(e.activation){case"Relu":return`value = max(value, ${t}(0.0));`;case"Sigmoid":return`value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;case"Clip":return`value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;case"HardSigmoid":return`value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;case"LeakyRelu":return`value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;case"Tanh":return"let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        ";case"":return"";default:throw new Error(`Unsupported activation ${e.activation}`)}},Ze=(e,t)=>{"Clip"===e.activation?t.push({type:1,data:e.clipMax},{type:1,data:e.clipMin}):"HardSigmoid"===e.activation?t.push({type:1,data:e.alpha},{type:1,data:e.beta}):"LeakyRelu"===e.activation&&t.push({type:1,data:e.alpha})},Qe=(e,t)=>{"Clip"===e.activation?t.push({name:"clip_max",type:"f32"},{name:"clip_min",type:"f32"}):"HardSigmoid"===e.activation?t.push({name:"alpha",type:"f32"},{name:"beta",type:"f32"}):"LeakyRelu"===e.activation&&t.push({name:"alpha",type:"f32"})},Zr=e=>{let t=e?.activation||"";if("HardSigmoid"===t){let[r,n]=e?.activation_params||[.2,.5];return{activation:t,alpha:r,beta:n}}if("Clip"===t){let[r,n]=e?.activation_params||[Ls,Gs];return{activation:t,clipMax:n,clipMin:r}}if("LeakyRelu"===t){let[r]=e?.activation_params||[.01];return{activation:t,alpha:r}}return{activation:t}}})),Ee,Sd,Qr=W((()=>{Ee=(e,t)=>{switch(e){case 1:return t;case 2:return`vec2<${t}>`;case 3:return`vec3<${t}>`;case 4:return`vec4<${t}>`;default:throw new Error(`${e}-component is not supported.`)}},Sd=e=>`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      `})),Td,Cd=W((()=>{Td=e=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e}.x), i32(${e}.y), i32(${e}.z), 1));\n}\n`})),rr,Yr,Xr=W((()=>{te(),ae(),ce(),vt(),rr=(e,t,r,n,a)=>{let o=n-r;return`\n      ${Array.from({length:r}).map(((r,i)=>`\n      if (${j(t.shape,i,t.rank)} != 1) {\n        ${t.indicesSet(e,i,j(a,i+o,n))}\n      } else {\n        ${t.indicesSet(e,i,0)}\n      }`)).join("")}\n`},Yr=(e,t,r,n,a=!1,o)=>{let i=e[0].dims,s=e[1].dims,l=i[i.length-2],d=s[s.length-1],u=i[i.length-1],c=ge(d),p=ge(u),g=ge(l),A=E.size(r)/c/g,h=e.length>2,B=n?n.slice(0,-2):r.slice(0,-2),m=[E.size(B),l,d],C=[{type:12,data:A},{type:12,data:l},{type:12,data:d},{type:12,data:u}];Ze(t,C),C.push(...G(B,i,s)),h&&C.push(...G(e[2].dims)),C.push(...G(m));return{name:"MatMulNaive",shaderCache:{hint:`${t.activation};${c};${p};${g};${a}`,inputDependencies:h?["rank","rank","rank"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:o?o(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(A/64)},programUniforms:C}),getShaderSource:n=>{let o=Gr("batch_dims",e[0].dataType,B.length),l=P("a",e[0].dataType,i.length,p),d=P("b",e[1].dataType,s.length,c),u=N("output",e[0].dataType,m.length,c),A=_e(u.type.tensor),C=je(t,u.type.value,A),w=[l,d],b="";if(h){let t=a?c:1;w.push(P("bias",e[2].dataType,e[2].dims.length,t)),b=""+(a?`value += bias[col / ${t}];`:`value += ${u.type.value}(bias[row + i]);`)}let K=[{name:"output_size",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"}];Qe(t,K);return`\n  ${n.registerUniforms(K).registerInternalVariables(o).declareVariables(...w,u)}\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let col = (global_idx % (uniforms.N / ${c})) * ${c};\n    var index1 = global_idx / (uniforms.N / ${c});\n    let stride1 = uniforms.M / ${g};\n    let row = (index1 % stride1) * ${g};\n    let batch = index1 / stride1;\n\n    ${2===r.length?"":`let batch_indices = ${o.offsetToIndices("batch")};`}\n\n    var a_indices: ${l.type.indices};\n    ${rr("a_indices",l,l.rank-2,o.rank,"batch_indices")}\n    ${l.indicesSet("a_indices",l.rank-2,0)}\n    ${l.indicesSet("a_indices",l.rank-1,0)}\n    let a_offset = ${l.indicesToOffset("a_indices")};\n\n    var b_indices: ${d.type.indices};\n    ${rr("b_indices",d,d.rank-2,o.rank,"batch_indices")}\n    ${d.indicesSet("b_indices",d.rank-2,0)}\n    ${d.indicesSet("b_indices",d.rank-1,0)}\n    let b_offset = ${d.indicesToOffset("b_indices")};\n    var values: array<${u.type.value}, ${g}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${p}) {\n      ${(()=>{let e=`var a_data: ${l.type.value};`;for(let t=0;t<p;t++)e+=`\n              let b_data${t} = b[(b_offset + (k + ${t}) * uniforms.N + col) / ${c}];`;for(let t=0;t<g;t++){e+=`a_data = a[(a_offset + (row + ${t}) * uniforms.K + k) / ${p}];`;for(let r=0;r<p;r++)e+=`\n            values[${t}] = fma(${d.type.value}(a_data${1===p?"":`[${r}]`}), b_data${r}, values[${t}]);\n`}return e})()}\n    }\n    for (var i = 0u; i < ${g}u; i++) {\n      var value = values[i];\n      ${b}\n      ${C}\n      let cur_indices = ${u.type.indices}(batch, row + i, col);\n      let offset = ${u.indicesToOffset("cur_indices")};\n      ${u.setByOffset(`offset / ${c}`,"value")};\n    }\n  }\n  `}}}})),Kh,jh,go,Id,Zh,yo,Qh,nr,Jr=W((()=>{te(),ae(),ce(),vt(),Xr(),Qr(),Kh=(e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t?", batchIndices":""});\n        `,jh=(e,t)=>e?`\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${3===t?"":"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`,go=(e,t,r="f32",n,a=!1,o=32,i=!1,s=32)=>{let l=t[1]*e[1],d=t[0]*e[0],u=a?l:o,c=a?o:l,p=u/t[0],g=o/t[1];if((!a||4!==p||4!==e[1])&&(a||3!==p&&4!==p)||u%t[0]!=0||o%t[1]!=0||4!==e[0])throw new Error(`If transposeA ${a} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n      Otherwise, innerElementSize ${p} must be 3 or 4.\n  tileAWidth ${u} must be divisible by workgroupSize[0]${t[0]}. tileInner ${o} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`);return`\nvar<workgroup> mm_Asub: array<array<vec${p}<${r}>, ${u/p}>, ${c}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${d/e[0]}>, ${o}>;\n\nconst rowPerThread = ${e[1]};\nconst colPerThread = ${e[0]};\nconst innerElementSize = ${p};\nconst tileInner = ${o};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${i?"0":"i32(globalId.z)"};\n  ${n?`let batchIndices = ${n.offsetToIndices("u32(batch)")};`:""}\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let num_tiles = ${i?`${Math.ceil(s/o)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n  var kStart = ${i?`i32(globalId.z) * ${s}`:"0"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${g};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${Kh(a,n)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${n?", batchIndices":""});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${3===p?"":"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}\n\n          ${jh(a,p)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`},Id=(e,t)=>e?`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t?", batchIndices":""});\n            `:`\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t?", batchIndices":""});\n            `,Zh=e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];",yo=(e,t,r="f32",n,a=!1,o=32,i=!1,s=32,l=!1)=>{let d=e[1]*t[1],u=e[0]*t[0],c=a?d:o,p=a?o:d;if(p%t[1]!=0||c%t[0]!=0||o%t[1]!=0)throw new Error(`tileAHight ${p} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${o} must be divisible by workgroupSize[1]${t[1]}`);let g=p/t[1],A=c/t[0],h=o/t[1],B=l?`\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${d};\n    let globalColStart = i32(workgroupId.x) * ${u};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${p}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n          ${Id(a,n)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${o}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${n?", batchIndices":""});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${a?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    `:`\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${d};\n\nlet tileRowA = i32(localId.y) * ${g};\nlet tileColA = i32(localId.x) * ${A};\nlet tileRowB = i32(localId.y) * ${h};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${A}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Id(a,n)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${h}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${n?", batchIndices":""});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${Zh(a)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;return`\n  var<workgroup> mm_Asub : array<array<${r}, ${c}>, ${p}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${u}>, ${o}>;\n  const rowPerThread = ${e[1]};\n  const colPerThread = ${e[0]};\n  const tileInner = ${o};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${i?"0":"i32(globalId.z)"};\n    ${n?`let batchIndices = ${n.offsetToIndices("u32(batch)")};`:""}\n    let num_tiles = ${i?`${Math.ceil(s/o)}`:"(uniforms.dim_inner - 1) / tileInner + 1"};\n    var kStart = ${i?`i32(globalId.z) * ${s}`:"0"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n    ${B}\n  }\n`},Qh=(e,t,r,n,a=!1)=>{let[o,i,s,l]=n,d=_e(n[0].type.tensor);return`\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${o.type.indices}) -> ${Ee(e,d)} {\n      var value = ${Ee(e,d)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${i.type.indices};\n        ${rr("aIndices",i,i.rank-2,o.rank,"batchIndices")}\n        ${i.indicesSet("aIndices",i.rank-2,"u32(row)")}\n        ${i.indicesSet("aIndices",i.rank-1,"u32(colIn)")}\n        value = ${i.getByIndices("aIndices")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${o.type.indices}) -> ${Ee(e,d)} {\n      var value = ${Ee(e,d)}(0.0);\n      let col = colIn * ${e};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${s.type.indices};\n        ${rr("bIndices",s,s.rank-2,o.rank,"batchIndices")}\n        ${s.indicesSet("bIndices",s.rank-2,"u32(row)")}\n        ${s.indicesSet("bIndices",s.rank-1,"u32(colIn)")}\n        value = ${s.getByIndices("bIndices")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ee(e,d)}) {\n      let col = colIn * ${e};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t?`value = value + ${a?"bias[colIn]":`${Ee(e,d)}(bias[row])`};`:""}\n        ${r}\n        ${l.setByIndices("vec3<u32>(coords)","value")}\n      }\n    }\n    `},nr=(e,t,r,n,a=!1,o)=>{let i=e[0].dims,s=e[1].dims,l=i.slice(0,-2),d=s.slice(0,-2),u=n?n.slice(0,-2):r.slice(0,-2),c=E.size(u),p=i[i.length-2],g=i[i.length-1],A=s[s.length-1],h=g%4==0&&A%4==0,B=p<=8?[4,1,1]:[4,4,1],m=[8,8,1],C=[Math.ceil(A/m[0]/B[0]),Math.ceil(p/m[1]/B[1]),Math.ceil(c/m[2]/B[2])],w=h?4:1,b=[...l,p,g/w],K=b.length,f=[...d,g,A/w],Q=f.length,W=[c,p,A/w],F=[{type:6,data:p},{type:6,data:A},{type:6,data:g}];Ze(t,F),F.push(...G(u,b,f));let _=["rank","rank"],y=e.length>2;y&&(F.push(...G(e[2].dims)),_.push("rank")),F.push(...G(W));return{name:"MatMul",shaderCache:{hint:`${B};${t.activation};${h};${a}`,inputDependencies:_},getRunData:()=>({outputs:[{dims:o?o(r):r,dataType:e[0].dataType}],dispatchGroup:{x:C[0],y:C[1],z:C[2]},programUniforms:F}),getShaderSource:r=>{let n=u.length,o=Gr("batchDims",e[0].dataType,n,1),i=_e(e[0].dataType),s=P("a",e[0].dataType,K,w),l=P("b",e[1].dataType,Q,w),d=N("result",e[0].dataType,W.length,w),c=[s,l];if(y){let t=a?w:1;c.push(P("bias",e[2].dataType,e[2].dims.length,t))}let p=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"}];Qe(t,p);let g=_e(d.type.tensor),A=je(t,d.type.value,g),C=Qh(w,y,A,[o,s,l,d],a);return`\n  ${r.registerUniforms(p).registerInternalVariables(o).declareVariables(...c,d)}\n  ${C}\n  ${h?go(B,m,i,o):yo(B,m,i,o)}\n                   `}}}})),Yh,Ad,kd=W((()=>{te(),tt(),ce(),vt(),Qr(),Cd(),Jr(),Yh=(e,t,r,n,a=!1,o,i=4,s=4,l=4,d="f32")=>{let u=e=>{switch(e){case 1:return"return w[row * i32(uniforms.w_shape[3]) + colIn];";case 4:return"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}},c=e?"\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ":"\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    ",p=e?"\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ":"\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    ",g=e?"i32(uniforms.x_shape[1])":"i32(uniforms.x_shape[2])",A=e?"i32(uniforms.x_shape[2])":"i32(uniforms.x_shape[3])",h=e?"row":"col",B=e?"col":"row",m=`\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n    let outRow = ${h} / outWidth;\n    let outCol = ${h} % outWidth;\n\n    let WRow = ${B} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${B} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${B} % inChannels;\n    var resData = ${Ee(i,d)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${g} && xCol >= 0 && xCol < ${A}) {\n      ${c}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return`resData = vec3<${d}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(i)}\n    }\n    return resData;`,C=e?t&&n?`\n    let col = colIn * ${i};\n    ${m}`:`\n    let col = colIn * ${i};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${m}\n    }\n    return ${Ee(i,d)}(0.0);`:n&&r?`\n    let col = colIn * ${i};\n    ${m}`:`\n    let col = colIn * ${i};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${m}\n    }\n    return ${Ee(i,d)}(0.0);`,w=e?n&&r?u(s):`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${u(s)}\n    }\n    return ${Ee(s,d)}(0.0);`:`\n    let col = colIn * ${s};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${u(s)}\n    }\n    return ${Ee(s,d)}(0.0);`,b=Ee(l,d),K=Ee(e?i:s,d),f=Ee(e?s:i,d),Q=je(o,b,d);return`\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${K} {\n      ${e?C:w}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${f} {\n      ${e?w:C}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${b}) {\n      let col = colIn * ${l};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e?"i32(uniforms.result_shape[2])":"i32(uniforms.result_shape[3])"};\n      ${p}\n      ${Sd(a)}\n      ${Q}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`},Ad=(e,t,r,n,a,o,i,s,l)=>{let d="NHWC"===t.format,u=d?e[0].dims[3]:e[0].dims[1],c=r[0],p=d?r[2]:r[3],g=d?r[1]:r[2],A=d?r[3]:r[1],h=d&&(u%4==0||u%3==0)&&A%4==0,B=d?A:p*g,m=d?p*g:A,C=[8,8,1],w=n<=8?[4,1,1]:[4,4,1],b=[Math.ceil(B/C[0]/w[0]),Math.ceil(m/C[1]/w[1]),Math.ceil(c/C[2]/w[2])];pe("verbose",(()=>`[conv2d_mm_webgpu] dispatch = ${b}`));let K=h?d&&u%4!=0?3:4:1,f=C[1]*w[1],Q=C[0]*w[0],W=Math.max(C[0]*K,C[1]),F=n%f==0,_=a%Q==0,y=o%W==0,v=h?[K,4,4]:[1,1,1],E=[{type:6,data:n},{type:6,data:a},{type:6,data:o},{type:6,data:[t.pads[0],t.pads[1]]},{type:6,data:t.strides},{type:6,data:t.dilations}];Ze(t,E),E.push(...G(e[0].dims,e[1].dims));let R=["rank","rank"];i&&(E.push(...G(e[2].dims)),R.push("rank")),E.push(...G(r));return{name:"Conv2DMatMul",shaderCache:{hint:`${t.cacheKey};${K};${h};${F};${_};${y};${f};${Q};${W}`,inputDependencies:R},getRunData:()=>({outputs:[{dims:l?l(r):r,dataType:e[0].dataType}],dispatchGroup:{x:b[0],y:b[1],z:b[2]},programUniforms:E}),getShaderSource:n=>{let a=[{name:"dim_a_outer",type:"i32"},{name:"dim_b_outer",type:"i32"},{name:"dim_inner",type:"i32"},{name:"pad",type:"i32",length:2},{name:"stride",type:"i32",length:2},{name:"dilation",type:"i32",length:2}];Qe(t,a);let o=h?4:1,l=_e(e[0].dataType),u=`\n      fn setOutputAtIndex(flatIndex : i32, value : ${h?`vec4<${l}>`:l}) {\n        result[flatIndex] = ${h?`vec4<${l}>`:l}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${h?`vec4<${l}>`:l}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${h?"/ 4":""}, value);\n      }`,c=[P("x",e[0].dataType,e[0].dims.length,3===K?1:K),P("w",e[1].dataType,e[1].dims.length,o)],p=N("result",e[0].dataType,r.length,o);if(i){let t=P("bias",e[2].dataType,e[2].dims.length,o);c.push(t),u+=`\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${h?`vec4<${l}>`:l} {\n          return bias[coords.${d?"w":"y"}${h?"/ 4":""}];\n        }`}return`\n        ${Td("uniforms.result_strides")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${n.registerUniforms(a).declareVariables(...c,p)}\n        ${u}\n        ${Yh(d,F,_,y,i,t,v[0],v[1],v[2],l)}\n        ${h?go(w,C,l,void 0,!d,W):yo(w,C,l,void 0,!d,W,!1,void 0,s)}`}}}})),Xh,Ed,en,Jh,Pd,eg,zd,Od,Bd=W((()=>{te(),tt(),ae(),ce(),vt(),Qr(),Xh=e=>{let t=1;for(let r=0;r<e.length;r++)t*=e[r];return t},Ed=e=>"number"==typeof e?[e,e,e]:e,en=(e,t)=>t<=1?e:e+(e-1)*(t-1),Jh=(e,t,r,n=1)=>{let a=en(t,n);return Math.floor((e[0]*(r-1)-r+a)/2)},Pd=(e,t,r,n,a)=>{null==a&&(a=Jh(e,t[0],n[0]));let o=[0,0,0,r];for(let r=0;r<3;r++)e[r]+2*a>=t[r]&&(o[r]=Math.trunc((e[r]-t[r]+2*a)/n[r]+1));return o},eg=(e,t,r,n,a,o,i,s,l,d)=>{let u,c,p,g;if("VALID"===e&&(e=0),"number"==typeof e){u={top:e,bottom:e,left:e,right:e,front:e,back:e};let A=Pd([t,r,n,1],[s,l,d],1,[a,o,i],e);c=A[0],p=A[1],g=A[2]}else if(Array.isArray(e)){if(!e.every(((e,t,r)=>e===r[0])))throw Error(`Unsupported padding parameter: ${e}`);u={top:e[0],bottom:e[1],left:e[2],right:e[3],front:e[4],back:e[5]};let A=Pd([t,r,n,1],[s,l,d],1,[a,o,i],e[0]);c=A[0],p=A[1],g=A[2]}else{if("SAME_UPPER"!==e)throw Error(`Unknown padding parameter: ${e}`);{c=Math.ceil(t/a),p=Math.ceil(r/o),g=Math.ceil(n/i);let e=(c-1)*a+s-t,A=(p-1)*o+l-r,h=(g-1)*i+d-n,B=Math.floor(e/2),m=e-B,C=Math.floor(A/2),w=A-C,b=Math.floor(h/2);u={top:C,bottom:w,left:b,right:h-b,front:B,back:m}}}return{padInfo:u,outDepth:c,outHeight:p,outWidth:g}},zd=(e,t,r,n,a,o=!1,i="channelsLast")=>{let s,l,d,u,c;if("channelsLast"===i)[s,l,d,u,c]=e;else{if("channelsFirst"!==i)throw new Error(`Unknown dataFormat ${i}`);[s,c,l,d,u]=e}let[p,,g,A,h]=t,[B,m,C]=Ed(r),[w,b,K]=Ed(n),f=en(g,w),Q=en(A,b),W=en(h,K),{padInfo:F,outDepth:_,outHeight:y,outWidth:v}=eg(a,l,d,u,B,m,C,f,Q,W),E=o?p*c:p,G=[0,0,0,0,0];return"channelsFirst"===i?G=[s,E,_,y,v]:"channelsLast"===i&&(G=[s,_,y,v,E]),{batchSize:s,dataFormat:i,inDepth:l,inHeight:d,inWidth:u,inChannels:c,outDepth:_,outHeight:y,outWidth:v,outChannels:E,padInfo:F,strideDepth:B,strideHeight:m,strideWidth:C,filterDepth:g,filterHeight:A,filterWidth:h,effectiveFilterDepth:f,effectiveFilterHeight:Q,effectiveFilterWidth:W,dilationDepth:w,dilationHeight:b,dilationWidth:K,inShape:e,outShape:G,filterShape:t}},Od=(e,t,r,n,a,o)=>{let i="channelsLast"===o;i?e[0].dims[3]:e[0].dims[1];let s={x:r.map(((e,t)=>t))},l=[Math.ceil(Xh(s.x.map((e=>r[e])))/64),1,1];pe("verbose",(()=>`[conv3d_naive_webgpu] dispatch = ${l}`));let d=[{type:12,data:E.size(r)},{type:12,data:n},{type:12,data:a},{type:12,data:t.strides},{type:12,data:t.dilations}];Ze(t,d),d.push(...G(e[0].dims,e[1].dims));let u=["rank","rank"],c=3===e.length;c&&(d.push(...G(e[2].dims)),u.push("rank")),d.push(...G(r));return{name:"Conv3DNaive",shaderCache:{hint:`${t.cacheKey};${i};1;${c}`,inputDependencies:u},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:l[0],y:l[1],z:l[2]},programUniforms:d}),getShaderSource:o=>{let s=[{name:"output_size",type:"u32"},{name:"filter_dims",type:"u32",length:n.length},{name:"pads",type:"u32",length:a.length},{name:"strides",type:"u32",length:t.strides.length},{name:"dilations",type:"u32",length:t.dilations.length}];Qe(t,s);let l=_e(e[0].dataType),d=P("x",e[0].dataType,e[0].dims.length,1),u=P("W",e[1].dataType,e[1].dims.length,1),p=[d,u],g=N("result",e[0].dataType,r.length,1),A="";if(c){let t=P("bias",e[2].dataType,e[2].dims.length,1);p.push(t),A+=`\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l} {\n          return bias[${j("coords",i?4:1,5)}];\n        }`}let h=Ee(1,l),B=je(t,h,l);return`\n            ${A}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${d.getByIndices("aIndices")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${u.getByIndices("aIndices")};\n            }\n          ${o.registerUniforms(s).declareVariables(...p,g)}\n          ${o.mainStart()}\n          ${o.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n              let coords = ${g.offsetToIndices("global_idx")};\n              let batch = ${j("coords",0,d.rank)};\n              let d2 = ${j("coords",i?d.rank-1:1,d.rank)};\n              let xFRCCorner = vec3<u32>(${j("coords",i?1:2,d.rank)},\n              ${j("coords",i?2:3,d.rank)},\n              ${j("coords",i?3:4,d.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${j("uniforms.x_shape",i?1:2,d.rank)};\n              let xShapeZ = ${j("uniforms.x_shape",i?2:3,d.rank)};\n              let xShapeW = ${j("uniforms.x_shape",i?3:4,d.rank)};\n              let xShapeU = ${j("uniforms.x_shape",i?4:1,d.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${i?"let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            ":"let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            "}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${i?"value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);":"value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);"}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${i?"let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      ":"let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    "}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${i?"let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      ":"let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    "}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${c?"value = value + getBiasByOutputCoords(coords)":""};\n              ${B}\n              result[global_idx] = f32(value);\n          }`}}}})),Dd,Md,Rd=W((()=>{te(),ae(),ce(),vt(),Dd=(e,t,r,n)=>{let a=e.length>2,o=a?"value += b[output_channel];":"",i=e[0].dims,s=e[1].dims,l="NHWC"===t.format,d=l?r[3]:r[1],u=d/t.group,c=l&&u>=4?ge(d):1,p=E.size(r)/c,g=[{type:12,data:p},{type:12,data:t.dilations},{type:12,data:[t.strides[0],t.strides[1]]},{type:12,data:[t.pads[0],t.pads[1]]},{type:12,data:u}];Ze(t,g),g.push(...G(i,[s[0],s[1],s[2],s[3]/c]));let A=a?["rank","rank","rank"]:["rank","rank"];g.push(...G([r[0],r[1],r[2],r[3]/c]));return{name:"GroupedConv",shaderCache:{hint:`${t.cacheKey}_${c}`,inputDependencies:A},getRunData:()=>({outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:g}),getShaderSource:n=>{let d=N("output",e[0].dataType,r.length,c),u=_e(d.type.tensor),p=je(t,d.type.value,u),g=P("x",e[0].dataType,i.length),A=P("w",e[1].dataType,s.length,c),h=[g,A];a&&h.push(P("b",e[2].dataType,e[2].dims,c));let B=[{name:"output_size",type:"u32"},{name:"dilations",type:"u32",length:t.dilations.length},{name:"strides",type:"u32",length:2},{name:"pads",type:"u32",length:2},{name:"output_channels_per_group",type:"u32"}];Qe(t,B);let m=l?`\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${g.get("batch","xHeight","xWidth","input_channel")};\n            let wVal = ${A.get("wHeight","wWidth","wInChannel","output_channel")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `:`\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${g.get("batch","input_channel","xHeight","xWidth")};\n            let wVal = ${A.get("output_channel","wInChannel","wHeight","wWidth")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;return`\n  ${n.registerUniforms(B).declareVariables(...h,d)}\n\n  ${n.mainStart()}\n    ${n.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let outputIndices = ${d.offsetToIndices("global_idx")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${l?3:1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l?1:2}], outputIndices[${l?2:3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${c} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${l?2:1}];\n\n    var value: ${d.type.value} = ${d.type.value}(0);\n    ${m}\n    ${o}\n    ${p}\n    ${d.setByOffset("global_idx","value")}\n  }`}}},Md=(e,t,r,n)=>{let a=e.length>2,o=ge(r[3]),i=ge(r[2]),s=E.size(r)/o/i,l=[e[0].dims[0],e[0].dims[1],e[0].dims[2],e[0].dims[3]/o],d=[e[1].dims[0],e[1].dims[1],e[1].dims[2],e[1].dims[3]/o],u=[r[0],r[1],r[2],r[3]/o],c=[{type:12,data:s},{type:6,data:[t.strides[0],t.strides[1]]},{type:6,data:[t.pads[0],t.pads[1]]}];Ze(t,c),c.push(...G(l,d,u));let p=(i-1)*t.strides[1]+d[1];return{name:"GroupedConv-Vectorize",shaderCache:{hint:`${t.cacheKey};${o};${i};${p};${d[0]};${d[1]}`,inputDependencies:a?["rank","rank","type"]:["rank","rank"]},getRunData:()=>({outputs:[{dims:n?n(r):r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(s/64)},programUniforms:c}),getShaderSource:r=>{let n=N("output",e[0].dataType,u.length,o),s=_e(n.type.tensor),c=je(t,n.type.value,s),g=P("x",e[0].dataType,l.length,o),A=P("w",e[1].dataType,d.length,o),h=[g,A];a&&h.push(P("b",e[2].dataType,e[2].dims,o));let B=a?"value += b[output_channel];":"",m=[{name:"output_size",type:"u32"},{name:"strides",type:"i32",length:2},{name:"pads",type:"i32",length:2}];return Qe(t,m),`\n  ${r.registerUniforms(m).declareVariables(...h,n)}\n  ${r.mainStart()}\n    ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${i}u;\n    let col = (index1 % width1) * ${i}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${g.type.value}, ${p}>;\n    var values: array<${n.type.value}, ${i}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${d[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${p}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${g.get("batch","u32(x_height)","u32(x_width)","input_channel")};\n          } else {\n            x_vals[i] = ${g.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${d[1]}; w_width++) {\n          let w_val = ${A.get("w_height","w_width","0","output_channel")};\n          for (var i = 0u; i < ${i}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${i}u; i++) {\n      var value = values[i];\n      ${B}\n      ${c}\n      ${n.set("batch","row","col + i","output_channel","value")};\n    }\n  }`}}}})),tg,bo,rg,_o,wo,Ud,ng,og,vo,Nd=W((()=>{ae(),kd(),Bd(),Jr(),Rd(),vt(),Xr(),ct(),tg=(e,t,r,n,a,o)=>{let i=e[0],s=e.slice(o?1:2,o?3:4),l=s.length,d=t[0],u=t.slice(2).map(((e,t)=>e+(e-1)*(r[t]-1))),c=s.map(((e,t)=>e+n[t]+n[t+l])).map(((e,t)=>Math.floor((e-u[t]+a[t])/a[t])));return c.splice(0,0,i),c.splice(o?3:1,0,d),c},bo=[2,3,1,0],rg=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length>5)throw new Error("greater than 5D is not supported");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let r=e[0].dims.length-2;if(t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape")},_o=(e,t)=>{let r=e.kernelShape.slice();r.length<t[1].dims.length-2&&r.push(...Array(t[1].dims.length-2-r.length).fill(0));for(let e=2;e<t[1].dims.length;++e)0===r[e-2]&&(r[e-2]=t[1].dims[e]);let n=e.pads.slice();kt.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,n,"NHWC"===e.format,e.autoPad);let a=Object.assign({},e);return Object.assign(a,{kernelShape:r,pads:n}),a},wo=e=>{let t=Zr(e),r=e.format;return{autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],format:r,dilations:e.dilations,group:e.group,kernelShape:e.kernel_shape,pads:e.pads,strides:e.strides,wIsConst:e.w_is_const(),...t,cacheKey:`${e.format};${t.activation};`}},Ud=(e,t,r,n)=>{let a="NHWC"===r.format,o=tg(t[0].dims,t[1].dims,r.dilations,r.pads,r.strides,a);if(1!==r.group){let i=[t[0]];if(a){let n=e.kernelCustomData.wT??e.compute(Oe(t[1],bo),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=n),i.push(n)}else i.push(t[1]);return 3===t.length&&i.push(t[2]),void(!e.adapterInfo.isArchitecture("ampere")&&a&&t[1].dims[0]===r.group&&1===t[1].dims[1]&&1===r.dilations[0]&&1===r.dilations[1]?e.compute(Md(i,r,o,n),{inputs:i}):e.compute(Dd(i,r,o,n),{inputs:i}))}let i=3===t.length,s=t[0].dims[a?1:2],l=t[0].dims[a?2:3],d=t[0].dims[a?3:1],u=t[1].dims[2],c=t[1].dims[3],p=o[a?1:2],g=o[a?2:3],A=o[a?3:1],h=a&&u===s&&c===l&&0===r.pads[0]&&0===r.pads[1];if(h||1===u&&1===c&&1===r.dilations[0]&&1===r.dilations[1]&&1===r.strides[0]&&1===r.strides[1]&&0===r.pads[0]&&0===r.pads[1]){let u,c,B,m=o[0],C=[];if(a){let n=e.kernelCustomData.wT??e.compute(Oe(t[1],bo),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];if(r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=n),h){let e=s*l*d;u=t[0].reshape([1,m,e]),c=n.reshape([1,e,A]),B=[1,m,A]}else u=t[0].reshape([m,s*l,d]),c=n.reshape([1,d,A]),B=[m,p*g,A];C.push(u),C.push(c)}else u=t[0].reshape([m,d,s*l]),c=t[1].reshape([1,A,d]),B=[m,A,p*g],C.push(c),C.push(u);i&&C.push(t[2]);let w=B[2],b=C[0].dims[C[0].dims.length-1];return void(w<8&&b<8?e.compute(Yr(C,r,o,B,a,n),{inputs:C}):e.compute(nr(C,r,o,B,a,n),{inputs:C}))}let B=e.kernelCustomData.wT??e.compute(Oe(t[1],bo),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=B);let m=[t[0],B];i&&m.push(t[2]);let C=a?p*g:A,w=a?A:p*g,b=u*c*d;e.compute(Ad(m,r,o,C,w,b,i,!0,n),{inputs:m})},ng=(e,t)=>{let r="NHWC"===t.format,n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&n.push(e.inputs[2]);let a=[0,t.pads[0],0,t.pads[1]],o=[1].concat(t.strides),i=[1].concat(t.dilations),s=[1].concat(t.kernelShape),l=_o({...t,pads:a,strides:o,dilations:i,kernelShape:s},n);Ud(e,n,l,(e=>r?[e[0],e[2],e[3]]:[e[0],e[1],e[3]]))},og=(e,t,r)=>{let n="NHWC"===r.format?"channelsLast":"channelsFirst",a=_o(r,t),o="NOTSET"===r.autoPad?r.pads:r.autoPad,i=zd(t[0].dims,t[1].dims,r.strides,r.dilations,o,!1,n);e.compute(Od(t,a,i.outShape,[i.filterDepth,i.filterHeight,i.filterWidth],[i.padInfo.front,i.padInfo.top,i.padInfo.left],n))},vo=(e,t)=>{if(rg(e.inputs,t),3===e.inputs[0].dims.length)ng(e,t);else if(5===e.inputs[0].dims.length)og(e,e.inputs,t);else{let r=_o(t,e.inputs);Ud(e,e.inputs,r)}}})),Vd,Wd=W((()=>{te(),tt(),ae(),ce(),Vd=(e,t,r)=>{let n=e.length>2,a=t.outputShape,o="NHWC"===t.format,i=t.group,s=e[1].dims,l=s[2]/i,d=s[3],u=o?ge(l):1,c=o&&1===d&&l>=4,p=c?4*Math.floor(l/4):Math.floor(l/u)*u,g=l-p,A=o?ge(d):1,h=o?1===d?u:A:1,B=E.size(a)/A,m=[Math.ceil(B/64),1,1];pe("verbose",(()=>`[conv2d_backprop_webgpu] dispatch = ${m}`));let C=["rank","rank"],w=[t.strides[0],t.strides[1]],b=[t.kernelShape[o?1:2],t.kernelShape[o?2:3]],K=[t.dilations[0],t.dilations[1]],f=[b[0]+(t.dilations[0]<=1?0:(t.kernelShape[o?1:2]-1)*(t.dilations[0]-1)),b[1]+(t.dilations[1]<=1?0:(t.kernelShape[o?2:3]-1)*(t.dilations[1]-1))],Q=[f[0]-1-Math.floor((t.pads[0]+t.pads[2])/2),f[1]-1-Math.floor((t.pads[1]+t.pads[3])/2)],W=[{type:12,data:B},{type:12,data:w},{type:12,data:b},{type:12,data:K},{type:12,data:f},{type:6,data:Q},{type:12,data:p},{type:12,data:l},{type:12,data:d},...G(e[0].dims,e[1].dims)];n&&(W.push(...G(e[2].dims)),C.push("rank")),W.push(...G(a));return{name:"ConvTranspose2D",shaderCache:{hint:`${t.cacheKey};${u}${h}${A}${c}${g}`,inputDependencies:C},getRunData:()=>({dispatchGroup:{x:m[0],y:m[1],z:m[2]},outputs:[{dims:r?r(a):a,dataType:e[0].dataType}],programUniforms:W}),getShaderSource:t=>{let r=[{name:"output_size",type:"u32"},{name:"strides",type:"u32",length:w.length},{name:"filter_dims",type:"u32",length:b.length},{name:"dilations",type:"u32",length:b.length},{name:"effective_filter_dims",type:"u32",length:f.length},{name:"pads",type:"i32",length:Q.length},{name:"input_channels_per_group_int",type:"u32"},{name:"input_channels_per_group",type:"u32"},{name:"output_channels_per_group",type:"u32"}],i=_e(e[0].dataType),s=o?1:2,l=o?2:3,d=o?3:1,p=P("W",e[1].dataType,e[1].dims.length,h),B=P("Dy",e[0].dataType,e[0].dims.length,u),m=[B,p];n&&m.push(P("bias",e[2].dataType,[a[d]].length,A));let C=N("result",e[0].dataType,a.length,A),K=`\n            let outputIndices = ${C.offsetToIndices(`global_idx * ${A}`)};\n            let batch = ${C.indicesGet("outputIndices",0)};\n            let d1 = ${C.indicesGet("outputIndices",d)};\n            let r = ${C.indicesGet("outputIndices",s)};\n            let c = ${C.indicesGet("outputIndices",l)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${C.type.value}(0.0);\n            var wR: u32 = 0;\n            if (uniforms.dilations.x == 1) {\n              // Minimum wR >= 0 that satisfies (dyRCorner + wR) % (uniforms.strides.x) == 0\n              wR = u32(((dyRCorner + i32(uniforms.strides.x) - 1) / i32(uniforms.strides.x)) * i32(uniforms.strides.x) - dyRCorner);\n            }\n            for (; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${i}(dyRCorner) + ${i}(wR)) / ${i}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${i}(uniforms.Dy_shape[${s}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              let idyR: u32 = u32(dyR);\n              var wC: u32 = 0;\n              if (uniforms.dilations.y == 1) {\n                // Minimum wC >= 0 that satisfies (dyCCorner + wC) % (uniforms.strides.y) == 0\n                wC = u32(((dyCCorner + i32(uniforms.strides.y) - 1) / i32(uniforms.strides.y)) * i32(uniforms.strides.y) - dyCCorner);\n              }\n              for (; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${i}(dyCCorner) + ${i}(wC)) / ${i}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${i}(uniforms.Dy_shape[${l}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                ${c?`\n                var x_offset = ${B.indicesToOffset(`${B.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${u};\n                var w_offset = ${p.indicesToOffset(`${p.type.indices}(wRPerm, wCPerm, inputChannel, wOutChannel)`)} / ${h};\n                  `:""}\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group_int; d2 = d2 + ${c?4:u}) {\n                  ${(()=>{let e="";if(c)4===u?e+=`\n        let xValue = ${B.getByOffset("x_offset")};\n        let wValue = ${p.getByOffset("w_offset")};\n        dotProd = dotProd + dot(xValue, wValue);\n        x_offset += 1u;\n        w_offset += 1u;`:2===u?e+=`\n          dotProd = dotProd + dot(vec4<${i}>(${B.getByOffset("x_offset")}, ${B.getByOffset("x_offset + 1u")}), vec4<${i}>(${p.getByOffset("w_offset")}, ${p.getByOffset("w_offset + 1u")}));\n          x_offset += 2u;\n          w_offset += 2u;`:1===u&&(e+=`\n          dotProd = dotProd + dot(vec4<${i}>(${B.getByOffset("x_offset")}, ${B.getByOffset("x_offset + 1u")}, ${B.getByOffset("x_offset + 2u")}, ${B.getByOffset("x_offset + 3u")}), vec4<${i}>(${p.getByOffset("w_offset")}, ${p.getByOffset("w_offset + 1u")}, ${p.getByOffset("w_offset + 2u")}, ${p.getByOffset("w_offset + 3u")}));\n          x_offset += 4u;\n          w_offset += 4u;`);else if(e+=`\n                  let xValue = ${o?B.getByOffset(`${B.indicesToOffset(`${B.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${u}`):B.get("batch","inputChannel","idyR","idyC")};\n        `,1===u)e+=`\n          let w_offset = ${p.indicesToOffset(`${p.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n          let wValue = ${p.getByOffset(`w_offset / ${h}`)};\n          dotProd = dotProd + xValue * wValue;`;else for(let t=0;t<u;t++)e+=`\n            let wValue${t} = ${p.getByOffset(`${p.indicesToOffset(`${p.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${t}, wOutChannel)`)} / ${h}`)};\n            dotProd = dotProd + xValue[${t}] * wValue${t};`;return e})()}\n                  inputChannel = inputChannel + ${c?4:u};\n                }\n                ${(()=>{if(0===g)return"";if(!c)throw new Error(`packInputAs4 ${c} is not true.`);let e="";if(1===u){e+="dotProd = dotProd";for(let t=0;t<g;t++)e+=`\n            + ${B.getByOffset(`x_offset + ${t}`)} * ${p.getByOffset(`w_offset + ${t}`)}`;e+=";"}else if(2===u){if(2!==g)throw new Error(`Invalid inputChannelsRemainder ${g}.`);e+=`\n          let xValue = ${B.getByOffset("x_offset")};\n          let wValue = ${p.getByOffset("w_offset")};\n          dotProd = dotProd + dot(xValue, wValue);`}return e})()}\n                wC = wC + uniforms.strides.y - 1;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n            }\n            let value = dotProd${n?` + bias[d1 / ${A}]`:""};\n            ${C.setByOffset("global_idx","value")};\n          `;return`\n    ${t.registerUniforms(r).declareVariables(...m,C)}\n      ${t.mainStart()}\n      ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")};\n    ${K}}`}}}})),ig,ag,sg,Ld,Gd,ug,Hd,dg,Fd,qd=W((()=>{Wd(),vt(),ct(),ig=(e,t,r,n,a,o)=>(e-1)*t+r+(n-1)*a+1-o,ag=(e,t,r,n,a)=>{let o=Math.floor(e/2);"SAME_UPPER"===t?(r[n]=o,r[a]=e-o):"SAME_LOWER"===t&&(r[n]=e-o,r[a]=o)},sg=(e,t,r,n,a,o,i,s,l,d)=>{let u=e.length-2,c=0===d.length;l.length<u&&l.push(...Array(u-l.length).fill(0));let p=e[0],g=t[s?3:1]*a;for(let a=0,p=e.length-u-(s?1:0);a<u;++a,++p){let s=e[p],g=c?s*i[a]:d[a],A=ig(s,i[a],o[a],t[p],r[a],g);ag(A,n,o,a,a+u),c&&d.push(i[a]*(s-1)+l[a]+(t[p]-1)*r[a]+1-o[a]-o[a+u])}d.splice(0,0,p),d.splice(s?3:1,0,g)},Ld=(e,t)=>{let r=e.kernelShape.slice();if(0===e.kernelShape.length||0===e.kernelShape.reduce(((e,t)=>e*t),1)){r.length=0;for(let e=2;e<t[1].dims.length;++e)r.push(t[1].dims[e])}let n="NHWC"===e.format;r.splice(0,0,t[1].dims[0]),r.splice(n?3:1,0,t[1].dims[1]);let a=e.pads.slice(),o=e.outputShape.slice(),i=e.outputPadding.slice(),s=t[0].dims,l=e.dilations.slice();if(0===l.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;l=new Array(e).fill(1)}let d=e.strides.slice();if(0===d.reduce(((e,t)=>e+t),0)){let e=t[0].dims.length-2;d=new Array(e).fill(1)}sg(s,r,l,e.autoPad,e.group,a,d,n,i,o);let u=Object.assign({},e);return Object.assign(u,{kernelShape:r,pads:a,outputPadding:i,outputShape:o,dilations:l,strides:d}),u},Gd=e=>{let t=Zr(e),r=e.format,n=["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][typeof e.autoPad>"u"?0:e.autoPad],a=e.dilations,o=e.group,i=e.kernelShape,s=e.pads,l=e.strides,d=e.wIsConst();return{autoPad:n,format:r,dilations:a,group:o,kernelShape:i,outputPadding:e.outputPadding,outputShape:e.outputShape,pads:s,strides:l,wIsConst:d,...t,cacheKey:`${e.format};${t.activation};`}},ug=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length&&3!==e[0].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims.length!==e[1].dims.length)throw new Error("filter does not have same dimension as input");if(e[0].dims["NHWC"===t.format?e[0].dims.length-1:1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let r=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==r))throw new Error("invalid bias");let n=e[0].dims.length-2;if(t.dilations.reduce(((e,t)=>e+t),0)>0&&t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.reduce(((e,t)=>e+t),0)>0&&t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.reduce(((e,t)=>e+t),0)>0&&t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(t.outputPadding.length!==n&&0!==t.outputPadding.length)throw new Error(`output_padding should be ${n}D`);if(t.kernelShape.reduce(((e,t)=>e+t),0)>0&&0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape")},Hd=(e,t,r,n)=>{let a=e.kernelCustomData.wT??e.compute(Oe(t[1],[2,3,0,1]),{inputs:[1],outputs:[r.wIsConst?-2:-1]})[0];r.wIsConst&&!e.kernelCustomData.wT&&(e.kernelCustomData.wT=a);let o=[t[0],a];3===t.length&&o.push(t[2]),e.compute(Vd(o,r,n),{inputs:o})},dg=(e,t)=>{let r="NHWC"===t.format,n=[e.inputs[0].reshape(r?[e.inputs[0].dims[0],1,e.inputs[0].dims[1],e.inputs[0].dims[2]]:[e.inputs[0].dims[0],e.inputs[0].dims[1],1,e.inputs[0].dims[2]]),e.inputs[1].reshape([e.inputs[1].dims[0],e.inputs[1].dims[1],1,e.inputs[1].dims[2]])];3===e.inputs.length&&n.push(e.inputs[2]);let a=t.kernelShape;(0===a.length||0===a[0])&&(a=[e.inputs[1].dims[2]]);let o=t.dilations;(0===o.length||0===o[0])&&(o=[1]);let i=t.strides;(0===i.length||0===i[0])&&(i=[1]);let s=t.pads;0===s.length&&(s=[0,0]),s=[0,s[0],0,s[1]],i=[1].concat(i),o=[1].concat(o),a=[1].concat(a);let l=t.outputPadding;l=[0].concat(l);let d=Ld({...t,pads:s,strides:i,dilations:o,kernelShape:a,outputPadding:l},n);Hd(e,n,d,(e=>r?[e[0],e[2],e[3]]:[e[0],e[1],e[3]]))},Fd=(e,t)=>{if(ug(e.inputs,t),3===e.inputs[0].dims.length)dg(e,t);else{let r=Ld(t,e.inputs);Hd(e,e.inputs,r)}}})),lg,Kd,jd,Zd=W((()=>{te(),ae(),Ce(),ce(),lg=(e,t,r,n)=>{let a=E.size(t),o=t.length,i=P("input",e,o),s=N("output",e,o),l=6===r.dataType?r.getInt32Array()[0]:Number(r.getBigInt64Array()[0]),d=E.normalizeAxis(l,o);return{name:"CumSum",shaderCache:{hint:n.cacheKey,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:t,dataType:e}],dispatchGroup:{x:Math.ceil(a/64)},programUniforms:[{type:12,data:a},{type:12,data:d},...G(t,t)]}),getShaderSource:e=>{let t=` i32(${i.indicesGet("inputIndices","uniforms.axis")}) `,r=j("uniforms.input_shape","uniforms.axis",o),a=n.reverse?t+(n.exclusive?" + 1":""):"0",l=n.reverse?r:t+(n.exclusive?"":" + 1");return`\n                ${e.registerUniform("outputSize","u32").registerUniform("axis","u32").declareVariables(i,s)}\n                ${e.mainStart()}\n                  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n                  var inputIndices = ${s.offsetToIndices("global_idx")};\n                  var sum = ${s.type.value}(0);\n                  let first : i32 = ${a};\n                  let last : i32 = ${l};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${i.indicesSet("inputIndices","uniforms.axis","u32(i)")};\n                    sum = sum + ${i.getByIndices("inputIndices")};\n                  }\n                  ${s.setByOffset("global_idx","sum")};\n                }`}}},Kd=(e,t)=>{let r=e.inputs[0].dims,n=e.inputs[0].dataType,a=e.inputs[1];e.compute(lg(n,r,a,t),{inputs:[0]})},jd=e=>{let t=1===e.exclusive,r=1===e.reverse;return re({exclusive:t,reverse:r})}})),cg,pg,mg,Qd,Yd,Xd=W((()=>{te(),ae(),Ce(),ce(),cg=e=>{if(!e||1!==e.length)throw new Error("DepthToSpace requires 1 input.");if(4!==e[0].dims.length)throw new Error("DepthToSpace requires 4D input.")},pg=(e,t,r,n)=>{let a=[];a.push(`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);for(let n=0;n<t;++n)a.push(r.indicesSet("a",e[n],`i[${n}]`));return a.push("return a;}"),a.join("\n")},mg=(e,t)=>{let r,n,a,o,i,s,l="NHWC"===t.format,d=t.blocksize,u="DCR"===t.mode;l?([r,n,a,o]=e.dims,i=u?[r,n,a,d,d,o/d**2]:[r,n,a,o/d**2,d,d],s=u?[0,1,3,2,4,5]:[0,1,4,2,5,3]):([r,n,a,o]=[e.dims[0],e.dims[2],e.dims[3],e.dims[1]],i=u?[r,d,d,o/d**2,n,a]:[r,o/d**2,d,d,n,a],s=u?[0,3,4,1,5,2]:[0,1,4,2,5,3]);let c=e.reshape(i),p=c.dims.length,g=e.dataType,A=P("a",g,p),h=N("output",g,p);return{name:"DepthToSpace",shaderCache:{hint:`${e.dims};${t.blocksize};${t.mode}`,inputDependencies:["rank"]},getRunData:e=>{let t=l?[r,n*d,a*d,o/d**2]:[r,o/d**2,n*d,a*d],i=E.size(t),u=c.dims,p=E.sortBasedOnPerm(u,s);return{outputs:[{dims:t,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:[{type:12,data:i},...G(u,p)]}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(A,h)}\n\n  ${pg(s,p,A,h)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n    let indices = ${h.offsetToIndices("global_idx")};\n    let aIndices = perm(indices);\n\n    ${h.setByOffset("global_idx",A.getByIndices("aIndices"))}\n  }`}},Qd=(e,t)=>{cg(e.inputs),e.compute(mg(e.inputs[0],t))},Yd=e=>re({blocksize:e.blocksize,mode:e.mode,format:e.format})})),$o,tn,Jd,fg,hg,xo,So,el,gg,tl,rl,nl=W((()=>{te(),ae(),Ce(),ce(),Jd="^"+(tn="("+($o="[a-zA-Z]|\\.\\.\\.")+")+")+"$",hg="^"+(fg="("+tn+",)*"+tn)+"$",xo=class{constructor(e=-1){this.symbolToIndices=new Map,this.inputIndex=e}addSymbol(e,t){let r=this.symbolToIndices.get(e);void 0===r?r=[t]:r.push(t),this.symbolToIndices.set(e,r)}},So=class{constructor(e,t){this.equation=t,this.hasEllipsis=!1,this.symbolToInfo=new Map,this.lhs=new Array,this.outputDims=[];let[r,n]=t.includes("->")?t.split("->",2):[t,""];if(!r.match(RegExp(hg)))throw new Error("Invalid LHS term");if(r.split(",").forEach(((t,r)=>{let n=e[r].dims.slice();if(!t.match(RegExp(Jd)))throw new Error("Invalid LHS term");let a=this.processTerm(t,!0,n,r);this.lhs.push(a)})),""===n)n+=[...this.symbolToInfo.entries()].filter((([e,t])=>1===t.count||"..."===e)).map((([e])=>e)).join("");else if(!n.match(RegExp(tn)))throw new Error("Invalid RHS");n.match(RegExp($o,"g"))?.forEach((e=>{if("..."===e)this.outputDims=this.outputDims.concat(this.ellipsisDims);else{let t=this.symbolToInfo.get(e);if(void 0===t)throw new Error("Invalid RHS symbol");this.outputDims.push(t.dimValue)}})),this.rhs=this.processTerm(n,!1,this.outputDims)}addSymbol(e,t,r){let n=this.symbolToInfo.get(e);if(void 0!==n){if(n.dimValue!==t&&1!==n.count)throw new Error("Dimension mismatch");n.count++,n.inputIndices.push(r)}else n={count:1,dimValue:t,inputIndices:[r]};this.symbolToInfo.set(e,n)}processTerm(e,t,r,n=-1){let a=r.length,o=!1,i=[],s=0;if(!e.match(RegExp(Jd))&&!t&&""!==e)throw new Error("Invalid LHS term");let l=e.match(RegExp($o,"g")),d=new xo(n);return l?.forEach(((e,u)=>{if("..."===e){if(o)throw new Error("Only one ellipsis is allowed per input term");o=!0;let e=a-l.length+1;if(e<0)throw new Error("Ellipsis out of bounds");if(i=r.slice(s,s+e),this.hasEllipsis){if(this.ellipsisDims.length!==i.length||this.ellipsisDims.toString()!==i.toString())throw new Error("Ellipsis dimensions mismatch")}else{if(!t)throw new Error("Ellipsis must be specified in the LHS");this.hasEllipsis=!0,this.ellipsisDims=i}for(let e=0;e<i.length;e++){let t=String.fromCharCode(48+e);d.addSymbol(t,u+e),this.addSymbol(t,r[s++],n)}}else d.addSymbol(e,u+(this.hasEllipsis?this.ellipsisDims.length-1:0)),this.addSymbol(e,r[s++],n)})),d}},el=e=>e+"_max",gg=(e,t,r,n)=>{let a=e.map((e=>e.length)).map(((e,r)=>P(`input${r}`,t,e))),o=E.size(n),i=N("output",t,n.length),s=[...r.symbolToInfo.keys()].filter((e=>!r.rhs.symbolToIndices.has(e)));return{name:"Einsum",shaderCache:{hint:r.equation,inputDependencies:e.map((()=>"rank"))},getRunData:()=>{let a=s.filter((e=>r.symbolToInfo.has(e))).map((e=>({type:12,data:r.symbolToInfo.get(e)?.dimValue||0})));a.push({type:12,data:o});let i=e.map(((e,t)=>[...G(e)])).reduce(((e,t)=>e.concat(t)),a);return i.push(...G(n)),{outputs:[{dims:n,dataType:t}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:i}},getShaderSource:e=>{let t=[],n=[],o=[],l=[],d=[],u=r.symbolToInfo.size===r.rhs.symbolToIndices.size;r.symbolToInfo.forEach(((e,s)=>{if(r.rhs.symbolToIndices.has(s)){let n=r.rhs.symbolToIndices.get(s)?.[0];void 0!==n&&r.lhs.forEach(((r,o)=>{if(e.inputIndices.includes(o)){let e=r.symbolToIndices.get(s);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{t.push(`${a[o].indicesSet(`input${o}Indices`,e,i.indicesGet("outputIndices",n))}`)}))}}))}else r.lhs.forEach(((t,r)=>{if(e.inputIndices.includes(r)){let e=t.symbolToIndices.get(s);if(void 0===e)throw new Error("Invalid symbol error");e.forEach((e=>{n.push(`${a[r].indicesSet(`input${r}Indices`,e,`${s}`)}`)})),d.push(`prod *= ${a[r].getByIndices(`input${r}Indices`)};`)}})),o.push(`for(var ${s}: u32 = 0; ${s} < uniforms.${el(s)}; ${s}++) {`),l.push("}")}));let c=u?[...t,`let sum = ${a.map(((e,t)=>e.getByIndices(`input${t}Indices`))).join(" * ")};`]:[...t,"var sum = 0.0;",...o,...n,"var prod = 1.0;",...d,"sum += prod;",...l];return`\n            ${e.registerUniforms(s.map((e=>({name:`${el(e)}`,type:"u32"})))).registerUniform("outputSize","u32").declareVariables(...a,i)}\n\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n            var outputIndices = ${i.offsetToIndices("global_idx")};\n            ${a.map(((e,t)=>`var input${t}Indices: ${a[t].type.indices};`)).join("\n")}\n            ${c.join("\n")};\n            ${i.setByOffset("global_idx","sum")};\n          }`}}},tl=(e,t)=>{let r=new So(e.inputs,t.equation),n=r.outputDims,a=e.inputs.map(((e,t)=>e.dims));e.compute(gg(a,e.inputs[0].dataType,r,n))},rl=e=>{let t=e.equation.replace(/\s+/g,"");return re({equation:t})}})),yg,ol,bg,_g,il,al=W((()=>{te(),ae(),ce(),yg=e=>{if(!e||2!==e.length)throw new Error("Expand requires 2 input.");let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=r.length<t.length?0:r.length-t.length,a=t.length<r.length?0:t.length-r.length;for(;n<r.length&&a<t.length;++n,++a)if(r[n]!==t[a]&&1!==r[n]&&1!==t[a])throw new Error("Expand requires shape to be broadcastable to input")},ol=(e,t)=>{let r=e.length-t.length,n=[];for(let t=0;t<r;++t)n.push(e[t]);for(let a=0;a<t.length;++a)n.push(1===t[a]?e[a+r]:t[a]);return n},bg=(e,t)=>e.length>t.length?ol(e,t):ol(t,e),_g=e=>{let t=e[0].dims,r=Array.from(e[1].getBigInt64Array(),Number),n=bg(t,r),a=e[0].dataType,o=9===a||1===E.size(t),i=9===a||t.length>0&&t[t.length-1]%4==0?4:1,s=o||n.length>0&&n[n.length-1]%4==0?4:1,l=Math.ceil(E.size(n)/s),d=[{type:12,data:l},...G(t,n)];return{name:"Expand",shaderCache:{hint:`${n.length};${i}${s}`,inputDependencies:["rank"]},getShaderSource:e=>{let r,o=P("input",a,t.length,i),l=N("output",a,n.length,s);if(9===a){let e=(e,t,r="")=>`\n          let outputIndices${t} = ${l.offsetToIndices(`outputOffset + ${t}u`)};\n          let offset${t} = ${o.broadcastedIndicesToOffset(`outputIndices${t}`,l)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${r}(${o.getByOffset(`index${t}`)}[component${t}]);\n        `;r=`\n        let outputOffset = global_idx * ${s};\n        var data = vec4<u32>(0);\n        ${e("data",0,"u32")}\n        ${e("data",1,"u32")}\n        ${e("data",2,"u32")}\n        ${e("data",3,"u32")}\n        ${l.setByOffset("global_idx","data")}\n      }`}else r=`\n        let outputIndices = ${l.offsetToIndices(`global_idx * ${s}`)};\n        let inputOffset = ${o.broadcastedIndicesToOffset("outputIndices",l)};\n        let data = ${l.type.value}(${o.getByOffset(`inputOffset / ${i}`)});\n        ${l.setByOffset("global_idx","data")}\n      }`;return`\n    ${e.registerUniform("vec_size","u32").declareVariables(o,l)}\n    ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n    ${r}`},getRunData:()=>({outputs:[{dims:n,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d})}},il=e=>{yg(e.inputs),e.compute(_g(e.inputs),{inputs:[0]})}})),wg,sl,ul=W((()=>{te(),ae(),ce(),jr(),wg=e=>{let t=e[0].dataType,r=E.size(e[0].dims),n=E.size(e[1].dims),a=n%4==0;return{name:"FastGeluWithBias",shaderCache:{hint:`${a}`,inputDependencies:["type","type"]},getShaderSource:e=>{let r=P("x",t,[1],4),n=P("bias",t,[1],4),o=N("y",t,[1],4),i=e=>`\n      let bias${e}_offset: u32 = (global_idx * 4 + ${e}) % uniforms.bias_size;\n      let bias${e} = ${n.getByOffset(`bias${e}_offset / 4`)}[bias${e}_offset % 4];`,s=a?`\n      let bias = ${n.getByOffset("global_idx % (uniforms.bias_size / 4)")};`:`${i(0)}${i(1)}${i(2)}${i(3)}\n      let bias = ${r.type.value}(bias0, bias1, bias2, bias3);`;return`${e.registerUniforms([{name:"output_vec_size",type:"u32"},{name:"bias_size",type:"u32"}]).declareVariables(r,n,o)}\n\n    ${fo(ze(t))}\n\n    ${e.mainStart(Et)}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_vec_size")}\n\n      let x = ${r.getByOffset("global_idx")};\n      ${s}\n      let x_in = x + bias;\n      ${o.setByOffset("global_idx",ho("x_in"))}\n    }`},getRunData:e=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],programUniforms:[{type:12,data:Math.ceil(r/4)},{type:12,data:n}],dispatchGroup:{x:Math.ceil(r/Et/4)}})}},sl=e=>{e.inputs.length<2||0===E.size(e.inputs[1].dims)?nd(e):e.compute(wg(e.inputs))}})),vg,$g,dl,ll,cl=W((()=>{te(),ae(),Ce(),ce(),vg=e=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.")},$g=(e,t)=>{let r=e[0].dims,n=e[1].dims,a=r.length,o=E.normalizeAxis(t.axis,a),i=r.slice(0);i.splice(o,1,...n);let s=r[o],l=9===e[0].dataType?4:1,d=Math.ceil(E.size(i)/l),u=[{type:12,data:d},{type:6,data:s},{type:12,data:o},...G(e[0].dims,e[1].dims,i)];return{name:"Gather",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:i,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}),getShaderSource:t=>{let r,s=P("data",e[0].dataType,e[0].dims.length,l),d=P("inputIndices",e[1].dataType,e[1].dims.length),u=N("output",e[0].dataType,i.length,l),c=e=>{let t=n.length,r=`var indicesIndices${e}  = ${d.type.indices}(0);`;for(let n=0;n<t;n++)r+=`${t>1?`indicesIndices${e}[${n}]`:`indicesIndices${e}`} = ${i.length>1?`outputIndices${e}[uniforms.axis + ${n}]`:`outputIndices${e}`};`;r+=`\n          var idx${e} = ${d.getByIndices(`indicesIndices${e}`)};\n          if (idx${e} < 0) {\n            idx${e} = idx${e} + uniforms.axisDimLimit;\n          }\n          var dataIndices${e} : ${s.type.indices};\n        `;for(let n=0,s=0;n<a;n++)n===o?(r+=`${a>1?`dataIndices${e}[${n}]`:`dataIndices${e}`} = u32(idx${e});`,s+=t):(r+=`${a>1?`dataIndices${e}[${n}]`:`dataIndices${e}`} = ${i.length>1?`outputIndices${e}[${s}]`:`outputIndices${e}`};`,s++);return r};if(9===e[0].dataType){let e=(e,t,r="")=>`\n          let outputIndices${t} = ${u.offsetToIndices(`outputOffset + ${t}u`)};\n          ${c(t)};\n          let offset${t} = ${s.indicesToOffset(`dataIndices${t}`)};\n          let index${t} = offset${t} / 4u;\n          let component${t} = offset${t} % 4u;\n          ${e}[${t}] = ${r}(${s.getByOffset(`index${t}`)}[component${t}]);\n        `;r=`\n        let outputOffset = global_idx * ${l};\n        var value = vec4<u32>(0);\n        ${e("value",0,"u32")}\n        ${e("value",1,"u32")}\n        ${e("value",2,"u32")}\n        ${e("value",3,"u32")}\n        ${u.setByOffset("global_idx","value")}\n      `}else r=`\n      let outputIndices = ${u.offsetToIndices("global_idx")};\n      ${c("")};\n      let value = ${s.getByIndices("dataIndices")};\n      ${u.setByOffset("global_idx","value")};\n      `;return`\n      ${t.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(s,d,u)}\n      ${t.mainStart()}\n        ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        ${r}\n      }`}}},dl=e=>re({axis:e.axis}),ll=(e,t)=>{let r=e.inputs;vg(r),e.compute($g(e.inputs,t))}})),xg,pl,ml,fl=W((()=>{te(),ae(),ce(),xg=(e,t,r,n,a,o,i,s,l)=>{let d=[{type:12,data:o},{type:12,data:n},{type:12,data:a},{type:12,data:r},{type:12,data:i},{type:12,data:s},{type:12,data:l}],u=[o];d.push(...G(t.dims,u));return e.compute({name:"computeSliceOffsets",shaderCache:{hint:`${a.length}_${r.length}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:u,dataType:e.inputs[1].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:d}),getShaderSource:e=>{let n=[P("indices_data",t.dataType,t.dims.length),N("input_slice_offsets_data",12,1,1)],o=[{name:"output_size",type:"u32"},{name:"batch_dims",type:"u32"},{name:"input_dims",type:"u32",length:a.length},{name:"sizes_from_slice_dims_data",type:"u32",length:r.length},{name:"num_slices_per_batch",type:"u32"},{name:"input_batch_stride",type:"u32"},{name:"num_slice_dims",type:"u32"}];return`\n  ${e.registerUniforms(o).declareVariables(...n)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${1===a.length?"index += i32(uniforms.input_dims);":"index += i32(uniforms.input_dims[input_dim_idx]);"}\n      }\n      ${1===r.length?"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);":"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`}},{inputs:[t],outputs:[-1]})[0]},pl=(e,t)=>{let r=e.inputs,n=r[0].dims,a=r[0].dataType,o=r[1].dims,i=o[o.length-1],s=E.sizeToDimension(o,o.length-1),l=E.sizeFromDimension(n,t.batchDims+i),d=E.sizeToDimension(n,t.batchDims),u=E.sizeFromDimension(n,t.batchDims),c=s/d,p=new Array(i),g=l;for(let e=0;e<i;++e)p[i-1-e]=g,g*=n[t.batchDims+i-1-e];let A=xg(e,r[1],p,t.batchDims,n,s,c,u,i),h=t.batchDims+i;if(h>n.length)throw new Error("last dimension of indices must not be larger than rank of input tensor");let B=o.slice(0,-1).concat(n.slice(h)),m=E.size(B),C=[{type:12,data:m},{type:12,data:l},...G(r[0].dims,A.dims,B)];e.compute({name:"GatherND",shaderCache:{hint:t.cacheKey,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:B,dataType:a}],dispatchGroup:{x:Math.ceil(m/64)},programUniforms:C}),getShaderSource:e=>{let t=P("data",r[0].dataType,r[0].dims.length),n=P("slice_offsets",12,A.dims.length),a=N("output",r[0].dataType,B.length);return`\n          ${e.registerUniform("output_size","u32").registerUniform("slice_size","u32").declareVariables(t,n,a)}\n            ${e.mainStart()}\n            ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`}},{inputs:[r[0],A]})},ml=e=>({batchDims:e.batch_dims,cacheKey:""})})),Sg,Tg,hl,gl,yl=W((()=>{te(),ae(),Ce(),ce(),Sg=(e,t)=>{if(e.length<3||e.length>4)throw new Error("GatherBlockQuantized requires 3 or 4 inputs.");let r=E.normalizeAxis(t.quantizeAxis,e[0].dims.length),n=t.blockSize,a=e[0],o=e[2],i=4===e.length?e[3]:void 0;if(o.dims.length!==a.dims.length||!a.dims.map(((e,t)=>t===r?Math.ceil(e/n)===o.dims[t]:e===o.dims[t])).reduce(((e,t)=>e&&t),!0))throw new Error("Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.");if(i){if(i.dataType!==a.dataType)throw new Error("Zero point must have the same data type as the input tensor.");if(i.dims.length!==o.dims.length||!i.dims.map(((e,t)=>e===o.dims[t])).reduce(((e,t)=>e&&t),!0))throw new Error("Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.")}},Tg=(e,t)=>{let r=e[0].dims,n=e[1].dims,a=r.length,o=E.normalizeAxis(t.gatherAxis,a),i=E.normalizeAxis(t.quantizeAxis,a),s=r.slice(0);s.splice(o,1,...n);let l=E.size(s),d=e[2].dataType,u=22===e[0].dataType,c=[{type:12,data:l},{type:12,data:i},{type:12,data:o},{type:12,data:t.blockSize},...G(...e.map(((e,t)=>e.dims)),s)];return{name:"GatherBlockQuantized",shaderCache:{hint:`${t.cacheKey};${e.filter(((e,t)=>1!==t)).map((e=>e.dims.join("_"))).join(";")}`,inputDependencies:Array.from({length:e.length},((e,t)=>"rank"))},getRunData:()=>({outputs:[{dims:s,dataType:d}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:c}),getShaderSource:t=>{let a=P("data",e[0].dataType,e[0].dims.length),i=P("inputIndices",e[1].dataType,e[1].dims.length),l=P("scales",e[2].dataType,e[2].dims.length),c=e.length>3?P("zeroPoint",e[3].dataType,e[3].dims.length):void 0,p=N("output",d,s.length),g=[a,i,l];c&&g.push(c);return`\n        ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"quantize_axis",type:"u32"},{name:"gather_axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...g,p)}\n        ${t.mainStart()}\n        let output_indices = ${p.offsetToIndices("global_idx")};\n        var indices_indices = ${i.type.indices}(0);\n        ${n.length>1?`\n          for (var i: u32 = 0; i < ${n.length}; i++) {\n            let index = ${p.indicesGet("output_indices","uniforms.gather_axis + i")};\n            ${i.indicesSet("indices_indices","i","index")};\n          }`:`indices_indices = ${p.indicesGet("output_indices","uniforms.gather_axis")};`};\n        var data_indices = ${a.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${p.indicesGet("output_indices","i")};\n          ${a.indicesSet("data_indices","i","index")};\n        }\n        var index_from_indices = ${i.getByIndices("indices_indices")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${r[o]};\n        }\n        ${a.indicesSet("data_indices","uniforms.gather_axis","u32(index_from_indices)")};\n        for (var i = uniforms.gather_axis + 1; i < ${s.length}; i++) {\n          let index = ${p.indicesGet("output_indices",`i + ${n.length} - 1`)};\n          ${a.indicesSet("data_indices","i","index")};\n        }\n        let data_offset = ${a.indicesToOffset("data_indices")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${a.getByOffset("data_offset / 8")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${u?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${l.indicesGet("data_indices","uniforms.quantize_axis")} / uniforms.block_size;\n        ${l.indicesSet("scale_indices","uniforms.quantize_axis","quantize_axis_index")};\n        var scale = ${l.getByIndices("scale_indices")};\n        ${c?`\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${c.indicesToOffset("zero_point_indices")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${c.getByOffset("zero_point_offset / 8")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${u?"unpack4xI8":"unpack4xU8"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];`:"var zero_point = 0"};\n        let dequantized_data = ${ze(d)}(quantized_data - zero_point) * scale;\n        ${p.setByOffset("global_idx","dequantized_data")};\n    }`}}},hl=(e,t)=>{let r=e.inputs;Sg(r,t),e.compute(Tg(e.inputs,t))},gl=e=>re({blockSize:e.blockSize,gatherAxis:e.gatherAxis,quantizeAxis:e.quantizeAxis})})),Cg,Ig,bl,_l,wl=W((()=>{te(),ae(),Ce(),ce(),Cg=e=>{if(!e||2!==e.length)throw new Error("GatherElements requires 2 inputs.");if(e[0].dims.length<1)throw new Error("GatherElements requires that the data input be rank >= 1.");if(e[0].dims.length!==e[1].dims.length)throw new Error("GatherElements requires that the data input and\n                     indices input tensors be of same rank.")},Ig=(e,t)=>{let r=e[0].dims,n=e[0].dataType,a=r.length,o=e[1].dims,i=e[1].dataType,s=E.normalizeAxis(t.axis,a),l=r[s],d=o.slice(0),u=E.size(d),c=P("input",n,a),p=P("indicesInput",i,o.length),g=N("output",n,d.length),A=[{type:12,data:u},{type:6,data:l},{type:12,data:s}];return A.push(...G(r,o,d)),{name:"GatherElements",shaderCache:{inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:d,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(u/64)},programUniforms:A}),getShaderSource:e=>`\n      ${e.registerUniform("outputSize","u32").registerUniform("axisDimLimit","i32").registerUniform("axis","u32").declareVariables(c,p,g)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n      let outputIndices = ${g.offsetToIndices("global_idx")};\n\n      var idx = ${p.getByOffset("global_idx")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${c.type.indices}(outputIndices);\n      ${c.indicesSet("inputIndices","uniforms.axis","u32(idx)")};\n      let value = ${c.getByIndices("inputIndices")};\n\n      ${g.setByOffset("global_idx","value")};\n  }`}},bl=e=>re({axis:e.axis}),_l=(e,t)=>{let r=e.inputs;Cg(r),e.compute(Ig(e.inputs,t))}})),Ag,kg,vl,$l,xl=W((()=>{te(),ae(),ce(),Ag=e=>{if(!e)throw new Error("Input is missing");if(e.length<2||e.length>3)throw new Error("Invaid input number.");if(3===e.length&&e[2].dims.length>2)throw new Error("Invalid input shape of C");if(e[0].dataType!==e[1].dataType||3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("Input types are mismatched")},kg=(e,t)=>{let r=e[0].dims.slice(),n=e[1].dims.slice(),[a,o,i]=Wr.getShapeOfGemmResult(r,t.transA,n,t.transB,3===e.length?e[2].dims:void 0),s=[a,o];if(!s)throw new Error("Can't use gemm on the given tensors");let l=16,d=Math.ceil(o/l),u=Math.ceil(a/l),c=(E.size(s),[{type:12,data:d},{type:12,data:a},{type:12,data:o},{type:12,data:i},{type:1,data:t.alpha},{type:1,data:t.beta}]),p=["type","type"];3===e.length&&(c.push(...G(e[2].dims)),p.push("rank")),c.push(...G(s));return{name:"GemmShared",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:p},getRunData:()=>({outputs:[{dims:s,dataType:e[0].dataType}],dispatchGroup:{x:d*u},programUniforms:c}),getShaderSource:r=>{let n=P("a",e[0].dataType,e[0].dims),a=P("b",e[1].dataType,e[1].dims),o=null,i=[n,a];3===e.length&&(o=P("c",e[2].dataType,e[2].dims.length),i.push(o));let d=N("output",e[0].dataType,s.length);i.push(d);let u="",c="";t.transA&&t.transB?(c=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${n.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${a.type.value}(0);\n      }\n      `,u="value += tile_a[k][local_id.y] * tile_b[local_id.x][k];"):t.transA&&!t.transB?(c=`\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${n.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${a.type.value}(0);\n      }\n      `,u="value += tile_a[k][local_id.y] * tile_b[k][local_id.x];"):!t.transA&&t.transB?(c=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${n.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${a.type.value}(0);\n      }\n      `,u="value += tile_a[local_id.y][k] * tile_b[local_id.x][k];"):!t.transA&&!t.transB&&(c=`\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${n.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${a.type.value}(0);\n      }\n      `,u="value += tile_a[local_id.y][k] * tile_b[k][local_id.x];");let p=1===t.alpha?"":"value *= uniforms.alpha;";return`\n  ${r.registerUniforms([{name:"num_tile_n",type:"u32"},{name:"M",type:"u32"},{name:"N",type:"u32"},{name:"K",type:"u32"},{name:"alpha",type:"f32"},{name:"beta",type:"f32"}]).declareVariables(...i)}\n  var<workgroup> tile_a: array<array<${n.type.storage}, 16>, 16>;\n  var<workgroup> tile_b: array<array<${a.type.storage}, 16>, 16>;\n  ${r.mainStart([l,l,1])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * 16;\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * 16;\n    let num_tiles = (uniforms.K - 1) / 16 + 1;\n    var k_start = 0u;\n    var value = ${d.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${c}\n      k_start = k_start + 16;\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < 16; k++) {\n        ${u}\n      }\n      workgroupBarrier();\n    }\n\n    ${p}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${null!=o?`let cOffset = ${o.broadcastedIndicesToOffset("vec2(m, n)",d)}; value += ${d.type.value}(uniforms.beta) * ${o.getByOffset("cOffset")};`:""}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`}}},vl=e=>({transA:e.transA,transB:e.transB,alpha:e.alpha,beta:e.beta,cacheKey:`${e.transA};${e.transB};${1===e.alpha}`}),$l=(e,t)=>{Ag(e.inputs),e.compute(kg(e.inputs,t))}})),pt,$t,Nt,Vt,Eg,Pg,zg,Og,Bg,Dg,Mg,Rg,Sl,Tl,Cl=W((()=>{te(),ae(),Ce(),ce(),[pt,$t,Nt,Vt]=[0,1,2,3],Eg=e=>{if(4!==e[0].dims.length)throw new Error("only 4-D tensor is supported.");if(e[0].dims.length!==e[1].dims.length)throw new Error("input dimensions must be equal to grid dimensions");if(e[0].dims.length-2!==e[1].dims[e[1].dims.length-1])throw new Error("last dimension of grid must be equal to "+(e[0].dims.length-2));if(e[0].dims[0]!==e[1].dims[0])throw new Error("grid batch size must match input batch size")},Pg="\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n",zg=e=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e}>, x: f32, y: f32) -> ${e} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`,Og=e=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${0===e.alignCorners?"\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    ":"\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    "}\n  }\n`,Bg=e=>`\n  ${"reflection"===e.paddingMode?"\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }":""}\n`,Dg=(e,t,r)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${pt}] = batch;\n     indices[${$t}] = channel;`+(()=>{switch(r.paddingMode){case"zeros":return`\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${Nt}] = u32(r);\n            indices[${Vt}] = u32(c);\n          }\n        `;case"border":return`\n          indices[${Nt}] = u32(clamp(r, 0, H - 1));\n          indices[${Vt}] = u32(clamp(c, 0, W - 1));\n        `;case"reflection":return`\n          indices[${Nt}] = gs_reflect(r, border[1], border[3]);\n          indices[${Vt}] = gs_reflect(c, border[0], border[2]);\n        `;default:throw new Error(`padding mode ${r.paddingMode} is not supported`)}})()+`\n    return ${e.getByIndices("indices")};\n  }\n`,Mg=(e,t,r)=>(()=>{switch(r.mode){case"nearest":return`\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${pt}], indices[${$t}], border);\n        `;case"bilinear":return`\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${pt}], indices[${$t}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${pt}], indices[${$t}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;case"bicubic":return`\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${pt}], indices[${$t}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;default:throw new Error(`mode ${r.mode} is not supported`)}})()+`${e.setByOffset("global_idx","result")}`,Rg=(e,t)=>{let r=P("x",e[0].dataType,e[0].dims.length),n=[e[1].dims[0],e[1].dims[1],e[1].dims[2]],a=P("grid",e[1].dataType,n.length,2),o=[e[0].dims[0],e[0].dims[1],e[1].dims[1],e[1].dims[2]];"NHWC"===t.format&&(o=[e[0].dims[0],e[1].dims[1],e[1].dims[2],e[0].dims[3]],[pt,$t,Nt,Vt]=[0,3,1,2]);let i=N("output",e[0].dataType,o.length),s=r.type.value,l=[{type:12,data:E.size(o)},...G(e[0].dims,n,o)];return{name:"GridSample",shaderCache:{hint:`${t.cacheKey}`,inputDependencies:["type","type"]},getRunData:e=>{let t=E.size(o);return{outputs:[{dims:o,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(t/64)},programUniforms:l}},getShaderSource:e=>`\n  ${e.registerUniform("output_size","u32").declareVariables(r,a,i)}\n  ${Pg}\n  ${zg(s)}\n  ${Og(t)}\n  ${Bg(t)}\n  ${Dg(r,s,t)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let H_in = i32(uniforms.x_shape[${Nt}]);\n      let W_in = i32(uniforms.x_shape[${Vt}]);\n\n      ${0===t.alignCorners?"\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      ":"\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      "};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${i.offsetToIndices("global_idx")};\n      var grid_indices = vec3<u32>(indices[${pt}], indices[${Nt}], indices[${Vt}]);\n      let nxy = ${a.getByIndices("grid_indices")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${Mg(i,s,t)}\n  }`}},Sl=(e,t)=>{Eg(e.inputs),e.compute(Rg(e.inputs,t))},Tl=e=>re({alignCorners:e.align_corners,mode:e.mode,paddingMode:e.padding_mode,format:e.format})})),Me,Vg,Al,Il,Wg,or,kl,To=W((()=>{te(),ae(),Ce(),Vr(),qr(),ce(),ct(),Me=(e,t)=>e.length>t&&e[t].dims.length>0?e[t]:void 0,Vg=(e,t)=>{let r=e[0],n=Me(e,1),a=Me(e,2),o=Me(e,3),i=Me(e,4),s=Me(e,5),l=Me(e,6),d=Me(e,7);if(3!==r.dims.length&&5!==r.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let u,c=r.dims[0],p=r.dims[1],g=3===r.dims.length?r.dims[2]:t.numHeads*r.dims[4],A=p,h=0,B=0,m=Math.floor(g/t.numHeads);if(l&&d&&E.size(l.dims)&&E.size(d.dims)){if(4!==l.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(l.dims[0]!==c||l.dims[1]!==t.numHeads||l.dims[3]!==m)throw new Error('Input "past_key" shape (batch_size, num_heads, past_sequence_length, head_size)');if(d.dims[0]!==c||d.dims[1]!==t.numHeads||d.dims[3]!==m)throw new Error('Input "past_value" shape (batch_size, num_heads, past_sequence_length, head_size)');if(l.dims[2]!==d.dims[2])throw new Error('Input "past_key" and "past_value" shall have same dim 2 (past_sequence_length)');if(4!==d.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');h=l.dims[2],B=l.dims[2]}else if(l&&E.size(l.dims)||d&&E.size(d.dims))throw new Error('Input "past_key" and "past_value" shall be both present or both absent');if(n&&E.size(n.dims)>0){if(3!==r.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===n.dims.length){if(n.dims[2]!==r.dims[2])throw new Error('Input "query" and "key" shall have same dim 2 (hidden_size)');u=2,A=n.dims[1]}else if(5===n.dims.length){if(n.dims[2]!==t.numHeads||2!==n.dims[3]||n.dims[4]!==m)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(a)throw new Error('Expect "value" be none when "key" has packed kv format.');u=5,A=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==m)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');u=0,A=n.dims[2]}}else{if(5!==r.dims.length)throw new Error('Input "query" is expected to have 5 dimensions when key is empty');if(r.dims[2]!==t.numHeads||3!==r.dims[3])throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');u=3}if(o&&E.size(o.dims)>0){if(1!==o.dims.length)throw new Error('Input "bias" is expected to have 1 dimension');if(n&&5===n.dims.length&&2===n.dims[3])throw new Error("bias is not allowed for packed kv.")}let C=h+A,w=0;if(i&&E.size(i.dims)>0){w=8;let e=i.dims;throw 1===e.length?e[0]===c?w=1:e[0]===3*c+2&&(w=3):2===e.length&&e[0]===c&&e[1]===C&&(w=5),8===w?new Error('Input "key_padding_mask" shape shall be (batch_size) or (batch_size, total_sequence_length)'):new Error("Mask not supported")}let b=!1,K=g;if(a&&E.size(a.dims)>0){if(3!==a.dims.length&&4!==a.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(r.dims[0]!==a.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===a.dims.length){if(A!==a.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');K=a.dims[2]}else{if(A!==a.dims[2])throw new Error('Input "key" and "value" shall have the same dim 2 (kv_sequence_length)');K=a.dims[1]*a.dims[3],b=!0}}if(i&&E.size(i.dims)>0)throw new Error("Key padding mask is not supported");if(s&&E.size(s.dims)>0){if(4!==s.dims.length)throw new Error('Input "attention_bias" is expected to have 4 dimensions');if(s.dims[0]!==c||s.dims[1]!==t.numHeads||s.dims[2]!==p||s.dims[3]!==C)throw new Error('Expect "attention_bias" shape (batch_size, num_heads, sequence_length, total_sequence_length)')}return{batchSize:c,sequenceLength:p,pastSequenceLength:h,kvSequenceLength:A,totalSequenceLength:C,maxSequenceLength:B,inputHiddenSize:0,hiddenSize:g,vHiddenSize:K,headSize:m,vHeadSize:Math.floor(K/t.numHeads),numHeads:t.numHeads,isUnidirectional:!1,pastPresentShareBuffer:!1,maskFilterValue:t.maskFilterValue,maskType:w,scale:t.scale,broadcastResPosBias:!1,passPastInKv:b,qkvFormat:u}},Al=e=>re({...e}),Il=re({perm:[0,2,1,3]}),Wg=(e,t,r,n,a,o,i)=>{let s=[n,a,o],l=E.size(s),d=[{type:12,data:l},{type:12,data:i},{type:12,data:o}];return e.compute({name:"MultiHeadAttentionAddBias",shaderCache:{inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:s,dataType:t.dataType,gpuDataType:0}],dispatchGroup:{x:Math.ceil(l/64)},programUniforms:d}),getShaderSource:e=>{let n=N("qkv_with_bias",t.dataType,s),a=P("qkv",t.dataType,s),o=P("bias",r.dataType,s);return`\n  ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"bias_offset",type:"u32"},{name:"hidden_size",type:"u32"}]).declareVariables(a,o,n)}\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`}},{inputs:[t,r],outputs:[-1]})[0]},or=(e,t,r,n,a,o,i,s)=>{let l=o;if(i&&E.size(i.dims)>0){if(1===n)throw new Error("AddBiasReshape is not implemented. Please export your model with packed QKV or KV");return l=Wg(e,o,i,t,n,r*a,s),l=l.reshape([t,n,r,a]),1===r||1===n?l:e.compute(Oe(l,Il.perm),{inputs:[l],outputs:[-1]})[0]}return 3===o.dims.length&&(l=o.reshape([t,n,r,a])),1===r||1===n?l:e.compute(Oe(l,Il.perm),{inputs:[l],outputs:[-1]})[0]},kl=(e,t)=>{let r=Vg(e.inputs,t),n=e.inputs[0],a=Me(e.inputs,1),o=Me(e.inputs,2),i=Me(e.inputs,3),s=Me(e.inputs,4),l=Me(e.inputs,5),d=Me(e.inputs,6),u=Me(e.inputs,7);if(5===n.dims.length)throw new Error("Packed QKV is not implemented");if(5===a?.dims.length)throw new Error("Packed KV is not implemented");let c=a&&o&&4===a.dims.length&&4===o.dims.length,p=or(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,n,i,0);if(c)return Ut(e,p,a,o,s,void 0,d,u,l,r);if(!a||!o)throw new Error("key and value must be provided");let g=or(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.headSize,a,i,r.hiddenSize),A=or(e,r.batchSize,r.numHeads,r.kvSequenceLength,r.vHeadSize,o,i,2*r.hiddenSize);Ut(e,p,g,A,s,void 0,d,u,l,r)}})),Lg,Gg,Hg,Fg,Co,El,Pl,Io=W((()=>{te(),ae(),Ce(),ce(),Lg=e=>{if(!e||e.length<1)throw new Error("too few inputs")},Gg=(e,t)=>{let r=[],n=t.numOutputs;return e[1].dims[0]>0&&(e[1].getBigInt64Array().forEach((e=>r.push(Number(e)))),n=r.length),re({numOutputs:n,axis:t.axis,splitSizes:r})},Hg=e=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e}u; i += 1u ) {\n    if (index < ${j("uniforms.size_in_split_axis","i",e)}) {\n        return i;\n    }\n    }\n    return ${e}u;\n}`,Fg=e=>{let t=e.length,r=[];for(let n=0;n<t;++n){let a=e[n].setByIndices("indices","input[global_idx]");1===t?r.push(a):0===n?r.push(`if (output_number == ${n}u) { ${a} }`):n===t-1?r.push(`else { ${a} }`):r.push(`else if (output_number == ${n}) { ${a} }`)}return`\n      fn writeBufferData(output_number: u32, indices: ${e[0].type.indices}, global_idx: u32) {\n        ${r.join("\n")}\n      }`},Co=(e,t)=>{let r=e[0].dims,n=E.size(r),a=e[0].dataType,o=E.normalizeAxis(t.axis,r.length),i=new Array(t.numOutputs),s=P("input",a,r.length),l=new Array(t.numOutputs),d=[],u=[],c=0,p=[{type:12,data:n}];for(let n=0;n<t.numOutputs;n++){c+=t.splitSizes[n],l[n]=c;let s=r.slice();s[o]=t.splitSizes[n],u.push(s),i[n]=N(`output${n}`,a,s.length),d.push({dims:u[n],dataType:e[0].dataType})}p.push({type:12,data:l},...G(r,...u));return{name:"Split",shaderCache:{hint:t.cacheKey,inputDependencies:["rank"]},getShaderSource:e=>`\n  ${e.registerUniform("input_size","u32").registerUniform("size_in_split_axis","u32",l.length).declareVariables(s,...i)}\n  ${Hg(l.length)}\n  ${Fg(i)}\n\n  ${e.mainStart()}\n    ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.input_size")}\n\n    var indices = ${s.offsetToIndices("global_idx")};\n    var index = ${s.indicesGet("indices",o)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${j("uniforms.size_in_split_axis","output_number - 1u",l.length)};\n      ${s.indicesSet("indices",o,"index")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`,getRunData:()=>({outputs:d,dispatchGroup:{x:Math.ceil(n/64)},programUniforms:p})}},El=(e,t)=>{Lg(e.inputs);let r=1===e.inputs.length?t:Gg(e.inputs,t);e.compute(Co(e.inputs,r),{inputs:[0]})},Pl=e=>{let t=e.axis,r=e.splitSizes,n=e.numOutputs<0?r.length:e.numOutputs;if(n!==r.length)throw new Error("numOutputs and splitSizes lengh must be equal");return re({axis:t,numOutputs:n,splitSizes:r})}})),qg,Kg,zl,Ol,Bl=W((()=>{Ce(),qr(),To(),Io(),ct(),qg=(e,t)=>{if(t.doRotary)throw new Error("GroupQuerryAttention do_rotary attribute is not supported");if(t.doRotary&&e.length<=7)throw new Error("cos_cache and sin_cache inputs are required if do_rotary is specified");let r=e[0],n=e[1],a=e[2],o=e[3],i=e[4];if(-1!==t.localWindowSize)throw new Error("Local attention is not supported");if(0!==t.softcap)throw new Error("Softcap is not supported");if(0!==t.rotaryInterleaved)throw new Error("Rotary interleaved is not supported");if(t.smoothSoftmax)throw new Error("Smooth softmax is not supported");if(3!==r.dims.length&&5!==r.dims.length)throw new Error("Input query is expected to have 3 or 5 dimensions");let s=r.dims[0],l=r.dims[1],d=3===r.dims.length?r.dims[2]:t.numHeads*r.dims[4],u=l,c=0,p=!n||0===n.dims.length,g=Math.floor(p?d/(t.numHeads+2*t.kvNumHeads):d/t.numHeads);p&&(d=g*t.numHeads);let A=o&&0!==o.dims.length,h=i&&0!==i.dims.length;if(A&&4===o.dims.length&&o.dims[0]===s&&o.dims[1]!==t.kvNumHeads&&o.dims[2]===t.kvNumHeads&&o.dims[3]===g)throw new Error("BSNH pastKey/pastValue is not supported");if(A&&h){if(4!==o.dims.length)throw new Error('Input "past_key" is expected to have 4 dimensions');if(4!==i.dims.length)throw new Error('Input "past_value" is expected to have 4 dimensions');c=o.dims[2]}else if(A||h)throw new Error('Input "past_key" and "past_value" shall be both present or both absent');let B=1;if(n&&n.dims.length>0){if(3!==r.dims.length)throw new Error('Input "query" is expected to have 3 dimensions when key is given');if(n.dims.length<3||n.dims.length>5)throw new Error('Input "key" is expected to have 3, 4, or 5 dimensions');if(r.dims[0]!==n.dims[0])throw new Error('Input "query" and "key" shall have same dim 0 (batch size)');if(3===n.dims.length){if(r.dims[2]%n.dims[2]!=0)throw new Error('Dimension 2 of "query" should be a multiple of "key"');u=n.dims[1]}else if(5===n.dims.length){if(n.dims[2]!==t.numHeads||2!==n.dims[3]||n.dims[4]!==g)throw new Error('Expect "key" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');if(a)throw new Error('Expect "value" be none when "key" has packed kv format.');u=n.dims[1]}else{if(n.dims[1]!==t.numHeads||n.dims[3]!==g)throw new Error('Expect "key" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');u=n.dims[2]}}else{if(3!==r.dims.length&&5!==r.dims.length)throw new Error('Input "query" is expected to have 3 or 5 dimensions when key is empty');if(5===r.dims.length&&(r.dims[2]!==t.numHeads||3!==r.dims[3]))throw new Error('Expect "query" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');B=3}let m=!1,C=t.kvNumHeads?g*t.kvNumHeads:d;if(a&&a.dims.length>0){if(3!==a.dims.length&&4!==a.dims.length)throw new Error('Input "value" is expected to have 3 or 4 dimensions');if(r.dims[0]!==a.dims[0])throw new Error('Input "query" and "value" shall have same dim 0 (batch_size)');if(3===a.dims.length){if(u!==a.dims[1])throw new Error('Input "key" and "value" shall have the same dim 1 (kv_sequence_length)');C=a.dims[2]}else{if(u!==a.dims[2])throw new Error('Input "past_key" and "past_value" shall have the same dim 2 (kv_sequence_length)');C=a.dims[1]*a.dims[3],m=!0}}let w=e.length>4?e[5]:void 0;if(w&&1!==w.dims.length&&w.dims[0]!==s)throw new Error('Input "seqlens" is expected to have 1 dimension and the same dim 0 as batch_size');return{batchSize:s,sequenceLength:l,pastSequenceLength:c,kvSequenceLength:u,totalSequenceLength:-1,maxSequenceLength:-1,inputHiddenSize:0,hiddenSize:d,vHiddenSize:C,headSize:g,vHeadSize:Math.floor(C/t.kvNumHeads),numHeads:t.numHeads,kvNumHeads:t.kvNumHeads,nReps:t.numHeads/t.kvNumHeads,pastPresentShareBuffer:!1,maskType:0,scale:t.scale,broadcastResPosBias:!1,passPastInKv:m,qkvFormat:B}},Kg=re({perm:[0,2,1,3]}),zl=(e,t,r)=>{let n=t,a=r.kvNumHeads;return 3===t.dims.length&&0!==r.kvSequenceLength&&(n=t.reshape([r.batchSize,r.kvSequenceLength,a,r.headSize]),n=e.compute(Oe(n,Kg.perm),{inputs:[n],outputs:[-1]})[0]),n},Ol=(e,t)=>{let r=qg(e.inputs,t);if(5===e.inputs[0].dims.length)throw new Error("Packed QKV is not implemented");if(5===e.inputs[1]?.dims.length)throw new Error("Packed KV is not implemented");let n=e.inputs[0],a=e.inputs[1]&&e.inputs[1].dims.length>0?e.inputs[1]:void 0,o=e.inputs[2]&&e.inputs[2].dims.length>0?e.inputs[2]:void 0,i=e.inputs[3]&&0!==e.inputs[3].dims.length?e.inputs[3]:void 0,s=e.inputs[4]&&0!==e.inputs[4].dims.length?e.inputs[4]:void 0,l=e.inputs.length>4?e.inputs[5]:void 0,d=e.inputs.length>5?e.inputs[6]:void 0,u=r.kvNumHeads?r.kvNumHeads:r.numHeads,c=re({axis:2,numOutputs:3,splitSizes:[r.numHeads*r.headSize,u*r.headSize,u*r.headSize]}),[p,g,A]=a||o?[n,a,o]:e.compute(Co([n],c),{inputs:[n],outputs:[-1,-1,-1]}),h=or(e,r.batchSize,r.numHeads,r.sequenceLength,r.headSize,p,void 0,0);Ut(e,h,zl(e,g,r),zl(e,A,r),void 0,void 0,i,s,void 0,r,l,d)}})),Dl,jg,Zg,Ml,Rl=W((()=>{te(),ae(),ct(),ce(),Dl=(e,t,r,n,a,o,i,s)=>{let l=ge(o),d=1===l?"f32":`vec${l}f`,u=1===l?"vec2f":`mat2x${l}f`,c=a*i,p=64;1===c&&(p=256);let g=[a,i,o/l],A=[a,i,2],h=[];h.push(...G(g,A));return e.compute({name:"InstanceNormComputeChannelScaleShift",shaderCache:{hint:`${l};${s};${p}`,inputDependencies:["rank","type","type"]},getRunData:()=>({outputs:[{dims:A,dataType:1}],dispatchGroup:{x:c},programUniforms:h}),getShaderSource:e=>{let a=P("x",t.dataType,3,l),o=[a,P("scale",r.dataType,r.dims),P("bias",n.dataType,n.dims),N("output",1,3,2)];return`\n  var<workgroup> workgroup_shared : array<${u}, ${p}>;\n  const workgroup_size = ${p}u;\n  ${e.declareVariables(...o)}\n  ${e.mainStart(p)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${d}(0);\n    var squared_sum = ${d}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${d}(${a.get("batch","channel","h")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${u}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${Ke("workgroup_shared[0][0]",l)} / f32(hight * ${l});\n      let squared_sum_final = ${Ke("workgroup_shared[0][1]",l)} / f32(hight * ${l});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${s}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`}},{inputs:[t,r,n],outputs:[-1]})[0]},jg=(e,t,r)=>{let n=t[0].dims,a=n,o=n[0],i=n[1],s=E.sizeFromDimension(n,2),l=ge(s),d=E.size(a)/l,u=Dl(e,t[0],t[1],t[2],o,s,i,r.epsilon),c=[o,i,s/l],p=[o,i];e.compute({name:"InstanceNormalization",shaderCache:{hint:`${l}`,inputDependencies:["type","none"]},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:[{type:12,data:d},...G(c,p,c)]}),getShaderSource:e=>{let r=P("x",t[0].dataType,c.length,l),n=P("scale_shift",1,p.length,2),a=N("output",t[0].dataType,c.length,l),o=[r,n,a];return`\n  ${e.registerUniform("output_size","u32").declareVariables(...o)}\n  ${e.mainStart()}\n  ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let outputIndices = ${a.offsetToIndices("global_idx")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${n.getByIndices("vec2<u32>(batch, channel)")};\n      let value = ${r.getByOffset("global_idx")} * ${a.type.value}(scale_shift.x) + ${a.type.value}(scale_shift.y);\n      ${a.setByOffset("global_idx","value")};\n  }`}},{inputs:[t[0],u]})},Zg=(e,t,r)=>{let n=t[0].dims,a=n,o=n[0],i=n[n.length-1],s=E.sizeFromDimension(n,1)/i,l=ge(i),d=E.size(a)/l,u=[{type:12,data:s},{type:12,data:Math.floor(i/l)}],c=!1,p=[0,n.length-1];for(let e=0;e<n.length-2;e++)c=c||1!==n[e+1],p.push(e+1);c=c&&1!==n[n.length-1];let g=c?e.compute(Oe(e.inputs[0],p),{inputs:[e.inputs[0]],outputs:[-1]})[0]:e.inputs[0].reshape(Array.from({length:n.length},((e,t)=>n[p[t]]))),A=Dl(e,g,t[1],t[2],o,s,i,r.epsilon);e.compute({name:"InstanceNormalizationNHWC",shaderCache:{hint:`${l}`,inputDependencies:["type","type"]},getRunData:()=>({outputs:[{dims:a,dataType:t[0].dataType}],dispatchGroup:{x:Math.ceil(d/64)},programUniforms:u}),getShaderSource:e=>{let r=_e(t[0].dataType),n=1===l?"vec2f":`mat${l}x2f`,o=e=>{let t=0===e?"x":"y",n=1===l?"f32":`vec${l}f`;switch(l){case 1:return`${r}(${n}(scale.${t}))`;case 2:return`vec2<${r}>(${n}(scale[0].${t}, scale[1].${t}))`;case 4:return`vec4<${r}>(${n}(scale[0].${t}, scale[1].${t}, scale[2].${t}, scale[3].${t}))`;default:throw new Error(`Not supported compoents ${l}`)}},i=P("input",t[0].dataType,t[0].dims,l),s=N("output",t[0].dataType,a,l);return`\n  @group(0) @binding(0) var<storage, read> input : array<${i.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${n}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${s.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${e.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${o(0)}, ${o(1)});\n  }`}},{inputs:[t[0],A]})},Ml=(e,t)=>{"NHWC"===t.format?Zg(e,e.inputs,t):jg(e,e.inputs,t)}})),Qg,Yg,Ul,Nl=W((()=>{te(),ae(),ce(),Qg=e=>{if(!e||e.length<2)throw new Error("layerNorm requires at least 2 inputs.")},Yg=(e,t,r)=>{let n=t.simplified,a=e[0].dims,o=e[1],i=!n&&e[2],s=a,l=E.normalizeAxis(t.axis,a.length),d=E.sizeToDimension(a,l),u=E.sizeFromDimension(a,l),c=E.size(o.dims),p=i?E.size(i.dims):0;if(c!==u||i&&p!==u)throw new Error(`Size of X.shape()[axis:] == ${u}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${c} and bias size of ${p}`);let g=[];for(let e=0;e<a.length;++e)e<l?g.push(a[e]):g.push(1);let A=ge(u),h=["type","type"],B=[{type:12,data:d},{type:1,data:u},{type:12,data:Math.floor(u/A)},{type:1,data:t.epsilon}];i&&h.push("type");let m=r>1,C=r>2,w=[{dims:s,dataType:e[0].dataType}];return m&&w.push({dims:g,dataType:1}),C&&w.push({dims:g,dataType:1}),{name:"LayerNormalization",shaderCache:{hint:`${A};${r};${n}`,inputDependencies:h},getRunData:()=>({outputs:w,dispatchGroup:{x:Math.ceil(d/64)},programUniforms:B}),getShaderSource:t=>{let r=_e(e[0].dataType),a=[P("x",e[0].dataType,e[0].dims,A),P("scale",o.dataType,o.dims,A)];i&&a.push(P("bias",i.dataType,i.dims,A)),a.push(N("output",e[0].dataType,s,A)),m&&a.push(N("mean_data_output",1,g)),C&&a.push(N("inv_std_output",1,g));return`\n  ${t.registerUniforms([{name:"norm_count",type:"u32"},{name:"norm_size",type:"f32"},{name:"norm_size_vectorized",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...a)}\n  ${t.mainStart()}\n    ${t.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.norm_count")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${lo("f32",A)};\n    var mean_square_vector = ${lo("f32",A)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Pt(r,A,"x[h + offset]")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${Ke("mean_vector",A)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${Ke("mean_square_vector",A)} / uniforms.norm_size ${n?"":"- mean * mean"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Pt(r,A,"x[j + offset]")};\n      let f32scale = ${Pt(r,A,"scale[j]")};\n      output[j + offset] = ${a[0].type.value}((f32input ${n?"":"- mean"}) * inv_std_dev * f32scale\n        ${i?`+ ${Pt(r,A,"bias[j]")}`:""}\n      );\n    }\n\n    ${m?"mean_data_output[global_idx] = mean":""};\n    ${C?"inv_std_output[global_idx] = inv_std_dev":""};\n  }`}}},Ul=(e,t)=>{Qg(e.inputs),e.compute(Yg(e.inputs,t,e.outputCount))}})),Xg,Vl,Wl=W((()=>{ae(),Xr(),Jr(),Xg=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.")},Vl=e=>{Xg(e.inputs);let t=rt.calcShape(e.inputs[0].dims,e.inputs[1].dims,!0);if(!t)throw new Error("Can't use matmul on the given tensors");let r=t[t.length-1],n=e.inputs[0].dims[e.inputs[0].dims.length-1];if(r<8&&n<8)e.compute(Yr(e.inputs,{activation:""},t));else{let a=t[t.length-2],o=E.size(e.inputs[0].dims.slice(0,-2)),i=E.size(e.inputs[1].dims.slice(0,-2));if(1!==o&&1===a&&1===i){let a=[1,o,r],i=[e.inputs[0].reshape([1,o,n]),e.inputs[1].reshape([1,n,r])];e.compute(nr(i,{activation:""},t,a),{inputs:i})}else e.compute(nr(e.inputs,{activation:""},t))}}})),Jg,ey,ty,Ll,Gl,Hl=W((()=>{te(),ae(),Ce(),ce(),Jg=(e,t)=>{if(e.length<3||e.length>4)throw new Error("MatMulNBits requires 3 or 4 inputs");let r=e[0],n=r.dims.length;if(r.dims[n-1]!==t.k)throw new Error("The last dim of input shape does not match the k value");let a=Math.floor((t.k+t.blockSize-1)/t.blockSize),o=t.blockSize/8*t.bits,i=e[1];if(!E.areEqual(i.dims,[t.n,a,o]))throw new Error("The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize");let s=e[2].dims;if(E.size(s)!==t.n*a)throw new Error("scales input size error.");if(4===e.length){let r=e[3].dims,n=t.bits>4?t.n*a:t.n*Math.floor((a+1)/2);if(E.size(r)!==n)throw new Error("zeroPoints input size error.")}},ey=(e,t)=>{let r=e[0].dims,n=r.length,a=r[n-2],o=t.k,i=t.n,s=r.slice(0,n-2),l=E.size(s),d=e[1].dims[2]/4,u=e[0].dataType,c=ge(t.k),p=ge(d),g=ge(i),A=s.concat([a,i]),h=a>1&&i/g%2==0?2:1,B=E.size(A)/g/h,m=64,C=[],w=[l,a,o/c],b=E.convertShape(e[1].dims).slice();b.splice(-1,1,d/p),C.push(...G(w)),C.push(...G(b)),C.push(...G(e[2].dims)),4===e.length&&C.push(...G(E.convertShape(e[3].dims)));let K=[l,a,i/g];C.push(...G(K));return{name:"MatMulNBits",shaderCache:{hint:`${t.blockSize};${t.bits};${c};${p};${g};${h};64`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:A,dataType:u}],dispatchGroup:{x:B},programUniforms:C}),getShaderSource:r=>{let n=w.length,a=P("a",e[0].dataType,n,c),o=P("b",12,b.length,p),i=P("scales",e[2].dataType,e[2].dims.length),s=[a,o,i],l=4===e.length?P("zero_points",12,e[3].dims.length):void 0;l&&s.push(l);let u=K.length,A=N("output",e[0].dataType,u,g),B=_e(e[0].dataType),C=(()=>{switch(c){case 1:return`array<${B}, 8>`;case 2:return`mat4x2<${B}>`;case 4:return`mat2x4<${B}>`;default:throw new Error(`${c}-component is not supported.`)}})();return`\n        var<workgroup> workgroup_shared: array<${A.type.value}, ${h*m}>;\n        ${r.declareVariables(...s,A)}\n        ${r.mainStart([m,1,1])}\n          let output_indices = ${A.offsetToIndices(`(global_idx / 64) * ${h}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += 64) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize/c};\n            ${(()=>{let e=`\n            var col_index = col * ${g};\n            ${l?"\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;":`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${B}(8);`}\n            `;for(let t=0;t<g*h;t++)e+=`\n            let scale${t} = ${i.getByOffset("col_index * nBlocksPerCol + block")};\n            ${l?`\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${l.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\n            let zero_point${t} = ${B}((zero_point_word) & 0xFu);`:""}\n            col_index += 1;`;return e})()}\n            for (var word: u32 = 0; word < ${d}; word += ${p}) {\n              ${(()=>{let e=`col_index = col * ${g};`;for(let t=0;t<g*h;t++)e+=`\n            let b${t}_data = ${o.getByIndices(`${o.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;return e+=`\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${C};\n            var b_dequantized_values: ${C};`,e})()}\n              for (var i: u32 = 0; i < ${p}; i++) {\n                ${(()=>{let e=`\n          // reuse a data\n            var input_offset = ${a.indicesToOffset(`${a.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${C};\n            for (var j: u32 = 0; j < ${8/c}; j++) {\n              a_data[j] = ${a.getByOffset("input_offset")};\n              input_offset++;\n            }\n          `;for(let t=0;t<g*h;t++)e+=`\n            b_value = ${1===p?`b${t}_data`:`b${t}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${C}(${Array.from({length:4},((e,t)=>`${B}(b_value_lower[${t}]), ${B}(b_value_upper[${t}])`)).join(", ")});\n            b_dequantized_values = ${1===c?`${C}(${Array.from({length:8},((e,r)=>`(b_quantized_values[${r}] - ${l?`zero_point${t}`:"zero_point"}) * scale${t}`)).join(", ")});`:`(b_quantized_values - ${C}(${Array(8).fill(""+(l?`zero_point${t}`:"zero_point")).join(",")})) * scale${t};`};\n            workgroup_shared[local_id.x * ${h} + ${Math.floor(t/g)}]${g>1?`[${t%g}]`:""} += ${Array.from({length:8/c},((e,t)=>""+(1===c?`a_data[${t}] * b_dequantized_values[${t}]`:`dot(a_data[${t}], b_dequantized_values[${t}])`))).join(" + ")};\n          `;return e})()}\n                word_offset += ${8/c};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${h}) {\n            var output_value: ${A.type.value} = ${A.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < 64u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${h};\n            }\n            ${A.setByIndices(`${A.type.indices}(batch, row, col + local_id.x)`,"output_value")};\n          }\n        }`}}},ty=(e,t)=>{let r=e[0].dims,n=r.length,a=r[n-2],o=t.k,i=t.n,s=r.slice(0,n-2),l=E.size(s),d=e[1].dims[2]/4,u=e[0].dataType,c=ge(t.k),p=ge(d),g=s.concat([a,i]),A=i%8==0?8:i%4==0?4:1,h=128/A,B=h*p*8,m=B/c,C=B/t.blockSize,w=E.size(g)/A,b=[],K=[l,a,o/c],f=E.convertShape(e[1].dims).slice();f.splice(-1,1,d/p),b.push(...G(K)),b.push(...G(f)),b.push(...G(e[2].dims)),4===e.length&&b.push(...G(E.convertShape(e[3].dims)));let Q=[l,a,i];b.push(...G(Q));return{name:"BlockwiseMatMulNBits32",shaderCache:{hint:`${t.blockSize};${c};${p};${h};${A}`,inputDependencies:Array(e.length).fill("rank")},getRunData:()=>({outputs:[{dims:g,dataType:u}],dispatchGroup:{x:w},programUniforms:b}),getShaderSource:r=>{let n=K.length,a=P("a",e[0].dataType,n,c),o=P("b",12,f.length,p),i=P("scales",e[2].dataType,e[2].dims.length),s=[a,o,i],l=4===e.length?P("zero_points",12,e[3].dims.length):void 0;l&&s.push(l);let d=Q.length,u=N("output",e[0].dataType,d),g=_e(e[0].dataType);return`\n        var<workgroup> sub_a: array<${a.type.value}, ${m}>;\n        var<workgroup> inter_results: array<array<${u.type.value}, ${h}>, ${A}>;\n        ${r.declareVariables(...s,u)}\n        ${r.mainStart([h,A,1])}\n          let output_indices = ${u.offsetToIndices(`workgroup_index * ${A}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${C} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${m};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${m}; a_offset += 128)\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${a.getByIndices(`${a.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${a.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${C} + local_id.x;\n            ${l?`\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${l.getByOffset("zero_point_word_index")} >> zero_point_bits_offset;\n            let zero_point = ${g}((zero_point_word) & 0xFu);`:`\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${g}(8);`}\n            let scale = ${i.getByOffset("b_row * n_blocks_per_col + block")};\n            let b_data = ${o.getByIndices(`${o.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize/c};\n            for (var i: u32 = 0; i < ${p}; i++) {\n              ${(()=>{switch(c){case 1:return`\n          let a_data0 = vec4<${g}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${g}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;case 2:return`\n          let a_data0 = vec4<${g}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${g}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;case 4:return"\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];";default:throw new Error(`${c}-component is not supported.`)}})()}\n              let b_value = ${1===p?"b_data":"b_data[i]"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${g}>(${Array.from({length:4},((e,t)=>`${g}(b_value_lower[${t}]), ${g}(b_value_upper[${t}])`)).join(", ")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${g}>(${Array(8).fill("zero_point").join(",")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({length:2},((e,t)=>`dot(a_data${t}, b_dequantized_values[${t}])`)).join(" + ")};\n              word_offset += ${8/c};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${A}) {\n            var output_value: ${u.type.value} = ${u.type.value}(0);\n            for (var b = 0u; b < ${h}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${u.setByIndices(`${u.type.indices}(batch, row, col + local_idx)`,"output_value")}\n            }\n          }\n        }`}}},Ll=(e,t)=>{Jg(e.inputs,t),32===t.blockSize&&e.adapterInfo.isVendor("intel")&&e.adapterInfo.isArchitecture("gen-12lp")?e.compute(ty(e.inputs,t)):e.compute(ey(e.inputs,t))},Gl=e=>re(e)})),ry,ny,oy,iy,ay,sy,uy,dy,Fl,ql=W((()=>{te(),ae(),ce(),ry=e=>{if(!e||e.length<1)throw new Error("Too few inputs");if(1!==e[0].dataType&&10!==e[0].dataType)throw new Error("Input type must be float or float16.");if(e.length>=2){let t=2*e[0].dims.length===e[1].dims[0];if(4===e.length&&(t=2*e[3].dims[0]===e[1].dims[0]),!t)throw new Error("The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].")}},ny=(e,t,r)=>{let n="";for(let a=t-1;a>=0;--a)n+=`\n            k = i32(${e.indicesGet("indices",a)}) - ${j("uniforms.pads",a,r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${j("uniforms.x_shape",a,t)})) {\n              break;\n            }\n            offset += k * i32(${j("uniforms.x_strides",a,t)});\n        `;return`\n          value = ${e.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${n}\n            value = x[offset];\n          }\n      `},oy=(e,t,r)=>{let n="";for(let a=t-1;a>=0;--a)n+=`\n                k = i32(${e.indicesGet("indices",a)}) - ${j("uniforms.pads",a,r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${j("uniforms.x_shape",a,t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${j("uniforms.x_shape",a,t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${j("uniforms.x_strides",a,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},iy=(e,t,r)=>{let n="";for(let a=t-1;a>=0;--a)n+=`\n                k = i32(${e.indicesGet("indices",a)}) - ${j("uniforms.pads",a,r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${j("uniforms.x_shape",a,t)})) {\n                  k = i32(${j("uniforms.x_shape",a,t)}) - 1;\n                }\n                offset += k * i32(${j("uniforms.x_strides",a,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},ay=(e,t,r)=>{let n="";for(let a=t-1;a>=0;--a)n+=`\n                k = i32(${e.indicesGet("indices",a)}) - ${j("uniforms.pads",a,r)};\n                if (k < 0)  {\n                  k += i32(${j("uniforms.x_shape",a,t)}]);\n                }\n                if (k >= i32(${j("uniforms.x_shape",a,t)})) {\n                  k -= i32(${j("uniforms.x_shape",a,t)});\n                }\n                offset += k * i32(${j("uniforms.x_strides",a,t)});\n            `;return`\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `},sy=(e,t,r)=>{switch(r.mode){case 0:return ny(e,t,r.pads.length);case 1:return oy(e,t,r.pads.length);case 2:return iy(e,t,r.pads.length);case 3:return ay(e,t,r.pads.length);default:throw new Error("Invalid mode")}},uy=(e,t)=>{let r=E.padShape(e[0].dims.slice(),t.pads),n=e[0].dims,a=[{type:12,data:E.size(r)},{type:6,data:t.pads}],o=e.length>=3&&e[2].data;0===t.mode&&a.push({type:o?e[2].dataType:1,data:t.value}),a.push(...G(e[0].dims,r));return{name:"Pad",shaderCache:{hint:`${t.mode}${o}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:r,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(E.size(r)/64)},programUniforms:a}),getShaderSource:a=>{let i=N("output",e[0].dataType,r.length),s=P("x",e[0].dataType,n.length),l=s.type.value,d=sy(i,n.length,t),u=[{name:"output_size",type:"u32"},{name:"pads",type:"i32",length:t.pads.length}];return 0===t.mode&&u.push({name:"constant_value",type:o?l:"f32"}),`\n            ${a.registerUniforms(u).declareVariables(s,i)}\n            ${a.mainStart()}\n            ${a.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n\n            let indices = ${i.offsetToIndices("global_idx")};\n\n            var value = ${l}(0);\n            ${d}\n            output[global_idx] = value;\n        }`}}},dy=(e,t)=>{if(e.length>1){let r=e[1].getBigInt64Array(),n=e.length>=3&&e[2].data?10===e[2].dataType?e[2].getUint16Array()[0]:e[2].getFloat32Array()[0]:0,a=e[0].dims.length,o=new Int32Array(2*a).fill(0);if(e.length>=4){let t=e[3].getBigInt64Array();for(let e=0;e<t.length;e++)o[Number(t[e])]=Number(r[e]),o[Number(t[e])+a]=Number(r[e+t.length])}else r.forEach(((e,t)=>o[Number(t)]=Number(e)));let i=[];return o.forEach((e=>i.push(e))),{mode:t.mode,value:n,pads:i}}return t},Fl=(e,t)=>{ry(e.inputs);let r=dy(e.inputs,t);e.compute(uy(e.inputs,r),{inputs:[0]})}})),rn,Kl,jl,Zl,Ql,ly,cy,Yl,Xl,Jl,ec,tc,rc,nc,oc,ic,ac,sc,uc,dc=W((()=>{Ge(),te(),ae(),ce(),rn=e=>{if(we.webgpu.validateInputContent&&(!e||1!==e.length))throw new Error("Pool ops requires 1 input.")},Kl=(e,t,r)=>{let n="NHWC"===t.format,a=e.dims.slice();n&&a.splice(1,0,a.pop());let o=Object.hasOwnProperty.call(t,"dilations"),i=t.kernelShape.slice(),s=t.strides.slice(),l=o?t.dilations.slice():[],d=t.pads.slice();kt.adjustPoolAttributes(r,a,i,s,l,d);let u=kt.computePoolOutputShape(r,a,s,l,i,d,t.autoPad),c=Object.assign({},t);o?Object.assign(c,{kernelShape:i,strides:s,pads:d,dilations:l,cacheKey:t.cacheKey}):Object.assign(c,{kernelShape:i,strides:s,pads:d,cacheKey:t.cacheKey});let p=u.slice();return p.push(p.splice(1,1)[0]),[c,n?p:u]},jl=(e,t)=>{let r="NHWC"===t.format,n=[{type:12,data:E.size(e)},{type:12,data:E.size(t.kernelShape)}],a=[{name:"outputSize",type:"u32"},{name:"kernelSize",type:"u32"}];if(t.kernelShape.length<=2){let e=t.kernelShape[t.kernelShape.length-1],r=t.strides[t.strides.length-1],o=t.pads[t.pads.length/2-1],i=t.pads[t.pads.length-1],s=!!(o+i);n.push({type:12,data:e},{type:12,data:r},{type:12,data:o},{type:12,data:i}),a.push({name:"kw",type:"u32"},{name:"sw",type:"u32"},{name:"pwStart",type:"u32"},{name:"pwEnd",type:"u32"});let l=!1;if(2===t.kernelShape.length){let e=t.kernelShape[t.kernelShape.length-2],r=t.strides[t.strides.length-2],o=t.pads[t.pads.length/2-2],i=t.pads[t.pads.length-2];l=!!(o+i),n.push({type:12,data:e},{type:12,data:r},{type:12,data:o},{type:12,data:i}),a.push({name:"kh",type:"u32"},{name:"sh",type:"u32"},{name:"phStart",type:"u32"},{name:"phEnd",type:"u32"})}return[n,a,!0,s,l]}{if(r)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let e=E.computeStrides(t.kernelShape);return n.push({type:12,data:e},{type:12,data:t.pads},{type:12,data:t.strides}),a.push({name:"kernelStrides",type:"u32",length:e.length},{name:"pads",type:"u32",length:t.pads.length},{name:"strides",type:"u32",length:t.strides.length}),[n,a,!!t.pads.reduce(((e,t)=>e+t)),!1,!1]}},Zl=(e,t,r,n,a,o,i,s,l,d,u,c)=>{let p="NHWC"===a.format,g=t.type.value,A=N("output",t.type.tensor,n);if(a.kernelShape.length<=2){let n="",d="",h="",B=r-(p?2:1);if(n=u?`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${B}] = indices[${B}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${B}] < 0 || xIndices[${B}]\n                      >= uniforms.x_shape[${B}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${o}\n                }`:`\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${B}] = indices[${B}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset("xIndices")}];\n                  ${o}\n                }`,2===a.kernelShape.length){let e=r-(p?3:2);d=c?`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${e}] < 0 || xIndices[${e}] >= uniforms.x_shape[${e}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              `:`\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${e}] = indices[${e}] * uniforms.sh - uniforms.phStart + j;\n                `,h="\n              }\n            "}return`\n            ${e.registerUniforms(l).declareVariables(t,A)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n\n              let indices = ${A.offsetToIndices("global_idx")};\n              var xIndices = ${A.offsetToIndices("global_idx")};\n\n              var value = ${g}(${s});\n              var pad = 0;\n              ${d}\n              ${n}\n              ${h}\n              ${i}\n\n              output[global_idx] = value;\n            }`}{if(p)throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");let n=a.kernelShape.length,u=a.pads.length,c="";return c=d?`\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset("xIndices")}];\n                ${o}\n              }`:`\n              }\n              let x_val = x[${t.indicesToOffset("xIndices")}];\n              ${o}\n            `,`\n            ${e.registerUniforms(l).declareVariables(t,A)}\n\n            ${e.mainStart()}\n              ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n              let indices = ${A.offsetToIndices("global_idx")};\n              var xIndices = ${A.offsetToIndices("global_idx")};\n\n              var offsets: array<u32, ${n}>;\n\n              var value = ${g}(${s});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${n-1}u; j++) {\n                  offsets[j] = offset / ${j("uniforms.kernelStrides","j",n)};\n                  offset -= offsets[j] * ${j("uniforms.kernelStrides","j",n)};\n                }\n                offsets[${n-1}] = offset;\n\n                isPad = false;\n                for (var j = ${r-n}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${j("uniforms.strides",`j - ${r-n}u`,n)}\n                    + offsets[j - ${r-n}u] - ${j("uniforms.pads","j - 2u",u)};\n                  ${c}\n              }\n              ${i}\n\n              output[global_idx] = value;\n            }`}},Ql=e=>`${e.format};${e.ceilMode};${e.autoPad};${e.kernelShape.length}`,ly=e=>`${Ql(e)};${e.countIncludePad}`,cy=e=>`${Ql(e)};${e.storageOrder};${e.dilations}`,Yl=e=>({format:e.format,autoPad:["NOTSET","VALID","SAME_UPPER","SAME_LOWER"][e.auto_pad],ceilMode:e.ceil_mode,kernelShape:e.kernel_shape,strides:e.strides,pads:e.pads}),Xl=(e,t,r,n)=>{let[a,o]=Kl(t,n,r),i=P("x",t.dataType,t.dims.length),s=i.type.value,l="";a.countIncludePad?l+=`value /= ${s}(uniforms.kernelSize);`:l+=`value /= ${s}(i32(uniforms.kernelSize) - pad);`;let[d,u,c,p,g]=jl(o,a);d.push(...G(t.dims,o));return{name:e,shaderCache:{hint:`${n.cacheKey};${c};${p};${g}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(E.size(o)/64)},programUniforms:d}),getShaderSource:e=>Zl(e,i,t.dims.length,o.length,a,"value += x_val;",l,0,u,c,p,g)}},Jl=e=>{let t=0!==e.count_include_pad,r=Yl(e);if(0!==r.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");let n={countIncludePad:t,...r,cacheKey:""};return{...n,cacheKey:ly(n)}},ec=(e,t)=>{rn(e.inputs),e.compute(Xl("AveragePool",e.inputs[0],!1,t))},tc={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[]},rc=e=>{let t=e.format;return{format:t,...tc,cacheKey:t}},nc=(e,t)=>{rn(e.inputs),e.compute(Xl("GlobalAveragePool",e.inputs[0],!0,t))},oc=(e,t,r,n)=>{let[a,o]=Kl(t,n,r),i=P("x",t.dataType,t.dims.length),[s,l,d,u,c]=jl(o,a);return s.push(...G(t.dims,o)),{name:e,shaderCache:{hint:`${n.cacheKey};${d};${u};${c}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:o,dataType:t.dataType}],dispatchGroup:{x:Math.ceil(E.size(o)/64)},programUniforms:s}),getShaderSource:e=>Zl(e,i,t.dims.length,o.length,a,"\n      value = max(x_val, value);\n    ","",10===t.dataType?-65504:-1e5,l,d,u,c)}},ic=(e,t)=>{rn(e.inputs),e.compute(oc("MaxPool",e.inputs[0],!1,t))},ac=e=>{let t=e.storage_order,r=e.dilations,n=Yl(e);if(0!==t)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==n.ceilMode)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");let a={storageOrder:t,dilations:r,...n,cacheKey:""};return{...a,cacheKey:cy(a)}},sc=e=>{let t=e.format;return{format:t,...tc,cacheKey:t}},uc=(e,t)=>{rn(e.inputs),e.compute(oc("GlobalMaxPool",e.inputs[0],!0,t))}})),my,fy,lc,cc,pc=W((()=>{te(),ae(),Ce(),ce(),my=(e,t)=>{if(e.length<2||e.length>3)throw new Error("DequantizeLinear requires 2 or 3 inputs.");if(3===e.length&&e[1].dims===e[2].dims)throw new Error("x-scale and x-zero-point must have the same shape.");if(3===e.length&&e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(6===e[0].dataType&&e.length>2)throw new Error("In the case of dequantizing int32 there is no zero point.");if(0!==e[1].dims.length&&1!==e[1].dims.length&&e[1].dims.length!==e[0].dims.length)throw new Error("scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.");if(e.length>2){if(e[0].dataType!==e[2].dataType)throw new Error("x and x-zero-point must have the same data type.");if(e[1].dims.length!==e[2].dims.length)throw new Error("scale and zero-point inputs must have the same rank.");if(!e[1].dims.map(((t,r)=>t===e[2].dims[r])).reduce(((e,t)=>e&&t),!0))throw new Error("scale and zero-point inputs must have the same shape.")}if(t.blockSize>0){if(0===e[1].dims.length||1===e[1].dims.length&&1===e[1].dims[0])throw new Error("blockSize must be set only for block quantization.");if(!e[1].dims.map(((r,n)=>n===t.axis||r===e[0].dims[n])).reduce(((e,t)=>e&&t),!0))throw new Error("For block qunatization, scale input shape to match the input shape except for the axis");if(e[1].dims.length!==e[0].dims.length)throw new Error("For block qunatization the scale input rank must be the same as the x rank.");let r=e[0].dims[t.axis],n=e[1].dims[t.axis];if(t.blockSize<Math.ceil(r/n)||t.blockSize>Math.ceil(r/(n-1)-1))throw new Error("blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].")}},fy=(e,t)=>{let r=E.normalizeAxis(t.axis,e[0].dims.length),n=e[0].dataType,a=3===n,o=e[0].dims,i=e[1].dataType,s=E.size(o),l=3===n||2===n,d=l?[Math.ceil(E.size(e[0].dims)/4)]:e[0].dims,u=e[1].dims,c=e.length>2?e[2]:void 0,p=c?l?[Math.ceil(E.size(c.dims)/4)]:c.dims:void 0,g=0===u.length||1===u.length&&1===u[0],A=!1===g&&1===u.length,h=ge(s),B=g&&(!l||4===h),m=B?h:1,C=B&&!l?h:1,w=P("input",l?12:n,d.length,C),b=P("scale",i,u.length),K=c?P("zero_point",l?12:n,p.length):void 0,f=N("output",i,o.length,m),Q=[w,b];K&&Q.push(K);let W=[d,u];c&&W.push(p);let F=[{type:12,data:s/m},{type:12,data:r},{type:12,data:t.blockSize},...G(...W,o)];return{name:"DequantizeLinear",shaderCache:{hint:t.cacheKey,inputDependencies:K?["rank","rank","rank"]:["rank","rank"]},getShaderSource:e=>`\n      ${e.registerUniforms([{name:"output_size",type:"u32"},{name:"axis",type:"u32"},{name:"block_size",type:"u32"}]).declareVariables(...Q,f)}\n      ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n          let output_indices = ${f.offsetToIndices("global_idx")};\n\n          // Set input x\n          ${l?`\n            let input = ${w.getByOffset("global_idx / 4")};\n            let x_vec = ${a?"unpack4xI8(input)":"unpack4xU8(input)"};\n            let x_value = ${1===m?"x_vec[global_idx % 4]":"x_vec"};`:`let x_value = ${w.getByOffset("global_idx")};`};\n\n          // Set scale input\n          ${g?`let scale_value= ${b.getByOffset("0")}`:A?`\n            let scale_index = ${f.indicesGet("output_indices","uniforms.axis")};\n            let scale_value= ${b.getByOffset("scale_index")};`:`\n            var scale_indices: ${b.type.indices} = output_indices;\n            let index = ${b.indicesGet("scale_indices","uniforms.axis")} / uniforms.block_size;\n            ${b.indicesSet("scale_indices","uniforms.axis","index")};\n            let scale_value= ${b.getByIndices("scale_indices")};`};\n\n          // Set zero-point input\n          ${K?g?l?`\n                let zero_point_input = ${K.getByOffset("0")};\n                let zero_point_vec =  ${a?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value= zero_point_vec[0]`:`let zero_point_value = ${K.getByOffset("0")}`:A?l?`\n                let zero_point_index = ${f.indicesGet("output_indices","uniforms.axis")};\n                let zero_point_input = ${K.getByOffset("zero_point_index / 4")};\n                let zero_point_vec =  ${a?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]`:`\n                let zero_point_index = ${f.indicesGet("output_indices","uniforms.axis")};\n                let zero_point_value = ${K.getByOffset("zero_point_index")};`:l?`\n                let zero_point_offset = ${b.indicesToOffset("scale_indices")};\n                let zero_point_input = ${K.getByOffset("zero_point_offset / 4")};\n                let zero_point_vec = ${a?"unpack4xI8(zero_point_input)":"unpack4xU8(zero_point_input)"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];`:`let zero_point_value = ${K.getByIndices("scale_indices")};`:`let zero_point_value = ${l?a?"i32":"u32":w.type.value}(0);`};\n      // Compute and write output\n      ${f.setByOffset("global_idx",`${f.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`,getRunData:()=>({outputs:[{dims:o,dataType:i}],dispatchGroup:{x:Math.ceil(s/m/64),y:1,z:1},programUniforms:F})}},lc=(e,t)=>{my(e.inputs,t),e.compute(fy(e.inputs,t))},cc=e=>re({axis:e.axis,blockSize:e.blockSize})})),hy,gy,mc,fc=W((()=>{Ge(),te(),ce(),hy=(e,t,r)=>{if(e===t||e<t&&r<0||e>t&&r>0)throw new Error("Range these inputs' contents are invalid.")},gy=(e,t,r,n)=>{let a=Math.abs(Math.ceil((t-e)/r)),o=[a],i=a,s=[{type:12,data:i},{type:n,data:e},{type:n,data:r},...G(o)];return{name:"Range",shaderCache:{hint:`${n}`},getShaderSource:e=>{let t=N("output",n,o.length),r=t.type.value,a=[{name:"outputSize",type:"u32"},{name:"start",type:r},{name:"delta",type:r}];return`\n        ${e.registerUniforms(a).declareVariables(t)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n        output[global_idx] = uniforms.start + ${r}(global_idx) * uniforms.delta;\n      }`},getRunData:()=>({outputs:[{dims:o,dataType:n}],dispatchGroup:{x:Math.ceil(i/64)},programUniforms:s})}},mc=e=>{let t=0,r=0,n=0;6===e.inputs[0].dataType?(t=e.inputs[0].getInt32Array()[0],r=e.inputs[1].getInt32Array()[0],n=e.inputs[2].getInt32Array()[0]):1===e.inputs[0].dataType&&(t=e.inputs[0].getFloat32Array()[0],r=e.inputs[1].getFloat32Array()[0],n=e.inputs[2].getFloat32Array()[0]),we.webgpu.validateInputContent&&hy(t,r,n),e.compute(gy(t,r,n,e.inputs[0].dataType),{inputs:[]})}})),yy,by,hc,gc,yc=W((()=>{te(),ae(),Ce(),ce(),yy=(e,t,r,n)=>{if("none"!==e&&"i32"!==n&&"u32"!==n&&"f32"!==n)throw new Error(`Input ${n} is not supported with reduction ${e}.`);let a="{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =",o=`;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;switch(e){case"none":return`${t}=${r};`;case"add":return"i32"===n||"u32"===n?`atomicAdd(&${t}, bitcast<${n}>(${r}));`:`\n              ${a}bitcast<${n}>(oldValue) + (${r})${o}`;case"max":return"i32"===n||"u32"===n?`atomicMax(&${t}, bitcast<${n}>(${r}));`:`\n                ${a}max(bitcast<f32>(oldValue), (${r}))${o}`;case"min":return"i32"===n||"u32"===n?`atomicMin(&${t}, bitcast<${n}>(${r}));`:`${a}min(bitcast<${n}>(oldValue), (${r}))${o}`;case"mul":return`${a}(bitcast<${n}>(oldValue) * (${r}))${o}`;default:throw new Error(`Reduction ${e} is not supported.`)}},by=(e,t)=>{let r=e[0].dims,n=e[1].dims,a=r,o=Math.ceil(E.size(n)/1),i=n[n.length-1],s=E.sizeFromDimension(r,i),l=[{type:12,data:o},{type:12,data:i},{type:12,data:s},...G(e[1].dims,e[2].dims,a)];return{name:"ScatterND",shaderCache:{hint:`${t.cacheKey}_${t.reduction}`,inputDependencies:["rank","rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:l}),getShaderSource:r=>{let o=P("indices",e[1].dataType,e[1].dims.length),i=P("updates",e[2].dataType,e[2].dims.length,1),s="none"!==t.reduction&&""!==t.reduction?Hs("output",e[0].dataType,a.length):N("output",e[0].dataType,a.length,1);return`\n      ${r.registerUniform("output_size","u32").registerUniform("last_index_dimension","u32").registerUniform("num_updates_elements","u32").declareVariables(o,i,s)}\n      ${r.mainStart()}\n        ${r.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n  var hasDuplicates = false;\n  if (${"none"===t.reduction}) {\n    let n = ${E.size(n)};\n    for (var i = 0; i < n; i = i + 1) {\n      for (var j = i + 1; j < n; j = j + 1) {\n        var index_i = i32(indices[i].x);\n        var index_j = i32(indices[j].x);\n        if (index_i == index_j) {\n          hasDuplicates = true;\n          break;\n        }\n      }\n      if (hasDuplicates) {\n        break;\n      }\n    }\n  }\n\n  var data_offset = 0u;\n  var indices_start = uniforms.last_index_dimension * global_idx;\n  if (${"none"===t.reduction} && hasDuplicates) {\n    if (global_idx != 0u) {\n      return;\n    }\n    indices_start = 0u;\n  }\n  let indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${1===e[0].dims.length?"\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;":"\n    let element_count_dim = uniforms.output_strides[i - indices_start];\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];"}\n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));\n  }\n\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\n    ${yy(t.reduction,"output[data_offset + i]","value",s.type.value)}\n  }\n\n      }`}}},hc=e=>re({reduction:e.reduction}),gc=(e,t)=>{e.compute(by(e.inputs,t),{inputs:[e.inputs[1],e.inputs[2]],outputs:[]})}})),_y,wy,vy,bc,$y,xy,Sy,Ty,Cy,Iy,Ay,ky,_c,Ey,Py,zy,Oy,By,wc,vc,$c=W((()=>{te(),ae(),Ce(),ce(),_y=(e,t)=>{if(e.every((e=>e>0||(()=>{throw new Error("Resize requires scales input values to be positive")}))),e.length>0)if("linear"===t.mode){if(!(2===e.length||3===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]||5===e.length&&1===e[0]&&1===e[1]))throw new Error("For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1")}else if("cubic"===t.mode&&!(2===e.length||4===e.length&&1===e[0]&&1===e[1]||4===e.length&&1===e[0]&&1===e[3]))throw new Error("Resize requires scales input size to be 2 or 4 for cubic mode")},wy=(e,t,r)=>{t.every((e=>e>=0&&e<r||(()=>{throw new Error("Resize requires axes input values to be positive and less than rank")})));let n=new Array(r).fill(1);return t.forEach(((t,r)=>n[t]=e[r])),n},vy=(e,t,r,n,a,o)=>{let[i,s,l]=r>10?[1,2,3]:[-1,e.length>1?1:-1,-1],d=e[0].dims.length;if(i>0&&e.length>i&&e[i].dims.length>0)e[i].getFloat32Array().forEach((e=>o.push(e)));else if("tf_crop_and_resize"===t.coordinateTransformMode)throw new Error("Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize");if(s>0&&e.length>s&&1===e[s].dims.length&&e[s].dims[0]>0){if(e[s].getFloat32Array().forEach((e=>n.push(e))),0!==n.length&&n.length!==d&&r>=18&&n.length!==t.axes.length)throw new Error("Resize requires scales input size to be same as input rank or axes size for opset 18 and up");_y(n,t),t.axes.length>0&&wy(n,t.axes,d).forEach(((e,t)=>n[t]=e))}if(l>0&&e.length>l&&1===e[l].dims.length&&e[l].dims[0]>0&&(e[l].getBigInt64Array().forEach((e=>a.push(Number(e)))),0!==a.length&&a.length!==d&&r>=18&&a.length!==t.axes.length))throw new Error("Resize requires sizes input size to be same as input rank or axes size for opset 18 and up");if(t.axes.length>0){if(0!==n.length&&n.length!==t.axes.length)throw new Error('Resize requires "scales" input size to be of axes rank when axes attributes is specified');if(0!==a.length&&a.length!==t.axes.length)throw new Error('Resize requires "sizes" input size to be of rank axes rank when axes attributes is specified')}if(typeof n<"u"&&typeof a<"u"&&n.length>0&&a.length>d)throw new Error("Resize requires only of scales or sizes to be specified")},bc=(e,t,r,n)=>`\n  // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n  // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n  // offset-by-one error later in floor().\n  let big = (${e}) * (${t});\n  let whole = ${n}(big / (${r}));\n  let fract = ${n}(big % (${r})) / ${n}(${r});\n  return whole + fract;\n`,$y=(e,t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { `+(()=>{switch(e){case"asymmetric":return`\n          if (xScale < 1.0 || floor(xScale) != xScale) {\n            return ${t}(xResized) / ${t}(xScale);\n          } else {\n            ${bc("xResized","lengthOriginal","lengthResized",t)}\n          }\n        `;case"pytorch_half_pixel":return`if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;case"tf_half_pixel_for_nn":return`return (${t}(xResized) + 0.5) / ${t}(xScale);`;case"align_corners":return`if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    ${bc("xResized","lengthOriginal - 1","lengthResized - 1",t)}\n                  }`;case"tf_crop_and_resize":return`if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;case"half_pixel_symmetric":return`const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;case"half_pixel":return`return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;default:throw new Error(`Coordinate transform mode ${e} is not supported`)}})()+"}",xy=(e,t,r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {`+(()=>{switch(e){case"round_prefer_ceil":return"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }";case"floor":return"return floor(xOriginal);";case"ceil":return"return ceil(xOriginal);";case"round_prefer_floor":return"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }";default:if(t<11)return"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }";throw new Error(`Nearest mode ${e} is not supported`)}})()+"}",Sy=(e,t,r)=>{let n=new Array(r).fill(0).concat(new Array(r).fill(1)),a=0===e.length?n:e.slice();return t.length>0?(t.forEach(((e,o)=>{n[e]=a[o],n[o+r]=a[t.length+o]})),n):a},Ty=(e,t,r,n)=>{let a=[];if(r.length>0)if(n.length>0){if(e.forEach((e=>a.push(e))),Math.max(...n)>e.length)throw new Error("axes is out of bound");n.forEach(((e,t)=>a[e]=r[t]))}else r.forEach((e=>a.push(e)));else{if(0===t.length)throw new Error("Resize requires either scales or sizes.");a=e.map(((e,r)=>Math.round(e*t[r])))}return a},Cy=(e,t,r)=>{let n=(()=>{switch(r.keepAspectRatioPolicy){case"not_larger":return r.axes.length>0?Math.min(...r.axes.map((e=>t[e])),Number.MAX_VALUE):Math.min(...t,Number.MAX_VALUE);case"not_smaller":return r.axes.length>0?Math.max(...r.axes.map((e=>t[e])),Number.MIN_VALUE):Math.max(...t,Number.MIN_VALUE);default:throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`)}})();t.fill(1,0,t.length);let a=e.slice();return r.axes.length>0?(r.axes.forEach((e=>t[e]=n)),r.axes.forEach((r=>a[r]=Math.round(e[r]*t[r])))):(t.fill(n,0,t.length),a.forEach(((e,r)=>a[r]=Math.round(e*t[r])))),a},Iy=(e,t,r,n,a)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e.type.indices}) -> array<${e.type.value}, ${r.length}> {\n      var original_indices: array<${e.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e.indicesGet("output_indices","i")};\n        var scale = ${j("uniforms.scales","i",n)};\n        var roi_low = ${j("uniforms.roi","i",a)};\n        var roi_hi = ${j("uniforms.roi",`i + ${t.length}`,a)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e.type.value}(output_index);\n        } else {\n          var input_shape_i = ${j("uniforms.input_shape","i",t.length)};\n          var output_shape_i = ${j("uniforms.output_shape","i",r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`,Ay=(e,t,r,n,a,o,i)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n      var input_indices: ${e.type.indices};\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${t.indicesGet("output_indices","i")};\n        var input_index: u32;\n        var scale = ${j("uniforms.scales","i",a)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${j("uniforms.roi","i",o)};\n          var roi_hi = ${j("uniforms.roi",`i + ${r.length}`,o)};\n          var input_shape_i = ${j("uniforms.input_shape","i",r.length)};\n          var output_shape_i = ${j("uniforms.output_shape","i",n.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${i} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e.indicesSet("input_indices","i","input_index")}\n      }\n      return input_indices;\n    }`,ky=(e,t)=>`\n    fn checkInputIndices(input_indices: ${e.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e.indicesGet("input_indices","i")};\n        if (input_index < 0 || input_index >= ${j("uniforms.input_shape","i",t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`,_c=(e,t,r,n)=>e.rank>n?`\n    ${e.indicesSet("input_indices",t,"channel")};\n    ${e.indicesSet("input_indices",r,"batch")};\n`:"",Ey=(e,t,r,n,a)=>{let[o,i,s,l]=2===r.length?[-1,0,1,-1]:[0,2,3,1],d=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${d} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",i,`max(0, min(row, ${r[i]} - 1))`)};\n      ${e.indicesSet("input_indices",s,`max(0, min(col, ${r[s]} - 1))`)};\n      ${_c(e,l,o,2)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${d} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${d} = originalIndices[${i}];\n      var col:${d} = originalIndices[${s}];\n      ${n?`if (row < 0 || row > (${r[i]} - 1) || col < 0 || col > (${r[s]} - 1)) {\n        return ${a};\n      }`:""};\n      row = max(0, min(row, ${r[i]} - 1));\n      col = max(0, min(col, ${r[s]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length>2?`u32(originalIndices[${l}])`:"0"};\n      var batch: u32 =  ${r.length>2?`u32(originalIndices[${o}])`:"0"};\n      var x11: ${d} = getInputValue(batch, channel, row1, col1);\n      var x12: ${d} = getInputValue(batch, channel, row1, col2);\n      var x21: ${d} = getInputValue(batch, channel, row2, col1);\n      var x22: ${d} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${d} = abs(row - ${d}(row1));\n      var dx2: ${d} = abs(${d}(row2) - row);\n      var dy1: ${d} = abs(col - ${d}(col1));\n      var dy2: ${d} = abs(${d}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`},Py=(e,t,r,n,a,o,i,s,l,d)=>{let u=2===r.length,[c,p]=u?[0,1]:[2,3],g=e.type.value,A=i=>{let u=i===c?"row":"col";return`\n      fn ${u}CubicInterpolation(input_indices: ${e.type.indices}, output_indices: ${t.type.indices}) -> ${g} {\n        var output_index = ${t.indicesGet("output_indices",i)};\n        var originalIdx: ${g} = getOriginalCoordinateFromResizedCoordinate(output_index, ${a[i]},\n        ${n[i]}, ${r[i]}, ${o[i]}, ${o[i]} + ${r.length});\n        var fractOriginalIdx: ${g} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${s} && (originalIdx < 0 || originalIdx > (${r[i]} - 1))) {\n          return ${l};\n        }\n        var data: array<${g}, 4> = array<${g}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${u}: ${g} = originalIdx + ${g}(i);\n          if (${u} < 0 || ${u} >= ${r[i]}) {\n            ${d?"coefs[i + 1] = 0.0;\n                        continue;":s?`return ${l};`:`${u} = max(0, min(${u}, ${r[i]} - 1));`};\n          }\n        var input_indices_copy: ${e.type.indices} = input_indices;\n          ${e.indicesSet("input_indices_copy",i,`u32(${u})`)};\n          data[i + 1] = ${i===c?e.getByIndices("input_indices_copy"):"rowCubicInterpolation(input_indices_copy, output_indices)"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`};return`\n    ${A(c)};\n    ${A(p)};\n  fn getCubicInterpolationCoefs(s: ${g}) -> array<${g}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${g}, 4> = array<${g}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${g} = 1.0 - absS;\n    var twoMinusAbsS: ${g} = 2.0 - absS;\n    var onePlusAbsS: ${g} = 1.0 + absS;\n    coeffs[0] = ((${i} * onePlusAbsS - 5 * ${i}) * onePlusAbsS + 8 * ${i}) * onePlusAbsS - 4 * ${i};\n    coeffs[1] = ((${i} + 2) * absS - (${i} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${i} + 2) * oneMinusAbsS - (${i} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${i} * twoMinusAbsS - 5 * ${i}) * twoMinusAbsS + 8 * ${i}) * twoMinusAbsS - 4 * ${i};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${g}, 4>, coefs: array<${g}, 4>) -> ${g} {\n    var coefsSum: ${g} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${g} {\n    var input_indices: ${e.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `},zy=(e,t,r,n,a)=>{let[o,i,s,l,d]=3===r.length?[-1,0,1,2,-1]:[0,2,3,4,1],u=e.type.value;return`\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${u} {\n      var input_indices: ${e.type.indices};\n      ${e.indicesSet("input_indices",i,`max(0, min(depth, ${r[i]} - 1))`)};\n      ${e.indicesSet("input_indices",s,`max(0, min(height, ${r[s]} - 1))`)};\n      ${e.indicesSet("input_indices",l,`max(0, min(width, ${r[l]} - 1))`)};\n      ${_c(e,d,o,3)}\n      return ${e.getByIndices("input_indices")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${u} = originalIndices[${i}];\n      var height:${u} = originalIndices[${s}];\n      var width:${u} = originalIndices[${l}];\n      ${n?`if (depth < 0 || depth > (${r[i]} - 1) || height < 0 || height > (${r[s]} - 1) || width < 0 || (width > ${r[l]} - 1)) {\n      return ${a};\n        }`:""};\n\n    depth = max(0, min(depth, ${r[i]} - 1));\n      height = max(0, min(height, ${r[s]} - 1));\n      width = max(0, min(width, ${r[l]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length>3?`u32(originalIndices[${d}])`:"0"};\n      var batch: u32 =  ${r.length>3?`u32(originalIndices[${o}])`:"0"};\n\n      var x111: ${u} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${u} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${u} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${u} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${u} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${u} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${u} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${u} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${u} = abs(depth - ${u}(depth1));\n      var dx2: ${u} = abs(${u}(depth2) - depth);\n      var dy1: ${u} = abs(height - ${u}(height1));\n      var dy2: ${u} = abs(${u}(height2) - height);\n      var dz1: ${u} = abs(width - ${u}(width1));\n      var dz2: ${u} = abs(${u}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`},Oy=(e,t,r,n,a,o)=>{let i=e.dims,s=Sy(o,t.axes,i.length),l=Ty(i,n,a,t.axes),d=n.slice();0===n.length&&(d=i.map(((e,t)=>0===e?1:l[t]/e)),"stretch"!==t.keepAspectRatioPolicy&&(l=Cy(i,d,t)));let u=N("output",e.dataType,l.length),c=P("input",e.dataType,i.length),p=E.size(l),g=i.length===l.length&&i.every(((e,t)=>e===l[t])),A="tf_crop_and_resize"===t.coordinateTransformMode,h=t.extrapolationValue,B=c.type.value;return{name:"Resize",shaderCache:{hint:`${t.cacheKey}|${r}|${d.length>0?"cubic"===t.mode?d:d.length:""}|${a.length>0?a:""}|${s.length>0?s:""}|${g}|${"nearest"===t.mode?i.length:i}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${g?"":`\n      ${$y(t.coordinateTransformMode,B)};\n      ${(()=>{switch(t.mode){case"nearest":return`\n              ${ky(c,i)};\n              ${xy(t.nearestMode,r,B)};\n              ${Ay(c,u,i,l,d.length,s.length,A)};\n              `;case"linear":return`\n              ${Iy(u,i,l,d.length,s.length)};\n              ${(()=>{if(2===i.length||4===i.length)return`${Ey(c,u,i,A,h)}`;if(3===i.length||5===i.length)return`${zy(c,u,i,A,h)}`;throw Error("Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.")})()};\n            `;case"cubic":return`\n            ${(()=>{if(2===i.length||4===i.length)return`${Py(c,u,i,l,d,s,t.cubicCoeffA,A,t.extrapolationValue,t.excludeOutside)}`;throw Error("Cubic mode only supports input dims 2 and 4 are supported in linear mode.")})()};\n            `;default:throw Error("Invalid resize mode")}})()};\n      `}\n      ${e.registerUniform("output_size","u32").registerUniform("scales","f32",d.length).registerUniform("roi","f32",s.length).declareVariables(c,u)}\n      ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n        ${g?"output[global_idx] = input[global_idx];":`\n        let output_indices = ${u.offsetToIndices("global_idx")};\n        var input_indices: ${c.type.indices};\n        ${(()=>{switch(t.mode){case"nearest":return`input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${c.getByIndices("input_indices")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;case"linear":return`output[global_idx] = ${2===i.length||4===i.length?"bilinearInterpolation":"trilinearInterpolation"}(output_indices);`;case"cubic":return"output[global_idx] = bicubicInterpolation(output_indices);";default:throw Error(`Unsupported resize mode: ${t.mode}`)}})()};\n`}\n      }`,getRunData:()=>({outputs:[{dims:l,dataType:e.dataType}],dispatchGroup:{x:Math.ceil(p/64)},programUniforms:[{type:12,data:p},{type:1,data:d},{type:1,data:s},...G(i,l)]})}},By=e=>{let t=e.customDataBuffer;return new Uint32Array(t,t.byteOffset,1)[0]},wc=(e,t)=>{let r=[],n=[],a=[],o=By(e);if(0!==t.antialias)throw Error("Only default value (0) for Antialias attribute is supported");vy(e.inputs,t,o,r,n,a),e.compute(Oy(e.inputs[0],t,o,r,n,a),{inputs:[0]})},vc=e=>{let t=e.antialias,r=e.axes,n=e.coordinateTransformMode,a=e.cubicCoeffA,o=0!==e.excludeOutside,i=e.extrapolationValue,s=e.keepAspectRatioPolicy,l=e.mode,d=""===e.nearestMode?"simple":e.nearestMode;return re({antialias:t,axes:r,coordinateTransformMode:n,cubicCoeffA:a,excludeOutside:o,extrapolationValue:i,keepAspectRatioPolicy:s,mode:l,nearestMode:d})}})),Dy,My,xc,Sc=W((()=>{te(),ae(),Ce(),ce(),Dy=(e,t)=>{let[r,n,a,o]=e,{numHeads:i,rotaryEmbeddingDim:s}=t;if(3!==r.dims.length&&4!==r.dims.length)throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);if(!E.areEqual(n.dims,[])&&!E.areEqual(n.dims,[1])&&2!==n.dims.length)throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${n.dims.length}`);if(2!==a.dims.length)throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${a.dims.length}`);if(2!==o.dims.length)throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${o.dims.length}`);if(!E.areEqual(a.dims,o.dims))throw new Error("Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape");if(s>0&&0===i)throw new Error("num_heads must be provided if rotary_embedding_dim is specified");let l=r.dims[0],d=r.dims[r.dims.length-2],u=a.dims[0],c=E.sizeFromDimension(r.dims,1)/d,p=0===s?2*a.dims[1]:c/i;if(s>p)throw new Error("rotary_embedding_dim must be less than or equal to head_size");if(2===n.dims.length){if(l!==n.dims[0])throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${n.dims[0]}`);if(d!==n.dims[1])throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${n.dims[1]}`)}if(p/2!==a.dims[1]&&s/2!==a.dims[1])throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${a.dims[1]}`);if(d>u)throw new Error("Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported")},My=(e,t)=>{let{interleaved:r,numHeads:n,rotaryEmbeddingDim:a,scale:o}=t,i=e[0].dims[0],s=E.sizeFromDimension(e[0].dims,1),l=e[0].dims[e[0].dims.length-2],d=s/l,u=e[2].dims[1],c=0===a?2*u:d/n,p=new Array(i,l,d/c,c-u),g=E.computeStrides(p),A=[{type:1,data:o},{type:12,data:p},{type:12,data:g},...3===e[0].dims.length?new Array({type:12,data:[s,d,c,1]}):[],...4===e[0].dims.length?new Array({type:12,data:[s,c,l*c,1]}):[],...G(e[0].dims,e[1].dims,e[2].dims,e[3].dims,e[0].dims)];return{name:"RotaryEmbedding",shaderCache:{hint:re({interleaved:r}).cacheKey,inputDependencies:["rank","rank","rank","rank"]},getShaderSource:t=>{let n=P("input",e[0].dataType,e[0].dims.length),a=P("position_ids",e[1].dataType,e[1].dims.length),o=P("cos_cache",e[2].dataType,e[2].dims.length),i=P("sin_cache",e[3].dataType,e[3].dims.length),s=N("output",e[0].dataType,e[0].dims.length);return t.registerUniforms([{name:"scale",type:"f32"},{name:"global_shape",type:"u32",length:p.length},{name:"global_strides",type:"u32",length:g.length},{name:"input_output_strides",type:"u32",length:g.length}]),`\n        ${t.declareVariables(n,a,o,i,s)}\n\n        ${t.mainStart(Et)}\n          let half_rotary_emb_dim = uniforms.${o.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${t.guardAgainstOutOfBoundsWorkgroupSizes("size")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${a.broadcastedIndicesToOffset("bsnh.xy",N("",a.type.tensor,2))};\n            let position_id =\n                u32(${a.getByOffset("position_ids_idx")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});\n            let j = i + select(half_rotary_emb_dim, 1, ${r});\n            let re = ${n.getByOffset("i")} * ${o.get("position_id","bsnh[3]")} -\n                ${n.getByOffset("j")} * ${i.get("position_id","bsnh[3]")};\n            ${s.setByOffset("i","re")}\n            let im = ${n.getByOffset("i")} * ${i.get("position_id","bsnh[3]")} +\n                ${n.getByOffset("j")} * ${o.get("position_id","bsnh[3]")};\n            ${s.setByOffset("j","im")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${s.setByOffset("k",n.getByOffset("k"))}\n          }\n        }`},getRunData:()=>({outputs:[{dims:e[0].dims,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(E.size(p)/Et)},programUniforms:A})}},xc=(e,t)=>{Dy(e.inputs,t),e.compute(My(e.inputs,t))}})),Ry,Uy,Tc,Cc=W((()=>{te(),ae(),ce(),Ry=e=>{if(!e||e.length<3)throw new Error("layerNorm requires at least 3 inputs.");let t=e[0],r=e[1],n=e[2];if(t.dataType!==r.dataType||t.dataType!==n.dataType)throw new Error("All inputs must have the same data type");if(3!==t.dims.length&&2!==t.dims.length)throw new Error("Input must be 2D or 3D");if(3!==r.dims.length&&2!==r.dims.length)throw new Error("Skip must be 2D or 3D");let a=t.dims[t.dims.length-1],o=t.dims[t.dims.length-2];if(r.dims[r.dims.length-1]!==a)throw new Error("Skip must have the same hidden size as input");if(r.dims[r.dims.length-2]!==o)throw new Error("Skip must have the same sequence length as input");if(1!==n.dims.length)throw new Error("Gamma must be 1D");if(n.dims[n.dims.length-1]!==a)throw new Error("Gamma must have the same hidden size as input");if(e.length>3){let t=e[3];if(1!==t.dims.length)throw new Error("Beta must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Beta must have the same hidden size as input")}if(e.length>4){let t=e[4];if(1!==t.dims.length)throw new Error("Bias must be 1D");if(t.dims[t.dims.length-1]!==a)throw new Error("Bias must have the same hidden size as input")}},Uy=(e,t,r,n)=>{let a=t.simplified,o=e[0].dims,i=E.size(o),s=o,l=i,d=o.slice(-1)[0],u=n?o.slice(0,-1).concat(1):[],c=!a&&e.length>3,p=e.length>4,g=n&&r>1,A=n&&r>2,h=r>3,B=64,m=ge(d),C=[{type:12,data:l},{type:12,data:m},{type:12,data:d},{type:1,data:t.epsilon}],w=[{dims:s,dataType:e[0].dataType}];return r>1&&w.push({dims:u,dataType:1}),r>2&&w.push({dims:u,dataType:1}),r>3&&w.push({dims:o,dataType:e[0].dataType}),{name:"SkipLayerNormalization",shaderCache:{hint:`${m};${g};${A};${h}`,inputDependencies:e.map(((e,t)=>"type"))},getShaderSource:t=>{let r=[P("x",e[0].dataType,e[0].dims,m),P("skip",e[1].dataType,e[1].dims,m),P("gamma",e[2].dataType,e[2].dims,m)];c&&r.push(P("beta",e[3].dataType,e[3].dims,m)),p&&r.push(P("bias",e[4].dataType,e[4].dims,m)),r.push(N("output",e[0].dataType,s,m)),g&&r.push(N("mean_output",1,u)),A&&r.push(N("inv_std_output",1,u)),h&&r.push(N("input_skip_bias_sum",e[0].dataType,s,m));let n=_e(e[0].dataType),o=_e(1,m);return`\n\n      ${t.registerUniforms([{name:"output_size",type:"u32"},{name:"components",type:"u32"},{name:"hidden_size",type:"u32"},{name:"epsilon",type:"f32"}]).declareVariables(...r)}\n      var<workgroup> sum_shared : array<${o}, 64>;\n      var<workgroup> sum_squared_shared : array<${o}, 64>;\n\n      ${t.mainStart([B,1,1])}\n        let ix = local_id.x;\n        let iy = global_id.x / 64;\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / 64;\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == 63) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${p?"bias[offset1d + i]":n+"(0.0)"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${h?"input_skip_bias_sum[offset + i] = value;":""}\n          output[offset + i] = value;\n          let f32_value = ${Pt(n,m,"value")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = 64;\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${Ke("sum",m)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${Ke("square_sum",m)} / f32(uniforms.hidden_size) ${a?"":"- mean * mean"} + uniforms.epsilon);\n        ${g?"mean_output[global_idx] = mean;":""}\n        ${A?"inv_std_output[global_idx] = inv_std_dev;":""}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${a?"":`- ${n}(mean)`}) *\n            ${n}(inv_std_dev) * gamma[offset1d + i]\n            ${c?"+ beta[offset1d + i]":""};\n        }\n      }`},getRunData:()=>({outputs:w,dispatchGroup:{x:Math.ceil(l/d)},programUniforms:C})}},Tc=(e,t)=>{Ry(e.inputs);let r=[0];e.outputCount>1&&r.push(-3),e.outputCount>2&&r.push(-3),e.outputCount>3&&r.push(3),e.compute(Uy(e.inputs,t,e.outputCount,!1),{outputs:r})}})),Ny,nn,Vy,Ic,Wy,Ly,Ac,kc,Ec=W((()=>{te(),ae(),Ce(),ce(),Ny=(e,t)=>{if(!e||e.length<1)throw new Error("too few inputs");if(0!==t.axes.length){if(t.axes.length!==t.starts.length||t.axes.length!==t.ends.length)throw new Error("axes, starts and ends must have the same length")}else if(t.starts.length!==t.ends.length)throw new Error("starts and ends must have the same length");e.slice(1).forEach(((t,r)=>{if(6!==e[r+1].dataType&&7!==e[r+1].dataType)throw new Error(`Input ${r} must be an array of int32 or int64`)}))},nn=(e,t)=>{let r=[];if(e.length>t)if(7===e[t].dataType)e[t].getBigInt64Array().forEach((e=>r.push(Number(e))));else{if(6!==e[t].dataType)throw new Error(`Input ${t} must be an array of int32 or int64`);e[t].getInt32Array().forEach((e=>r.push(Number(e))))}return r},Vy=(e,t)=>{if(e.length>1){let t=nn(e,1),r=nn(e,2),n=nn(e,3);return 0===n.length&&(n=[...Array(e[0].dims.length).keys()]),re({starts:t,ends:r,axes:n})}return t},Ic=(e,t,r,n,a)=>{let o=e;return e<0&&(o+=r[n[t]]),a[t]<0?Math.max(0,Math.min(o,r[n[t]]-1)):Math.max(0,Math.min(o,r[n[t]]))},Wy=(e,t,r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e.type.indices} {\n          var input_indices: ${e.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${j("uniforms.input_shape","i",r.length)};\n            let steps_i = ${j("uniforms.steps","i",r.length)};\n            let signs_i = ${j("uniforms.signs","i",r.length)};\n            let starts_i = ${j("uniforms.starts","i",r.length)};\n            var output_index = ${t.indicesGet("output_indices","i")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e.indicesSet("input_indices","i","input_index")};\n          }\n          return input_indices;\n      }`,Ly=(e,t)=>{let r=e[0].dims,n=E.size(r),a=t.axes.length>0?E.normalizeAxes(t.axes,r.length):[...Array(r.length).keys()],o=nn(e,4);o.forEach((e=>0!==e||(()=>{throw new Error("step cannot be 0")}))),0===o.length&&(o=Array(a.length).fill(1));let i=t.starts.map(((e,t)=>Ic(e,t,r,a,o))),s=t.ends.map(((e,t)=>Ic(e,t,r,a,o)));if(a.length!==i.length||a.length!==s.length)throw new Error("start, ends and axes should have the same number of elements");if(a.length!==r.length)for(let e=0;e<r.length;++e)a.includes(e)||(i.splice(e,0,0),s.splice(e,0,r[e]),o.splice(e,0,1));let l=o.map((e=>Math.sign(e)));o.forEach(((e,t,r)=>{if(e<0){let n=(s[t]-i[t])/e,a=i[t],l=a+n*o[t];i[t]=l,s[t]=a,r[t]=-e}}));let d=r.slice(0);a.forEach(((e,t)=>{d[e]=Math.ceil((s[e]-i[e])/o[e])}));let u={dims:d,dataType:e[0].dataType},c=N("output",e[0].dataType,d.length),p=P("input",e[0].dataType,e[0].dims.length),g=E.size(d),A=[{name:"outputSize",type:"u32"},{name:"starts",type:"u32",length:i.length},{name:"signs",type:"i32",length:l.length},{name:"steps",type:"u32",length:o.length}],h=[{type:12,data:g},{type:12,data:i},{type:6,data:l},{type:12,data:o},...G(e[0].dims,d)];return{name:"Slice",shaderCache:{hint:`${l.length}_${i.length}_${o.length}`,inputDependencies:["rank"]},getShaderSource:e=>`\n      ${e.registerUniforms(A).declareVariables(p,c)}\n        ${Wy(p,c,r)}\n        ${e.mainStart()}\n          ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.outputSize")}\n          let output_indices = ${c.offsetToIndices("global_idx")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${c.setByOffset("global_idx",p.getByIndices("input_indices"))}\n      }`,getRunData:()=>({outputs:[u],dispatchGroup:{x:Math.ceil(n/64)},programUniforms:h})}},Ac=(e,t)=>{Ny(e.inputs,t);let r=Vy(e.inputs,t);e.compute(Ly(e.inputs,r),{inputs:[0]})},kc=e=>{let t=e.starts,r=e.ends,n=e.axes;return re({starts:t,ends:r,axes:n})}})),Gy,Hy,Pc,zc,Oc=W((()=>{te(),ae(),Ce(),ct(),ce(),Gy=e=>{if(!e||1!==e.length)throw new Error("Softmax op requires 1 input.")},Hy=(e,t)=>{let r,n=e.inputs[0],a=n.dims,o=E.size(a),i=a.length,s=E.normalizeAxis(t.axis,i),l=s<a.length-1,d=[];l?(d=Array.from({length:i},((e,t)=>t)),d[s]=i-1,d[i-1]=s,r=e.compute(Oe(n,d),{inputs:[n],outputs:[-1]})[0]):r=n;let u=r.dims,c=u[i-1],p=o/c,g=ge(c),A=c/g,h=64;1===p&&(h=256);let B=P("x",r.dataType,r.dims,g),m=N("result",r.dataType,r.dims,g),C=B.type.value,w="f32"===_e(r.dataType)?`var threadMax = ${C}(-3.402823e+38f);`:`var threadMax = ${C}(-65504.0h);`,b=e.compute({name:"Softmax",shaderCache:{hint:`${g};${h}`,inputDependencies:["type"]},getRunData:()=>({outputs:[{dims:u,dataType:r.dataType}],dispatchGroup:{x:p},programUniforms:[{type:6,data:A}]}),getShaderSource:e=>`\n      var<workgroup> rowMaxShared : ${C};\n      var<workgroup> rowSumShared : ${C};\n      var<workgroup> threadShared : array<${C}, ${h}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${C} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${C}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${e.registerUniform("packedCols","i32").declareVariables(B,m)}\n      ${e.mainStart(h)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${h};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${w}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${C}(${((e,t)=>4===t?`max(max(${e}.x, ${e}.y), max(${e}.z, ${e}.w))`:2===t?`max(${e}.x, ${e}.y)`:3===t?`max(max(${e}.x, ${e}.y), ${e}.z)`:e)("threadShared[0]",g)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${C}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${C}(${Ke("threadShared[0]",g)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`},{inputs:[r],outputs:[l?-1:0]})[0];l&&e.compute(Oe(b,d),{inputs:[b]})},Pc=(e,t)=>{Gy(e.inputs),Hy(e,t)},zc=e=>re({axis:e.axis})})),Bc,Fy,qy,Ky,Dc,Mc=W((()=>{te(),ae(),ce(),Bc=e=>Array.from(e.getBigInt64Array(),Number),Fy=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 inputs.");if(1!==e[0].dataType&&10!==e[0].dataType&&6!==e[0].dataType&&12!==e[0].dataType)throw new Error("Tile only support float, float16, int32, and uint32 data types");if(7!==e[1].dataType)throw new Error("Tile `repeats` input should be of int64 data type");if(1!==e[1].dims.length)throw new Error("Tile `repeats` input should be 1-D");if(Bc(e[1]).length!==e[0].dims.length)throw new Error("Tile `repeats` input should have same number of elements as rank of input data tensor")},qy=(e,t)=>{let r=[];for(let n=0;n<e.length;++n)r.push(e[n]*t[n]);return r},Ky=(e,t)=>{let r=e[0].dims,n=t??Bc(e[1]),a=qy(r,n),o=E.size(a),i=e[0].dataType,s=P("input",i,r.length),l=N("output",i,a.length);return{name:"Tile",shaderCache:{hint:`${n}`,inputDependencies:["rank"]},getRunData:()=>({outputs:[{dims:a,dataType:e[0].dataType}],dispatchGroup:{x:Math.ceil(o/64)},programUniforms:[{type:12,data:o},...G(e[0].dims,a)]}),getShaderSource:e=>`\n      const inputShape = ${s.indices(...r)};\n      ${e.registerUniform("output_size","u32").declareVariables(s,l)}\n      ${e.mainStart()}\n      ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.output_size")}\n      let output_indices = ${l.offsetToIndices("global_idx")};\n      var input_indices: ${s.type.indices};\n      for (var i = 0; i < ${r.length}; i++) {\n        let input_dim_i = ${s.indicesGet("uniforms.input_shape","i")};\n        let input_dim_value = ${l.indicesGet("output_indices","i")}  % input_dim_i;\n\n        ${s.indicesSet("input_indices","i","input_dim_value")}\n      }\n      ${l.setByOffset("global_idx",s.getByIndices("input_indices"))}\n    }`}},Dc=e=>{Fy(e.inputs),e.compute(Ky(e.inputs),{inputs:[0]})}})),jy,Zy,Rc,Uc=W((()=>{te(),ae(),ce(),jy=(e,t,r,n,a)=>{let o,i=N("output_data",a,r.length,4),s=P("a_data",t[1].dataType,t[1].dims.length,4),l=P("b_data",t[2].dataType,t[2].dims.length,4),d=P("c_data",t[0].dataType,t[0].dims.length,4),u=(e,t,r)=>`select(${t}, ${e}, ${r})`;if(n){let e=(e,t,r="")=>{let n=`a_data[index_a${t}][component_a${t}]`,a=`b_data[index_b${t}][component_b${t}]`,o=`bool(c_data[index_c${t}] & (0xffu << (component_c${t} * 8)))`;return`\n            let output_indices${t} = ${i.offsetToIndices(`global_idx * 4u + ${t}u`)};\n            let offset_a${t} = ${s.broadcastedIndicesToOffset(`output_indices${t}`,i)};\n            let offset_b${t} = ${l.broadcastedIndicesToOffset(`output_indices${t}`,i)};\n            let offset_c${t} = ${d.broadcastedIndicesToOffset(`output_indices${t}`,i)};\n            let index_a${t} = offset_a${t} / 4u;\n            let index_b${t} = offset_b${t} / 4u;\n            let index_c${t} = offset_c${t} / 4u;\n            let component_a${t} = offset_a${t} % 4u;\n            let component_b${t} = offset_b${t} % 4u;\n            let component_c${t} = offset_c${t} % 4u;\n            ${e}[${t}] = ${r}(${u(n,a,o)});\n          `};o=9===a?`\n            var data = vec4<u32>(0);\n            ${e("data",0,"u32")}\n            ${e("data",1,"u32")}\n            ${e("data",2,"u32")}\n            ${e("data",3,"u32")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));`:`\n            ${e("output_data[global_idx]",0)}\n            ${e("output_data[global_idx]",1)}\n            ${e("output_data[global_idx]",2)}\n            ${e("output_data[global_idx]",3)}\n          `}else o=i.setByOffset("global_idx",u(s.getByOffset("global_idx"),l.getByOffset("global_idx"),d.getByOffset("global_idx")));return`\n        ${e.registerUniform("vec_size","u32").declareVariables(d,s,l,i)}\n        ${e.mainStart()}\n        ${e.guardAgainstOutOfBoundsWorkgroupSizes("uniforms.vec_size")}\n        ${o}\n      }`},Zy=e=>{let t=e[1].dims,r=e[2].dims,n=e[0].dims,a=e[1].dataType,o=!(E.areEqual(t,r)&&E.areEqual(r,n)),i=t,s=E.size(t);if(o){let e=rt.calcShape(rt.calcShape(t,r,!1),n,!1);if(!e)throw new Error("Can't perform where op on the given tensors");i=e,s=E.size(i)}let l=Math.ceil(s/4);return{name:"Where",shaderCache:{inputDependencies:["rank","rank","rank"]},getShaderSource:t=>jy(t,e,i,o,a),getRunData:()=>({outputs:[{dims:i,dataType:a}],dispatchGroup:{x:Math.ceil(s/64/4)},programUniforms:[{type:12,data:l},...G(n,t,r,i)]})}},Rc=e=>{e.compute(Zy(e.inputs))}})),Nc,Vc=W((()=>{_u(),qr(),$u(),Su(),dd(),wd(),xd(),Nd(),qd(),Zd(),Xd(),nl(),al(),ul(),cl(),fl(),yl(),wl(),xl(),Cl(),Bl(),Rl(),Nl(),Wl(),Hl(),To(),ql(),dc(),pc(),fc(),yc(),Hr(),$c(),Sc(),Cc(),Ec(),Oc(),Io(),Mc(),ct(),jr(),Uc(),Nc=new Map([["Abs",[Tu]],["Acos",[Cu]],["Acosh",[Iu]],["Add",[ld]],["ArgMax",[bu,po]],["ArgMin",[yu,po]],["Asin",[Au]],["Asinh",[ku]],["Atan",[Eu]],["Atanh",[Pu]],["Attention",[wu]],["AveragePool",[ec,Jl]],["BatchNormalization",[vu]],["BiasAdd",[xu]],["BiasSplitGelu",[ud]],["Cast",[Ou,zu]],["Ceil",[Du]],["Clip",[Bu]],["Concat",[vd,$d]],["Conv",[vo,wo]],["ConvTranspose",[Fd,Gd]],["Cos",[Mu]],["Cosh",[Ru]],["CumSum",[Kd,jd]],["DepthToSpace",[Qd,Yd]],["DequantizeLinear",[lc,cc]],["Div",[cd]],["Einsum",[tl,rl]],["Elu",[Uu,tr]],["Equal",[pd]],["Erf",[Nu]],["Exp",[Vu]],["Expand",[il]],["FastGelu",[sl]],["Floor",[Wu]],["FusedConv",[vo,wo]],["Gather",[ll,dl]],["GatherElements",[_l,bl]],["GatherBlockQuantized",[hl,gl]],["GatherND",[pl,ml]],["Gelu",[Lu]],["Gemm",[$l,vl]],["GlobalAveragePool",[nc,rc]],["GlobalMaxPool",[uc,sc]],["Greater",[gd]],["GreaterOrEqual",[bd]],["GridSample",[Sl,Tl]],["GroupQueryAttention",[Ol]],["HardSigmoid",[Qu,Zu]],["InstanceNormalization",[Ml]],["LayerNormalization",[Ul]],["LeakyRelu",[Gu,tr]],["Less",[yd]],["LessOrEqual",[_d]],["Log",[id]],["MatMul",[Vl]],["MatMulNBits",[Ll,Gl]],["MaxPool",[ic,ac]],["Mul",[md]],["MultiHeadAttention",[kl,Al]],["Neg",[Fu]],["Not",[Hu]],["Pad",[Fl]],["Pow",[fd]],["QuickGelu",[ad,tr]],["Range",[mc]],["Reciprocal",[qu]],["ReduceMin",[cu]],["ReduceMean",[au]],["ReduceMax",[lu]],["ReduceSum",[mu]],["ReduceProd",[pu]],["ReduceL1",[su]],["ReduceL2",[uu]],["ReduceLogSum",[hu]],["ReduceLogSumExp",[du]],["ReduceSumSquare",[fu]],["Relu",[Ku]],["Resize",[wc,vc]],["RotaryEmbedding",[xc]],["ScatterND",[gc,hc]],["Sigmoid",[ju]],["Sin",[Yu]],["Sinh",[Xu]],["Slice",[Ac,kc]],["SkipLayerNormalization",[Tc]],["Split",[El,Pl]],["Sqrt",[Ju]],["Softmax",[Pc,zc]],["Sub",[hd]],["Tan",[ed]],["Tanh",[rd]],["ThresholdedRelu",[od,tr]],["Tile",[Dc]],["Transpose",[Ks,js]],["Where",[Rc]]])})),on,Wc=W((()=>{Ge(),tt(),ce(),on=class{constructor(e){this.backend=e,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,r,n,a){Ne(e.programInfo.name);let o=this.backend.device,i=this.backend.getComputePassEncoder();this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber);let s=[];for(let e of t)s.push({binding:s.length,resource:{buffer:e.buffer}});for(let e of r)s.push({binding:s.length,resource:{buffer:e.buffer}});a&&s.push({binding:s.length,resource:a});let l=o.createBindGroup({layout:e.computePipeline.getBindGroupLayout(0),entries:s,label:e.programInfo.name});if("capturing"===this.backend.sessionStatus){let t={kernelId:this.backend.currentKernelId,computePipeline:e.computePipeline,bindGroup:l,dispatchGroup:n};this.backend.capturedCommandList.get(this.backend.currentSessionId).push(t)}i.setPipeline(e.computePipeline),i.setBindGroup(0,l),i.dispatchWorkgroups(...n),this.backend.writeTimestamp(2*this.backend.pendingDispatchNumber+1),this.backend.pendingDispatchNumber++,(this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber||"at-passes"===this.backend.queryType)&&this.backend.endComputePass(),this.backend.pendingDispatchNumber>=this.backend.maxDispatchNumber&&this.backend.flush(),De(e.programInfo.name)}dispose(){}build(e,t){Ne(e.name);let r=this.backend.device,n=[];[{feature:"shader-f16",extension:"f16"},{feature:"subgroups",extension:"subgroups"}].forEach((e=>{r.features.has(e.feature)&&n.push(`enable ${e.extension};`)}));let a=Fs(t,this.backend.device.limits),o=e.getShaderSource(a),i=`${n.join("\n")}\n${a.additionalImplementations}\n${o}`,s=r.createShaderModule({code:i,label:e.name});pe("verbose",(()=>`[WebGPU] ${e.name} shader code: ${i}`));let l=r.createComputePipeline({compute:{module:s,entryPoint:"main"},layout:"auto",label:e.name});return De(e.name),{programInfo:e,computePipeline:l,uniformVariablesInfo:a.variablesInfo}}normalizeDispatchGroupSize(e){let t="number"==typeof e?e:e.x,r="number"==typeof e?1:e.y||1,n="number"==typeof e?1:e.z||1,a=this.backend.device.limits.maxComputeWorkgroupsPerDimension;if(t<=a&&r<=a&&n<=a)return[t,r,n];let o=t*r*n,i=Math.ceil(Math.sqrt(o));if(i>a){if(i=Math.ceil(Math.cbrt(o)),i>a)throw new Error("Total dispatch size exceeds WebGPU maximum.");return[i,i,i]}return[i,i,1]}}})),Qy,Yy,Ao,an,Lc=W((()=>{Ge(),te(),tt(),eo(),Ws(),Vc(),Wc(),Qy=(e,t)=>{if(t.length!==e.length)throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e.length}.`);let r=[];for(let n=0;n<e.length;++n){let a=e[n].dataType;switch(t[n]){case"none":r.push("");break;case"type":r.push(`${a}`);break;case"rank":{let t=e[n].dims.length;r.push(`${a};${t}`);break}case"dims":{let t=e[n].dims.join(",");r.push(`${a};${t}`);break}default:throw new Error(`unsupported input dependency: ${t[n]}`)}}return r.join("|")},Yy=(e,t,r)=>{let n=e.name;return e.shaderCache?.hint&&(n+="["+e.shaderCache.hint+"]"),n+=":"+r+`:${Qy(t,e.shaderCache?.inputDependencies??new Array(t.length).fill("dims"))}`,n},Ao=class{constructor(e){e&&(this.architecture=e.architecture,this.vendor=e.vendor)}isArchitecture(e){return this.architecture===e}isVendor(e){return this.vendor===e}},an=class{constructor(){this.currentSessionId=null,this.currentKernelId=null,this.commandEncoder=null,this.computePassEncoder=null,this.maxDispatchNumber=16,this.pendingDispatchNumber=0,this.pendingKernels=[],this.pendingQueries=new Map,this.sessionStatus="default",this.capturedCommandList=new Map,this.capturedPendingKernels=new Map,this.sessionExternalDataMapping=new Map}get currentKernelCustomData(){if(null===this.currentKernelId)throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");let e=this.kernelCustomData.get(this.currentKernelId);return e||(e={},this.kernelCustomData.set(this.currentKernelId,e)),e}async initialize(e,t){this.env=e;let r=[],n={requiredLimits:{maxComputeWorkgroupStorageSize:t.limits.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:t.limits.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:t.limits.maxStorageBufferBindingSize,maxBufferSize:t.limits.maxBufferSize,maxComputeInvocationsPerWorkgroup:t.limits.maxComputeInvocationsPerWorkgroup,maxComputeWorkgroupSizeX:t.limits.maxComputeWorkgroupSizeX,maxComputeWorkgroupSizeY:t.limits.maxComputeWorkgroupSizeY,maxComputeWorkgroupSizeZ:t.limits.maxComputeWorkgroupSizeZ},requiredFeatures:r},a=e=>t.features.has(e)&&r.push(e)&&!0;a("chromium-experimental-timestamp-query-inside-passes")||a("timestamp-query"),a("shader-f16"),a("subgroups"),this.device=await t.requestDevice(n),this.adapterInfo=new Ao(t.info||await t.requestAdapterInfo()),this.gpuDataManager=Vs(this),this.programManager=new on(this),this.kernels=new Map,this.kernelPersistentData=new Map,this.kernelCustomData=new Map,Ur(e.logLevel,!!e.debug),this.device.onuncapturederror=e=>{e.error instanceof GPUValidationError&&console.error(`An uncaught WebGPU validation error was raised: ${e.error.message}`)},Object.defineProperty(this.env.webgpu,"device",{value:this.device,writable:!1,enumerable:!0,configurable:!1}),Object.defineProperty(this.env.webgpu,"adapter",{value:t,writable:!1,enumerable:!0,configurable:!1}),this.setQueryType()}dispose(){typeof this.querySet<"u"&&this.querySet.destroy(),this.gpuDataManager.dispose()}getCommandEncoder(){return this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder()),this.commandEncoder}getComputePassEncoder(){if(!this.computePassEncoder){let e=this.getCommandEncoder(),t={};"at-passes"===this.queryType&&(t.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:2*this.pendingDispatchNumber,endOfPassWriteIndex:2*this.pendingDispatchNumber+1}),this.computePassEncoder=e.beginComputePass(t)}return this.computePassEncoder}endComputePass(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}flush(){if(!this.commandEncoder)return;let e;Ne(),this.endComputePass(),"none"!==this.queryType&&(this.commandEncoder.resolveQuerySet(this.querySet,0,2*this.pendingDispatchNumber,this.queryResolveBuffer,0),e=this.device.createBuffer({size:2*this.pendingDispatchNumber*8,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),this.pendingQueries.set(e,this.pendingKernels),this.pendingKernels=[],this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,2*this.pendingDispatchNumber*8)),this.device.queue.submit([this.commandEncoder.finish()]),this.gpuDataManager.refreshPendingBuffers(),this.commandEncoder=null,this.pendingDispatchNumber=0,"none"!==this.queryType&&e.mapAsync(GPUMapMode.READ).then((()=>{let t=new BigUint64Array(e.getMappedRange()),r=this.pendingQueries.get(e);for(let e=0;e<t.length/2;e++){let n=r[e],a=n.kernelId,o=this.kernels.get(a),i=o.kernelType,s=o.kernelName,l=n.programName,d=n.inputTensorViews,u=n.outputTensorViews,c=t[2*e],p=t[2*e+1];typeof this.queryTimeBase>"u"&&(this.queryTimeBase=c);let g=Number(c-this.queryTimeBase),A=Number(p-this.queryTimeBase);if(!Number.isSafeInteger(g)||!Number.isSafeInteger(A))throw new RangeError("incorrect timestamp range");if(this.env.webgpu.profiling?.ondata)this.env.webgpu.profiling.ondata({version:1,inputsMetadata:d.map((e=>({dims:e.dims,dataType:_t(e.dataType)}))),outputsMetadata:u.map((e=>({dims:e.dims,dataType:_t(e.dataType)}))),kernelId:a,kernelType:i,kernelName:s,programName:l,startTime:g,endTime:A});else{let e="";d.forEach(((t,r)=>{e+=`input[${r}]: [${t.dims}] | ${_t(t.dataType)}, `}));let t="";u.forEach(((e,r)=>{t+=`output[${r}]: [${e.dims}] | ${_t(e.dataType)}, `})),console.log(`[profiling] kernel "${a}|${i}|${s}|${l}" ${e}${t}execution time: ${A-g} ns`)}vr("GPU",`${l}::${c}::${p}`)}e.unmap(),this.pendingQueries.delete(e)})),De()}run(e,t,r,n,a,o){Ne(e.name);let i=[];for(let e=0;e<t.length;++e){let r=t[e].data;if(0===r)continue;let n=this.gpuDataManager.get(r);if(!n)throw new Error(`no GPU data for input: ${r}`);i.push(n)}let{outputs:s,dispatchGroup:l,programUniforms:d}=e.getRunData(t),u=0===r.length?s.map(((e,t)=>t)):r;if(u.length!==s.length)throw new Error(`Output size ${u.length} must be equal to ${s.length}.`);let c,p=[],g=[];for(let e=0;e<s.length;++e){if(!Number.isInteger(u[e])||u[e]<-3||u[e]>=o)throw new Error(`Invalid output index: ${u[e]}`);if(-3===u[e])continue;let t=-1===u[e],r=-2===u[e],i=t||r?a(s[e].dataType,s[e].dims):n(u[e],s[e].dataType,s[e].dims);if(p.push(i),0===i.data)continue;let l=this.gpuDataManager.get(i.data);if(!l)throw new Error(`no GPU data for output: ${i.data}`);if(t&&this.temporaryData.push(l),r){let e=this.kernelPersistentData.get(this.currentKernelId);e||(e=[],this.kernelPersistentData.set(this.currentKernelId,e)),e.push(l)}g.push(l)}if(i.length!==t.length||g.length!==p.length){if(0===g.length)return De(e.name),p;throw new Error(`Program ${e.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`)}if(d){let e=0,t=[];d.forEach((r=>{let n="number"==typeof r.data?[r.data]:r.data;if(0===n.length)return;let a,o,i=10===r.type?2:4;10===r.type?(o=n.length>4?16:n.length>2?8:n.length*i,a=n.length>4?16:i*n.length):(o=n.length<=2?n.length*i:16,a=16),e=Math.ceil(e/o)*o,t.push(e);let s=10===r.type?8:4;e+=n.length>4?Math.ceil(n.length/s)*a:n.length*i}));let r=16;e=Math.ceil(e/r)*r;let n=new ArrayBuffer(e);d.forEach(((e,r)=>{let a=t[r],o="number"==typeof e.data?[e.data]:e.data;if(6===e.type)new Int32Array(n,a,o.length).set(o);else if(12===e.type)new Uint32Array(n,a,o.length).set(o);else if(10===e.type)new Uint16Array(n,a,o.length).set(o);else{if(1!==e.type)throw new Error(`Unsupported uniform type: ${_t(e.type)}`);new Float32Array(n,a,o.length).set(o)}}));let a=this.gpuDataManager.create(e,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.device.queue.writeBuffer(a.buffer,0,n,0,e),this.gpuDataManager.release(a.id),c={offset:0,size:e,buffer:a.buffer}}let A=this.programManager.normalizeDispatchGroupSize(l),h=1===A[1]&&1===A[2],B=Yy(e,t,h),m=this.programManager.getArtifact(B);if(m||(m=this.programManager.build(e,A),this.programManager.setArtifact(B,m),pe("info",(()=>`[artifact] key: ${B}, programName: ${e.name}`))),d&&m.uniformVariablesInfo){if(d.length!==m.uniformVariablesInfo.length)throw new Error(`Uniform variables count mismatch: expect ${m.uniformVariablesInfo.length}, got ${d.length} in program "${m.programInfo.name}".`);for(let e=0;e<d.length;e++){let t=d[e],r=t.type,n="number"==typeof t.data?1:t.data.length,[a,o]=m.uniformVariablesInfo[e];if(r!==a||n!==o)throw new Error(`Uniform variable ${e} mismatch: expect type ${a} with size ${o}, got type ${r} with size ${n} in program "${m.programInfo.name}".`)}}if(pe("info",(()=>`[ProgramManager] run "${e.name}" (key=${B}) with ${A[0]}x${A[1]}x${A[2]}`)),"none"!==this.queryType||"capturing"===this.sessionStatus){let e={kernelId:this.currentKernelId,programName:m.programInfo.name,inputTensorViews:t,outputTensorViews:p};this.pendingKernels.push(e),"capturing"===this.sessionStatus&&this.capturedPendingKernels.get(this.currentSessionId).push(e)}return this.programManager.run(m,i,g,A,c),De(e.name),p}upload(e,t){this.gpuDataManager.upload(e,t)}memcpy(e,t){this.gpuDataManager.memcpy(e,t)}async download(e,t){await this.gpuDataManager.download(e,t)}alloc(e){return this.gpuDataManager.create(e).id}free(e){return this.gpuDataManager.release(e)}createKernel(e,t,r,n){let a=Nc.get(e);if(!a)throw new Error(`kernel not implemented: ${e}`);let o={kernelType:e,kernelName:n,kernelEntry:a[0],attributes:[a[1],r]};this.kernels.set(t,o)}releaseKernel(e){let t=this.kernelPersistentData.get(e);if(t){for(let e of t)this.gpuDataManager.release(e.id);this.kernelPersistentData.delete(e)}this.kernelCustomData.delete(e),this.kernels.delete(e)}computeKernel(e,t,r){let n=this.kernels.get(e);if(!n)throw new Error(`kernel not created: ${e}`);let a=n.kernelType,o=n.kernelName,i=n.kernelEntry,s=n.attributes;if(null!==this.currentKernelId)throw new Error(`kernel "[${a}] ${o}" is not allowed to be called recursively`);this.currentKernelId=e,s[0]&&(s[1]=s[0](s[1]),s[0]=void 0),pe("info",(()=>`[WebGPU] Start to run kernel "[${a}] ${o}"...`));let l=this.env.debug;this.temporaryData=[];try{return l&&this.device.pushErrorScope("validation"),i(t,s[1]),0}catch(e){return r.push(Promise.resolve(`[WebGPU] Kernel "[${a}] ${o}" failed. ${e}`)),1}finally{l&&r.push(this.device.popErrorScope().then((e=>e?`GPU validation error for kernel "[${a}] ${o}": ${e.message}`:null)));for(let e of this.temporaryData)this.gpuDataManager.release(e.id);this.temporaryData=[],this.currentKernelId=null}}registerBuffer(e,t,r,n){let a=this.sessionExternalDataMapping.get(e);a||(a=new Map,this.sessionExternalDataMapping.set(e,a));let o=a.get(t),i=this.gpuDataManager.registerExternalBuffer(r,n,o);return a.set(t,[i,r]),i}unregisterBuffers(e){let t=this.sessionExternalDataMapping.get(e);t&&(t.forEach((e=>this.gpuDataManager.unregisterExternalBuffer(e[0]))),this.sessionExternalDataMapping.delete(e))}getBuffer(e){let t=this.gpuDataManager.get(e);if(!t)throw new Error(`no GPU data for buffer: ${e}`);return t.buffer}createDownloader(e,t,r){return async()=>{let n=await oo(this,e,t);return Nr(n.buffer,r)}}writeTimestamp(e){"inside-passes"===this.queryType&&this.computePassEncoder.writeTimestamp(this.querySet,e)}setQueryType(){this.queryType="none",("default"===this.env.webgpu.profiling?.mode||(typeof this.env.trace>"u"?this.env.wasm.trace:this.env.trace))&&(this.device.features.has("chromium-experimental-timestamp-query-inside-passes")?this.queryType="inside-passes":this.device.features.has("timestamp-query")&&(this.queryType="at-passes"),"none"!==this.queryType&&typeof this.querySet>"u"&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2*this.maxDispatchNumber}),this.queryResolveBuffer=this.device.createBuffer({size:2*this.maxDispatchNumber*8,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE})))}captureBegin(){pe("info","captureBegin"),this.capturedCommandList.get(this.currentSessionId)||this.capturedCommandList.set(this.currentSessionId,[]),this.capturedPendingKernels.get(this.currentSessionId)||this.capturedPendingKernels.set(this.currentSessionId,[]),this.flush(),this.sessionStatus="capturing"}captureEnd(){pe("info","captureEnd"),this.flush(),this.sessionStatus="default"}replay(){pe("info","replay"),this.sessionStatus="replaying";let e=this.capturedCommandList.get(this.currentSessionId),t=this.capturedPendingKernels.get(this.currentSessionId),r=e.length;this.pendingKernels=[];for(let n=0;n<r;n++){let r=this.getComputePassEncoder(),a=e[n];this.writeTimestamp(2*this.pendingDispatchNumber),r.setPipeline(a.computePipeline),r.setBindGroup(0,a.bindGroup),r.dispatchWorkgroups(...a.dispatchGroup),this.writeTimestamp(2*this.pendingDispatchNumber+1),this.pendingDispatchNumber++,"none"!==this.queryType&&this.pendingKernels.push(t[n]),(this.pendingDispatchNumber>=this.maxDispatchNumber||"at-passes"===this.queryType)&&this.endComputePass(),this.pendingDispatchNumber>=this.maxDispatchNumber&&this.flush()}this.flush(),this.sessionStatus="default"}onCreateSession(){this.gpuDataManager.onCreateSession()}onReleaseSession(e){this.unregisterBuffers(e),this.capturedCommandList.has(e)&&this.capturedCommandList.delete(e),this.capturedPendingKernels.has(e)&&this.capturedPendingKernels.delete(e),this.gpuDataManager.onReleaseSession(e)}onRunStart(e){this.currentSessionId=e,this.setQueryType()}}})),Xy,Gc,Jy,Hc,sn,un,ko,Fc,qc=W((()=>{tt(),Xy=1,Gc=()=>Xy++,Jy=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),Hc=(e,t)=>{let r=Jy.get(e);if(!r)throw new Error("Unsupported data type.");return t.length>0?Math.ceil(t.reduce(((e,t)=>e*t))*r/8):0},sn=class{constructor(e){this.sessionId=e.sessionId,this.mlContext=e.context,this.mlTensor=e.tensor,this.dataType=e.dataType,this.tensorShape=e.shape}get tensor(){return this.mlTensor}get type(){return this.dataType}get shape(){return this.tensorShape}get byteLength(){return Hc(this.dataType,this.tensorShape)}destroy(){pe("verbose",(()=>"[WebNN] TensorWrapper.destroy")),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor)}canReuseTensor(e,t,r){return this.mlContext===e&&this.dataType===t&&this.tensorShape.length===r.length&&this.tensorShape.every(((e,t)=>e===r[t]))}},un=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,r,n){let a=this.tensorManager.getMLContext(e);if(this.wrapper){if(this.wrapper.canReuseTensor(a,t,r))return this.wrapper.tensor;if(n){if(this.wrapper.byteLength!==Hc(t,r))throw new Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let o=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,t,r,o,!0,!0),n&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){if(this.wrapper){if(e.byteLength===this.wrapper.byteLength)return void this.wrapper.write(e);pe("verbose",(()=>"Data size does not match tensor size. Releasing tensor.")),this.releaseTensor()}this.activeUpload?this.activeUpload.set(e):this.activeUpload=new Uint8Array(e)}async download(e){if(this.activeUpload)return e?void(e instanceof ArrayBuffer?new Uint8Array(e).set(this.activeUpload):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(this.activeUpload)):this.activeUpload.buffer;if(!this.wrapper)throw new Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},ko=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let t=this.backend.getMLContext(e);if(!t)throw new Error("MLContext not found for session.");return t}reserveTensorId(){let e=Gc();return this.tensorTrackersById.set(e,new un(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,r,n,a){pe("verbose",(()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${r}, shape: ${n}, copyOld: ${a}}`));let o=this.tensorTrackersById.get(t);if(!o)throw new Error("Tensor not found.");return o.ensureTensor(e,r,n,a)}upload(e,t){let r=this.tensorTrackersById.get(e);if(!r)throw new Error("Tensor not found.");r.upload(t)}async download(e,t){pe("verbose",(()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`));let r=this.tensorTrackersById.get(e);if(!r)throw new Error("Tensor not found.");return r.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter((t=>t.sessionId!==e))}registerTensor(e,t,r,n){let a=this.getMLContext(e),o=Gc(),i=new sn({sessionId:e,context:a,tensor:t,dataType:r,shape:n});return this.tensorTrackersById.set(o,new un(this,i)),this.externalTensors.add(i),o}async getCachedTensor(e,t,r,n,a,o){let i=this.getMLContext(e);for(let[n,a]of this.freeTensors.entries())if(a.canReuseTensor(i,t,r)){pe("verbose",(()=>`[WebNN] Reusing tensor {dataType: ${t}, shape: ${r}}`));let a=this.freeTensors.splice(n,1)[0];return a.sessionId=e,a}pe("verbose",(()=>`[WebNN] MLContext.createTensor {dataType: ${t}, shape: ${r}}`));let s=await i.createTensor({dataType:t,shape:r,dimensions:r,usage:n,writable:a,readable:o});return new sn({sessionId:e,context:i,tensor:s,dataType:t,shape:r})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},Fc=(...e)=>new ko(...e)})),Eo,eb,dn,Kc=W((()=>{te(),bt(),eo(),qc(),tt(),Eo=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),eb=(e,t)=>{if(e===t)return!0;if(void 0===e||void 0===t)return!1;let r=Object.keys(e).sort(),n=Object.keys(t).sort();return r.length===n.length&&r.every(((r,a)=>r===n[a]&&e[r]===t[r]))},dn=class{constructor(e){this.tensorManager=Fc(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.temporaryGraphInputs=[],this.temporarySessionTensorIds=new Map,Ur(e.logLevel,!!e.debug)}get currentSessionId(){if(void 0===this.activeSessionId)throw new Error("No active session");return this.activeSessionId}onRunStart(e){pe("verbose",(()=>`[WebNN] onRunStart {sessionId: ${e}}`)),this.activeSessionId=e}onRunEnd(e){pe("verbose",(()=>`[WebNN] onRunEnd {sessionId: ${e}}`));let t=this.temporarySessionTensorIds.get(e);if(t){for(let e of t)pe("verbose",(()=>`[WebNN] releasing temporary tensor {tensorId: ${e}}`)),this.tensorManager.releaseTensorId(e);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let t=this.mlContextCache.findIndex((t=>t.gpuDevice===e));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:t}),t}}if(void 0===e){let e=this.mlContextCache.findIndex((e=>void 0===e.options&&void 0===e.gpuDevice));if(-1!==e)return this.mlContextCache[e].mlContext;{let e=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:e}),e}}let t=this.mlContextCache.findIndex((t=>eb(t.options,e)));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:t}),t}}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let r=this.sessionIdsByMLContext.get(t);r||(r=new Set,this.sessionIdsByMLContext.set(t,r)),r.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e);let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let r=this.sessionIdsByMLContext.get(t);if(r.delete(e),0===r.size){this.sessionIdsByMLContext.delete(t);let e=this.mlContextCache.findIndex((e=>e.mlContext===t));-1!==e&&this.mlContextCache.splice(e,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){pe("verbose",(()=>`[WebNN] releaseTensorId {tensorId: ${e}}`)),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,r,n,a){let o=Eo.get(r);if(!o)throw new Error(`Unsupported ONNX data type: ${r}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,t,o,n,a)}async createTemporaryTensor(e,t,r){pe("verbose",(()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${r}}`));let n=Eo.get(t);if(!n)throw new Error(`Unsupported ONNX data type: ${t}`);let a=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,a,n,r,!1);let o=this.temporarySessionTensorIds.get(e);return o?o.push(a):this.temporarySessionTensorIds.set(e,[a]),a}uploadTensor(e,t){if(!Ie().shouldTransferToMLTensor)throw new Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");pe("verbose",(()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`)),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let r=await this.tensorManager.download(e);return Nr(r,t)}}registerMLTensor(e,t,r,n){let a=Eo.get(r);if(!a)throw new Error(`Unsupported ONNX data type: ${r}`);let o=this.tensorManager.registerTensor(e,t,a,n);return pe("verbose",(()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${a}, dimensions: ${n}} -> {tensorId: ${o}}`)),o}registerMLConstant(e,t,r,n,a,o){if(!o)throw new Error("External mounted files are not available.");let i=e;e.startsWith("./")&&(i=e.substring(2));let s=o.get(i);if(!s)throw new Error(`File with name ${i} not found in preloaded files.`);if(t+r>s.byteLength)throw new Error("Out of bounds: data offset and length exceed the external file data size.");let l,d=s.slice(t,t+r).buffer;switch(a.dataType){case"float32":l=new Float32Array(d);break;case"float16":l=typeof Float16Array<"u"&&Float16Array.from?new Float16Array(d):new Uint16Array(d);break;case"int32":l=new Int32Array(d);break;case"uint32":l=new Uint32Array(d);break;case"int64":l=new BigInt64Array(d);break;case"uint64":l=new BigUint64Array(d);break;case"int8":l=new Int8Array(d);break;case"int4":case"uint4":case"uint8":l=new Uint8Array(d);break;default:throw new Error(`Unsupported data type: ${a.dataType} in creating WebNN Constant from external data.`)}return pe("verbose",(()=>`[WebNN] registerMLConstant {dataType: ${a.dataType}, shape: ${a.shape}}}`)),n.constant(a,l)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}isGraphInput(e,t){let r=this.sessionGraphInputs.get(e);return!!r&&r.includes(t)}flush(){}}})),jc={};Zt(jc,{init:()=>tb});var ir,Po,tb,Zc=W((()=>{te(),Lc(),tt(),ae(),Kc(),ir=class e{constructor(e,t,r,n){this.module=e,this.dataType=t,this.data=r,this.dims=n}getFloat32Array(){if(1!==this.dataType)throw new Error("Invalid data type");let e=E.size(this.dims);return 0===e?new Float32Array:new Float32Array(this.module.HEAP8.buffer,this.data,e)}getBigInt64Array(){if(7!==this.dataType)throw new Error("Invalid data type");let e=E.size(this.dims);return 0===e?new BigInt64Array:new BigInt64Array(this.module.HEAP8.buffer,this.data,e)}getInt32Array(){if(6!==this.dataType)throw new Error("Invalid data type");let e=E.size(this.dims);return 0===e?new Int32Array:new Int32Array(this.module.HEAP8.buffer,this.data,e)}getUint16Array(){if(10!==this.dataType&&4!==this.dataType)throw new Error("Invalid data type");let e=E.size(this.dims);return 0===e?new Uint16Array:new Uint16Array(this.module.HEAP8.buffer,this.data,e)}reshape(t){if(E.size(t)!==E.size(this.dims))throw new Error("Invalid new shape");return new e(this.module,this.dataType,this.data,t)}},Po=class{constructor(e,t,r){this.module=e,this.backend=t,this.customDataOffset=0,this.customDataSize=0,this.adapterInfo=t.adapterInfo;let n=e.PTR_SIZE,a=r/e.PTR_SIZE,o=4===n?"i32":"i64";this.opKernelContext=Number(e.getValue(n*a++,o));let i=Number(e.getValue(n*a++,o));this.outputCount=Number(e.getValue(n*a++,o)),this.customDataOffset=Number(e.getValue(n*a++,"*")),this.customDataSize=Number(e.getValue(n*a++,o));let s=[];for(let t=0;t<i;t++){let t=Number(e.getValue(n*a++,o)),r=Number(e.getValue(n*a++,"*")),i=Number(e.getValue(n*a++,o)),l=[];for(let t=0;t<i;t++)l.push(Number(e.getValue(n*a++,o)));s.push(new ir(e,t,r,l))}this.inputs=s}get kernelCustomData(){return this.backend.currentKernelCustomData}get customDataBuffer(){return this.module.HEAPU8.subarray(this.customDataOffset,this.customDataOffset+this.customDataSize)}compute(e,t){let r=t?.inputs?.map((e=>"number"==typeof e?this.inputs[e]:e))??this.inputs,n=t?.outputs??[];return this.backend.run(e,r,n,((e,t,r)=>new ir(this.module,t,this.output(e,r),r)),((e,t)=>{let r=wt(e,t);if(!r)throw new Error(`Unsupported data type: ${e}`);let n=r>0?this.backend.gpuDataManager.create(r).id:0;return new ir(this.module,e,n,t)}),this.outputCount)}output(e,t){let r=this.module.stackSave();try{let r=this.module.PTR_SIZE,n=4===r?"i32":"i64",a=this.module.stackAlloc((1+t.length)*r);this.module.setValue(a,t.length,n);for(let e=0;e<t.length;e++)this.module.setValue(a+r*(e+1),t[e],n);return this.module._JsepOutput(this.opKernelContext,e,a)}catch(r){throw new Error(`Failed to generate kernel's output[${e}] with dims [${t}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${r}`)}finally{this.module.stackRestore(r)}}},tb=async(e,t,r,n)=>{let a=t.jsepInit;if(!a)throw new Error("Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.");if("webgpu"===e){let e=new an;await e.initialize(r,n),a("webgpu",[e,t=>e.alloc(Number(t)),t=>e.free(t),(r,n,a,o=!1)=>{if(o)pe("verbose",(()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(r)}, dst=${Number(n)}, size=${Number(a)}`)),e.memcpy(Number(r),Number(n));else{pe("verbose",(()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(r)}, gpuDataId=${Number(n)}, size=${Number(a)}`));let o=t.HEAPU8.subarray(Number(r>>>0),Number(r>>>0)+Number(a));e.upload(Number(n),o)}},async(r,n,a)=>{pe("verbose",(()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${r}, dataOffset=${n}, size=${a}`)),await e.download(Number(r),(()=>t.HEAPU8.subarray(Number(n)>>>0,Number(n+a)>>>0)))},(r,n,a)=>e.createKernel(r,Number(n),a,t.UTF8ToString(t._JsepGetNodeName(Number(n)))),t=>e.releaseKernel(t),(r,n,a,o)=>{pe("verbose",(()=>`[WebGPU] jsepRun: sessionHandle=${a}, kernel=${r}, contextDataOffset=${n}`));let i=new Po(t,e,Number(n));return e.computeKernel(Number(r),i,o)},()=>e.captureBegin(),()=>e.captureEnd(),()=>e.replay()])}else{let e=new dn(r);a("webnn",[e,()=>e.reserveTensorId(),t=>e.releaseTensorId(t),async(t,r,n,a,o)=>e.ensureTensor(t,r,n,a,o),(t,r)=>{e.uploadTensor(t,r)},async(t,r)=>e.downloadTensor(t,r)])}}})),rb,Cr,Ir,zt,nb,Yt,Ar,kr,Qc,Er,Pr,zr,qn=W((()=>{zs(),Bs(),te(),bt(),Br(),Jn(),rb=(e,t)=>{0!==Ie()._OrtInit(e,t)&&he("Can't initialize onnxruntime.")},Cr=async e=>{rb(e.wasm.numThreads,Jt(e.logLevel))},Ir=async(e,t)=>{{let r=(Zc(),br(jc)).init;if("webgpu"===t){if(typeof navigator>"u"||!navigator.gpu)throw new Error("WebGPU is not supported in current environment");let t=e.webgpu.adapter;if(t){if("object"!=typeof t.limits||"object"!=typeof t.features||"function"!=typeof t.requestDevice)throw new Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let r=e.webgpu.powerPreference;if(void 0!==r&&"low-power"!==r&&"high-performance"!==r)throw new Error(`Invalid powerPreference setting: "${r}"`);let n=e.webgpu.forceFallbackAdapter;if(void 0!==n&&"boolean"!=typeof n)throw new Error(`Invalid forceFallbackAdapter setting: "${n}"`);if(t=await navigator.gpu.requestAdapter({powerPreference:r,forceFallbackAdapter:n}),!t)throw new Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}await r("webgpu",Ie(),e,t)}if("webnn"===t){if(typeof navigator>"u"||!navigator.ml)throw new Error("WebNN is not supported in current environment");await r("webnn",Ie(),e)}}},zt=new Map,nb=e=>{let t=Ie(),r=t.stackSave();try{let r=t.PTR_SIZE,n=t.stackAlloc(2*r);0!==t._OrtGetInputOutputCount(e,n,n+r)&&he("Can't get session input/output count.");let a=4===r?"i32":"i64";return[Number(t.getValue(n,a)),Number(t.getValue(n+r,a))]}finally{t.stackRestore(r)}},Yt=e=>{let t=Ie(),r=t._malloc(e.byteLength);if(0===r)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},Ar=async(e,t)=>{let r,n,a=Ie();Array.isArray(e)?[r,n]=e:e.buffer===a.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=Yt(e);let o=0,i=0,s=0,l=[],d=[],u=[];try{if([i,l]=Os(t),t?.externalData&&a.mountExternalData){let e=[];for(let r of t.externalData){let t="string"==typeof r?r:r.path;e.push(er("string"==typeof r?r:r.data).then((e=>{a.mountExternalData(t,e)})))}await Promise.all(e)}for(let e of t?.executionProviders??[])if("webnn"===("string"==typeof e?e:e.name)){if(a.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e,r=t?.context,n=t?.gpuDevice,o=t?.deviceType,i=t?.powerPreference;a.currentContext=r||(n?await a.jsepCreateMLContext(n):await a.jsepCreateMLContext({deviceType:o,powerPreference:i}))}else a.currentContext=await a.jsepCreateMLContext();break}o=await a._OrtCreateSession(r,n,i),0===o&&he("Can't create a session."),a.jsepOnCreateSession?.(),a.currentContext&&(a.jsepRegisterMLContext(o,a.currentContext),a.currentContext=void 0,a.shouldTransferToMLTensor=!0);let[e,c]=nb(o),p=!!t?.enableGraphCapture,g=[],A=[],h=[];for(let t=0;t<e;t++){let e=a._OrtGetInputName(o,t);0===e&&he("Can't get an input name."),d.push(e),g.push(a.UTF8ToString(e))}for(let e=0;e<c;e++){let r=a._OrtGetOutputName(o,e);0===r&&he("Can't get an output name."),u.push(r);let n=a.UTF8ToString(r);A.push(n);{if(p&&void 0===t?.preferredOutputLocation){h.push("gpu-buffer");continue}let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[n]??"cpu";if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e&&"ml-tensor"!==e)throw new Error(`Not supported preferred output location: ${e}.`);if(p&&"gpu-buffer"!==e)throw new Error(`Not supported preferred output location: ${e}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);h.push(e)}}let B=null;return h.some((e=>"gpu-buffer"===e||"ml-tensor"===e))&&(s=a._OrtCreateBinding(o),0===s&&he("Can't create IO binding."),B={handle:s,outputPreferredLocations:h,outputPreferredLocationsEncoded:h.map((e=>Xn(e)))}),zt.set(o,[o,d,u,B,p,!1]),[o,g,A]}catch(e){throw d.forEach((e=>a._OrtFree(e))),u.forEach((e=>a._OrtFree(e))),0!==s&&0!==a._OrtReleaseBinding(s)&&he("Can't release IO binding."),0!==o&&0!==a._OrtReleaseSession(o)&&he("Can't release session."),e}finally{a._free(r),0!==i&&0!==a._OrtReleaseSessionOptions(i)&&he("Can't release session options."),l.forEach((e=>a._free(e))),a.unmountExternalData?.()}},kr=e=>{let t=Ie(),r=zt.get(e);if(!r)throw new Error(`cannot release session. invalid session id: ${e}`);let[n,a,o,i,s]=r;i&&(s&&0!==t._OrtClearBoundOutputs(i.handle)&&he("Can't clear bound outputs."),0!==t._OrtReleaseBinding(i.handle)&&he("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),a.forEach((e=>t._OrtFree(e))),o.forEach((e=>t._OrtFree(e))),0!==t._OrtReleaseSession(n)&&he("Can't release session."),zt.delete(e)},Qc=async(e,t,r,n,a,o=!1)=>{if(!e)return void t.push(0);let i,s,l=Ie(),d=l.PTR_SIZE,u=e[0],c=e[1],p=e[3],g=p;if("string"===u&&("gpu-buffer"===p||"ml-tensor"===p))throw new Error("String tensor is not supported on GPU.");if(o&&"gpu-buffer"!==p)throw new Error(`External buffer must be provided for input/output index ${a} when enableGraphCapture is true.`);if("gpu-buffer"===p){let t=e[2].gpuBuffer;s=wt(Rt(u),c);let r=l.jsepRegisterBuffer;if(!r)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');i=r(n,a,t,s)}else if("ml-tensor"===p){let t=e[2].mlTensor;s=wt(Rt(u),c);let r=l.jsepRegisterMLTensor;if(!r)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');i=r(n,t,Rt(u),c)}else{let t=e[2];if(Array.isArray(t)){s=d*t.length,i=l._malloc(s),r.push(i);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw new TypeError(`tensor data at index ${e} is not a string`);l.setValue(i+e*d,Pe(t[e],r),"*")}}else{let e=l.jsepIsGraphInput;if("string"!==u&&e){let o=l._OrtGetInputName(n,a);if(e(n,l.UTF8ToString(o))){let e=Rt(u);s=wt(e,c),g="ml-tensor";let r=l.jsepCreateTemporaryTensor,a=l.jsepUploadTensor;if(!r||!a)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');let o=await r(n,e,c);a(o,new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),i=o}else s=t.byteLength,i=l._malloc(s),r.push(i),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,s),i)}else s=t.byteLength,i=l._malloc(s),r.push(i),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,s),i)}}let A=l.stackSave(),h=l.stackAlloc(4*c.length);try{c.forEach(((e,t)=>l.setValue(h+t*d,e,4===d?"i32":"i64")));let e=l._OrtCreateTensor(Rt(u),i,s,h,c.length,Xn(g));0===e&&he(`Can't create tensor for input/output. session=${n}, index=${a}.`),t.push(e)}finally{l.stackRestore(A)}},Er=async(e,t,r,n,a,o)=>{let i=Ie(),s=i.PTR_SIZE,l=zt.get(e);if(!l)throw new Error(`cannot run inference. invalid session id: ${e}`);let d=l[0],u=l[1],c=l[2],p=l[3],g=l[4],A=l[5],h=t.length,B=n.length,m=0,C=[],w=[],b=[],K=[],f=i.stackSave(),Q=i.stackAlloc(h*s),W=i.stackAlloc(h*s),F=i.stackAlloc(B*s),_=i.stackAlloc(B*s);try{[m,C]=Ps(o);for(let n=0;n<h;n++)await Qc(r[n],w,K,e,t[n],g);for(let t=0;t<B;t++)await Qc(a[t],b,K,e,h+n[t],g);for(let e=0;e<h;e++)i.setValue(Q+e*s,w[e],"*"),i.setValue(W+e*s,u[t[e]],"*");for(let e=0;e<B;e++)i.setValue(F+e*s,b[e],"*"),i.setValue(_+e*s,c[n[e]],"*");if(p&&!A){let{handle:r,outputPreferredLocations:o,outputPreferredLocationsEncoded:s}=p;if(u.length!==h)throw new Error(`input count from feeds (${h}) is expected to be always equal to model's input count (${u.length}).`);for(let n=0;n<h;n++){let a=t[n];0!==await i._OrtBindInput(r,u[a],w[n])&&he(`Can't bind input[${n}] for session=${e}.`)}for(let t=0;t<B;t++){let l=n[t];a[t]?.[3]?0!==i._OrtBindOutput(r,c[l],b[t],0)&&he(`Can't bind pre-allocated output[${t}] for session=${e}.`):0!==i._OrtBindOutput(r,c[l],0,s[l])&&he(`Can't bind output[${t}] to ${o[t]} for session=${e}.`)}zt.set(e,[d,u,c,p,g,!0])}let l;i.jsepOnRunStart?.(d),l=p?await i._OrtRunWithBinding(d,p.handle,B,F,m):await i._OrtRun(d,W,Q,h,_,B,F,m),0!==l&&he("failed to call OrtRun().");let f=[];for(let t=0;t<B;t++){let r=Number(i.getValue(F+t*s,"*"));if(r===b[t]){f.push(a[t]);continue}let o,l=i.stackSave(),u=i.stackAlloc(4*s),c=!1,g=0;try{0!==i._OrtGetTensorData(r,u,u+s,u+2*s,u+3*s)&&he(`Can't access output tensor data on index ${t}.`);let a=4===s?"i32":"i64",l=Number(i.getValue(u,a));g=i.getValue(u+s,"*");let d=i.getValue(u+2*s,"*"),A=Number(i.getValue(u+3*s,a)),h=[];for(let e=0;e<A;e++)h.push(Number(i.getValue(d+e*s,a)));0!==i._OrtFree(d)&&he("Can't free memory for tensor dims.");let B=h.reduce(((e,t)=>e*t),1);o=_t(l);let m=p?.outputPreferredLocations[n[t]];if("string"===o){if("gpu-buffer"===m||"ml-tensor"===m)throw new Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<B;t++){let r=i.getValue(g+t*s,"*"),n=i.getValue(g+(t+1)*s,"*"),a=t===B-1?void 0:n-r;e.push(i.UTF8ToString(r,a))}f.push([o,h,e,"cpu"])}else if("gpu-buffer"===m&&B>0){let e=i.jsepGetBuffer;if(!e)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let t=e(g),n=wt(l,B);if(void 0===n||!Mr(o))throw new Error(`Unsupported data type: ${o}`);c=!0,f.push([o,h,{gpuBuffer:t,download:i.jsepCreateDownloader(t,n,o),dispose:()=>{0!==i._OrtReleaseTensor(r)&&he("Can't release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===m&&B>0){let t=i.jsepEnsureTensor;if(!t)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(void 0===wt(l,B)||!Rr(o))throw new Error(`Unsupported data type: ${o}`);let n=await t(e,g,l,h,!1);c=!0,f.push([o,h,{mlTensor:n,download:i.jsepCreateMLTensorDownloader(g,o),dispose:()=>{i.jsepReleaseTensorId(g),i._OrtReleaseTensor(r)}},"ml-tensor"])}else{let e=new(Dr(o))(B);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(i.HEAPU8.subarray(g,g+e.byteLength)),f.push([o,h,e,"cpu"])}}finally{i.stackRestore(l),"string"===o&&g&&i._free(g),c||i._OrtReleaseTensor(r),i.jsepOnRunEnd?.(d)}}return p&&!g&&(0!==i._OrtClearBoundOutputs(p.handle)&&he("Can't clear bound outputs."),zt.set(e,[d,u,c,p,g,!1])),f}finally{i.stackRestore(f),w.forEach((e=>i._OrtReleaseTensor(e))),b.forEach((e=>i._OrtReleaseTensor(e))),K.forEach((e=>i._free(e))),0!==m&&i._OrtReleaseRunOptions(m),C.forEach((e=>i._free(e)))}},Pr=e=>{let t=Ie(),r=zt.get(e);if(!r)throw new Error("invalid session id");let n=r[0],a=t._OrtEndProfiling(n);0===a&&he("Can't get an profile file name."),t._OrtFree(a)},zr=e=>{let t=[];for(let r of e){let e=r[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}})),Ot,He,ar,cn,pn,ln,zo,Oo,Wt,Lt,ib,Yc,Xc,Jc,ep,tp,rp,np,Bo=W((()=>{Ge(),qn(),bt(),Sr(),Ot=()=>!!we.wasm.proxy&&typeof document<"u",ar=!1,cn=!1,pn=!1,Oo=new Map,Wt=(e,t)=>{let r=Oo.get(e);r?r.push(t):Oo.set(e,[t])},Lt=()=>{if(ar||!cn||pn||!He)throw new Error("worker not ready")},ib=e=>{switch(e.data.type){case"init-wasm":ar=!1,e.data.err?(pn=!0,zo[1](e.data.err)):(cn=!0,zo[0]()),ln&&(URL.revokeObjectURL(ln),ln=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=Oo.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out);break}}},Yc=async()=>{if(!cn){if(ar)throw new Error("multiple calls to 'initWasm()' detected.");if(pn)throw new Error("previous call to 'initWasm()' failed.");if(ar=!0,Ot())return new Promise(((e,t)=>{He?.terminate(),As().then((([r,n])=>{try{(He=n).onerror=e=>t(e),He.onmessage=ib,zo=[e,t];let a={type:"init-wasm",in:we};!a.in.wasm.wasmPaths&&(r||Zn)&&(a.in.wasm.wasmPaths={wasm:new URL("ort-wasm-simd-threaded.jsep.wasm",import.meta.url).href}),He.postMessage(a),ln=r}catch(e){t(e)}}),t)}));try{await Tr(we.wasm),await Cr(we),cn=!0}catch(e){throw pn=!0,e}finally{ar=!1}}},Xc=async e=>{if(Ot())return Lt(),new Promise(((t,r)=>{Wt("init-ep",[t,r]);let n={type:"init-ep",in:{epName:e,env:we}};He.postMessage(n)}));await Ir(we,e)},Jc=async e=>Ot()?(Lt(),new Promise(((t,r)=>{Wt("copy-from",[t,r]);let n={type:"copy-from",in:{buffer:e}};He.postMessage(n,[e.buffer])}))):Yt(e),ep=async(e,t)=>{if(Ot()){if(t?.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Lt(),new Promise(((r,n)=>{Wt("create",[r,n]);let a={type:"create",in:{model:e,options:{...t}}},o=[];e instanceof Uint8Array&&o.push(e.buffer),He.postMessage(a,o)}))}return Ar(e,t)},tp=async e=>{if(Ot())return Lt(),new Promise(((t,r)=>{Wt("release",[t,r]);let n={type:"release",in:e};He.postMessage(n)}));kr(e)},rp=async(e,t,r,n,a,o)=>{if(Ot()){if(r.some((e=>"cpu"!==e[3])))throw new Error("input tensor on GPU is not supported for proxy.");if(a.some((e=>e)))throw new Error("pre-allocated output tensor is not supported for proxy.");return Lt(),new Promise(((a,i)=>{Wt("run",[a,i]);let s=r,l={type:"run",in:{sessionId:e,inputIndices:t,inputs:s,outputIndices:n,options:o}};He.postMessage(l,zr(s))}))}return Er(e,t,r,n,a,o)},np=async e=>{if(Ot())return Lt(),new Promise(((t,r)=>{Wt("end-profiling",[t,r]);let n={type:"end-profiling",in:e};He.postMessage(n)}));Pr(e)}})),op,ab,mn,ip=W((()=>{Ge(),Bo(),te(),xr(),Jn(),op=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${t()}`)}},ab=e=>{switch(e[3]){case"cpu":return new qe(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!Mr(t))throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:n,dispose:a}=e[2];return qe.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:a})}case"ml-tensor":{let t=e[0];if(!Rr(t))throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:n,dispose:a}=e[2];return qe.fromMLTensor(r,{dataType:t,dims:e[1],download:n,dispose:a})}default:throw new Error(`invalid data location: ${e[3]}`)}},mn=class{async fetchModelAndCopyToWasmMemory(e){return Jc(await er(e))}async loadModel(e,t){let r;Ne(),r="string"==typeof e?await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames]=await ep(r,t),De()}async dispose(){return tp(this.sessionId)}async run(e,t,r){Ne();let n=[],a=[];Object.entries(e).forEach((e=>{let t=e[0],r=e[1],o=this.inputNames.indexOf(t);if(-1===o)throw new Error(`invalid input '${t}'`);n.push(r),a.push(o)}));let o=[],i=[];Object.entries(t).forEach((e=>{let t=e[0],r=e[1],n=this.outputNames.indexOf(t);if(-1===n)throw new Error(`invalid output '${t}'`);o.push(r),i.push(n)}));let s=n.map(((e,t)=>op(e,(()=>`input "${this.inputNames[a[t]]}"`)))),l=o.map(((e,t)=>e?op(e,(()=>`output "${this.outputNames[i[t]]}"`)):null)),d=await rp(this.sessionId,a,s,i,l,r),u={};for(let e=0;e<d.length;e++)u[this.outputNames[i[e]]]=o[e]??ab(d[e]);return De(),u}startProfiling(){}endProfiling(){np(this.sessionId)}}})),sp={};Zt(sp,{OnnxruntimeWebAssemblyBackend:()=>fn,initializeFlags:()=>ap,wasmBackend:()=>sb});var ap,fn,sb,up=W((()=>{Ge(),Bo(),ip(),ap=()=>{if(("number"!=typeof we.wasm.initTimeout||we.wasm.initTimeout<0)&&(we.wasm.initTimeout=0),!1===we.wasm.simd&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),"boolean"!=typeof we.wasm.proxy&&(we.wasm.proxy=!1),"boolean"!=typeof we.wasm.trace&&(we.wasm.trace=!1),"number"!=typeof we.wasm.numThreads||!Number.isInteger(we.wasm.numThreads)||we.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)we.wasm.numThreads=1;else{let e=typeof navigator>"u"?Nn("node:os").cpus().length:navigator.hardwareConcurrency;we.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},sb=new(fn=class{async init(e){ap(),await Yc(),await Xc(e)}async createInferenceSessionHandler(e,t){let r=new mn;return await r.loadModel(e,t),Promise.resolve(r)}})}));Ge(),Ge(),Ge();var hs="1.22.0-dev.20250306-ccf8fdd9ea",lT=Fn;{let e=(up(),br(sp)).wasmBackend;Ct("webgpu",e,5),Ct("webnn",e,5),Ct("cpu",e,10),Ct("wasm",e,10)}Object.defineProperty(we.versions,"web",{value:hs,enumerable:!0});
/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
var __WEBPACK_EXTERNAL_MODULE_onnxruntime_web_74d14b94__=Object.freeze({__proto__:null,get InferenceSession(){return Of},get TRACE(){return vr},get TRACE_FUNC_BEGIN(){return Ne},get TRACE_FUNC_END(){return De},get Tensor(){return qe},default:lT,get env(){return we},get registerBackend(){return Ct}});const base64decode=function(e){return atob(e)},utf8ByteToHex=e=>`<0x${e.toString(16).toUpperCase().padStart(2,"0")}>`,hexToUtf8Byte=e=>{const t=e.replace(/<0x|>/g,"");return parseInt(t,16)};class PriorityQueue{constructor(e=(e,t)=>e>t){this._heap=[],this._comparator=e}size(){return this._heap.length}isEmpty(){return 0==this.size()}peek(){return this._heap[0]}push(...e){return e.forEach((e=>{this._heap.push(e),this._siftUp()})),this.size()}pop(){const e=this.peek(),t=this.size()-1;return t>0&&this._swap(0,t),this._heap.pop(),this._siftDown(),e}replace(e){const t=this.peek();return this._heap[0]=e,this._siftDown(),t}_parent(e){return(e+1>>>1)-1}_left(e){return 1+(e<<1)}_right(e){return e+1<<1}_greater(e,t){return this._comparator(this._heap[e],this._heap[t])}_swap(e,t){[this._heap[e],this._heap[t]]=[this._heap[t],this._heap[e]]}_siftUp(){let e=this.size()-1;for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size()&&this._greater(this._left(e),e)||this._right(e)<this.size()&&this._greater(this._right(e),e);){let t=this._right(e)<this.size()&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,t),e=t}}}const BOS_TOKEN_ID=1;class LlamaTokenizer{vocabById;vocabByString;merges;utf8Encoder=new TextEncoder;utf8Decoder=new TextDecoder("utf-8");constructor(e,t){this.vocabById=this.decodeVocabulary(e||llama_vocab_base64),this.vocabByString=new Map,this.vocabById.forEach(((e,t)=>{this.vocabByString.set(e,t)})),this.merges=this.decompressMerges(t||llama_merges_binary)}getMergeIdentifierString(e,t){return this.vocabById[e]+" "+this.vocabById[t]}decompressMerges(e){const t=base64decode(e),r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);const n=[];for(let e=0;e<r.length;e+=2){const t=r[e]+(r[e+1]<<8);n.push(t)}const a=new Map;for(let e=0;e<n.length;e+=2){const t=n[e],r=n[e+1],o=this.getMergeIdentifierString(t,r);a.set(o,e+1)}return a}decodeVocabulary(e){const t=Uint8Array.from(base64decode(e),(e=>e.charCodeAt(0)));return new TextDecoder("utf-8").decode(t).split("\n")}mapCharactersToTokenIds(e,t,r){const n=[];t&&n.push(BOS_TOKEN_ID),r&&(e=" "+e);const a=e.replaceAll(" ",this.vocabById[29871]),o=Array.from(a);for(let e=0;e<o.length;e++){const t=o[e];if(this.vocabByString.has(t))n.push(this.vocabByString.get(t));else{const e=this.utf8Encoder.encode(t);for(let r=0;r<e.length;r++){const a=this.vocabByString.get(utf8ByteToHex(e[r]));n.push(a),a>=0||(console.log("Encountered unknown character "+t+" (partial UTF-8 byte "+e[r]+" + hex + "+utf8ByteToHex(e[r])+")"),n[n.length-1]=0)}}}return n}encode(e,t=!0,r=!0,n=!1){let a=null;if(n&&(a=performance.now()),!this.vocabById||!this.vocabByString||!this.merges)return void console.log("Tokenizer not initialized properly!");if(0===e.length)return[];const o=this.mapCharactersToTokenIds(e,t,r),i=new PriorityQueue(((e,t)=>e.mergePrio<t.mergePrio)),s=t=>{const r=this.getMergeIdentifierString(t.tokenId,t.next.tokenId),n=this.merges.get(r)+t.origPos/e.length;n&&(t.mergePrio=n,t.mergeToString=r.replace(" ",""),i.push(t))};let l={origPos:0,tokenId:o[0],prev:null,next:null},d=l;for(let e=1;e<o.length;e++){const t={origPos:e,tokenId:o[e],prev:d,next:null};d.next=t,s(d),d=t}for(;!i.isEmpty();){const e=i.pop();if(e.deleted)continue;if(!e.next)continue;if(e.next.deleted)continue;if(e.deleted=!0,e.next.deleted=!0,e.prev){const t=e.prev;t.deleted=!0;const r={origPos:t.origPos,tokenId:t.tokenId,prev:t.prev,next:t.next};e.prev=r,r.prev?r.prev.next=r:l=r}const t={origPos:e.origPos,tokenId:this.vocabByString.get(e.mergeToString),prev:e.prev,next:e.next.next};t.prev?(t.prev.next=t,t.prev,s(t.prev)):l=t,t.next&&(t.next.prev=t,s(t))}const u=[];for(let e=l;null!==e;e=e.next)u.push(e.tokenId);if(n){const e=performance.now();console.log("Tokenizer running time: "+(e-a)+" milliseconds")}return u}decode(e,t=!0,r=!0){const n=[];for(let r=t&&e[0]===BOS_TOKEN_ID?1:0;r<e.length;r++){const t=e[r],a=this.vocabById[t];if(a.startsWith("<0x")&&a.endsWith(">")){const e=hexToUtf8Byte(a);n.push(e)}else{this.utf8Encoder.encode(a).forEach((e=>n.push(e)))}}const a=new Uint8Array(n),o=this.utf8Decoder.decode(a).replaceAll(this.vocabById[29871]," ");return r&&" "===o[0]?o.slice(1):o}defaultTests(e){function t(t,r,n=!0,a=!0){const o=e.decode(t,n,a);if(o!==r)throw Error(`Decode test failed. Expected ${r}, actual was: ${o}`)}function r(t,r){const n=e.encode(t,!0,!0,!0);if(o=r,(a=n).length!==o.length||!a.every((function(e,t){return e===o[t]})))throw Error(`Test failed. LLaMA Tokenizer Encoder returned unexpected result: expected tokenize(${t}) === ${r}, actual was: ${n}`);var a,o;if(t!==e.decode(n))throw Error(`Test failed. LLaMA Tokenizer Decoder returned unexpected result: expected decode(${n}) === ${t}, actual was: ${decode(n)}`)}return r("grabbed",[1,2646,1327,287]),r(" grabbed",[1,29871,2646,1327,287]),r("           grabbed",[1,9651,2646,1327,287]),r("\n",[1,29871,13]),r(" \n",[1,259,13]),r("\ttabs\t\t\t\tout here",[1,29871,12,21175,12,12,12,12,449,1244]),r("ax\n####\nboo",[1,4853,13,4136,13,833,29877]),r("镇",[1,29871,30411]),r("🦙",[1,29871,243,162,169,156]),r("🦙Ꙋ",[1,29871,243,162,169,156,237,156,141]),r("Ꙋ🦙",[1,29871,237,156,141,243,162,169,156]),t([1,2646,1327,287],"grabbed",!0,!0),t([1,2646,1327,287],"<s> grabbed",!1,!1),t([1,2646,1327,287]," grabbed",!0,!1),t([1,2646,1327,287],"<s> grabbed",!1,!0),t([2646,1327,287],"grabbed",!0,!0),t([2646,1327,287]," grabbed",!1,!1),t([2646,1327,287]," grabbed",!0,!1),t([2646,1327,287],"grabbed",!1,!0),r('The llama (/ˈlɑːmə/; 🦙Spanish pronunciation: [ˈʎama]) (Lama glama) is a domesticated South American camelid, widely used as a meat and pack animal by Andean cultures since the Pre-Columbian era. Llamas are social animals and live with others as a herd. Their wool is soft and contains only a small amount of lanolin.[2] Llamas can learn simple tasks after a few repetitions. When using a pack, they can carry about 25 to 30% of their body weight for 8 to 13 km (5–8 miles).[3] The name llama (in the past also spelled "lama" or "glama") was adopted by European settlers from native Peruvians.[4] The ancestors of llamas are thought to have originated from the Great Plains of North America about 40 million years ago, and subsequently migrated to South America about three million years ago during the Great American Interchange. By the end of the last ice age (10,000–12,000 years ago), camelids were extinct in North America.[3] As of 2007, there were over seven million llamas and alpacas in South America and over 158,000 llamas and 100,000Ꙋ🦙 alpacas, descended from progenitors imported late in the 20th century, in the United States and Canada.[5] In Aymara mythology, llamas are important beings. The Heavenly Llama is said to drink water from the ocean and urinates as it rains.[6] According to Aymara eschatology, llamas will return to the water springs and lagoons where they come from at the end of time.[6]',[1,450,11148,3304,20374,30176,29880,30426,30215,29885,30184,29914,29936,29871,243,162,169,156,15495,728,11504,11173,362,29901,518,30176,31743,3304,2314,313,29931,3304,3144,3304,29897,338,263,21849,630,4275,3082,3949,295,333,29892,17644,1304,408,263,27654,322,4870,13019,491,1126,29872,273,4185,1973,1951,278,4721,29899,1625,3774,713,3152,29889,365,5288,294,526,5264,15006,322,5735,411,4045,408,263,902,29881,29889,11275,281,1507,338,4964,322,3743,871,263,2319,5253,310,10906,22878,7226,29906,29962,365,5288,294,508,5110,2560,9595,1156,263,2846,21159,2187,29889,1932,773,263,4870,29892,896,508,8677,1048,29871,29906,29945,304,29871,29941,29900,29995,310,1009,3573,7688,363,29871,29947,304,29871,29896,29941,2383,313,29945,29994,29947,7800,467,29961,29941,29962,450,1024,11148,3304,313,262,278,4940,884,805,14356,376,29880,3304,29908,470,376,3820,3304,1159,471,16356,491,7824,3604,9306,515,7531,25493,1403,550,7226,29946,29962,450,19525,943,310,11829,294,526,2714,304,505,3978,630,515,278,7027,13494,1144,310,4644,6813,1048,29871,29946,29900,7284,2440,8020,29892,322,17602,9725,630,304,4275,6813,1048,2211,7284,2440,8020,2645,278,7027,3082,4124,3167,29889,2648,278,1095,310,278,1833,14890,5046,313,29896,29900,29892,29900,29900,29900,29994,29896,29906,29892,29900,29900,29900,2440,8020,511,3949,295,4841,892,1294,5562,297,4644,6813,7226,29941,29962,1094,310,29871,29906,29900,29900,29955,29892,727,892,975,9881,7284,11829,294,322,394,29886,562,294,297,4275,6813,322,975,29871,29896,29945,29947,29892,29900,29900,29900,11829,294,322,29871,29896,29900,29900,29892,29900,29900,29900,237,156,141,243,162,169,156,394,29886,562,294,29892,5153,2760,515,410,1885,17259,19673,5683,297,278,29871,29906,29900,386,6462,29892,297,278,3303,3900,322,7400,7226,29945,29962,512,319,962,2518,22082,3002,29892,11829,294,526,4100,367,886,29889,450,22977,368,365,29880,3304,338,1497,304,13748,4094,515,278,23474,322,5065,262,1078,408,372,1153,1144,7226,29953,29962,7579,304,319,962,2518,831,13496,3002,29892,11829,294,674,736,304,278,4094,7689,886,322,301,4425,787,988,896,2041,515,472,278,1095,310,931,7226,29953,29962]),console.log("LLaMA Tokenizer tests passed successfully."),!0}runTests(e=this.defaultTests){e(this)}}const llama_vocab_base64="PHVuaz4KPHM+Cjwvcz4KPDB4MDA+CjwweDAxPgo8MHgwMj4KPDB4MDM+CjwweDA0Pgo8MHgwNT4KPDB4MDY+CjwweDA3Pgo8MHgwOD4KPDB4MDk+CjwweDBBPgo8MHgwQj4KPDB4MEM+CjwweDBEPgo8MHgwRT4KPDB4MEY+CjwweDEwPgo8MHgxMT4KPDB4MTI+CjwweDEzPgo8MHgxND4KPDB4MTU+CjwweDE2Pgo8MHgxNz4KPDB4MTg+CjwweDE5Pgo8MHgxQT4KPDB4MUI+CjwweDFDPgo8MHgxRD4KPDB4MUU+CjwweDFGPgo8MHgyMD4KPDB4MjE+CjwweDIyPgo8MHgyMz4KPDB4MjQ+CjwweDI1Pgo8MHgyNj4KPDB4Mjc+CjwweDI4Pgo8MHgyOT4KPDB4MkE+CjwweDJCPgo8MHgyQz4KPDB4MkQ+CjwweDJFPgo8MHgyRj4KPDB4MzA+CjwweDMxPgo8MHgzMj4KPDB4MzM+CjwweDM0Pgo8MHgzNT4KPDB4MzY+CjwweDM3Pgo8MHgzOD4KPDB4Mzk+CjwweDNBPgo8MHgzQj4KPDB4M0M+CjwweDNEPgo8MHgzRT4KPDB4M0Y+CjwweDQwPgo8MHg0MT4KPDB4NDI+CjwweDQzPgo8MHg0ND4KPDB4NDU+CjwweDQ2Pgo8MHg0Nz4KPDB4NDg+CjwweDQ5Pgo8MHg0QT4KPDB4NEI+CjwweDRDPgo8MHg0RD4KPDB4NEU+CjwweDRGPgo8MHg1MD4KPDB4NTE+CjwweDUyPgo8MHg1Mz4KPDB4NTQ+CjwweDU1Pgo8MHg1Nj4KPDB4NTc+CjwweDU4Pgo8MHg1OT4KPDB4NUE+CjwweDVCPgo8MHg1Qz4KPDB4NUQ+CjwweDVFPgo8MHg1Rj4KPDB4NjA+CjwweDYxPgo8MHg2Mj4KPDB4NjM+CjwweDY0Pgo8MHg2NT4KPDB4NjY+CjwweDY3Pgo8MHg2OD4KPDB4Njk+CjwweDZBPgo8MHg2Qj4KPDB4NkM+CjwweDZEPgo8MHg2RT4KPDB4NkY+CjwweDcwPgo8MHg3MT4KPDB4NzI+CjwweDczPgo8MHg3ND4KPDB4NzU+CjwweDc2Pgo8MHg3Nz4KPDB4Nzg+CjwweDc5Pgo8MHg3QT4KPDB4N0I+CjwweDdDPgo8MHg3RD4KPDB4N0U+CjwweDdGPgo8MHg4MD4KPDB4ODE+CjwweDgyPgo8MHg4Mz4KPDB4ODQ+CjwweDg1Pgo8MHg4Nj4KPDB4ODc+CjwweDg4Pgo8MHg4OT4KPDB4OEE+CjwweDhCPgo8MHg4Qz4KPDB4OEQ+CjwweDhFPgo8MHg4Rj4KPDB4OTA+CjwweDkxPgo8MHg5Mj4KPDB4OTM+CjwweDk0Pgo8MHg5NT4KPDB4OTY+CjwweDk3Pgo8MHg5OD4KPDB4OTk+CjwweDlBPgo8MHg5Qj4KPDB4OUM+CjwweDlEPgo8MHg5RT4KPDB4OUY+CjwweEEwPgo8MHhBMT4KPDB4QTI+CjwweEEzPgo8MHhBND4KPDB4QTU+CjwweEE2Pgo8MHhBNz4KPDB4QTg+CjwweEE5Pgo8MHhBQT4KPDB4QUI+CjwweEFDPgo8MHhBRD4KPDB4QUU+CjwweEFGPgo8MHhCMD4KPDB4QjE+CjwweEIyPgo8MHhCMz4KPDB4QjQ+CjwweEI1Pgo8MHhCNj4KPDB4Qjc+CjwweEI4Pgo8MHhCOT4KPDB4QkE+CjwweEJCPgo8MHhCQz4KPDB4QkQ+CjwweEJFPgo8MHhCRj4KPDB4QzA+CjwweEMxPgo8MHhDMj4KPDB4QzM+CjwweEM0Pgo8MHhDNT4KPDB4QzY+CjwweEM3Pgo8MHhDOD4KPDB4Qzk+CjwweENBPgo8MHhDQj4KPDB4Q0M+CjwweENEPgo8MHhDRT4KPDB4Q0Y+CjwweEQwPgo8MHhEMT4KPDB4RDI+CjwweEQzPgo8MHhEND4KPDB4RDU+CjwweEQ2Pgo8MHhENz4KPDB4RDg+CjwweEQ5Pgo8MHhEQT4KPDB4REI+CjwweERDPgo8MHhERD4KPDB4REU+CjwweERGPgo8MHhFMD4KPDB4RTE+CjwweEUyPgo8MHhFMz4KPDB4RTQ+CjwweEU1Pgo8MHhFNj4KPDB4RTc+CjwweEU4Pgo8MHhFOT4KPDB4RUE+CjwweEVCPgo8MHhFQz4KPDB4RUQ+CjwweEVFPgo8MHhFRj4KPDB4RjA+CjwweEYxPgo8MHhGMj4KPDB4RjM+CjwweEY0Pgo8MHhGNT4KPDB4RjY+CjwweEY3Pgo8MHhGOD4KPDB4Rjk+CjwweEZBPgo8MHhGQj4KPDB4RkM+CjwweEZEPgo8MHhGRT4KPDB4RkY+CuKWgeKWgQriloF0CmVyCmluCuKWgWEKZW4Kb24K4paBdGgKZXMK4paB4paB4paB4paBCuKWgXMK4paBZAphdApvcgphbgriloFjCmlzCnJlCml0CuKWgXRoZQphcgpsZQriloF3CuKWgXAKb3UKYWwK4paBZgriloFtCmVkCuKWgW8K4paBYgpvbQppb24KaW5nCmljCmFzCmVsCmVudAriloFpbgriloFoCm5kCmV0CuKWgWwK4paBbgpzdAriloF0bwpjaAriloFJCnJvCuKWgeKWgeKWgeKWgeKWgeKWgeKWgeKWgQppbAriloFvZgpkZQpjdAriloEoCmFtCuKWgUMK4paBZGUK4paBUwriloF1CuKWgUEK4paBXAriloFlCuKWgWFuZAriloFUCm9sCuKWgXYKaW0Kb3QKYWQKdXQK4paBZwplbQp1cgppZAriloEqCmlnCnJhCuKWgXJlCuKWgWlzCnF1Cm93CuKWgU0KZXN0CuKWgXkKc2UKdmUKY2UKaWUKdW4K4paBUAriloFCCmFnCnVsCuKWgT0KaGUKZW5kCm9kZQp0ZXIKbWVudApvcwriloFECmlmCmF0aW9uCuKWgWZvcgriloFyCuKWgUwK4paBeW91CuKWgWJlCmx5CnZlcgphYgp0ZQriloFpdAriloFvbgpyaQp1cwriloEiCuKWgXdoCuKWgWNvbgriloFICuKWgXN0CmlyCuKWgUUK4paBRgpjawriloFhbgp0aAplZwpheQppdGgK4paBUgppc3QKYW5kCuKWgXRoYXQK4paBYWwK4paBJAriloEjCm9kCnVtCuKWgVcKaHQKY29kZQriloFHCmF0ZQplc3MK4paBTgplcmUKcHAK4paBYXMK4paBc2UK4paBcHJvCuKWgXdpdGgKcGUK4paBawplcnMKcHQKKTsKbG8K4paB4paB4paB4paB4paBCuKWgWNvbQphbWUK4paBYAriloFDb20KaWEKYW50CuKWgWxhCuKWgXsK4paBZW4KY3Rpb24K4paBZXgKbGQKdWIK4paBagpsYQp1ZQriloFKCmljaAriloFkbwriloFPCuKWgXF1Cml2Cm9ydAphcnQK4paBdW4K4paBIyMK4paBdGhpcwprZQriloFoYQriloEtCm91dAriloFUaGUK4paBbm90CuKWgW5lCmlsbAriloFsZQpjaQpyb20KaW5lCi8vCm9wCmVnaW4K4paBQ29tbWVudAriloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloEKYmVnaW4K0YHRggphc3MKaXoKKS4Kb2cK4paB0L8K4paBb3IK4paBd2FzCuKWgWF0Cm91cgriloFpCmFpbgriloFLCtC90LAK4paBVgpnZQriloFzdQphcAphZ2UKb3VsZApuZQphdgp4dApvcmUKaWxlCi0tCuKWgdCyCuKWgWJ5CmxpCmF0aArRgNCwCmJlcgphY2gKYWxsCuKWgVRoCnVsdAriloF9CuKWgVUK4paBdXMK4paBegp1c3QK4paBaGF2ZQpsaWMK0L3QuAriloFjYW4KdHIKY29tCiksCuKWgUluCmluZAplbGwK4paBZnJvbQrQvtCyCnRvCuKWgVsKYWJsZQpvc3QK4paBY2gKZWN0CmlnaHQKaW50CuKWgScK4paBYXJlCuKWgWltCuKWgXNoCuKWgTwK4paBQW4K4paB0YEKYXRhCmlyZQriloF0cgpjb24Kb3JkCml0eQphcmQK4paB4paB4paB4paB4paB4paBCuKWgWhlCuKWgWJ1dApvYwo9IgriloFwcgp1cmUKcGVyCmFjawpvcmsKb25nCmFucwrQutC+CnBsZQriloFkZXMKb2sKb3JtCndlcgphawpwcgphc2UK4paBZWwKcGgKYWMK4paBdW5kCuKWgWFyCuKWgWlmCnVkCnBzCml0ZQpibGUK0L3QvgpmZXIKcGwKaXZlCmFuZwplbnMK0YDQvgriloFzbwpzbwphc3QKKCkKc3dlcgpydQppZXMK4paBOgphdQpvdgrRgNC1CtCz0L4K4paBZGVyCuKWgW15CuKWgXdlCuKWgW1lCm50CuKWgWFkCnVybgriloF5b3VyCjovLwphcmUK4paBYWxsCmZmCmlvCmVzdGlvbgppbWUK4paBZXIKbGFzcwriloHQuAriloF3aGljaApvbWUKb250CuKWgXBhcgriloFtYQriloFZCiIsCuKWgdC+CmZ0CmlhbApjYwpvdW5kCuKWgWxpCuKWgXJlcwpldGgKamVjdAriloFhcHAK4paBU3QKaWNlCuKWgWFtCmFjdAriloFkZWwKZ3IKYXRlZAppZXIK4paB4paB4paB4paB4paB4paB4paB4paB4paB4paB4paB4paBCuKWgWFiCuKWgWV0CmFsbHkKLi4KcG9ydAppawriloFwZXIK4paBY29udArRgNC4CtC60LAKc2VyCtC70LgKbGwKaWV3CmlnbgpfewpwdXQKb25lCnVuY3Rpb24K4paBZGkKYXJ5Cml0aW9uCm1hCtC10L0KZ2V0CuKWgWxvCuKWgXZhbAriloFRCnJhbgriloHQtAplbmNlCuKWgXdvcmsK4paB0L3QsAppcAppdGVtCnlwZQriloEmCuKWgWhpcwriloF1c2UKZGVyCuKWgUFuc3dlcgriloF3aWxsCml6ZQrRgtCwCmxvdwriloFDaAriloFnZXQKaWRlCm91cwppbmsKcHRpb24K0LvQsAp0dXJuCnVuZwplYwp1Zwpmb3JtCnJlcwpodHQKb3VnCtC70YwK4paBbm8KY2wK4paBcm8K4paBb25lCnR0CmNyaQpkdQriloF1cArRgtC+CigiCuKWgW9iCndlCm9yeQriloFlc3QKZXJ5CmllbApzdHIKb2IK4paBcXVlCmlhbgriloFvdXQK4paBcGwK4paBbmV3CtC60LgK4paBKwpyeQpvdGgKdGhlcgriloF2YXIK4paBd291bGQK4paBc2VyCnRlcm4KdGV4dAriloF0aGVyZQppc2gKcm9yCtGC0LUK4paBc2V0CuKWgUAK4paB0L/QvgriloF0ZQpleAriloFyZXR1cm4KYWlsCuKWgWFueQriloFJdAriloFmdW5jdGlvbgp7XAonLArDqXMKYWxlCtCw0L0K4paBd2hlbgppYgriloFnbwphbmNlCuKWgWhhZAriloFRdQriloFjb21wCtC70LUK4paB0LcKbWF0aAriloFoYXMK4paB0LwK4paBcHJlCmVuZXIK4paBcGFydAplbGYK4paBZGllCuKWgWxpa2UKcmF5Cmlyc3QK4paBZGlzCuKWgW1hbgpyaXQK4paBdGhlbgriloFjbGFzcwpwcm8K4paBcG8K4paBdXNpbmcKZWIK4paBY29kZQpvd24K4paBc29tZQpjZXMK4paBJFwK0LXRgApsZWN0CuKWgWF1CmlzY2gK4paBY29sCuKWgeKAkwp1cApvbnMK4paBYWRkCmlsZAppc3MKdmFsCm91bnQKbGVzCnZlbnQK4paB4paB4paB4paB4paB4paB4paB4paB4paB4paB4paB4paB4paBCuKWgVoKSW4Kcm93CmVhcgphdGlvbnMKYWgKcXVlCnVibGljCmFuawriloFzcAriloFXaAotLS0tCnNrCmV3CmFncwrRgtC4CmFubgriloHigJQKZXJ0CmFjZQpzY2gK4paBbmVlZAriloHDoAppZW4Kb3VnaArQvdC1CuKWgWRlZgppagplcm4K4paBd2hhdAriloFBcgp3bwptbAo8LwriloFSZQriloFlcwriloFpbnN0CmJvCmF6CuKWgSMjIwriloHQsQplcm0K4paBQWwKbGVkCtC00LAKdGVuCnNldArQu9C+CuKWgWNvbW0Kc2gK0LLQsAriloEvCuKWgWRhdGEK4paBLy8KXSgK4paBc3RyCm9zZQriloFVbgp2ZW4KU3QKLi4uCuKWgdChCnlzdAriloHCqwppY2sKaXgKcGFyCuKWgdGDCuKWgXdhbnQKbmcKb3RlCuKWgWdyCuKWgWR1CuKWgS4KdW5kCuKWgW9ubHkK4paBc2EKZWx5CnZlcnMK4paBZW50CikpCignCuKWgW1vZAphdmEKdG9uCuKWgXNob3VsZAplbWVudAriloFmb3JtCuKWgWFsc28K4paBc2MKaW5ncwriloFZb3UKw7NuCuKWgWtuCigpOwriloF8CuKWgXdlcmUKc3MK4paBUXVlc3Rpb24KaXNlCuKWgXRoZXkK4paBRGUKb25kCuKWgXNvbAriloFmb2wK4paBbW9yZQriloFoZXIK4paBXwriloHDqQphdGNoCmZ0ZXIK4paBY3JlCmxvY2sKdHJpbmcK4paBVGhpcwp6ZQphZG8KdWxsCmdlcgpiZQriloFvdGhlcgriloFUYWdzCnV0aW9uCmljdAriloFob3cK4paBeAriloFTZQriloFjaGUKY3JpcHQK4paBanVzdAriloFwb3MKYW5nZQppZmljCnJlZQp9fQriloF0aW1lCmFwcArQvdGLCuKWgWZpbGUKYXJrCmljYWwK4paBZmlyc3QK4paBaW50CuKWgdCSCuKWgUhlCnRhCnVtZW50Cm9ycwpsZW1lbnQKcmFjCuKWgWFnCuKWgWRvZXMKeW4KcmVhZAp1YWwK4paBTGUKeXMK4paBZW0K4paBbnVtCnZlbArQtNC4Cm92ZXIK4paBZGlmCmV0aG9kCuKWgUlmCuKWgXNwZQp5bQriloF0aGVtCuKWgWludG8K4paB4paB4paB4paB4paB4paB4paB4paB4paB4paBCuKWgWxlcwriloFpdHMKZXNlCmllbGQK4paBcHVibGljCuKWgdCfCuKWgWRlbgp5c3RlbQpvZgriloFvdmVyCi0+CuKWgWZpbApuYW1lCmluYWwK4paBaWwKYW1wbGUK4paBd2F5CmljYQrQstC+CmNlc3MKaXR0CnVjaAriloF3aGVyZQrQvNC4Cm9yZwpodHRwcwriloF2bwppZW50Cm92ZQriloF2YWx1ZQplbmcK4paBTGEKXnsKcmVmCmllZApFUgriloFzdGF0CmZpZwptZQriloF2b24K4paBaW50ZXIKcm9pZAphdGVyCuKWgXRoZWlyCuKWgWJldAriloFlaW4KfVwKIj4K4paBc3ViCuKWgW9wCuKWgWRvbgp0eQriloF0cnkK4paBUHJvCuKWgXRyYQriloFzYW1lCmVwCuKWgXR3bwriloFuYW1lCm9sZApsZXQK4paBc2ltCnNwCuKWgWF2CmJyZQpibGVtCmV5CuKWgWNvdWxkCuKWgWNvcgriloFhY2MKYXlzCmNyZQp1cnIKc2kK4paBY29uc3QKdWVzCn0kClZpZXcK4paBYWN0CuKWgWJvCuKWgdC60L4K4paBc29tCuKWgWFib3V0CmxhbmQKbWVyCuKWgWxpc3QKY2FsCuKWgWltcG9ydApjb2wK4paBbmEKbmEKOjoK4paBd2hvCuKWgWVycm9yCuKWgVgKYXRvcgpleHQK4paBYmVlbgrDqXIK4paBcnVuCnBvcwriloFjbAoqKgriloHQmgp1bGFyCmF1c2UK4paBcmVnCuKWgWtub3cK4paBc2VlCuKWgWhpbQpuaW5nCuKWgdC30LAKYXRlcwpmb3JlCmlvbnMK4paBaGVsCnV0ZQriloFyZW0K4paB0LPQvgriloFNYXIK0YDRgwp2aWNlCmlyZWN0Cm5lcgriloF1bmRlcgpyaWIKaHIK0YfQtQriloFBcwriloFlbmQKZW1iZXIK4paB0LAK4paBYXR0CmluYQpzb24K4paBZm9sbG93CuKWgVNjaApwZWN0CuKWgXJlbAriloFTbwriloFsb29rCmFiZWwK4paBcHJvYmxlbQriloF2YW4Kc3Ryb25nCmNvCnBvbgpjYQphZGEKIjoKY29uZAphbWIKfSwKcXVlc3QK4paBYXV0CuKWgXJlc3VsdAriloFtYXkKUmUKaHR0cAopOgriloFBbmQKcmVkCuKWgUhvdwpwbwrRgdC60L4KYXR0Cm91cApjZWQK4paBdHlwZQriloF0aGFuCuKWgWNvbnMKdWYK0YbQuAriloFxdWVzdGlvbgpyYXBoCmlnaAriloHQnAriloFodHQKaW5zCmRlbgriloFkYQriloF2ZXIKb2gK4paBPT4Kcml2CnVkZQriloFGb3IK4paBcmEKZnJhYwrQvNCwCuKWgWFmdGVyCn17CuKWgW1ldGhvZAoiKQphbXAKYXNoCuKWgXJlYwriloFkaWZmZXIKT04KYXgKYW1lbnQKb3VyY2UKQ29uCml0cwpOYW1lCm1hbgriloFiZWMKY2hlCuKWgUVuCmFqCuKWgWdlbmVyCklOCuKWgWlkCmFnZXMK4paBbG9jCmZvCmJyCuKWgXNoZQpQcm8K4paBdW5hCuKWgdC6CmV0YQpsb2cKb2xvZwriloFzdXIKYXJnCuKWgS0tCmt0CihcCm1pbgriloFsaW5lCuKWgXZhcmkK0YHRjwppY3MK0L3Rjwp2ZXJ5CmFkZAriloFvYmplY3QKSWQK4paBQnV0CuKWgWNhc2UK4paBbWFrZQriloFjYWwK4paBcGFzcwrRgdGMCmVzc2lvbgpuZXQKLiIK4paB0LMKw6RyCtC00LUKbm8KYXRpbmcKYXRvCmxpbmUK0LLQuAriloFFeAriloFhc3MK4paBdmVycwrQu9GPCuKWgWVkCnVtbgpvdGhlcgrRgdGC0LAKYXRpdmUKU3RyaW5nCuKWgWxvcwp3bgriloFhbnN3ZXIK4paBbGV0CuKWgXBlCmVudHMK4paBZmUKaW5jZQpuaQppZGVyCm93cwriloF0ZXN0CuKWgWhlcmUKcm9sbAriloFjYWxsCnJ1Y3QK4paBcG9sCmFpdAriloFiYWNrCmhvCkV4CnJlc3MKU1QKcmllZApkYXRlCtC10YIK4paBZGlkCnRpbmcK4paBRWwK4paBZGVtCikkCtC+0LLQsAp1cnJlbnQKbGFjZQpyaWdodApyZW4K0L/QvgriloFlYWNoCmN5CmJsb2NrCmRhdGEK4paBJQriloFhYwriloE9PQrDvHIK4paBcG9yCmFzawphcmNoCmFtZXMK4paBQ29uCtGH0LAK4paBb2ZmCuKWgWZpbmQKY29udAriloFub3cKd29yawphdGlvbmFsCmRkCmNpw7NuCuKWgdCQCmF1bHQKTGlzdAriloFleHQKdXJzCmFrZQp1bGUK4paBcG9pbnQKQVQKYXV0CuKWgXRyYW5zCuKWgWNvCuKWgXJlYWQK4paBdXNlZArRgdC60LgKYXJpCkxFCmV0ZXIKb3VuCmV2ZXIKc2VsZgppbmVkCmlkdGgKdXgKanMK4paBc3VjaAriloFJcwrDqWUKZnVsCuKWgWRpc3QK4paBYnUKaXRlbWl6ZQpDb250CmplCtGB0LgK4paBcHJvdgpiYgp3YXJkCmVzZW50CmVyc29uCmFua3MKd2gKbm90CuKWgVdlCmthCnJvcAphdHVyCmFscwriloFiZWwKw7ZyCmZyCuKWgWV4YW1wbGUK4paBaW5jbAphbWlsCuKWgdGA0LAK4paB4oCcCuKWgXN0cmluZwriloF0aGluawpUaAriloF0ZW0KYXZlCuKWgUZyYW4K4paBbnVtYmVyCuKWgXNpCmltZXMKdGVtCm15Cmxlcgpsb2FkCj09CuKWgWhhbmQKemEK4paBYmVjYXVzZQriloFzY2gKdm8KdGhpcwpJRArDo28K4paBc3RhcnQK4paBd2FyCuKWgWhlbHAKdHMK4paBY2hhcgriloFwaAriloFtaW4KdGlsCnJpdGUKLS0tLS0tLS0KZWxzCuKWgW1pdAplZGlhCtC60YMK4paBU2gKYW55Cl07CuKWgdCRCmlxdWUKZGEKZWYKZGV4CuKWgXByb2R1CuKWgdCdCmdyYW0K4paBT3IK4paBZ3JlCnF1b3RlCmxlZwpvcm4K4paBaW5kCuKWgXBvc3QK4paBZGVwCl0sCnZpCuKWgXVzZXIK4paBPgpsaWNrCuKWgXZlcnkKZXRoaW5nCuKWgWFycmF5CuKWgWd1CuKWgWR1cgpgLgrRgtGMCmxpY2F0aW9uCtGB0YLQuAplawppY28K4paBZGF0CtC+0YAKaHRtbAppb25lCuKWgWRpZmZlcmVudAriloFjaGVjawriloFmcgriloFFcgriloF0ZXh0CtC90ZYKaWNodApzdGFjawpFTgpyYWcK4paBZXZlcnkKQXIK4paBYmVmb3JlCmFsc2UK4paBZmluCuKWgWTDqQriloF0aGVzZQriloFkZXQKVmFsCmNlcHRpb24K4paBYW5kcm9pZApibG9ja3F1b3RlCuKWgWplCmZpbGUKYXRzCuKWgdC00L4KZXNzYWdlCuKWgWFnYWluCmF3CkNoCndlZW4K4paB0JQKZm9yCmNpYWwKcGxheQpwcmUKaWRhCuKWgVBhcgpueQpyYWN0CuKWgXN1cHAKYXNlZApsZWN0aW9uCuKWgWRhbnMKYWlyCnJvbAriloF0aHIKRGF0YQpsaWNoCuKWgdC/0YDQvgriloFsb25nCuKWgXNlY29uZAp1YWxseQppbmVzCuKWgWZvdW5kCmVuZ3RoCnlwCmVhZAriloFsb2cKdWkKbmV3CuKWgdCgCmdvCmF1cwpvZHkK4paBc29uCtC80LUKZXJvCnZlZApzdWIK4paBcmlnaHQKdmlldwriloFmb2xsb3dpbmcKJykKIik7CuKWgXNhaWQK0LbQtQrRh9C4CtGC0YMKb3R0CtGB0LUKYXJzCiQuCmdnCuKWgWJyCm9vbAp5bGUKdXNlCuKWgXNob3cKbGVhc2UKY2lhCuKWgWRpcmVjdApkb2MK0LDRgAptcwriloFnaXYK4paBZXhwCnFsCtC00YMK0LLQtQriloFCZQpDb20KaXRlcgpSRQptcAptZW4K4paBUm8KTUEK4paBQ29sCmlzdGVyCuKWgXdlbGwK4paBPC8KYXlvdXQKYXR1cmUKaXZlcnMKenkK4paB0L3QtQriloFtZXQKdW5lCnl0aApUeXBlCuKWgWVsZW1lbnQK4paBbGluawptb2QK4paBYmV0d2VlbgpjZXB0CnF1aXJlCuKWgXRocm91Z2gK4paBd2hpbGUK4paBT24KdGhlCsOtYQriloFzb21ldGhpbmcKdm9sCuKWgW1vc3QKc2MKdXNzCuKWgWNhcgriloFzbQriloHRgNC+CmFubwpsZWZ0CnZhCuKWgXRydWUKKCQKZW1zCuKWgW11Y2gKw6FzCuKWgU5ldwriloFwcm9wZXIKZXJhCml0ZWQK4paBZG9jCmljZXMKVGhlCuKWgT8K0YHRgtC+CmZsCuKWgXNwZWMKZW5kZXIKd2F5CuKWgXNlbGYK4paBZXZlbgrRltCyCuKWgdGB0LUK0L3QuNGPCuKWgVByCuKWgWtlCmVtYgriloF0YWJsZQriloFlcXUKbGllbnQKdGQKcGFydAriloFwcmludAriloF1bmUKaWZ5CuKWgS0+CmVuZQriloFtb24K4paBZGVjCuKWgXN0aWxsCuKWgdC+0LEK4paBVHIK4paB0YQKaWZlCmlzbQpieQpyYXcKaW9yCuKWgW1lZApvcmxkCuKWgWNvbXBsZQp3dwriloFhcnQKcm9uCuKWgdCTCuKWgU15CuKWgWFscwpyZWN0CuKWgWF1ZgriloFkb3duCmF0aGVyCkNvbApUZXh0CmJhY2sKJCwK4paBeWVhcgrQvNC+CnBpCuKWgUdyCnJlYW0K4paBcmVwCmJmCnd3dwriloF3dXIK4paBb3JnCmludGVyCuKWgURpZQriloFiZWluZwoiLgpsYWJlbAriloFjZW50CmphdmEKYmFyCmFudGUKYW5hCl9fCuKWgXNvbHV0aW9uCuKWgdCeCuKWgWZsCuKWgWNyZWF0ZQppY2kKc3RlCnl0aG9uCnVudAphc29uCmZlcmVuY2UKU0UK4paBbm9uCmFuZQriloFpbnMKYWRlcgpfe1wKUmVzCuKWgW1haW4K0L/QuAriloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloEK4paBVGhlcmUK4paBcG91cgpSTwpgLApsaXNoCmJqZWN0CmNjZXNzCuKWgW9yaWcK4paB4paB4paBCmlzY2hlbgpvd2VyCuKWgWhldAp1YwriloFlbHNlCsK7LgriloHQvtGCCmVxdQpzaWJsZQp0ZXN0CnN0YW5kCsOpbgpldHMKR0UKaWRlbnQK4paB0LUK4paB0L/RgNC4Ci4sCuKWgWRhcwpvY2sKLCIK4paBdm9sCuKWgWZvCuKWgXBhcmEK4paB0KIK4paBQ2FyCnJhbAriloFTcAp2YXIK4paBcGxheQpvdXNlCuKWgdGC0LAKaWNhbGx5CuKWgWNvbnRhaW4KcG9uc2UK4paBU3RyaW5nCsOhbgriloFib3RoCmtlbgpBUgrQtdGA0LUK4paBSWwK4paBaXNzCuKWgW9wZW4K4paBKQriloFXaGF0CmZlCnJpdmF0ZQpyZWcK4paBd2l0aG91dAriloF6dQp2aXMKZmxvdwriloFodHRwCmFiYXNlCuKWgXdvcmQK4paBY2hhbmdlCuKWgXdvcmtzCuKWgWdlCuKWgSEK4paBZWVuCml0bGUK4paBZXZlbnQKd29yZAphbmRvClNCCnJlbQriloFmaWVsZAp2aW5nClNlcgriloFvdXIK4paBcXVpCuKWgW9wZXIK4paBaXN0CmRlZgriloFtYWRlCtC90LjQtQpweAriloFtZW4Kcm0KYWlzCmNlbnQKbGlzdApUbwriloFUbwpqYQp2ZXJ0CuKWgW1hcgp2YWx1ZQriloHigJ4KIjsK4paBYXVzCuKWgUJyCm9sZQriloFtdWx0Cm91Z2h0CuKWgW1hdAriloF2aWV3CmZpbAriloHRgdC+CtCz0LAK4paBdm9pZAriloFnb29kCtCx0L4KQ1QK4paBbWFueQpiZW4K4paB0LLQvgriloHQutCwCuKWgXN5c3RlbQppbm8K4paBYW5vdGhlcgriloFyZXN0CnVzZXIKaWxpdHkKYWkK4paBbWlnaHQKdXN0b20K4paBb3JkZXIK4paBVmVyClNTCn0pCuKWgWVmZgrQtNC+CmV0dAriloFzaWduCtC80YMKSVQKc3RyaW5nCmVsbGUK4paBc2luZwpjdWwK4paBdHJ5aW5nCuKWgWJlZwriloFwYWdlCtGF0L4K4paBQ2FuCuKWgVNlcgorKwriloFtdXN0CuKWgXZhbHVlcwriloFrZXkKaWJsZQpdLgppcmQK4paBcHJvZ3JhbQpyb2xsZXIK4paBY29ubmUK4paBc2F5CuKWgXBhcmFtCmFjaGUKdmVsb3AK4paBc2VsZWN0CuKWgWZhbWlsCuKWgWxhc3QK4paBVGhhbmtzCuKWgXBvcAp9LgplcQriloFkb2VzbgpbJwriloF0ZXJtCuKWgXLDqQriloFkb2N1bWVudArQv9CwCtC70YMKYXRlZwouKQpsaW5nCmlvbmFsCmFibGVzCuKWgXRhawp1dHRvbgriloFhcmcKdHlwZQriloFzdXJlCuKWgXJlYWwK4paBd2ViCuKWgWN1cnJlbnQK4paBUGwKY2hvCm1lbnRzCuKWgUpvaApvdHMK4paBZXhpc3QK0L3RgwriloFmw7xyCuKWgdC40LcKZG8K0L3QvtCz0L4K4paBbGFzCuKWgW51bGwK4paBaW5mb3JtCuKWgdCbCuKWgXZlcnNpb24K4paBY2hhbmcKYWdlcgriloFDb21tCtC70ZYKdXNoCuKWgUdlCuKWgWhpZ2gK4paBaW5wdXQKb2dsZQpyb3MKYm94CmdlbgriloFzdGUK4paBbG9jYWwKSW0K4paBcHJvY2Vzcwp0ZXJuYWwKaXplZArQs9C4CsOpdAriloFJbmQK4paBb2NoCmx0CuKWgWNvbHVtbgriloF0cmllZAriloFjb21tYW5kCuKWgWJlc3QKYXN0ZXIK0LfQsAriloFwcmltCuKWgW1vZGVsCuKWgdGWCuKWgXRob3NlCml0aWVzCsOocmUK4paB0YDQtQrRmNC1CtGI0LgKcXVlcwriloFBbQriloFvd24KbGluCtC30LgKVmFsdWUKdGhpbmcK4paBLAriloFUZQriloFzdHVkCuKWgXVtCuKWgXNlcnZlcgppbGxlCuKWgXB1dAphdGl2Cmd5CtC+0LLQuApyYWYK0L7QstC+CuKWgXd1cmRlCuKWgVdoZW4K4paBZGl2CmFudHMK4paBdGVyCuKWgXBhcnRpYwriloHRggriloFEbwriloFObwpzZXJ0CmlkbwptYXRoY2FsCmFkZQriloFJSQpsZWFyCm9ncmFwaAplbnNlCuKWgXJvdwpudW0K4paBcG9zc2libGUK4paBc2luY2UK4paBQm8KY3Rpb25zCuKWgUltCk9SCtGG0ZYK4paBaWRlCm1hcAriloFjb3JyZWN0CnZlcwpwaHAK4paBb3V0cHV0CuKWgVBoCkFMCmFyZWQKXFwK4paBaW1hZ2UKZXNjaArQttC4CuKWgWNvbmYKcG9yCnF1ZXJ5CnVyZXMKaXVtCmVuZHMK4paBQWIKU0JOCtGW0LQKZXRoZXIKcHRpb25zCml0dQpsaWIKbnMKa2kK4paBd29ya2luZwriloFjb21vCuKWgVRoZW4KTUwKa2V5CmNsYXNzCm9wbGUKaXR0bGUK4paBbWF0Y2gKd2F5cwptYXRoYmIK4paBcmVxdWlyZQphbHQK4paBdmlzCuKWgWJsCuKWgWNhbGxlZApJdGVtCnVyYQp2ZWMKZW1lCuKWgWRlbGxhCmVtYnJlCnVyZwpTZQriloFyZXF1ZXN0CmlzY2hlCuKWgXBvcnQK4paBaW5zdGVhZAo9XAriloHQowpob3IKZW50ZQp1bWUKZXJkCtGB0LAK4paBd2h5CnJpc3QK4paBcGVyc29uCuKWgS4uLgriloFwcml2YXRlCuKWgXRvdApwaGEKaWZ0Cml0YQpsb2MK4paBb2xkCtC+0L0K4paBbmVsCiddCnRpCmlldApjaXRlCnBsZW1lbnQK4paBYWJvdmUKa3MKcmVhZHkK4paBY29tZQpzZWN0aW9uCuKWgVBvbAriloF3cml0CuKWgWh0dHBzCuKWgSQkCuKWgcK7CuKWgWJ1aWxkCml0bwriloFjb25zaWRlcgphZnQKQXBwCixcCmluZG93cwpjb21tCuKWgTsKZ3JvdW5kCuKWgXBsYWNlCkJ5CuKWgXByb2plY3QKT2JqZWN0CuKWgXJlcHIKZW5jZXMKaW5kb3cKenQK4paBZmlsZXMKY3oKaXZpdHkK4paBaW5pdAriloFwcm9iCuKWgXNrCm9ydGgKaW1lbnQKb3VibGUKYXRhbAppcmMK4paBw6gK4paBYnJlCmlzdGEKaW5wdXQK4paB0JgK0L3QvtC5CnN1bQpwYXRoCuKWgWNvdXIK4paBdG9vCuKWgUFkCuKWgUd1CuKWgWZhbHNlCuKWgWZ1bgriloHRgdGCCm9vZArDqHMK4paBZW5jCmJvbApybAphcmdldApvcmRlcgriloFtZWFuCtC/0LUKaWdlbgriloHQv9GA0LUKd2lkdGgKOw0KaXRvcgriloFzdGF0ZQriloFncmVhdAplbm4KYmluCkVyCk1vZApvegriloF3b24K4paBZmFjdAriloFqYXZhCuKWgVVuaXZlcnMK4paBY2FwCmlzdG9yCn0oCmt1Cml0aGVyCmFsZXMK4paBb3UKcm9zcwriloF0YWtlCnJpeApsb2IK4paBZWluZQphc2VzCuKWgWFjY2VzcwppdMOpCmlzdHIKaXphdGlvbgriloFhcHBybwpiYWxsCuKWgW1hawp9XgriloFDb25zCnByZXNzCnNlcnYKKCkuCmFmCuKWgXJlZgopXAriloFjb250aW4Kc3UKaXZlcgriloFjb25kCuKWgWV4cGVjdAriloFjaGFyYWN0CmJlcnQKZWx0CnRlcnMKc2NyaXB0CuKWgUVkCmFwdAonKTsKcHJpbnQK4paBc2l6ZQriloFzaWNoCmZhY2UKZW5kZW4K4paBQW1lcgppZmllZArDs3cK4paBU3UKdGVzCm1lZAriloFSZWcKc29sZQriloFpbmNsdWQKaW5pCmluY2kK4paBcGxhCuKWgWxlZnQKZGYKUGFyCuKWgUFsbAriloFvY2MK4paBQXQK4paBY3IKUXUK4paBZ2l2ZW4K4paBU3lzdGVtCmljYW4K4paBZmluYWwKaXRpb25zCuKWgdCx0YsK4paBcGVyZm9ybQpBTgriloFNZQp1cm8K4paBVGhhdArQs9GA0LAK4paB0J/QvgriloHQstC4CmFibHkK4paBcHJlc2VudApkdWN0CnJpYwriloFFbmcKdHJ5CuKWgWxhcgpibAppZGQK4paBw6RyCm9yYQpMTApvc3MK4paBSVNCTgriloF0aHJlZQpqbwpuw60KcmMK4paBZmFyCuKWgU5vdAriloFsaXR0bGUKZGlzCmF0aQpmdW5jdGlvbgriloFhYmxlCmxlc3MK0YHQvgriloFwYXRoCuKWgXByZXMKbG9zZQpQSQriloFpc3N1ZQphY2thZ2UKdGltZQppZ2UKYW1zCuKWgUNsCmFpbHMKYWxrCmlpCtGI0LUKcGVuClFMCuKWgWVhcwpSTApjZWwK4paBc2wK4paBYXNrCuKWgW5vbQriloF0b3AKaWRlcwppbmRleArDqW0K4paBaGFwcApveApjZAriloFiZXR0ZXIK4paBbG9hZAphZG9zCnplbgriloFjZQriloFmYQriloFKb2huCklNQQriloFCYXIKb3ZlcmZsb3cK4paB0LTQtQpuZXNzCmNlcgriloFIZXJlCnJldAriloFzegphbWJkYQpvcHkKdXJsCnB5CnJ0CuKWgXVuZGVyc3RhbmQKYcWCCmhlcgojIwriloFjaGlsZAriloFleGVjCuKWgWFwcGxpY2F0aW9uCuKWgXN0cnVjdAriloHRjwpGaWxlCuKWgWNlcnQKaXNvbgriloF2YXJpYWJsZQpERQpycwriloFyZWFsbHkKUG9ydApiYQriloFCZXIK4paBaW50ZQriloFzdGF0aWMK4paBY29uZmlnCuKWgVNoZQplc3Rpb25zCuKWgXBsdXMK4paBaGFiCm9wZQriloFtdXMK4paBY291bnQKTUUK4paBc3VwcG9ydAriloFwZW9wbGUK4paBYmVoCuKWgWFscmVhZHkKVHIK4paBZG9uZQpkZW0Kc2l6ZQphbHBoYQriloFkaXNjCl0pCuKWgU1hbgriloFtaWwK4paBc3RhbmQK4paBZ3JvdXAK4paBc21hbGwK4paBbWFnCtGB0YLRjAriloFkZWZhdWx0CuKWgXNpbmdsZQpsaW5rCmNsdWRlCuKWgWVhcgppbGFyCioqKioK4paBZml4CmxleQriloFwYXMK0L3QuNC5Cmlzc2lvbgriloFpbXBsZW1lbnQKaXRjaAriloHQs9C+0LTQsAriloFhbHdheXMK4paBSmFoCnByaW5nCsOnw6NvCnBsYXRlCuKWgWRlc2NyaQriloFoZWFkCmluaXQKb2dyYWYK4paBcXVlcnkKaXZlZAriloFpbmcKcHR5CmhhCuKWgW1vdgriloHRjQpldHRlCmlseQriloFnb3QKaWxlZAppY3JvCuKWgXdyCtGA0Y8K4paBbmV2ZXIKb3JlcwriloFiYXMKaW9zCmxhY2sKYWludAp2aW91cwriloFnaXZlCmlkYWQKRW4K0L3Ri9C5CnRhYmxlCuKWgdCd0LAK4paBcGF0CtGC0L7RgAphbmd1CmxveQriloFzZWcKYXJyYXkK4paBRmwK4paBaW5kZXgK4paBc3cKSU1BR0UK4paBa20K0LHQuApDbGFzcwplbmEK0LzQtdC9CmNvbXAKYXR1cwpyYXAK4paBTGlzdApFcnJvcgriloF0eXAK4paB0LzQsApjcwonOgpqaQriloFIb3dldmVyCuKWgdGC0LUK4paBYmVsb3cK4paBQXBwCtGJ0LUKfV8KYnVtCnZpcgrDqWVzCuKWgXJlY29yZAp0YWluCmxlbQppdGFsCuKWgWltcAplZ28K4paBb2QK4paBcmVjZQptaXQKZmZpYwpzdGFja292ZXJmbG93CmlldmUK4paB0JcK4paBbm92CtGG0LUK4paBSW50ZXJuCmJ1CuKWgXN1Z2cK4paBbG9vcApyaWRlCuKWgSQoCuKWgXN1cGVyCnJpZArQvdGL0YUK4paBUGVyCuKWgWRvbQo9Jwp1dHNjaApsZW4K4paBd3JpdGUK4paBaW52Cm91dGgK4paBSGVyCuKWgXllYXJzCuKWgW9yaWdpbmFsCmVnYQriloFTdGUK4paBc2VlbXMKw6lnCuKWgW5leHQKZWRlcgriloFOZQphdmFzCmlmaWNhdGlvbgpFeGNlcHRpb24K4paBRGVyCuKWgXZlCmF0aWMKaGF0CmJyYXJ5CnJldHVybgp1cmNoCmlzaW9uCm1pCm9pbnQK4paBZGF5CmljdGlvbgrDoWwK4paBw6lzCuKWgXRob3VnaAphY3Rpb24Kw610CnVuZ2VuCm91cnMK4paBc2NyaXB0CuKWgWluZm9ybWF0aW9uCuKWgW11bHRpCuKWgVxcCnN0ZXIK0LrQtQpBQwpjaWVzCuKWgWRpc3BsYXkKb21hbgpUaW1lCml1cwopKTsKdHJlCuKWgWxpbQphdGVseQrDqWQKaXN0ZQriloHRgdCwCnBvc3QKdWVsCmltZwriloHRhwrRgdC60LAKZWxkCnBwZXIKdWxhCuKWgWdlbmVyYWwKQWwKRm9ybQriloF1cG9uCnpvCmFtZW50ZQriloFwcm9tCuKWgcO8CmxleAriloF0dXJuCuKWgdC80LUKZW50aW9uCtC70LXQvQriloFhZgppY2xlCtGB0YLQsgriloFGaWwK4paB0KQKYXZhc2NyaXB0Ck1hbgphcmEKd2FyZQphbGlnbgphbmdsZQriloFTYwp1bmljCuKWgWZyYW4KVW4KemkKbWV0CkFkZAriloFwdWIK0LrQvtCyCuKWgWdlbgriloFwb2QK4paBc3VtCuKWgWhhdmluZwriloFhdmVjCnNsCuKWgWZpZwriloFSZXMKRGF0ZQp1bGVzCndpdGgK0YHQutC40LkKZ3UKRVQK4paBYnJvCnJpZQphcHMKZW5kaW5nCm1haWwKb29rCuKWgXN1Y2Nlc3MKYmVyZwriloFkZWIKZWx0YQooKWAKZW50aWFsCmZyYW1lCktleQppbm4K4paBc2ltcGxlCml2YWwK4paBY2FyZQriloFXZWIKIikuCj48LwriloFkYXRhYmFzZQriloFOb3cKSW5kCuKWgdC80L4KY2h0CmJhbgpyYW0KZXF1YXRpb24Kc2tpCmllZgpsaW0KR2V0CuKWgXRyZQphdGVuCmJlZAriloFKZQriloFyZXN1bHRzCtC70Y4K0YLQtdC70YwKZGIK4paBYml0CmJvZHkKQXJyYXkKbXUKcHJlc3Npb24K4paB0YHRgtCwCm9ueQppZmYK4paBYmFyCuKWgUFyY2gKYmVycwopewriloFNb24K4paBZG9pbmcK4paBcHJvZgriloFpbnN0YWxsCuKWgXBvc2l0aW9uCmVtYQriloF9KTsKUGF0aAphbGkK4paBJiYKbGV2CuKWgWNhbm5vdAriloFNYXkKaW5zdAotXAriloFjb3VuCuKWgWFuZwriloFhcHBlYXIKY29yCmNpw7MKaWRlZApxdWVzdGlvbnMKYXR0ZXIK4paBUGEKc2VsZWN0CuKWgXByaW5jaQpFdmVudAriloFzaWRlCuKWgW1lbQriloFKYW4KYXJpbwriloF3aXRoaW4K4paBVmFsCm9kZXMKaWRkbGUKdXJhdGlvbgpicmEK4paBZGF0ZQpbXQriloFlbnRyZQppbGkKUG9ydGFpbApkb2NzCtGB0LrQvtC5CkVsZW1lbnQK4paBbWVzc2FnZQriloFuYWNoCuKWgWR1cmluZwriloFncmEKZXR3b3JrCuKWgUJ5CuKWgXRlbGwKZXRlCn5cCuKWgWJpcwriloFwdQriloFyZWQK4paBdGhpbmcK4paBc29ydAp4aW0KaXJlcwpVc2VyCmlvZAriloFFc3QKb3NlZApvdXRlCuKWgUxlcwriloFzZW50CnJpYnV0ZQp1dGVzCmlzdG9yeQriloFzZXJ2aWNlCic7CmZpZWxkCuKWgUlOCmVuc2lvbgpyZWwK4paBZ29pbmcKd2ViCkNvbnRleHQK4paBbGF0ZXIKdWsKbGF5b3V0Cm9uYQrDoXQKLS0tLS0tLS0tLS0tLS0tLQriloFleGFjdAphbmRvbQriloFzaWUKSUkK4paBVGhleQptZW50ZQppYmxpCuKWgWZpbmUKVVQK4paBZGV2ZWxvcAriloFFaW4Kc29mdApvZmYKU2V0CuKWgWF6CmV0ZXJzCmlsZGVyCnBsZXMK4paBc3BlY2lmaWMK4paBb20KZXJyb3IKZW50bHkK4paBZmlsbQp1Y2sKYWlucwphY2nDs24KZ2VzCtC20LAK4paBdGhpbmdzClNoCuKWgXRob3VnaHQK4paBYWRkZWQKZGVwCtGB0LrQvtCz0L4K4paBTGkKaWxzCnluYwriloHRgtC+CnJpZXMK4paBY3UKY2hlbgpJT04K4paBRGVzCnVsdGFkbwppcnQK4paBYmFzZWQK4paBbW8K4paBZGVzdApwbmcKcmVlbgriloFydW5uaW5nCmFtbWEKb3VkCuKWgXJlZmVyCmlvdXMK4paBSnVsCuKWgXNlYXJjaAphbGQKZWRlCuKWgXdyb25nCkFuCuKWgXVudGlsCnNpdGUKYXllcgriloFvbmNlCmFycgriloFhZ2FpbnN0Cj09PT0K4paBc291cmNlCmFybgphcGkK4paBcmVwcmVzZW50CuKWgWFmZgriloFzZWluCuKWgWFsbG93Cm9ybWFsCmVuZGVkCuKWgWNvbnRyb2wKbWF0aGJmCmNvbWUKY3VyCmVuZG8Kd2EK4paBdXBkYXRlCuKWgWluc2lkZQriloFyZWFzb24Kb21lbgriloHQstGLCkRlCuKWgdGY0LUKc3cK4paBc2V2ZXIKT2YK4paBaW5zdGFuY2UK4paBbWVyCuKWgWVmZmVjdApjb2xvcgp1Z3VzdAppbHQKZGVzCml0egp1bGF0aW9uCm5pZQriloFXb3JsZAriloFzaW1pbGFyCnltYm9sCmhpbmcK4paBbWFyawpTdGF0ZQriloFjb250ZW50CuKWgW1lYW5zCmFtZWQK4paBRW5kCk5ECmNvdW50CuKWgUluc3QKcGVydHkKY3RvcgriloF7XAriloFMZXQK4paBIT0K4paBZ2V0dGluZwp1dGgKdW1iZXIK4paBQ29uc3VsdGFkbwpzY2hhZnQKbGV0ZQriloFXaWxsCuKWgUVtCmhlYWQK4paBbGVnCtC90L7QvApPcgphcm0KcG9uZAriloFDaHJpc3QK4paBYXJvdW5kCuKWgWNsZWFyCuKWgWhyZWYK4paBU2VlCicpLgriloFjcmVhdGVkCuKWgWJ1dHRvbgppbmluZwriloFjbGljawppYW0KcGxpdApGb3IK4paBcG9saXQK4paBc2VlbQriloFsaWZlCtC90L7QsgriloFpbnRlcm4K0YnQuApzZWwKc29jaQriloFzdG9yCmNsZQplYXJjaAphbmRyb2lkCn1eewriloFlaXRoZXIK4paBZmV3CuKWgWluaXRpYWwKbGVuZ3RoCnJpYQpzcWwKd2lrCuKWgcOpdAp1ZXIK4paBdmFsaWQKQW5kCmluY2x1ZGUKdXJ5CuKWgXN1cwppcmVkCuKWgUFmdGVyCuKWgWR1ZQriloFiZWkKb3VyY2VzCuKWgU5vdgpBY3QK4paBQ29udAriloFicmVhawplc3RlZAriloFhY3R1YWxseQplbHNlCnRtbApyZXIKb25lcwriloFkZXNpZ24K4paBcHJvcGVydHkKcGhpCmFsaXR5Cm9jaAppc3RzCuKWgcK3CnVkaW8KQUIKYWxhCmlvbmVzCtGE0LgKZmluZApBcwriloFjdXN0b20K4paBYW5uCkVTCk9UCmxhbWJkYQriloFpZGVudAriloFvcmdhbgriloFDZW50CuKWgUNoYXIK4paBb3MK4paBaGFyZArRgNC+0LIK4paBLz4Ka28K4paBZXhwZXIK4paBc2VwYXIKeWwKb3VybgriloFkZXYK4paBYXVjaAriloFibG9jawpib29rCuKWgW1hcAppbGxhCuKWgWNvbXB1dAriloFzcGFjZQpyZXN1bHQKKX0K4paBZWNobwpjb25maWcKaGkK4paBbGFyZ2UK4paBd2lkdGgK4paBR28KbWF0CuKWgWRpZmYK4paBa2luZAphbmNlcwp5bmFtCuKWgWNvbG9yCkludApzb2wK4paBcGkK4paBY2hhcmFjdGVyCm9tZW50CuKWgXJlc3BvbnNlCmlnbWEKd2FyZHMKYXJyb3cK0YHRgwp0aWVzCuKWgcO8YmVyCkltYWdlCnlkCuKWgdC/0LXRgNC1CuKWgW5vZGUK4paBaXRlbQphY2hpbmUKaW1hCuKWgXZhCuKWgWFwcHJvYWNoCuKWgXdlcgriloHRh9C1Ck9uCm9sbG93CtC+0L3QsApjdGVkCnVyZWQKQ29udHJvbGxlcgpsaWVkCuKWgWpvCuKWgWRhbAp1bmsK4paBw64Kc3RhcnQKb2xhCuKWgWNvbXBvbgpJQwpiaXQK4paBYmFzZQrQv9GDCuKWgWlkZWEK4paBZGlyZQriloFyYWQKZ3JvdXAK4paBV2l0aApzZXJ2ZXIKc2lkZQpzaW5nCuKWgWRpZXMK4paBbmVhcgriloF2b29yCuKWgWFyZ3VtZW50CuKWgX0sCuKWgWxhbmQK4paBbmFtZXMK4paBb3B0aW9uCml0aHViCnBwZWQKYXVnCuKWgWxpbmtzCuKWgWZ1bGwK4paBc2l0dQriloFjb25zb2xlCuKWgWV0YwphdXgK4paBQ29yCmljcm9zb2Z0CuKWgWNhbWUKbG9jYWwK4paBa25vd24K4paBbXVsdGlwbGUKYW5ndWFnZQriloF0b3RhbApvbG9neQrDpHQK4paB0KUK4paBZnJlCuKWgXRlbgppZGVvCuKWgWJlcwp0cnVlClF1ZXJ5Cm9tbQriloFBcnQK4paBa2VlcAriloFVbml2ZXJzaXR5CnJlYXRlCnBwb3J0CuKWgXB5dGhvbgp0cmEKZWN0b3IK0YDRlgpvcGgK4paBY29uYwriloFmb3VyCnZpcm9uCuKWgXZpYQo/IgppbWFnZQpvbGwK0L3Ri9C1CuKWgWNvbnRleHQK4paBc2VtCi5fCuKWgWVuZwptYXIKQUQK4paBbW9yCuKWgUNhbAriloFjZWxsCmltYWwKQVRFCuKWgWluZgrDtm4KdWZmZXIKc3EKLi4uLgriloF6dXIKV2l0aArRgNCw0L0KY2huCuKWgWRvb3IKY29udGVudAriloFtaXNzCuKWgXNpbXAKw6FyCmlyYQriloFoYXQKVGVzdAriloFjZXJ0YWluCk5TCuKWgWNobwriloFhZHYKd2hlcmUK4paBbG9va2luZwriloF0aW1lcwrQvdC40YUKdXRvCuKWgcOJCmNhbgpob3N0CuKWgSgqCmxvYXQK4paBbmljaHQKRmllbGQKYnVyZwpjb25zdAphZGVzCuKWgU11cwriloFub3RoaW5nCuKWgWluY3JlCuKWgU1pbgriloFwb3dlcgriloFBbWVyaWNhbgpsbgp2YWxpZAp1bmdzCuKWgU5hdGlvbmFsCuKWgVNhbgriloFZb3JrClJlcXVlc3QKY2hhcgriloFaZQpidXR0b24K4paBYWxnClNPTgriloFhcAp1ZmYKYWJpbGl0eQrQtdC8CuKWgWFueXRoaW5nCmVsYQooKSkK0LHQsAphbXBpb24K4paBcG90CuKWgWZ1dAphaWxhYmxlCuKWgXByb3AKIl0K4paBbGVzcwpsYWcK4paBQXVndXN0Ckl0CuKWgXBsZWFzZQriloFzdHlsZQriloFBbHNvCmJ0CuKWgXByb2JhYmx5CuKWgU9uZQriloFwb3NzClVJCnVpdAriloFXZXN0CmhuCitcCkJ1dHRvbgpqc29uCmVycgpyYW1lCmRvbQppbG9uCmFsZgriloFjbGllbnQK4paBY29udGludQp4bWwKcGVjCmFkb3IKbHMK4paBaG93ZXZlcgriloFBbnkKw6RuZAptYXRocm0K4paBdXJsCuKWgWJvb2sK4paBZ2wKaXZlcwpnaQriloF0cm8K4paBVVMKcG9pbnQKb3BlbgriloFjdXIK4paBZXJhCuKWgXBhcnRpY3VsYXIK4paBSFQKb290CmVsbG8KbG9iYWwK4paBYWN0aW9uCuKWgUludAriloFpbmNsdWRlCuKWgWVsZW1lbnRzCtC90LDRjwphcmRzCuKWgUJsCuKWgWh1bQpmcm9tCmNoYW5nZQriloFmdW5jdGlvbnMKaGVuClNlcnZpY2UK4paBaGVpZ2h0CuKWgUxhbmQKaWFzCmdzCmnDs24K0LvQvtCyCm5vZGUKLuKAnQpoYW5kCuKWgdCx0YMK4paBYW1iCuKWgUx1CuKWgXRocm93CuKWgW1vdAriloFBY3QK4paBd29ybGQKX1wKYmFzZQriloFDbwriloFhcmNoCuKWgSMjIyMKZ2VkCnByaWwKb2xkZXIKTW9kZWwK4paBc2V2ZXJhbApsaWUKY2hlY2sKXXsKY29ucwriloFUcmEKaGVjawriloFsZWFzdApkb3duCmVicnUKRGVmCnBhcmFtCmlzY2hlcgriloFjYXMKQ0gK4paBYWRkcmVzcwriloHRgNCw0LcKdWZlbgp1cm9wZQrQtdC5CuKWgWJvdW5kCkNPCuKWgUFuZwriloFNYQpJbmRleApjb3JlCm91Y2gKYXRhYmFzZQpyaWJ1dGlvbgpkb2N1bWVudApMZQp9X3sKdmVybgriloFzdGF0ZW1lbnQK4paBQnJpdApvbm8KcHNpbG9uCuKWgWxldmVsCuKWgXByb2R1Y3QKSVMK4paBY291cnNlCuKWgU1yCj4NCuKWgWJhY2tncm91bmQK4paBcmV0CmVyaW5nCm1vc3QK0YHRjNC60L4K4paBdGhyZWFkCml0aW9uYWwKaXRlcwpQbAriloFkb3MKZ2EKZGF5CuKWgUdlbmVyCuKWgXR3CkFkCiI+PAriloEoJAriloFtb21lbnQKdGl0bGUKY3JlYXRlCnZlcnNpb24KTWFuYWdlcgriloFmdXIKcHBpbmcKaWpuCtC+0YEK4paBcmF0aGVyCnB0ZW1iZXIKT1MK4paBc2l0ZQriloFjYXVzCmFuaQriloFob21lCtC80ZYK4paBc2hvcnQKcGEK4paBbGVhZAppc2hlZApjaW5nCm9yZGluZwriloFwcm90ZQrRgdC70LUKTEVDVAriloFkaWRuCnBvc2l0aW9uCiIsIgooKSwKdHJhbnMK4paBbG90CuKWgdC+0LQKQVMK4paBc2F0CuKWgXBvaW50cwpnaXRodWIKc3R5bGUK4paB0LPQvtC00YMK4paBRGlzCnBvbmVudApvbWV0CnplcgpVTEwK4paBcGEKQVAKYWNlcwriloFVbml0ZWQKYW1hCmV0eQpDb2xvcgriloFlbm91Z2gKVVMK4paBbGVuZ3RoCigpKTsKXntcCmZ0eQpCb3gKYXB0ZXIK4paBY29tcGxldArQvdC40LoKbWF4Cm9iamVjdAooewppbWd1cgppdGl2ZQp1bmNoCuKWgVN1YgplbmRlCtCz0YMKYXRlZ29yeQrRgtGLCmlhbm8K4paBdXBkCuKWgUF1c3QKfXtcCnRvcApsYXMKcGlzCmluZXNzCuKWgXsNCuKWgdCVCkdyCuKWgUFTCuKWgdCy0LUKdGhlcnMK4paBZGVmaW5lZAphemlvbmUK4paBb2ZmaWMK4paBYXV0b20Kw7xuCuKWgWJyb3cK4paBc2VydgriloFyZW1vdmUKaXJvCuKWgUJpYmxpCkVECuKWgXdob2xlCuKWgdGICuKWgUphdmEK4paBenVtCnVhCnBtCmRldgrQutGA0LAKb2xkcwriloFXYXIKw6RuCnBhc3MKdXoKWyIK4paBdHJpCmlzZWQK0YXQsAriloFtZW1vcnkK4paBUG9ydApvcGVyClVwCuKWgVRoYW5rCuKWgU1pY2gKeWNoCmJvYXJkCtCx0YMKSW5zdAriloFiZWdpbgppbmF0aW9uCuKWgU1vZApfLAriloFEZW4Kb3B0aW9uCuKWgWNvbnN0cnVjdAriloFKdXN0Ck1hcApydW4K4paBcmVzcGVjdApoYW0K0LzQsNC9CmltZWRpYQriloFhcHBseQpjcmlwdGlvbgptYWluCuKWgdCa0LAKb2lkCkNvZGUKfTsKSW5mbwriloFmb3JtYXQKTG9nCuKWgdGB0YMK4paBbGF0CnV0b3IK4paBcmVmZXJlbmNlCuKWgWNhbGN1bApvbm4KTG8KaW5mdHkK4paBYWxvbmcK4paBxI0K4paBdGFzawriloFldgp0aGV0YQpyYXMKam9yCuKWgdCx0L4K4paBcHJpbmNpcApNeQriloFlaW5lcgriloFFcwpvbWIKcXVhZApeey0KdW1wCuKWgXRpbGwK0LTRlgriloFsb29rcwriloFvawrRhtCwCm51CkZpbAriloFzb250CuKWgU1lZAphZ3VlCuKWgWNvc3QK4paBU2ltCuKWgWNvbW1lbnQK4paBKFwKZWdlbgriloFwYXJhbWV0ZXIK4paBRnJhbmNlCnJlcAriloFUSAriloF5ZXQK4paBYXdheQriloFjaXJjCuKWgUFQSQplbXAK0LLRlgpMYXlvdXQK4paBbGluZXMK4paBUGFydAplbXB0CuKWgUJpCuKWgW1pbmQKa3kKZ2luZwriloFyZXBvcnQK4paBQWRkCtGA0L7QtAriloFyYW5nZQpjaWFzCmxpcAriloFLYXIK4paBQ29tbW9ucwpnZXJ1ZmVuCmFmZgpzZWMK4paBaHRtbApsaWcK4paBd2luZG93CmluaXRpb24KY2lzCuKWgXV0CmVsbgriloFhdXgK4paBbmVnCkhhbmQK4paBKTsK4paBYW5hbAriloFmcmkK4paB0YHQuApldGNoCm1kCnBhZ2UK4paBbGlicmFyeQriloE6PQpST00KWW91CnNwYWNlCuKWgWR1cmNoCuKWgWhvc3QKYXZlbgriloFGaWxlCmFsbGUK0YLQuNCyCuKWgXBhcArRgdGC0LLQvgptYXJrCuKWgW1haXMKZXJtYW4KU2l6ZQrQtdC6CuKWgdCc0LAK4paBaXNuCuKWgWNvcHkKc3RlbgpyaXZlcgriloF3ZW50CuKWgWphdmFzY3JpcHQK4paBc2FtCuKWgWZyYW1lCuKWgXZpCuKWgXByZXZpb3VzCnJvZHUK4paBbWV0aG9kcwriloFuZWNlc3MKTkEKY2tldAriloFvcHQKTG9jCmhvdwriloHDrm4Kc2hpcAriloFpdHNlbGYK4paBUGxlYXNlCmllbmUK0LLQtdGACuKWgTw8CuKWgW1pbGwK4paBdHJhZApwYWNlCuKWgUhhcgppdGVuCndpc2UKd3JpdGUK0YbQuNC4CtGA0YsKTGluZQpvbG8K4paBYWNjZXB0CmhlaWdodAriloFlbGVjdAplbGxhCuKWgXDDpQpTZWxlY3QK4paB0LvQuAriloFcPAooKAriloFJRApvcHMK0LLQsNC9CmnDswpUUArCuywKbmVjdGlvbgpwYXJlbnQK4paBTWFnClRhYmxlCk92ZXIK4paBbmV0d29yawrRgdC/0L4K4paBYXNzaWduCmlnZ2VyCmlybQopYApvdHRvbQpiZXRhCuKWgWRlbGwK4paBYm9keQriloHQtNCwCuKWgVlvdXIK4paBZnVlCuKWgXBhY2thZ2UK4paBbGlnaHQK4paBKioKTVAK4paBY291Cnllcwo6XAriloHQpwriloFtZW50aW9uCmVuc2NoCuKWgWRlZwriloFjb252ZXJ0CuKWgURhdgphZHQKUmVzdWx0CnRob3VnaAriloFidXMKeHkK4paBc2VlbgpBbGwKcHVibGljCml2ZWx5CuKWgVJlYwriloFIaXMKc2ltCuKWgWbDtnIK4paBaGlzdG9yCuKWgXNldHQKcmF0CmFibGVkCuKWgcK7LApnb29nbGUKV2ViCsOpbAriloF0aXRsZQriloFKYW51CtGY0LAK4paBdG9vawppZGVuCnN6CuKWgUdldAriloFvYmplY3RzCuKWgWNvbW1vbgriloFjaGFuZ2VzCuKWgUxvbmQK4paBZXh0ZXJuCuKWgWp1CklzCuKWgWF2YWlsYWJsZQp0cmkK4paBbcOhcwpvc2EKQmUK4paBRGF0YQp1cmFsCuKWgWhvbQriloFhY2NvdW50Cm9vCuKWgXBlcm0KcmVzcG9uZAp5dAriloFzZW5kCuKWgXJldHVybnMKaXZpZAriloFleHBsYQrDrW4K4paBbm9yCklmCuKWgUZyb20K4paBdGFyZ2V0CmZlY3QK0LXQvdGCCuKWgXVpdAriloFKbwriloF2YXJpYWJsZXMK4paBc2VyaWVzCuKWgWZ1bmMK4paBaGltc2VsZgriloHRh9CwCmFudGkK4paBYWNoCmlhbG9nCuKWgXN0ZAphZQriloFmb290CuKWgXVudGVyCmdyZXNzCk5vdApyYWQKZsOpcgriloF1dGlsCm9yZW0K4paBc291Cm9wdAriloFvZwriloF1bWEKaXRhcgriloFPawrDvGNrCnNxcnQK4paBYW50CuKWgXdlcmRlbgrDpXIKfSk7CuKWgVBhcmlzCuKWgWV4Y2VwdGlvbgriloFkZXRlcm0K4paBVm9sCuKWgVNhbQriloFlc3MKbGllcwppb25pCm9kaW5nCmlkZ2V0CuKWgXByaQriloF3aGV0aGVyCuKWgdC/0L7QtAriloFudW1iZXJzCuKWgX4KZXZlbnQK4paBc2hvd3MKYXR1cmVzCuKWgWhvdXNlCuKWgWZhY2UK4paBc2nEmQp2aXJvbm1lbnQKdmFuCuKWgWluY2x1ZGluZwriloE8LQp0aW1lcwpub3cK4paBcHVyCmlmaWVyCuKWgWVtcAriloFjbGEKbW9uCuKWgURhcwphZHkK4paB0LLRltC0CuKWgdGGCmFib3IKT1NUCuKWgWJhbmQK4paBw7oK4paBZXhhY3RseQppZXJ0CmF2aWcK4paBcmVkdQriloFTRQpsaXNoZWQKQnUKTWVzc2FnZQpjZWxsCmZ1bGx5CuKWgXN2CuKWgW1ha2VzCnBvbAriloFyZXF1aXJlZApmZXJyZXIK4paBcGVycwriloFtaQpGSQriloFQYXVsCuKWgVVJCuKWgUJlbAppbmMK4paBY29udGFpbnMKT3V0CmFzdXJlCnB1Cm90bwriloFnYW1lCnpuCuKWgVdoeQpvcml0aApiaWcK0LrQuNC5CnNpZ21hCuKWgXF1aXRlCuKWgWplZApyZWMK4paBU1FMCtCx0LUK4paBTWFydAp5YQriloFzY2hvb2wK4paBc2ltcGx5CuKWgXZvcgriloFkb3VibGUK0YDQsNCyCuKWgVN0cgppZW0K4paBYWxidW0K4paBcmVzb2wK4paBZGVpCuKWgVdpawriloFhdwp1bWIKb2xzCuKWgSovCuKWgXplCuKWgWFuaW0KLz4KcmlzCnJlc2gKTm8KaXF1ZXMKY3VycmVudAriloFwZXJpb2QK4paBQXByaWwK4paBc3RvcmUKJywnCuKWgVNldAo9ewphY2hlZAriloFNYWwK4paBUGFsCmFudGVzCmF0ZXJpYWwK4paBd29ya2VkCmxlcQpvcmVmZXJyZXIK4paBaGFwcGVuCuKWgWJveApuZXkK4paBY2xvc2UK4paBZ3JhbgriloFsaWUK4paBaXIK4paBZXhwZWN0ZWQK4paB0LTQu9GPCmNsaWNrCsiZaQriloFwYXJ0ZQpvZ24K4paBRm9ybQriloFtZW1iCuKWgXBsYW4K4paBdGVhbQpdWwriloFjb21tdW4Kb3JyeQplbmN5CmdsCmluYXJ5CmNkb3QKXlwK4paBRmlyc3QKYW5kZXIK4paBRGVjCnJlcXVlc3QK0YHRgtCy0LAK4paBc3RydWN0dXJlCuKWgXx8CuKWgUNvbXAKYWN0b3J5CuKWgU1pbAriloFTb21lClN0cmVhbQriloFhc3N1bQp1ZW4K4paBd29yZHMK4paBU2VwdGVtYmVyCuKWgdCa0L4K4paBZGF5cwpvcmllcwrRgdGC0LDQsgpzbQp2aW4KcGFydGlhbAriloFwYXJlbnQKb2oK0L3QuNC4CiEiCnVnaW4K4paBV2luZG93cwpFZAo6fQriloFxCuKWgWJlbgppYW5hCuKWgWxhYmVsCnN0YXRlCnV0ZWQK4paBKCkK4paB0YHQstC+CuKWgWVkaXQKdXJpbmcK4paBTlMK4paBSmFocgriloFwcm92aWRlCkhlCuKWgVllcwphbmVsCmVuYW1lCuKWgURvbgppc2sKZ3JhCmVsaWoK4paBcm9vdAoqLwriloFGcmUK4paBTW9yCnVzZWQKcmFuZ2UK4paBdGFtYgriloFtb2R1bGUK4paBZGlyZWN0b3J5Cm91bmRzCkFjdGl2aXR5CuKWgW11CmluZm8K4paBZnJlZQpvcmdlCnRhYgopPQpsYW5nCuKWgdC+0YEK4paBRlJPTQriloFlbnRlcgriloFiZWNhbWUKaWRhZQrRhdC4CuKWgVN0YXRlcwp2ZXJzZQriloFleHBsCnludApVTgplZQplbmRlbnQK4paBbWFraW5nCuKWgSIkCnVuaQpxdWVuY2UK4paBbHVpCkhUCuKWgXVzZXMKemllCm5pYQpDb250ZW50CuKWgUNvdW50CuKWgXN0YW5kYXJkCkVOVAriloHQutC+0L0KZm9ydAphZGFzCtC30YMKU3lzdGVtCuKWgVN3CuKWgWV2ZXIKTE8K4paBY29ycmVzcG9uZAriloFQbwphcmdpbgrQutGCCtGW0LkK4paBcmVtYWluCmNpbwriloFhY3R1YWwK0YHRgtGDCuKWgXNpbmQK4paBUGUK4paBY2hhbmdlZAriloFOb3RlCnNraWUK4paBZmFtaWx5Cml0w6AKY29zCnR4dAprZXIKY2VlZAriloFhcnIK4paBY2FtCml6ZXIK4paBRGFuCmhlbAppY3VsdApIUAppbGVyCuKWgVNhbAriloFjb25uZWN0aW9uCnVzaW9uCmtuClJJCuKWgXZvbQpMaXN0ZW5lcgriloHDtgriloFkaW0K4paBcHJlc3MK4paBZXNjCuKWgVRyeQphdGFsb2cK4paBdGhhbmtzCkRPCuKWgXdyaXR0ZW4KZGlyCnJldwriloFmaXJlCuKWgU5hY2gK4paBw6EKZW5jCuKWgW9yaWdpbgriloFOb3ZlbWJlcgriloF9OwpDb3VudAriloHQl9CwCuKWgWdyYXBoCuKWgW1pcwriloFFeHRlcm5hbAriloHiloHiloHiloHiloHiloHiloHiloHiloEK4paBb3B0aW9ucwriloFVUkwK4paBcGhwCuKWgWludGVncgpDb25maWcK4paBVGV4dAppbm5lcgriloFjcml0CizigJ0K4paBdG9nCiQkCm5vZgriloFzZXMKw7xocgriloFTaW5jZQpEZXMKdWJlCuKWgXNlY3Rpb24K4paBZ2kKZm9yZAriloFBc3MKYWluZXIKdHRwCuKWgWJlaGF2CnBvcnRzCmRyYXcKVGhpcwpyYW5jaAppbmRpbmcK4paBZXN0YWIK4paBb2J0YWluCnJpY2gKbGljaXQK0LXQsgriloFxdWFsCuKWgXphCuKWgWhhcgriloFmYWMKYWFyCmpldAppY2xlcwriloFBdXMK4paBaG9yCuKWgXJlbW92CuKWgXdpZQpDbGllbnQK4paBbmF0dXIKaGlwClN1YgriloFyYW5kb20KREYK4paBYXJlYQp0YWcKUHIK4paBSXRhbAriloFyb2t1Cm5vZm9sbG93Cip9CuKWgW90aGVycwriloFsaW1pdAriloFzaWwK4paBc2F2CuKWgW9mdGVuCuKWgXJlbmRlcgpEQgriloFNYwriloF6aWpuCtC20LXQvQriloF0YWcKbWluZwpsaWNoZW4KcGFjawriloFBZwriloFzZW5zZQpwZwpNZXRob2QKYWdlZArDoWcKxYJhCuKWgWludGVyZXN0CuKWgWFzc29jaQp2b2x1dGlvbgriloFlbXB0eQppY2hlCuKWgWdybwriloF0eXBlcwriloFTaWUKSW50ZXIK4paBbm9yZWZlcnJlcgriloFnaXZlcwpoYWwK4paBc2F2ZQriloFmb250CnJ1Y3Rpb24KU2NyaXB0CuKWgWFsbGEK4paBc2F5cwriloFmdQphcGUK4paBbGFuZ3VhZ2UKaWdlcgriloFLaW5nCmJvcgp1dgriloFzaGFsbAriloFFdXJvcGUK4paBZWluZW0K4paBd2F0ZXIK4paBZ292ZXJuCmFuegphdG9ycwriloFtb250aAp5ZQriloFpbXBvcnRhbnQKYXR6CmZpcnN0CuKWgVRyYW5zCuKWgU1hZAriloFicmEKaWthCuKWgVNhaW50Cm9yaWEKa3JlCmVtZW50cwriloFCZW4KbGF2CuKWgWFkbWluCuKWgUhlbgpyaWwK4paBU20KY2F0CuKWgVJlZmVyCuKWgdCoCuKWgXByYWN0CuKWgVBhdAriloFHcmUK4paBeW91bmcK4paBSW50ZXIKb21hCnRlZ2VyCmliaWxpdHkK4paBcGFyYW1ldGVycwriloFldmVyeXRoaW5nCmRhdAp1cm9wCm9sZWFuCuKWgXJldHVybmVkCuKWgUNsYXNzCmFjeQojIyMjCuKWgXDFmQriloFmb2xkZXIK4paBa29uCuKWgWd1ZXNzCmd0Cmplbgphbm5lbAppY29uCuKWgWNvbWIKcmljdAriloFoaWoK4paBYXV0aG9yCnNlZQpoZXJlCnN0cmEK4paBZW50aXJlCuKWgWRpcmVjdGx5CnJhZnQKaGVldAplc3RlcgriloHQvNC4CuKWgW1hc3MKdW50dQriloF1c2VycwpjaGkKUEUK4paBY29tcG9uZW50CkNsaWNrCkF0dAriloFzb2JyZQphbmRzCuKWgUhvbAriloFTYW50Cm9yaQriloFzdWEKc3RkCmVudGljCkNDCuKWgWZpbHRlcgpTUUwK4paBR29kCkF0CuKWgdC80YMK4paBcGVyZm9ybWFuY2UKZGVsdGEKYW5kZQphbWVyCtC00YsK4paBY3VsdAriloFOb3IKYnV0CuKWgWxpawoqKioqKioqKgrRgdGC0LLQtdC9CuKWgWNvbW1lCuKWgWRyCmltZXIKb3JkaW4K4paBY29uZGl0aW9uCmVzdGUKKFsKRkYK0YLRjNGB0Y8KaW1vCnJhYgrRltC70YwK4paBaGFsZgplYWNoCkRpcwriloFyb3dzCuKWgWhvbgriloF0b2dldGhlcgriloHImWkKbWVkaQphZ24KYWxsZWQK4paBdmlsbApJTkcKaWRkZW4K4paBZHJhdwp5bnRheAriloFhdHRlbXB0ClVSTApwb3NlCuKWgWluZGljCtC90LjQutCwCuKWgUVuZ2xpc2gK4paBZMOpYwriloFuZWVkcwriloFub3JtYWwKdXJ0CuKWgdC90L4KfX1cCmxhc3QK4paBRmluCuKWgUZlYnJ1CmlsYQriloFjb3VudHJ5CuKWgWZpZWxkcwriloFtYXgKbMOpcwpvd2llCuKWgWRldXgK4paBYnVpbHQK4paBTWFpbgriloFjYW1wCml2bwppdmEKaWN5Cnppb25lCk5vZGUK4paBOikK4paBYW1vbmcK4paBT2IK4paBY2FzZXMKaGFwcwpzZXJzCmFydGVyCsWbY2kK4paBaXRlcgriloFuYW1lZApleGVjCuKWgXNlYXNvbgp0b3QKPT4KZ3JhcGgK4paBbmlsCmFjaW9uYWwK4paBTlVMTAriloFzcGVjaWFsCtGB0YLQtQpjc3MK4paBXCgKdnMKYWVsCuKWgWNpdHkKb3ZhCuKWgWFydGljbGUK4paBU291dGgKQWN0aW9uCsOnYQpzcHJpbmcKaXR1ZGUK4paBY29tcGxleAriloHRh9GC0L4KYnVpbGQKZ2FtbWEK4paBRW50CmllcnMKJy4KY2FyCmFwYWNoZQppbmdlbgpJbnB1dAo64oCJCuKWgWR5bmFtCmFsbHMKc2hvdwp8XAriloF3aXJkCkJhcgphbHRoCm1vZGVsClRyYW5zClJvdwphYmUK4paBbGliCm51bGwKcmFnbWVudAriloFTdGF0ZQriloFsYXcKRnJhbWUK4paBTG8KZ2ViCn0kLgriloFuZWVkZWQK4paBY29udHIKYXJpZXMK4paBc2NyZWVuCnlyCm1tCuKWgXNob3duCuKWgWJhZAriloFjYXN0CuKWgVRlc3QK4paBQXVmCuKWgXF1YW50CmlnYQriloFyZW4K4paBTWFjCuKWgXRyYW5zZm9ybQriloFkaWZmZXJlbmNlCuKWgXRpdApURQriloFzdGVwCuKWgWNhcHQK4paBY29sbGVjdGlvbgppY3Rpb25hcnkK4paBVG9tCnJpZXIK4paBbW92ZQpjb3BlCm9yZHMK4paBZnVydGhlcgriloFjb2x1bW5zCuKWgUxpbgriloFmaXhlZAriloFjaGlsZHJlbgpNUwptbwp1bmEK4paBaW5kaXZpZAp0dHkKYXN0ZQpzcmMKbWF0Y2gKd2kK4paB0YUK4paB0LTQuAriloFvcmQKaXZpbmcK4paBQnJvCuKWgWFsbW9zdAriloFQcmVzCnJlY2kKYXJpbmcK4paBLy8vCtC10YLRgdGPCuKWgXNpZwpsaWdodAriloFSZWQK4paBc3VnZ2VzdApvbGYK4paBw6l0w6kKaXNhdGlvbgrQt9C90LAKTmV3CtGB0YLQsNC9CkxBCnVuaWNpcAriloFmaWd1cmUKbXQKaWFsZQriloFjYXRjaApkZWZhdWx0CuKWgXRlbGUK4paBbWF0dGVyCmNhc3QK4paBUmljaAriloFoYW5kbGUKdmFsdQokLQrQvtCxCuKWgWpzb24KQ3JlYXRlCuKWgWV4YW0K0LDQu9GMCtGO0YIKb3JlZAppZG9zCmFwcGVuZAriloFBcnJheQrQutGBCn1bCnJpdmUK4paBY2x1YgptYW5uCuKWgWVzdGUKZXN0YQriloFHaQriloFKYXAK4paBTmFtZQpDb2x1bW4Kb3Vwcwppc21vCuKWgUNpdHkK4paBY2xhc3NlcwriloFpbmZsCmhsCtGA0L7QvAriloFhZGRpbmcK4paBZmFpbAp4eArDtWVzClNjCnV0aWwK4paBbG9jYXRpb24KbGVnZQphZ28K4paBcHJvcGVydGllcwphYmlsCnZhcwp9JCwKaXR0ZWQKw7NkCuKWgURlbQriloFhc2tlZAriloF0YWIKU291cmNlCuKWgWVycm9ycwpvZ3JhcGhpZQriloHQttC4CuKWgW1hbApzdHJhY3QK4paBZHJvCnJhawriloFub3RlCuKWgXNldHRpbmcK4paBZmVtCuKWgXNhdwppYXIKSEVSCtC10YEK4paBcHJlZAriloFPdXQK4paBaXRlbXMK0LvQsNC9CuKWgXdlcmQKZXJzaW9uCmxpYQriloFzaW4KaWNodGUK4paBZmVlbAriloHQv9GA0LAK4paBb2RlcgpVRQpvY3VtZW50CuKWgW1vZGUK4paBTmEK0LTQtdC9Cm1lcwpmcmFtZXdvcmsK4paBYXV0bwrQvdGL0LwKdWJ5CuKWgXRlbXBsYXRlCuKWgW1lc3MKaWVkZXIK4paBcmVsYXRlZApva2VuCuKWgWZvbGxvd3MKc2VhcmNoCmFtaQriloF3YWl0CmlncgriloFsb3cK0YHQutC40YUK0YHQutCw0Y8K4paBTWFyawriloFpbGwKYW1lbnRvClw8CuKWgWRmCm9zaXRpb24K4paB0JLQuAppc2YK4paBRGV1dHNjaAphaGwKd2FyCml0ZWN0CuKWgXNhbAplbGVuCkJ5SWQK4paBZ3J1CnN2CuKWgXBhc3NlZAriloFhw7EKU2NoCuKWgXNvbHZlCndlaXNlCmF0b3MK4paBbWVnCuKWgW1lbWJlcgplcm5hbWUK4paBY29ubmVjdAppcHMK4paBcm91bmQK4paBXQpuZXMK4paBZGlyCuKWgUxvbmRvbgpkeQpGQQriloFyZWNlaXZlZApyZWV0CuKWgUxvZwriloFTY2hvb2wKYW5nbwriloFUaGVzZQriloFNb250CuKWgWVuZXIKbGFkCuKWgWRlZmluZQpzaWduCuKWgWNsZQpmaWd1cmUK4paBVmlldwp0ZXh0YmYKJFwK0LfRiwpudW1iZXIK4paBZGluCmVsbGVyCm9yaXRobQpmYWxzZQpmb2wKZmZpY2llbnQK4paBSFRNTApsaWNoZQriloFNbwriloFpbnRyb2R1CmV4cAriloFzdHJvbmcK4paBdGh1cwovKQriloFlbGUK4paB0YLQsNC6CuKWgdC/0LAK4paBZG9udAriloFjYXVzZQpOdW1iZXIK4paBaW1hZ2VzCuKWgXNhbXBsZQriloFzY2kKbGlrZQriloFMb3UKZGl2CmFuYwriloFmcm9udApuZW4K4paBbWlzc2luZwphcmlhCnByZXMK4paB0L/RgNC10LQKREkKZmlsdGVyCuKWgU1pdApVUgriloFvcHAK4paBc3FsCuKWgdGA0L7QutGDCmVyZW4KZW1hdArDrXMK4paBSmVhbgrDqWMK4paBY2kKZW5uZQphdGZvcm0K4paBdGFrZW4K4paBT2YK4paB0L3QsNGB0LUK4paBZXJyCk9QCkZyb20KRGVmYXVsdAriloFHZW5lcmFsCndpa2kK4paBZ3JhbmQK4paBZWluZW4KUmVnCkhhbmRsZXIKY29ub20KYW5nZXIK4paB0LHRi9C7CuKWgUxvcwriloFleHByZXNzaW9uCtGI0LAKeWFsCuKWgSQoJwriloFzd2l0Y2gK4paBdmVjdG9yCuKWgVRob20K4paBdmlydApsZWFzZWQK4paBY292ZXIK4paBcmVzcApha28KcmVuY2gKb3RhCkNlbGwKYW5nZWQK4paBKz0KbGFjCnNrYQpuZXh0CuKWgUludGVybmF0aW9uYWwK4paBV2lsCuKWgW9udAppYnIKdXN0cgriloFibGFjawriloFzZWxlY3RlZApjaGVyCuKWgWxpdGVyCnJvb3QK0LvRgdGPCuKWgUxpZmUK4paBaW5zZXJ0CuKWgW1hdHJpeAppc2VzCildCuKWgXBlbApPdmVycmlkZQpyeXB0CuKWgWZvcm1lcgriloFGaWxtCuKWgU5vcnRoCmNsaWVudAriloFuaWdodArRhdC+0LTQuAriloFBdXN0cmFsCuKWgVJldApyaG8K4paB0L/QtdGACmlwZWRpYQriloFleHByZXNzCuKWgXRoaXJkCuKWgW1ham9yCuKWgWdyYWQKb3dlCuKWgWJlbGlldmUKb3VybmFsCuKWgXN0YXR1cwp1bmMK4paBZG91CuKWgUpTT04KdWlzCuKWgXBvcHVsYXRpb24KZW56CuKWgVdpbGxpYW0Kc2YK4paBT2JqZWN0CuKWgWNpbgriloFEaQpjdXJpdHkK4paBT3BlbgriloHQu9C1CmxhcgphZGRpbmcK4paBa29tCn0oXAriloFraWwKdW1lcgoiLz4K4paBZmVhdHVyZQriloFBcmUKY2tzCuKWgUludGVybmV0CuKWgWloCuKWgXN0YXJ0ZWQK4paBZWFybHkK4paBYmVnYW4KVEgKcHl0aG9uCmFzcAriloFGcgriloFjbG9zCmlzdGljCuKWgW11c2ljCuKWgWRpZwriloFpdGFsCuKWgURhdmlkCuKWgXdlYnNpdGUK4paBY29udHJvbGxlcgriloFNZXIKY29udGV4dApwcm9kdWN0Cm9zcAriloHiloHiloHiloHiloHiloHiloEK4paBanVuCnJvd24K4paBQXoKIjoiCuKWgWFhbgriloFEYXRlCm11bHQK4paBYnJvd3NlcgrRgNC10LQKd2hpY2gKUkEKcXVhcmUK4paBUnVzcwriloFzb29uCuKWgVByZQp0YXUK4paBd2VlawriloHQsdCwCuKWgW9jdAriloF0b3duCnJveQriloFlbHMKYmxpYwp1bmRsZQriloFIaXN0b3IK4paBZm9pCuKWgW1vZGVscwrQt9C+Cm9ueW0KUGFyYW0K4paBTWV0CmdlbmVyCmrEhQriloFlc3BlCkNFCuKWgWRldmljZQplbGxvdwriloFkZWJ1ZwrDqXJpZQp1c2luZwrQsNC90LMK4paBKikKdWRpCuKWgU1pc3MK0LrQvtC8CnBvc2VkCuKWgXp3ZQrRltC9CuKWgVJvYmVydAriloFPY3QKbG9wCmphcgriloFhdmVyCuKWgWhhYml0CuKWgTo6CsOkbmcKU3RhcnQK4paBcG93CuKWgXNyYwriloFwYXR0ZXJuCuKWgdCtCuKWgWJpCm90ZXMK4paBX18K4paBc2VucwriloFhdm9pZApleGFtcGxlCnV0dApMYWJlbAp0ZXgKYm9vdAplc3RvCuKWgU1hcmNoCuKWgWVhc3kKaWN0dXJlCkdyb3VwCuKWgWZhdGhlcgriloF1cGRhdGVkCuKWgVZvCuKWgUlJSQpvbWVnYQriloFhbGxlClJlYwp5ZwrQt9C1CuKWgURpbQpuZWN0CuKWgVRvcgriloFkZXV0c2NoCuKWgXdoaXRlCuKWgW5hdGlvbmFsCnBwZQriloFhaXIK4paBcGFzc3dvcmQKZGV0CuKWgWJpZwriloFVc2UKY2FsbAriloFleHRyYQpXZQphbmlhCuKWgWhvbGQKQ29udHJvbAriloFDTwriloHQvNGWCml0aQriloFLZQplbnUK4paBUGFyawrRgtC+0LwK4paBYXV0aAriloFjZW50ZXIKUGgK0YLQvtCyCmlkaW5nCuKWgWFjcm9zcwriloFzb25nCuKWgXBoeXMK4paBbnVtZXIK0YnQsAriloFBbGV4CuKWgXByb2JsZW1zCuKWgUVycm9yCmZvcm1hdAriloFBY2MK4paBc2l4CuKWgWRiCuKWgUNhc3QKb21zCnByb2plY3QK4paBdmVydApjcmV0CuKWgWhlYWRlcgriloFzdHJlYW0KaWRzCuKWgXRvcgriloFzZXB0CuKWgWVzdGltCuKWgWRlY2wK4paBZ2F2ZQriloFwbGF5ZXIKeXNpcwriloHQtNGA0YMKYW1tCtGJ0L4K4paBKCIK4paBYXgKUHJvcGVydHkKdXNyCuKWgXNvbWVvbmUK4paBaW1wcm8KYWRlbgpyb3RlCuKWgdCc0LgKaWgKKyspCuKWgXZpZGVvCuKWgWV4aXN0cwrQutC70LAK4paBY29tcGxldGUK4paBc2Vzc2lvbgriloFjb25zdGFudAppY29zCuKWgXBhY2sKcm9tZQplZ3IKQXBwbGljYXRpb24K4paBeWVzCuKWgWVsbGUK4paBZW1haWwKb3JmCmNhc2UK4paBcG9pbnRlcgriloFyZWdhcmQKc2VuCnN0YXR1cwriloFtZXMK4paBZGVsbGUKaW5ndG9uCuKWgUJhcwopXgpkZXZlbG9wCuKWgWZvcmNlCuKWgWNoYXJhY3RlcnMK4paBY3Jvc3MK4paBZGVhdGgK4paBdGFrZXMKw6lyaQppZ25lCtGH0LXQvQpVUAouOgpUaHJlYWQKanUKaW55CuKWgWRldGFpbHMK4paBeG1sCnRhaXQKb3V0cHV0Cm1lc3NhZ2UKJycK4paBQnJpdGlzaAp2aWxsZQriloFEaXYK4paBVXNlcgpjbQrRh9C90L4KY29sdW1uCmVxcmVmCsOzcgpvbm9tCuKWgVBvc3QKZWxsZW4KQWIKdWx0w6kK4paBcGVyZmVjdAooKXsKdmlzaW9uCmFjdGl2ZQpsaWVyCnJpagpzZAriloFrw7YK4paBbmllCuKWgXJlbGlnCuKWgW90CuKWgW1hY2hpbmUK4paBaGVsZAopJC4KPT09PT09PT0KY2tlcgrQstGLCmJvcm4K4paBcGFzdArRgNC40Y8K4paBRHIK4paBcmVndWxhcgriloFwcm92aWRlZApURVIK4paBdW5pdmVycwriloFnZXRzCuKWgW51CuKWgS8qCm9iZXIKZmluCuKWgW5lbGxhCuKWgWJlY29tZQriloFgYAriloFoaXN0b3J5CuKWgVNvbAriloFSYWQK4paBdGVybXMK4paBZXZlbnRzCmx5bXAKKSkpCtGA0L7QstCwCuKWgWFic29sCuKWgXNvZnQKbGlua3MK4paBaG9wZQriloFzdWJqZWN0CiIpLAriloFjcmVhdGluZwriloF9DQriloFTawriloFmbG93CuKWgdCg0LAK4paBYXNzZXJ0CnpldAriloFGcmFuawpzYQriloFkaXN0cmlidXRpb24KY3UKYmFuZAppenoK4paBam9iCmluZXIKc3RydWN0CsOhawpUTwphdWYK4paBZXh0ZW5kcwriloFHcmEKZGlzcGxheQriloFzaWduaWZpYwpvbmV5CnNvdXJjZQptaWNyb3NvZnQKaW5kZXIK4paBcXVpY2sK4paBd29uZGVyCkluc3RhbmNlCmVsbGVzCsOobWUK4paBY29tcGFueQp1w58KLn0K4paBc2VwYXJhdGUKVU0KSEVSRQriloF3cml0aW5nCml0dXRpb24K4paBR2VzY2gK0LzRjwriloFKYW1lcwriloFERQriloFTcGUKcHJvY2VzcwpTdHIK4paBc3ltCuKWgWFvCuKWgXd5CuKWgWFueW9uZQriloFVcAp1c2V1bQphcm9uCuKWgWRlZmluaXRpb24K4paBYCQK4paBZmF2CnJpYnV0ZXMK4paBUsOpCm9ncmFmaWEKZWxlbWVudApjYXAKcGF0CuKWgUJyYQopKAriloFhY2NvcmRpbmcK0LPQtQriloFwaWUKZWxpCn0iCuKWgWFjdGl2CuKWgXN0b3AKcGF0Y2gK0YLRlgriloFKb3NlCkVuZAriloFwcnplCuKWgWFnZQppdG9yeQriloFQSFAKYWdlbWVudAriloFgLgriloFwcmV0dHkK4paBcmVjb21tCuKWgXN1ZAriloFyZXF1CuKWgdC+0LHQu9CwCmF0aXZlcwriloFIaWdoCsOhegpvdWwKcmVzdAriloFUZXIKdW5kZXIKdGhlcm4KY2VudGVyCuKWgXVyCmxhdAriloFpbnRlcmZhY2UK4paB0LjQvQriloF3aG9zZQppY2FzCmFtZW4KRmlsdGVyCuKWgXN0YXRpb24KUGFnZQriloFhcm0K4paBZXllcwriloHRgNCw0LkK4paBc2V1Cm9saQp3aW4KbGlrCmdleApjaGFuCmlkZW5jZQphcmdzCmFraW5nCuKWgUdvb2dsZQriloFTdHVkCuKWgWhvCtGC0L7RgNGLClN1CuKWgWF1dG9tYXQKw6ptZQriloFjeQpsb3IK4paBc3RhY2sK4paBU0VMRUNUCkFGCuKWgT4+CuKWgWNvbXBldAriloFwYWlyCuKWgWluZ2zDqXMKUmVzcG9uc2UK4paBRmlnCmdyYWQK4paBZG9jdW1lbnRhdGlvbgriloFjYW50CuKWgWFwcHJlY2kKw6VuCuKWgWxlYXJuCuKWgWluZGVwCuKWgXBhbApwYWNrYWdlCmFyZXMK4paBQmVybGluCtCx0LvQuApyZWljaArRkdC9CuKWgXNhdGlzZgriloFyZWdpb24K4paBZnJpZW5kCuKWgUdlb3JnZQriloHQktC+CuKWgSIiCuKWgWRlc2RlCkZhY3RvcnkK4paBQ291bnR5Cm91dgriloHigJgK4paBaW5zdGFsbGVkCuKWgXdhbnRlZAriloFQeXRob24K4paBaW50ZXJwcmUK4paBaW5jbHVkZWQK4paBKCgK4paBYWx0ZXJuCmlzdG8KZ24K4paBYm9yZGVyCnBkZgriloFkdXAK4paBZG93bmxvYWQKanVzdAriloFtZW1iZXJzCmNoaWxkCuKWgXBheQriloFjZXIK4paBbG9va2VkCuKWgWNvcnJlY3RseQphdXRoCuKWgdGB0YLQsNC9CuKWgWVzcAriloFkZXNjCmViZW4K4paBcXVlc3Rpb25zCm1hbAriloFhYmdlcnVmZW4K4paBQmFuZAriloFbXQpCYXNlCuKWgXJpcwriloFmb3J0CuKWgUlkCuKWgXZhcmlvdXMK4paBTGVhZ3VlCuKWgUhhbmQK4paBVHlwZQppcmwK4paBRmUKacOpbgppdHRlcgriloFmYXN0CnN0YQriloFleGNlcHQKaWN6CuKWgUZyZW5jaAriloFlbnZpcm9ubWVudAriloFjb25zZQrRg9GACtC+0LPQvgriloFuZWNlc3NhcnkKdGFyZ2V0CuKWgXJlYWRpbmcKaG9tZQp6ZWljaAriloFlcXVhbAriloFwacO5CuKWgXByZW0K4paBZGlmZmljdWx0CuKWgXVuaXQK4paBcmVwbGFjZQriloFoZWFydAriloF0YWxrCkFNCuKWgVJFCuKWgVBlcnNvbgplbmRlbmN5CuKWgWltbQriloFodW1hbgpkbgriloFLaXIK4paBQXV0Cmtub3duCuKWgWZyZXF1CnN5c3RlbQrQu9Cw0LIK4paBU3oK4paBR2FsCtC90L7QtQpzZWx2ZXMKcmlnaHRhcnJvdwriloHQodCwCj0iQAriloFidWlsZGluZwppbXBvcnQK4paBZmFtCuKWgWRlbGV0ZQphaXJlCm1hcnkK4paBZnVuZAriloFwYXJ0aWNpcAriloFzeW4Kc2luCuKWgWxvd2VyCuKWgXplcm8K4paBc2VjCuKWgWZyYQpQb2ludAriloFmYWlsZWQKaWVudG8KY3VwCuKWgXNsb3cK4paBbmF0aW9uCsOkaHIK4paBaW5mbwriloFQdWJsaWMK4paBZGVjbGEK4paB0KLQsAriloFzb2xkCuKWgVJlbQriloFQaGlsCtGB0YLRgNCwCuKWgW1laHIK4paBV29yawriloFOb3JkCuKWgWZhaXQK4paBZ2V3CnByaW50bG4Kb2JpbGUK4paBS29uCuKWgWFzc3VtZQpsYW5kcwriloFhbW91bnQK4paBUHJlc3MKw71jaAriloFtYXhpbQriloFDaGFtcGlvbgpsaWJyYXJ5CmHDsQriloFXYWwKQ29tbQpdXQriloF6dwriloFzb2NpYWwKTEkK4paBVW50ZXIKdm9yCkRlbHRhCmVtYWlsCnJhaW50Cm9uaQriloFhbHQK4paBbsOpCtGG0LjRjwpvZ3JhcGh5CuKWgW1lbnRpb25lZAriloE8PQriloFjZXR0ZQriloFjdXJyZW50bHkKdmFyZQppemluZwriloFEZWYKaWNvbArDvG5kCuKWgWNvbmZpZ3VyYXRpb24KZXN0aWcKSUlJCmxhbQppw6hyZQriloFFYXIK4paBdHUKRW50CuKWgVVzaW5nCuKWgdC60L7QvApjaWUK4paBcHJvb2YK4paBaW52b2wK4paBSGlzdG9yeQo+PAriloFBTkQKYXZ5CuKWgXJlbGF0aW9ucwokewriloFjb21lcwriloFkaXJlY3Rpb24K4paBSnVuZQriloFXYXkKQ29tcG9uZW50CmVjaAriloFQZXRlcgpzZwriloFzdHJhCnVjdAriloFpbXBsZW1lbnRhdGlvbgphdHRsZQriloFjegpwbG90CuKWgXBsYXllZAoiPjwvCuKWgWZpdmUK4paBY29sbAriloFDaGFybGVzClRyYQriloFzdW8KZmlsZXMKZW50ZXMKcmVzcG9uc2UKSG93CuKWgVNvY2kK4paBaWduCuKWgWxlZAriloFHZXJtYW4KdWRvCuKWgUR1CuKWgXRpbQpvdW50ZXIK4paBYXR0YWNrCnVyaQriloHQsNGACmVzc2UKaXZpbAriloFKdQriloF2ZWwKbWF0cml4CuKWgU1hdApnaW8K4paBWmVpdApWRVIKaGFzCkNvbm5lY3Rpb24K4paBaWhyCuKWgWF0dHJpYnV0ZQriloFkaXNjdXNzCuKWgWRvbWFpbgpiaW5kCuKWgVNlYwpyaWsKY2xvc2UKZ2luCuKWgWxvdmUKYW50bwpnZW50CmFiYQpqYW5nbwpiaQriloFvYnNlcgppdHRpbmcK4paB0YDRgwp9PQphZ2VuCkJDCnNvbWUK4paBQnUK4paBc29jaQriloFpbmRpdmlkdWFsCuKWgWRlYWwK4paBb3V0c2lkZQpyaW8KRXhlYwphbmRpZAriloFidXNpbmVzcwriloF0ZW1wb3IK4paBVHVyCuKWgSghCnJpdGVyCuKWgWdvb2dsZQpdOgppdHRlCnhpCuKWgdCf0LAKaG9sCtC90YwKcmluZwriloFzdWwK0L3QvtGB0YLQuApfLgpnYXIKVGFzawriloFDaGVjawriloFtb2Rlcm4K4paBd2luCnVzdGVyCmhhbgpmb3JtYXRpb24Kdm9pZAriloHRhNC4CuKWgXVzZWZ1bAriloFFbmdsYW5kCmxvcwpldGltZQpldXIK4paBdW5pcXVlCuKWgdC60LDQugp5aW5nCm9iagp1aWQK4paBd2luZG93cwriloFkaXN0YW5jZQriloFub21icmUK0ZbRjwpvY3VzCmFobgppZXJ0ZQriloFkYXIKU0kKbG9uZwphc3RhCml2ZW4K4paBdG9sZAriloFHcnUKZm9vCuKWgWNhbGxpbmcKaWVtYnJlCuKWgWZ1dHVyZQpwcsOocwpsZWVwCmF2aWdhdGlvbgpQT1NUCuKWgWRlc2NyaWJlZAriloFub2NoCnVuaXQKYWxsZW4K4paBYnJhbmNoCmZhCuKWgWZpbGwK4paBb2JqCuKWgXRyZWUK4paBd3VyZGVuCuKWgUxpdGVyCnJvdApzcGxpdAplbWVpbgptb2R1bGUKQ0EK4paBb3BlcmF0b3IK4paBd3JvdGUK4paBSmFjawpvbG9naWUK4paBQW50CtGC0LXRgApzdHJlYW0K4paBUXVlCmVwc2lsb24Kbm9uCnN0ZWluCuKWgXNpbXBsCnB1YgriloFKdWx5CuKWgW5hdHVyZQriloFEYXRhYmFzZQrDs2wK0L3QuNC8CuKWgVZJCsOqdHJlCmlsZXMK4paBd2VsCicpLAriloFtdXQKbG9jYXRpb24K4paBdGhlcmVmb3JlCmVsbGkK4paB0IYKbsOpCuKWgdCw0LIKbGVkZ2UK4paBY29udmVyCsOtbQriloFYVgp2aWRlcgriloFKYW51YXJ5CuKWgXVzdWFsbHkK4paBcmVsZWFzZWQK4paBTWkKSGVhZAppbGxlcgriloFqYW4K4paBbGV0dGVyCnByb2R1CnJkCuKWgUNhbQosJwriloHQpgriloFwdXNoCnVwZGF0ZQriloFtYXliZQpIdHRwCkAiCtC80LXRgApzZXJ2aWNlCnBhcnNlCuKWgWRhc3MKw6puCikiCm1vcmUKLyoK4paBbWFzCuKWgWxpa2VseQriloFtYXRlcmlhbAriloFbWwriloFsb25nZXIKYmFsCuKWgUFyY2hpdgppZ3QK4paBZWd5CmlkZ2UKaWd1CmNvbmYK4paBaW5jCmNvbnN1bHTDqQriloFtYWkKV29yawriloHQs9GA0LAK4paBT2N0b2JlcgriloFnbG9iYWwK4paBc2VsCuKWgW11bmljaXAK4paBdmlvbAriloFEb2VzCuKWgVxbCtGB0LrQvtC8CuKWgWNvbXBvcwrQsdGA0Y8K0LLRjwriloFyZXNwb25zCuKWgWNvbnNpZGVyZWQK4paBSmFwYW4KcGVzCm9zdG8K4paBbWlsaXQKU1AK0YHRiwphdHRyCmNpbAppcmVjdG9yeQphdmluZwriloFEZWwK4paBcHJldmVudAppZGFkZQpnaXQKaWZvcm0Kb3V0ZXIKaW5jdApsZXZlbAphdGV2ZXIK4paBcmVwZQriloFleGMK0LTQsNGAClN0eWxlCuKWgVRob21hcwplbGluZQriloHQtgp1bnRpbWUK4paBbGFyZwpUcnVlCi4qCmNyZWVuCnlsZXMK4paBdHJhbnNsCuKWgdCh0L4KZW5zaW9ucwrDpGwKaXNzZQriloF2b2x0CmNpYWxseQpuaWsKLl0K4paBU3RhZHQK0LzRiwpmaWxsCmxvdgriloEiLwpTcAriloFBaXIKQ2FsbAriloFudXIKQ2hlY2sKaWVuY2UKZWZpbmVkCuKWgdCy0YDQtQrFgm8KZHoK4paB0L7RgAppa2VyCm93YQrQvtCy0LjRhwpyw6kKT0wK4paBbGluZWFyCuKWgWV4cG9ydAphaHIKaWNpYWwKUmVwCuKWgW5hdHVyYWwK4paBY29wCuKWgX0pCsOnw7Vlcwp6egpXaGF0CuKWgUhvdXNlClJlZgppbmdlcgriloF0YWtpbmcKbsSbCuKWgUVpbnoK4paBZGFtCuKWgWlzc3VlcwpCdWlsZGVyCmVkaXQK4paBcHJ6CnBhc3N3b3JkCkdlbmVyCnJpbQriloFwYXJ0cwotLS0KaWdpbmFsCuKWgVNjaQriloFtb3RoZXIKcmVhCuKWgWNvbnRhaW5lcgrQtNGPCuKWgUlQCuKWgW5vbmUK4paBZm9sbG93ZWQK4paBcGxlCuKWgW1lYXN1cmUK4paBdG91dApFeHQK4paBVFYK4paBZXhwbGFpbgriloFwYXBlcgrRgdGC0ZYKd3MKV2lrCuKWgW1tCuKWgU5vcm0K4paBU2VydmVyCmZvbnQKZWNhdXNlClRSCuKWgdCx0LgKTGEK4paBZW5zCuKWgXJldHIK4paBU2lsCuKWgXNlcXVlbmNlCmFyYwpJVgp6w6EK4paBQW5kcm9pZAriloFTdXBlcgriloFyb3oKb3ZpZQpPbQriloFXZWxsCm1ha2UKb3JwaAriloFKZXIK4paBUm9zCnJlZmVyZW5jZQriloFmZWF0dXJlcwriloFHZXIK4paBTGVnCuKWgWxhdGUK4paBYWRkaXRpb25hbAriloFmbG8K4paB0LXQs9C+CuKWgWFsZ29yaXRobQpCQQprYXIKSVAKXSk7CuKWgWFwcGVhcnMKeXcK4paBdGVtcAriloFhdXNzaQptZXRob2QK4paBcGV0CnN0cmFwCmFybmluZwriloFjdXQK4paBU2EK4paBdHJhY2sK4paBZW1wbG95CuKWgWluZGUKcmF2CuKWgWdlbmVyYXRlCmJlcwphcnRzClN0YXR1cwp1Z2UKYWxpcwriloFvdmVycmlkZQriloFmaQriloFsb3N0Cm90ZWQK4paBcm9vbQriloFjYWxscwriloFjb25zaXN0CtGA0LXQvQriloF2aWxsYWdlCmRpc3QK4paBdGVjaG4KZW56YQriloHRgNC+0LcK4paBQ2F0YWxvZwriloFiZWNvbQpyb3dzCuKWgU5lbApjb21wbGUK4paBcHJlbWkK4paBcm90CuKWgVdlYmxpbmtzCuKWgWZvb3RiYWxsCuKWgWNvbXBhcgriloFsaXZlCtC60LjRhQriloFlcXVpdmFsCmNhcGUK4paBR2VuCm5kZXIK4paBVmlzCuKWgWJlaGluZApnZXJzCnZva2UK4paBbWVkaWEKRVgKdGhhdAriloFzb25vCuKWgW15c3FsCmV2CuKWgXJ1bGUK0LTQvtCyCmFjYwriloFXSEVSRQrQtdC90LUKR3JpZAriloFqdWwK4paBbW9ydAriloFnZW5lcmF0ZWQKZW5jaWEKYWN0ZXIKY2x1ZAriloFzY2VuCuKWgWNsb3NlZAriloFNaWNoYWVsCuKWgW1vdW50CikkLAriloFkcm9wCuKWgWNvbWJpbgp0b2NvbAriloFnb2VzCuKWgWdlYgpNRAriloFBbnRvbgriloEkKCIKVGVtCuKWgWNhCuKWgWluc3RydQplZHMK4paBdG9vbApteXMK4paBcm91dGUKIikpCtC/0YDQtQriloFmbG9hdAriloFzZXJ2aWNlcwriloHRh9C4CtC60ZYKZW1ibHkKYWtlcgriloFTb24K4paBTWF0aAphc3NlCm91c2x5CmxpY2F0aW9ucwriloFydQriloHRidC+CuKWgUNvbnN0CuKWgWltbWVkaQpGTwpvcm8K4paBcHJvZHVjdGlvbgpyZWkK4paBanF1ZXJ5CmFubnQK4paBV2hpbGUK4paBc24K4paB0LPQvtC00LgKRm9ybWF0CuKWgXN0YXIK4paBU2VuCuKWgWtvCk5BTUUK4paBcHLDqXMKY2hhCndoYXQKb21pbgplbmRhbnQKaHkK4paBb2JzZXJ2CuKWgXByZWZlcgrRg9C9CuKWgWNvbnN0cnVjdG9yCmJzCuKWgW1hYwriloFCcmUK4paBSW5zdGl0CuKWgXN0b3J5CuKWgXN5bWJvbAplbGVzCsOfZQphc2luZwriloF3ZXN0CmlhbnMK4paBbWFzdGVyCtC10LcK4paBd2F5cwpibQriloFwaWNrCuKWgWRlcGFydApCYWNrCmVuawpsaXBzZQriloFtYXRoCuKWgUZyYW5jaXMK4paBRGVjZW1iZXIKZnMKcnVtCuKWgWRldmVsb3BtZW50CkxUCmVybmVsCuKWgVRydWUK4paBTW9yZQpyYW5nbGUK4paBY29uZGl0aW9ucwpPcHRpb25zCuKWgWdsaQriloFvcGVyYXRpb24Kw6lrCmFjaHQKaWdodHMK4paBbWlzdAphbmRhCuKWgWVuZXJneQriloHQttC1CuKWgXdvbWVuCmFrdAriloFDSApnZWJyYQriloFtZWV0Cml1CndlbGwKw7ZsCuKWgWdvdmVybm1lbnQK4paBSm9zCmllZwriloFzeW50YXgKZml4CuKWgVBldApqcXVlcnkK4paBY2FyZAriloFwcmluY2lwYWwK4paBZHJ1CuKWgXRlcnJpdAriloHQv9C+0LIK4paBU1MK0YDQuNC4CnRyZXMKYWduZQpseWluZwp0aWxkZQpiZXJuCmVudGVyClBlcgriloFzb21ldApMb2FkCmxpY2UK4paBc291cwriloFMb3VpcwriloFsb2dpYwriloFPdGhlcgriloFjaXIKw6l2CmNocm9uCuKWgWhhbgriloFtYXJnaW4KV2luZG93CsOocmVzCm55Y2gKcHVzaApib2xkcwriloFsYXlvdXQK4paBW2AKQ2hhcgriloFDYXAKYm9sZHN5bWJvbAriloFSb21hbgriloFNYXgKOigK4paBQ29kZQppc2luZwriloFzdGF0ZXMK4paBZXhpc3RpbmcKc3VwcG9ydAriloFyZXNlYXJjaApsaWNhdGUKdmFyaQriloFiaWoK4paBYXBwZQriloFoYXBwZW5zClwiCuKWgWNvbmNlcm4Kd2VzdAriloFzYXlpbmcKcGlkCuKWgXJlY29nbgriloFIZXQKQ2hpbGQK4paBY3MKXCwK4paBY2xlYW4KbGVjdGlvbnMKYWNjZXNzCtCy0YMK0L/RgNC+CmFjaXR5CuKWgU9mZgriloFlYXNpbHkKw6hxdWUK4paBamFrbwriloFpegriloFIYQriloFEZXQK4paBZm9ybWEKc2NoZQpzd2VycwriloFvZmZlcgpxdWlyZWQKVXNlcnMK4paBc3Vic3QKPigK4paBZ3JvdW5kCnVubgpyb2QKc3BlCnVyc29yCuKWgWxlYXZlCmVyawriloF0YWwK4paBYm90dG9tCklPCuKWgXBvcHVsYXIKaWdvCuKWgVRpbWUKdmFsdWVzCuKWgUxvYwriloFDbHViCuKWgWFuY2hlCmlhxYIK0ZbRlwpPbWVnYQriloFsb2NhdGVkClVybAriloFFc3AK0LvRiwrRhtGMCnVsYXRlCuKWgWpvaW4KYXZlcwp2ZXQKbGlvCnJlbW92ZQriloF0b2tlbgriloFvcHRpbQriloFjbGFpbQpvbG9naWNhbAriloFjc3MK4paBYWx0aG91Z2gK4paBcHJpdgriloFCYQrDvGwKZW50aWNhdGlvbgriloF2ZW4KU2VydmVyCuKWgUNvbmcKTkVUCkNPTgpkdApwZXJ0aWVzCuKWgWVwaXMKd2lraXBlZGlhCuKWgWVuZ2luZQriloFmZXIKZ2V0RWxlbWVudAriloFDbGEKxZnDrQriloFyb20KdmFyZXBzaWxvbgriloFwcmltZQppc3RyeQpwZWN0ZWQKb3JhZ2UK4paBdG91Y2gK4paBWycK4paBZGFuCkVtCmFjaW9uZXMKQ2FuCuKWgXdob20K4paBYmVoYXZpb3IK4paBc3RyaW5ncwriloFFdXJvcAriloFSb20KY2lyYwriloFwdW4K4paBcmVnaXN0ZXIKYnVudHUKcmFpbgpPYgpUQQriloFzb21ldGltZXMK4paBbWVudAriloFpbnRlZ2VyCuKWgUphYwpsZWdhdGUKb3RoaW5nCuKWgXNvdW5kCmxhY2VzCuKWgdCR0LAKcmIKZGkK0LvQtdC90LjRjwriloF0aGVtc2VsdmVzCuKWgUJsYWNrCuKWgXNldHRpbmdzCuKWgW5vcm0K4paBcnVucwriloFOT1QKS0UK4paBcGVyaGFwcwriloHQrwriloFtb2wK4paBYW5zCmF0cmUK4paBRGllcwpUb2tlbgphbmllCuKWgWFsbG93ZWQKUmFuZ2UK4paBR3JvCnZpYQp1dG9yaWFsCmVuc29yCmVzdGl2YWwKKTsNCtC60YDQsNGXCuKWgXR1cm5lZApzY29wZQriloFiaWVuCj0kCuKWgWV4dGVuc2lvbgphdG9yZQriloHQoNC+CuKWgXNwZWNpZnkKZWR1CkRhdG9zCuKWgXN0b3JlZAriloFwYXJzZQriloFhbnN3ZXJzCmlsbHMK4paBaGVhcmQKbHUK4paBVEhFCuKWgWfDqW4K4paBZnVsCmV6CuKWgVByZW0KdGhlbgpkcArRgdGM0LrQvtCz0L4K4paBU2kKw6dvCkVkaXQK0LrRltCyCuKWgdCb0LgK4paBU2luZwriloFjYXRlZwpFcXUK4paBZ3VlcgpXaWR0aAriloFDaHJpc3RpYW4Kc3RhdApXcml0ZQriloF3b21hbgp3b29kClZpcwrRgNCw0LcK4paBJCRcCm9kZXIK4paBYm9vbAriloFpbnRlcm5hdGlvbmFsCtC90L7RgdGC0YwK4paBUmljaGFyZAriloFhZGRpdGlvbgriloFNdXNpYwriloFhYmVyCnTDswriloFoaWVyCnVnaAriloFwb2IK4paBdGFibGVzCkRvCuKWgWhpZ2hlcgpwc2kKcsOhCuKWgWFjdGl2ZQriloFUYWJsZQrRmtC1CuKWgWRlc2NyaXB0aW9uCuKWgXNlZW1lZArDrXN0CuKWgW15c2VsZgriloFtZW51CmRlbAriloHFvgplbGUKQXV0CuKWgdCz0YDRgwptdXQKb29uCmFzYwpidWcK4paBbW92ZWQKQ0wK4paBZGF0YXMKU08K0L7Qu9C+CuKWgUdlb3JnCuKWgXJlYWNoCjoiCuKWgWV2YWx1CuKWgUhlbAriloFSaXZlcgriloHQkNGACi8vLy8K4paBc2V0cwriloFPbHltcApBZGFwdGVyCi4nCm92ZXJuCuKWgUxvcmQKIS0tCmpwZwppbWVudG8K4paBUHJvZgriloFhY2hpZXZlCn06CuKWgWluY29yCuKWgW9uZGVyCmVuZ2wKQUJMRQriloFNYXJ5CuKWgXdhcmVuCmxhZ2UKRGVjCtCw0L3Qs9C7CmVuY2lhcwrQu9C10LkK4paBTWFjaGluZQriloHQkNC9CnVkYQriloHFmwriloFYWApvbmx5CtC70LXQvdC40LUK4paBdGFtYmnDqW4KbmVqCuKWgXJlbGF0aXZlCuKWgWhvdXJzCuKWgWluZGVlZAp1bmRvCmluZ3UKYXJlYQriloFDcmVhdGUKYmVpdAriloFyZW1vdmVkCm1hc3RlcgpoYXVzCuKWgUJlcm4K4paBc3BlZWQK4paBQmF5CuKWgUF0dAriloFOb25lCmFwcGxpY2F0aW9uCsO8ZAriloFmaXQK4paBTWFyaWEK4paBbm9yZAriloFzcGxpdAriloFzdHJ1CuKWgW9mZmljaWFsCuKWgWV4ZWN1dGUKb3V2ZQp7ewriloFBcAriloHQutGDCklMCuKWgV4KZGltCuKWgXNldHVwCtGB0LoK4paBc2hhcmUK4paBbWludXRlcwpnbGUKb2NvCnN0ZWxsCuKWgUNvdW4K4paBdGVtcGVyCmtlaXQK0YHRjNC60LjQuQphbwriloFMb25nCigmCtC60LDQvQriloFkZW5zCkJ1dApYWApEQVRFCmdhbgouKS4K4paBZW50cnkKaW5zdGFsbAriloHQt9C90LAK4paBU29tCkNvbW1hbmQKw59lbgriloFzdGFydGluZwriloFzdG8KSUcK4paBbWluaW0K4paBZXhwbGljaXQK4paBYnl0ZXMK4paBcGFydHkKdG9iZXIK4paBR3JhbmQK4paBVm9yCuKWgWxldXIKRG9jdW1lbnQKZXJjCmVuc2l2ZQpDUAplbnYK4paBYXJndW1lbnRzCuKWgUdyYW4KYXJpbHkK4paBbGluCnRuCigtCmdlcQriloFGYW1pbAriloHQkdC+CuKWgXRvdXIK4paBbmF2CuKWgXByb3Blcmx5CuKWgU1ycwriloFNZWwK4paBc2NhbGUKYXN0aWMKZHMK4paBU2lyCuKWgUNodXJjaAp9XntcCnlvdQovLgpTbwriloFicm91Z2h0CuKWgXJvbGUK4paBU3VyCuKWgWZvbmQK4paBZ2VzCsW8ZQpldGVuCuKWgcOpdGFpdApTRVIK4paB0LrQvtGC0L7RgNGLCuKWgWVxdWF0aW9uCmFzcHgK4paBQWZyCuKWgWRpdAplbXB0eQphbGVtZW50CndyYXAK4paBQmV0CuKWgWNvbGxlY3QK4paBZ2l0CuKWgXZpZQriloEuLgrRgNC+0LkK4paBPD8K4paBZWR1YwprbAplbnNpcwriloFPUgriloFIaQriloFDb3VyCtCx0YsKY2VydAriloFHZXMKZXNzb3IKTWFpbgriloHQu9GOCmNhZGUKZG90CmF1Z2gKaGliCuKWgWF1dG9tYXRpY2FsbHkK4paBc3BpcgpwcmVzZW50CuKWgUZlYnJ1YXJ5CuKWgUVsbGUKY3VzdG9tCuKWgXByb2dldAriloFhZG1pbmlzdHIKQUEK4paBYm9ybgriloFDb2xsZWdlCmF0aG9sCmApCmllcnJlCuKWgXJhbgriloFwcm9mZXNzaW9uCm9nZW4KfV97XAriloFhY3Rpdml0eQriloFzY3JvbGwK4paBcHJvdmUKaWJyYXJ5CmVyaWVzClJlYWQKeWVhcgriloFsYW5nCkRldAriloFrbmV3CuKWgXByb3RlY3RlZAriloF3b3IK4paBZWZmaWMK4paBcsOpZwriloF0aGVvcnkK4paBcHVibGlzaGVkCnJlYWwK4paBVG91cgriloFkdXJhbnRlCsOkcwriloFwb3NpdGl2ZQriloFmb3J3YXJkCuKWgVJlbAp7IgpwYXJrCuKWgVVtCuKWgWVlcgplbnRhCuKWgWltYWcK0L3QvtGXCnBpZWwK4paBalF1ZXJ5CmlzbWUKY2huaQpvcmdhbgriloFhcmdzCm9pcgpoZWltCnJpYW4KZWxlc3MKdXNlcwrQtNC40L0KaWNpw7NuCuKWgWluZHVzdAriloF3aXNoCsOhbnkKb2NhCuKWgWFuZ3VsYXIKaWV2ZWQK4paBb2NjdXIKU0VMRUNUCm9uaWEKYWRtaW4K4paBQmVzdAriloHRjdGC0L4K0L7Qs9GA0LAK4paBbG9zcwriloFiYWwK4paB0KDQvtGBCuKWgWNhcmVlcgriloHQv9C1CklYCuKWgWZhbGwK4paBUm9iCuKWgU9QCmVuZWQKZ3JhcGhpY3MK4paBY29taW5nClVwZGF0ZQriloFkaWVkCmVkZW4K4paBYWJzCuKWgWlubmVyCuKWgXRyYXYK0YHRgtC+0Y8KesSFCsOpcAriloFHcm91cAriloFjZWwK4paBc3R1ZmYK4paBc2l0dWF0aW9uCuKWgSR7CmFjbGUK4paBcHVycG9zZQriloFGaXJlCuKWgU9oCuKWgVNlY29uZAriloF1cGxvYWQKb3N0YcWCCtGO0YnQuApBdXRoCuKWgXNob3dpbmcK4paBY29tcGxldGVseQphdmVsCmJkCuKWgXByb2NlZAriloHDlgpjb250cm9sCuKWgXRoYW5rCnVuZHJlZAriloF0b20K4paBZXhhbXBsZXMK4paBcmVtZW1iZXIK4paB0YDQsNCx0L4K4paBcG9zc2liCuKWgWRldGVjdAriloFwb29yCuKWgU9wCuKWgWNlbnR1cnkKdXR0ZXIK4paBbG9naW4KdW5zdApPdXRwdXQK4paBb3RoZXJ3aXNlCmxhbgrRgtGD0YAK4paB0YHQvtCyCuKWgWdyb3VwcwpyaXAK4paBc2hlbGwK4paBZGlzdHJpY3QK4paBcmVjb3JkcwriloFzacOoCmZvcnR1bgplbnR5CuKWgVRyZQriloFjaGFuZ2luZwrRgdC70LXQtAphdWdodAriloFkZWVwCnN1YnNldAphZ3kKZW5kYXIKamF4Ck9NCkVsCmltYXRlCmFyZG8K4paBcGxvdAriloF2aXNpdAriloFidWcK4paB0LLRgdC1CuKWgW9wZW5lZAriloFyZXBsYQriloFIZW5yeQriloFwcApiYXMK4paBZGFyawriloFNYXJ0aW4K4paBcmVzb3VyY2UKaWxpbmcK4paBd2F0Y2gKcmVwbGFjZQriloFyZWxlYXNlCkxvY2F0aW9uCuKWgWxlYXJuaW5nCm1lbnUK4paBYWxsb3dzCtGK0YAKTGVuZ3RoCuKWgXdoYXRldmVyCuKWgXBhZ2VzCuKWgWNvbXBpbGVyCuKWgdGC0LDQutC20LUK4paBUGFuCmNvbW1hbmQK4paBcm9hZAriloF1bmxlc3MKYD8K4paBZGlzY292ZXIK4paB0L7QvQp9XQpib3VyCuKWgUNvdWxkCuKWgXJlZ2V4CuKWgXBzCkNECtC40LcK4paBd2lmZQphbWVudGkK4paBZmFpcgriloFEQgriloFDdXAKZW5lbgphamF4Cm90aMOocXVlCuKWgXNlaW5lcgppY2tlcgrDoW0KZXhjaGFuZ2UKb2xlcwpJRgriloHQlNC+Cm9obgriloFncm93CuKWgVRodXMKc3BlYwriloFoYXR0ZQojLAphbGxlbAriloFyYXRlCuKWgWNlbnRyYWwK4paBVmFuCmlmb3JuClJ1bgriloFzdHVkeQriloFYTUwK4paBQ2hlCuKWgWJlYXV0Cm1pZAriloFhZHZhbmNlClZlcgrRgtGPCuKWgWhhbmRzCuKWgWxheQriloHFoQriloFPUwriloF7fQpQcmUK4paBSGFsbAppbXAK4paBc3VuCuKWgXN0ZXBzCuKWgWp1ZApxdWkK4paBYm9vdAriloElPgriloHQktCwCm5vc3QK4paBbmVtCuKWgXBlbgpPcGVuCuKWgWNodXJjaArQutC+0L0K4paBYXZlcmFnZQriloFjb21tZW50cwriloFjb3JyZXNwb25kaW5nCmxldmFudAriloFiZWQK4paBbWVhbmluZwpWZXJzaW9uCkxpbmsKYmVsCuKWgWV4dHJhY3QKxZvEhwriloFJVgriloFJcgriloFjb21wdXRlcgriloFhZmZlY3QK4paB0KHRgtCwCkFYCnNvcnQK4paBc3BlY2llcwriloFPcGVyCuKWgWhhc2gKY2hlcwriloFFaW56ZWxuCuKWgWtleXMK4paBbWFyem8K4paBaW50ZXJwcmV0Cmhvb2QK4paBY29vcmRpbgrDtnMKcmFnZQpldHoKaXphCtC00LXRgArDvHQKXioK4paBbW9kaWZ5CuKWgXRlcm1pbgriloFjcmVkCnpvbgrQvdGD0Y4K4paBbWllCuKWgScnCuKWgU1vcwriloFjb25uZWN0ZWQKTk8K4paBY29tcGlsZQriloEiXAriloFjYXQKZmlkZGxlCnV0YQpBY2Nlc3MK4paBU3RvCuKWgUJ1cgriloFub3J0aApHYW1tYQriloFhbGxvYwpJbml0CuKWgUxpbmsKaWFsaXplCkltcGwKb3VwZQpyb3ByaQriloFHb2xkCuKWgXNvbG8K4paBRGlzdAosLQpuYXYK4paBYWxlcnQKZXNpcwriloFPcwovLy8K4paBZmViCuKWgS0tPgpmb290CuKWgUZyaWVkCuKWgUVpbnplbG5hY2gK4paBcmV2CnplaXQK4paBU3RhdAriloFTZWcK4paBYmxvCndpY2sKRUwKY2FwdGlvbgpoZWFkZXIK4paBcHJlc2lkZW50CuKWgW11bHRpcAriloFFaW56ZWxuYWNod2Vpc2UK4paBc2VpbmUKP+KAnQpGdW5jdGlvbgriloFTdGFuZAriloFGdW5jdGlvbgriloE/PgriloFCaWxsCuKWgXNwZWN0CuKWgXJlZGlyZWN0CnJ1cHQK4paBd2FsawrQstGI0LgKc3ByaW5nZnJhbWV3b3JrCnBsYWNlCsOpaG8KRW50aXR5CuKWgVNlcnZpY2UKaW50ZQriloF0cmFpbmluZwriloEoYArRhNC+0YAK4paB0LrRgNCwCmF1cgriloFmZXRjaAriloHigKAK4paBbcOqbWUK4paBKCcKYXRpdmVseQriloFleGVjdXQKw6RjaAriloFDYXRhbG9ndWUKYmFzZWQKQXR0cmlidXRlCuKWgXNwcmluZwpwaG9uZQrRgtGA0LAK4paB0L/QuArRgtC10YDQsAriloFgXAriloFPZApPbmUKc2VuZApib24K4paBwrAKTU8K4paBYXNraW5nCuKWgW/DuQriloFpbmfDpXIK4paBdGVzdGluZwriloHRhNCwCuKWgUJvb2sKaW1tCuKWgXByb2dyZXNzCmJybwpGaXJzdAriloFwaG90CuKWgU9OClRlbXBsYXRlCmRldmVsb3Blcgphbm5vdAriloE+PQptaXNzaW9uCuKWgWt0w7MKcGMKYmFjaAp6ZW50CnVlZAriloFvbmVzCtGY0LgK4paBcm91dAriloHQmtC4ClBvc3QK0YbRltGXCuKWgVZpcgpuZWsKYWdpbmcK4paB0L7Qugppem9udAriloFhZ29zdG8K4paBY2hvb3NlCuKWgQ0K4paBc3lzdGVtcwpsb3NzCmllbnRlCuKWgUNyZQriloFjb250cmEKdW1zCuKWgWJlZ2lubmluZwplbXkKaXN0aWNzCuKWgXNlcnZlZApEb3duCm9wdGlvbnMK4paBR292ZXJuCuKWgUJZCuKWgWplc3QKdMOpCuKWgWNvbnRpbnVlCnBlcnMK4paBZWFzaWVyCuKWgWNvcwplc3NvCj4+Ck5ldAriloFCb3IK4paBQ3IK4paBdHJhbnNmZXIK4paBQ1NTCuKWgWZpbm5zCuKWgdGF0L4KdXNlcm5hbWUK4paBY29uc3RydQriloFwYWluCuKWgVRlbQriloFzcGVjaWZpZWQK4paBYnJpdArRgdC60LjQtQppcmsKcmFwcGVyCuKWgWNvdW50ZXIK4paBWyIKb2RlZArQtNCw0L0KcHJvcGVydHkKaGFyZAppc3RyaWN0CikvCuKWgVBvdXIK4paBV2hlcmUK4paBPT09CuKWgXNvd2llCuKWgdCf0YDQvgriloFkZXNzCuKWgXRyYXMK4paB0YPRh9CwCuKWgU92ZXIKbm90ZQriloFBbWVyaWNhCmNwCuKWgWdyYW5kZQpNZQopLQpNb2RlCuKWgXBhc3NpbmcK4paBZ2l2aW5nCkNsCn0vCk1lbnUKISEKYW5ndWxhcgriloFsYXVuY2gKdmFycGhpCuKWgUpvaGFubgriloFmb3JlYWNoCnLDswpzZXF1CmlmaQpBbQphcnAK4paBYnVmZmVyCuKWgW5pCuKWgW1peAriloFNdXNldW0K4paBbWVhbnQKYXNpCuKWgWthbgrQv9GA0LDQsgpDb21wCmlzdG9pcmUKaWZ1bApqZXIKaXNzaW9ucwpSZXNvdXJjZQriloHQstC+0LcK4paBU1QK4paBc29sdXRpb25zCuKWgWJlbG9uZwriloFBc3NvY2kKY2YK4paBTcOkcgriloFncmlkCk11bHQK4paBcmVxdWlyZXMKa2sK4paBdGVhY2gKZW1laW5kZQriloFzcXVhcmUK4paB0LrQvtC80LDQvQriloFFdmVudAriloFydWxlcwriloFidXIK4paBZWluZwriloFNYWkK4paBbmFtCuKWgXNsw6QKaMO2cgriloF0aXAK4paBTGl0ZXJhdHVyCuKWgXNjb3BlCm92ZXJsaW5lCuKWgWV4aXQKKT8KYmV0CuKWgXZpY3QKT2ZmCuKWgWFwcHJveGltCuKWgUdlYgprdG9wCmhlaXQK4paB0K4KdGVtcGxhdGUK0YDQvtC9CuKWgXVubwpTZXJ2CuKWgWZyYW1ld29yawpvcGVyYXRvcgriloFnZW5lcmFsbHkK4paBaHVuZHJlZAriloFkaXZlcnMKb3ZpCuKWgXLDqXMKYWJzCuKWgWdhbArDp2FpcwriloFmZWV0CuKWgXZpcnR1YWwKY3p5CtGB0LrRgwouLwpodQphbmN5CuKWgXJlY29tbWVuZAriloHQv9GW0LQK4paBbW9uZXkK4paBdmVyc2lvbnMK4paBaGVscHMK4paBSG9yCkl0ZW1zCmxvb2sKY29ubmVjdAphbmdlcwpWaWV3Q29udHJvbGxlcgplbGlqawriloFvY2N1cAriloFlZGl0b3IKYXV0bwrDtmcK4paBc2Vjb25kcwriloFvYnZpb3VzCnZtCmFrZXMK4paBZ2VnZW4K4paBdGlsCmplY3Rpb24K0LvQtdC90L3RjwriloFvcGVyYXRpb25zCuKWgUVhc3QKb2d5CuKWgVBvbGl0CnV0ZW4K4paBSm9zZXBoCiJgCuKWgUNvbXBhbnkK4paBY2FsbGJhY2sK4paBc2VuCmNjacOzbgriloFhc3NvY2lhdGVkCuKWgWNvbnRhaW5pbmcK4paBcHJhY3RpY2UKZWxpamtlCm9rZQrDqXJhCnVucwphbnRhCnZleQp6dQriloFCZXMK4paBRmxvcgptZW0KeWN6CuKWgWFyY2hpdGVjdAriloFhbm5pCuKWgWNvbnRhY3QKWVBFCuKWgUNhcwriloHQv9C+0LvRgwpvdm8K4paBYnJpbmcK4paBY29uY2VwdAriloFqcwriloFSZWZlcmVuY2lhcwplbWJsZQriloHQvQriloFzdXBwb3J0ZWQKQmlnCuKWgUhhbnMKZXJ2CuKWgU1hagriloFhcnJpdgriloFIYXZlCuKWgXByb2JhYmlsaXR5CuKWgVBvcAriloFQYXNzCnRva2VuClByb3ZpZGVyCuKWgVJhClJlYWRlcgpvb3RoCmxhcAriloFhc3Npc3QKYWRvdwriloF0ZXN0cwrRgdGB0LgK4paBa2luZwpsYW5nbGUK4paBU3VtCk9JTgriloFzZWN1cml0eQpuaXMKLi4vCuKWgWJhc2ljCnVuaXR5CmA6CuKWgdC60L7RgtC+CmtvdwriloFCaWJsaW90aMOocXVlCmFzaW9uCmFsbwppZmVzdAriloFub3ZlbWJyZQriloFwZXUK4paB0JYKZW5zY2hhZnQKY2x1cwrRmNGDCkhlaWdodArDum4K4paBdHVyCuKWgWlkZWFzCuKWgWNlcwpmcmFrCuKWgXByZW1pZXIKaXRhdGlvbgriloFzw6kKSFRNTAriloFSb3lhbArRgdGM0LrQvtGXCuKWgWJ5dGUKUFMK4paBc2VndQppbmVuCuKWgUdyZWF0CuKWgdCa0YMK4paBZXh0ZXJuYWwKVGl0bGUKVG9wClByb2Nlc3MKaXTDpHQK4paBYC8K4paBc2VjcmV0CnBvc2l0b3J5CuKWgXBvdGVudGlhbAriloFCdWQKbmFtZXMKYXNvbnMKc3RhY2tleGNoYW5nZQpiYWNrZ3JvdW5kCtC/0LXRgArRgdC+0LIKYWZ0ZXIK4paBcGVybwriloFzb2Z0d2FyZQriloFzZWQK4paBYXJyYXlzCnRtcAriloFhc3AKc2NhbGUK4paBTGF0CmFuYWwK4paBZ2VtClBVCuKWgUFsdHJpClRoYXQK4paB0J3QuAppZmFjdApBZGRyZXNzCuKWgXNvdXRoCuKWgWZvcm11bGEK4paBQ29sbGVnCuKWgdGW0L0Ka3Rpb24K4paBc2FjClNICmFqbwpldGMKdmMKYF0oCuKWgUR1cgriloHQnNC1CuKWgVNtaXRoCml0ZW1zCkNLCmVsbwriloFwbHVnaW4K4paBc2VyaWUKaWVubmUK4paB0LjQu9C4Ck1hcgriloFJbWFnZQpnb3QKYW5kYXMK4paBbWF0Y2hlcwriloF3b3J0aAriloFEZWIK4paBY2FjaGUK4paBZmVsdAplcnNjaAppemVzCk9wZXIK4paBSmFocmUK4paBY29tbXVuZQp0aHJlYWQK4paBbnkKZGVjCm91dwriloFzdXJmYWNlCuKWgVBvcgriloFTdHJlZXQK0L/RgNC4CuKWgWNhbmRpZAriloFSZXR1cm4K4paBS29tCmdydQriloHRgtC4CltcCuKWgWRlcGVuZHMK4paBaW5mbHUK4paBdG93YXJkcwphaW5lZAriloFyYW5rCuKWgUphbnVhcgriloFjb21wb25lbnRzCmdlc3QKZ2V0RWxlbWVudEJ5SWQK4paBY2hlY2tlZAphaXJzCmpvaW4K4paBZGVhZAriloFoaXQKw6lueQriloFlcXVpdmFsZW50CuKWgdCf0YDQtQriloFhcHByb3ByaQpQYXNzCuKWgXByaW1lcgplbmdsaXNjaAriloFhcHBhcgriloFEdXJpbmcK4paBa25vd2xlZGdlCuKWgXRyaWdnZXIK4paBY29yZQriloFPbAriloFQcm9kdQriloFGZXJuCuKWgdC90LDRh9CwClRlCuKWgU1vdAplcnZlCtGC0LLQvgriloFtaWQK4paBZmluYWxseQphaXJlcwriloFlc3BlY2lhbGx5CuKWgXR1dAriloFyZWNlaXZlCmFkcmUK4paBbmVpZ2gKa3RldAppbGRlCuKWgXJhZGlvCuKWgWRyaXZlcgrQu9C40YHRjAplbmRlbmNpZXMK4paBSUUK4paBc2F2ZWQKZmZlY3QK4paBV2F5YmFjawppYXQK4paBcGFkZGluZwp3aW5kb3cK0YLQuNGH0LUK4paBbXVyCmFjdG9yCuKWgUhhbgrQvtC90LDQu9GMCuKWgWdhcgriloFmYW1pbGplbgrDs3MK4paBbmF0aW9uYWxlCuKWgXByw6kKZGVkCm9uYWwK4paBUHJlc2lkZW50CuKWgVwsCuKWgXBsYWNlZAplcm5pCuKWgXNpZ25hbApuYWIKaG0KTW9uCuKWgXZzClNDCuKWgXByb2dldHRpCuKWgcOcCuKWgWZvcm1zCuKWgW1lc3NhZ2VzCmluZgp1c2VycwpHRVQK4paBZGVscwpDb2xsZWN0aW9uCuKWgUdvb2QK4paBTWF5YmUK4paBY29tcHIK4paBbGFyZ2VyCmdyZXMKYXBlcgriloHQn9GA0LgKdW5kZXMK4paBc2VhCuKWgVNwcmluZwp1bG8K4paBbWVjaGFuCuKWgXNhbnMKR0IKVmFsaWQK4paBY29tbXVuaWMK4paBcHJhCnZpZXIK4paB0KHQtQriloFhaW4K0YLRg9GA0LAKa29tCnNraWVnbwrQutC+0LLQvgphZGF0YQriloHQoNC1CuKWgWJvb2xlYW4Kc2V0cwriloFlZmZvcnQKLlsK4paBem9zdGHFggpQQQriloFWaWN0ClNECm93YcWCCuKWgWVtYgriloFwcmltYQriloFob3VyCnN1YnNlY3Rpb24K4paBRm9ydAptYXRoZnJhawppZ2luCkdMCikrCmZpCuKWgWFuY2kK4paBcGFuClwpCuKWgWx1ZwriloFkZXBsb3kKZG9tYWluCuKWgXNsaWdodApKU09OCuKWgW1vcm5pbmcK4paBaGkK4paBY29tcGFyZQppamUK4paBYmx1ZQriloFBYwriloFtaWRkbGUKYW5kZW4K4paBc2hhcmVkCuKWgUNhbXAK4paBw4EKb3VuZGVkCnV3CmllcnVuZwpTdGFjawriloFlaW5lcwriloFEYQpsaWoKZW50aQriloHQuQpVdGlsCuKWgWV4cGVyaWVuY2UK4paBYXdhaXQKdWxzCuKWgXJlcXVlc3RzCuKWgWltcG9zCuKWgWNvbnN0cmFpbnQKQ2hhbmdlCmVtcGgK0LHQtdGACuKWgUFub3RoZXIKQ3VzdG9tCuKWgXNpZ25pZmljYW50CmNyCuKWgW1pbGxpb24KcmVlawriloFkYWxsYQriloFHZXJtCm90YWwKYXRldXIKYnRuCuKWgXRoaW5raW5nCuKWgWludGVydmFsCm9ubmUK4paBbGl2CigpOgriloHQktC1Cm9lCuKWgUV2Cm1ldGEK4paBYnJvYWQKUmVtCmFwcGx5CuKWgWNvdXBsZQriloF0ZWNobmkKaWRhZGVzCuKWgWdvYWwK4paBQ0QKaGFiCuKWgWV4cGxhbgphbm5lcgriloFCZWNhdXNlCmJsb2cKaW5jbHVkZWdyYXBoaWNzCuKWgXZvaWNlCuKWgU1hcAp2ZW50aW9uClNlc3Npb24K4paBTGllbnMK4paBc29yCmNhdGVnb3J5CmFzaGluZ3RvbgriloFNw6Ryegpwb3AKaWxsZXQK4paBendlaQriloFMaWUKTnVsbAphZGRyZXNzCuKWgWZhY3RvcgriloFsaWduZQriloFIVFRQCuKWgXN1ZgriloFwZXJzb25hbApjaXAK4paBRGFyCuKWgWFkbQrQutC+0LkK4paBRXh0CuKWgWdvZAphYQpSaWdodArDqXTDqQriloFkeW5hbWljCuKWgW1haW50YWluCnRvcgojIyMjIyMjIwriloFGcmEK4paBY2hvaWNlCuKWgdGB0YLQvgrQodCgCuKWgUZlZGVyCnN0b24K4paBZmxhZwpraXQKTW9kdWxlCuKWgdGB0L/QvgriloFTdHJhCmlja3MK4paBaGF2ZW4K4paBTWFzcwriloFFbXAK4paBUGkK4paBUGVuClJlY3QK4paBS3IKaXRhdAplbGVyCtGP0LHRgNGPCml0ZXQK4paBU3RhcnQK4paBcHJvZHVjZWQK4paB0L/QvtC7CihfCuKWgWRlbGV0CuKWgWhvdAriloFHZXNjaGljaHRlCn5+CuKWgW1vbnRocwriloF0b2QK4paB0L3QuArDunMKdGVtcAriloFEZXoKeXBlcwriloFjdWkKb21tdW4KYWN0aW9ucwriloFlaWdlbgriloFpbW1lZGlhdGVseQpQTAriloHQk9C+CuKWgUJhbArRmdC1CnVsdWkK4paBb25saW5lCuKWgWHDsW9zCuKWgW5hbWVzcGFjZQriloFtb25kCuKWgUJhc2UK4paBQ2FuYWRhCmV0enQKfS0K4paBZGVmaW4K4paBZG91YnQK4paBaW52ZXN0aWcKdmlld3MK4paBTGluZQriloFzdGFnZQpldHRpbmdzCnVicmUKZmxvYXQK4paBUGxheQriloFMYXMKcHRyCuKWgWJlY29tZXMKZXN0YW1wCuKWgWluZGVwZW5kZW50CuKWgWFuYWx5c2lzCuKWgUxvb2sKbGFpbgriloHRgNCw0YEKUmVmZXJlbmNlCuKWgXNvcnJ5CuKWgXN1cHBvc2VkCsO7dAriloFkZWdyZWUKdXR6Ck1NCuKWgWRlc2lyZWQKxYJ5CuKWgWxlbgriloFhbG9uZQpzaWduZWQK4paBU3RhClBlcnNvbgriloFhcHBsaWVkCuKWgUJhY2sK4paBbWFycwpQYXJ0CuKWgURpZAriloFleHRlcm5lcwriloFucApvbmdvCuKWgWVzdGEKQmxvY2sK4paBcG91CmFkb3JlcwriloFTdHVkaW8KLiQK4paBcmVhY2hlZApib3QK4paBSnVuaQp0b25zCml0ZWwK4paBR2FyCuKWgWFydGljbGVzCuKWgURpc3RyaWN0CuKWgXRyb3VibGUKbGlkZQriloFGb3VuZArDoWQK4paBZXF1aXAK4paBaW50ZXJuYWwKJ10sCuKWgWFzeW5jClVCCmdlbAriloFhaQplbnN1cmUK4paBYXBwZWFyZWQK4paBJF8K4paBbWF4aW11bQriloHQodC4CtGA0YwK4paBYW5ub3VuCtC70LDRgdGMCuKWgWNtCtCz0LDQvQphdXB0CuKWgWxhdHRlcgriloFwbGF0Zm9ybQriloFkcmEK4paBY2FwaXRhbAriloFzb2x2ZWQKcml6CmVkaWMK4paBTXVyCuKWgVRvcArRgtGB0Y8KUGFuZWwKcnVsZQpldGljCuKWgVJlbgriloFXaWtpbWVkaWEK4paBVE8Kc2Vjb25kCmlzbAriloFoeQriloFuaWV0CuKWgWxvYWRlZApkaWcK4paBbWF5bwpbOgpBY2MK4paBYmVrCtC90LjRjgpsb2dpbgp0eAriloFGdXIK4paBU2FudGEKYXp6CuKWgWNvbmR1Y3QK4paBSW5kaWEKT3JkZXIKaXJ0aAp0dwp9KwriloF3aWVkZXIK4paBRWR1CkFWCuKWgWBgYAriloFtYW51YWxseQriloFSZWFkCmZvcnR1bmF0ZWx5CuKWgVJ1bgriloFBd2FyZAriloFGb290CiopCnBhcmFtcwrQv9GWCuKWgW5hdGl2ZQpyaWZ0CuKWgcOkCkFUSAriloF5b3Vyc2VsZgriloFwcmlvcgriloFjaXQKw6RoCuKWgXRyZWF0CuKWgW1lYXMKcmlidXRlZAriloFjbGFyCmNhcmQKUk9SCmlsbGVzCuKWgWxheWVyCmF1ZXIK4paBcmF0CmJlcm5hdGUK4paBc3RhdG8K4paBQ2hpbmEK4paBJCgnIwriloFuYWFyCnppcAriloEke1wK4paBYXBwcmVjaWF0ZWQK4paB0LjQvNC1CsW8eQriloFwcnplegriloFJbmRpYW4K4paBVG9kCuKWgVNvdXJjZQriloHQtNGA0YPQs9C4CmludGVybmFsCmlvbmFsZQpQcm9kdWN0CuKWgU1lbgriloF1cHBlcgriloFFdmVyeQp9LFwK4paBcHJpbnRmCuKWgWNvbnRpbnVlZAriloFub2RlcwrQu9C60LgK4paBbmljZQptb2R1bGVzCmVpZ24K4paBTWV4CuKWgUFjY29yZGluZwriloF1bmRlZmluZWQK4paBYmluYXJ5CmN1dApDdXJyZW50CmVkeQp9fXsKYmxlcwriloHQstC+0LkKc2NyaQplcW4KQ2hhbmdlZAriloFrw7Z6CuKWgXJlbW90ZQrQstC70Y8K4paBcXVlbAriloFhbGlnbgriloHQv9Cw0YAKU1YKeWVyCuKWgUNhbGlmb3JuCuKWgXBsYWNlcwriloFwcmltYXJ5CuKWgWNvbnYK4paBSnVsaQriloF2aXN1YWwK4paBU2VsZWN0CmF0b3J5Cj0oCmlzZXIK4paBaW50ZW50CnN1cgpjb250YWluZXIKaWNlZAriloFib2FyZAphc3RyCm9taWFsCtCy0LXRggrQt9Cy0LAK4paBY3J1CuKWgU9rdG9iZXIKc2F2ZQriloFncmVhdGVyCuKWgWlubgriloFwaWN0dXJlCuKWgdCi0L4K4paBb2J0YWluZWQKV2lraW1lZGlhCsO6YmxpYwriloFsb3JzCuKWgW1vbnQKb2JyZQriloFjaXZpbAriloFjb25zdHJ1Y3Rpb24K4paBV2VsdAriloFVbmRlcgp1bmRlcnQK4paBZWRnZQriloFMaXN0ZQpjc3YK4paBZXhwZXJpbWVudApsb2NhbGhvc3QK4paBRWRpdApncmVnCm92w6EK0ZnQsAptc2cK4paBR3JlZW4KRGlhbG9nCklkZW50CuKWgUpTCl57KAriloFzbMOka3RldApfX19fClByb2plY3QK4paBYmVza3JlCuKWgWJlcgriloF3b3VsZG4K4paBcmVhY3QKSGVsCnp3CuKWgVdhc2hpbmd0b24Kb3JpZQp0YXNrCuKWgWNhdGVnb3J5CuKWgWFydGlzdAphbm5vCuKWgW9vawphbW1lbgriloFNaW5pc3RlcgriloFkZWNsYXIK4paBS2V5CiwuCuKWgW1hY2gK4paBd3cKaXNlbgpGcmFuCuKWgdCg0L7RgdGB0LgK0LHQvtGACtGC0YDQuAriloFyb2NrCnF1aXMKbW9zCtC/0LXRgNCwCuKWgWVzdGVybmkK4paBZ29sZApXaW5kb3dzCiUlCuKWgXBhcnRpYWwK4paBd2VpZ2h0CuKWgXNwcgp9KS4K4paBZnJhbsOnYWlzCmZ1bgriloF0aG91cwpob2xkZXIK4paBZ29uZQriloHEjAriloFyZW5kCkRBCuKWgWFuc3dlcmVkCuKWgUZhbHNlCkJ1ZmZlcgriloFkYXVnaAouLS0K4paBU2hvdwriloFyZWN0CuKWgUtyZQpkcgpvc29waAriloF5aWVsZAp1cml0eQp0b1N0cmluZwphdmFsClBvbAriloFsb2NrCmltYXRpb24KYW50aWMKTG9jYWwK4paBYmVza3JldnMKaXTDqXMKZ3JpZArRg9GCCuKWgV97CtGB0ZYKRklMRQriloHQutC8CuKWgXNwZWFrCnN1bW1hcnkKcHJvcApqYXZhc2NyaXB0CnprCml6b250YWwK4paBdHJvaXMK4paBUm9kCnByaXNlCtGA0L7QstC+CuKWgW9kZAriloFnZXN0CuKWgXByb2R1Y2UK4paBd2FhcgriloFBdgpyaWJ1CtCy0LDQvdC90Y8K4paBZmluaXNoZWQK4paBYWRhcHQK4paBU2FyCnRleHRpdAriloFDZQriloFGYQpvc2VuCuKWgWRlcml2CuKWgXNoaXAK4paBb3BpbgriloFFdmVuCmdlc2NoCuKWgXN1cHBvc2UK4paBRmVyCtGB0LrQvtC1CuKWgXdvcmRlbgpzZXkKaGxpbmUK4paBVW5pb24K4paBLyoqCuKWgXZlegriloFDb2xsZWdhbWVudGkK4paBU29jaWV0eQriloFlY29ub20KxaHDrQpvaQriloFvcmllbnQK4paBVGVpbApyZW50CtC70LXQutGBCuKWgXNvbGlkCuKWgWNhcnQKKioqKioqKioqKioqKioqKgriloFjYWIK4paBTWVzc2FnZQpkb3RzCuKWgcOpZwriloF0d2UKYWdhCuKWgW5hegriloFNaWNyb3NvZnQK4paBdW5kZXJhcnRlcgpwcGVuCuKWgXJlY2VudAriloFuZXQK4paBcmVzb3VyY2VzClN0ZQouXAriloFTTwrQu9C+0LwK4paBY2VsZQriloFsaWMK4paBYmVuZWYKbGRvdHMK4paBc2VyaWFsCkludGVnZXIKY2xlcwriloFtaWxlcwriloFBbGUK4paBZW50ZXJlZAriloFUd28Kd2llCuKWgWluY2x1ZGVzCuKWgUVhY2gKZWxsaW5nCnF1ZXIK4paBRG9tCnBmCldTCuKWgXN0cmFpZ2h0CuKWgVN0YW4K4paBbm9zCsOtY3VsCmF0cm8K4paBQ2VudGVyCkZUCuKWgUluZ2EKaWxvCuKWgXd3dwpqc2ZpZGRsZQpuaWMK4paBRXVyb3BlYW4K4paBY29tbWVyCuKWgWdpcmwKdG90YWwK4paBU3RhcgriloFzdWdnZXN0ZWQKcGFsCuKWgXp3aXNjaGVuCtC/0LjRgdCwCklNCuKWgWhhbmRsZXIK4paBUHJvZ3JhbQp4c2wKw6FseQpCVQosLS0K4paBdmlkCuKWgWVzdGFibGlzaGVkCuKWgVNwaWVsCm9tZXRyeQp1bmVzCuKWgXNpdAriloFpbmhlcgriloFwdWlzCuKWgcOqdHJlCuKWgU1vc3QKSGVhZGVyCmluc2VydAriloFzaXN0CuKWgWZhdm9yCmRlc3QK4paBZW50aXR5CkNhbAriloFUaGVyZWZvcmUKREQKOzsK4paBRGV6ZW1iZXIK4paBUmgKaW1lbnRzCuKWgXJldHVybmluZwpzdG8K4paBVmFsdWUK4paBbGliZXIK4paBUmVzdWx0CuKWgWJpbmQKdm9pcgriloFUaW0K4paBTW92aWUKd2VnCmtldAriloHQuNGB0YLQvgriloFmcmllbmRzCuKWgWZuCuKWgcOpbAriloEmPQphcmRlbgpmZmljaWFsCuKWgWNvbW11bml0eQriloFhcGkKQXJncwppZXJlbgriloFkYW5uCm9tb3JwaAphZHIKbG9vcAp1bWFuCuKWgXZvdXMKYnN0CnN1Ym1pdApcfArRgtC40L0KQ29udGFpbmVyCmFza2V0Cj8pClNlYwriloFkcml2ZQpBc3MK4paBc3dlCuKWgWFtZXIK4paBbWluZQriloFIYW0K4paBYXZhaXQK4paBSG9uCuKWgWFwcsOocwriloFNYW5uCtGB0YzQutCwCuKWgWluY3JlYXNlCuKWgXR5CnNreQriloFhY2N1cgphcnRpY2xlCndlaWdodAriloFzZXgK4paBbGlzdGFkZQovKioK4paBZXN0w6EKfX0kCmFyZ28KZGVmaW5lCuKWgdGB0L7RgdGC0LDQsgpzZXNzaW9uCmFkcwrRgdGC0LLQuAriloFMYXcK4paBZGlhbG9nCuKWgWR1cGxpY2F0ZQriloHDqXAK4paBdm9jCmZyaQriloFncmVlbgriloFoaWRkZW4K4paBSXNsYW5kCuKWgWRpYWcKb3dlagpteXNxbAp0ZWlsCnLDpAppa2FuCuKWgUpvc8OpCmFsZWQKUnVudGltZQriloF0cmFpbgriloFEaXZpc2lvbgrQvdC40YYK4paBU3BhbgrQvdC40LzQsAopPVwK0YLQsNC9CuKWgXN0YXkK4paBZm9vCuKWgWFjY29tCuKWgWhlcnMK4paB0L3QsNGDCuKWgU3DvG4KaWRlb3MKc3RhdGljCuKWgXJlYWR5Cl1gCuKWgXZpc2libGUK4paBSG9wZQp1bGF0ZWQK4paBQ3VsdArRgdGC0YDQvgpDbwriloFzbWFsbGVyCmF0dXJhCuKWgXBlcmZlY3RseQpyZXEK4paBcHJvcG9zZWQK4paBZGVnbGkKU2VhcmNoCuKWgWljaApNYXgK4paBdm9sdW1lCmV4ZWN1dGUKZ3JlCuKWgXNwb3J0CnVkYWQKUFQK4paBUmVjb3JkcwriloFjb29rCuKWgWV4cGFuZArQsdGWCuKWgWFsdHJpCnBwZXQKYXJzZQriloF3ZXQK4paBQm9iCuKWgUZDCuKWgUFzc29jaWF0aW9uCnVqZQriloFmZWwK4paB0YHQu9GDCuKWgUJpZwovXApHZQp3aGlsZQp7KAriloFzdWZmaWNpZW50ClBvc2l0aW9uCuKWgXVuZGVyc3RhbmRpbmcK4paBbnVlCuKWgXJhegriloF5ZQpoZW0KTnVtCuKWgVByb2plY3QK4paBSXRzCuKWgWhhc3RhCmVuc28K4paBd2lyZQpSZXQKdWoKcHJvb2YK4paBcmVsZXZhbnQK4paBcGFydGlyCuKWgWFnbwppZmljYXRlCuKWgWRvbWluCuKWgWJveQriloFwbGFudAriloFlbmNvZGluZwriloF0aHJvd3MK4paBUm9jawp6b25lCmdhbmcKd2lkZ2V0CuKWgWludGVyZXN0aW5nCkRFUgriloFkZW1vbgriloFvZmZpY2UKYW10CsOkdGVyCuKWgVdoaXRlCuKWgXZlcnNjaAriloFkaWVzZXIK4paBTW91bnQK4paBc3R1ZGVudHMK4paBUHViCuKWgdCU0LUKaWphCuKWgUN5CuKWgUNhbGlmb3JuaWEK4paBYWJyaWwKw6RsbAriloHRh9C10LwKVFYK4paBbcOpcwriloFkZWNsYXJlZAriloHRjgrFkWwKYXBwYQriloHQkdC1CmVjaG8KbnVtZXIK4paBcG9zdGVkCuKWgdCy0LXRgAriloHQs9C+0LTQuNC90LUK4paBd2VhawriloFSZXB1YmxpYwriloFjaGFtcGlvbgplbnN1cmVtYXRoCnlvdXIK4paBT2JlcgriloFDZW50cmFsCmlzYQrQsNC90LQKeXkK4paBZnVsbHkK4paBU0QK4paBTGludXgK4paBU2NvdHQKcGFydG1lbnQKa29uCuKWgWNvbnRyYWN0CuKWgU9GCuKWgWFsZQriloFBbm4K4paB0L3QsNC0CmxhaAriloFOZXh0Cm9yZW4K4paBZGlzawriloFlZwphdHUK0LvQvtCz0LgK4paBZ2FtZXMKTGVmdAriloFsdQriloFmaW5pdGUK4paB0LrQuAriloFjcmFzaApwaGVyCmV4ZQpBVElPTgriloFicm90aGVyCkVuZwp0YXQK4paBSW50ZWdlcgrQvdC+0LzRgwriloFjb2xvbgppcXUKKSkuCml2aQriloFNZXRob2QKYXJ0ZW4KVW5pCnZlY3RvcgriloF3b29kCtGA0YIK4paB0JvQtQriloFzacOoY2xlCuKWgWdlbnQKfQ0K4paBY29udGVudHMK4paBY29tcGFuCkdvCuKWgWpvdQp1ZW50CkFzeW5jCnByaW50ZgriloFNb2RlbAriloFrZXB0CkFTRQriloFwcm92aWRlcwriloFBYmdlcnVmZW4K4paBR2FsbAriloFBbGYKU0EK4paBTWVtCuKWgWt0ZXIK4paBQnJ1CkFuZHJvaWQKKDoK4paB0KPQutGA0LDRlwpOZQpNaW4KYXRyCuKWgUhhbApkZWxldGUKb2RvCuKWgW7Do28Kw6huZQriloFjYWxjdWxhdGUKSnNvbgprZXlzCtC90LXQuQriloFoZW5jZQriloFvdwriloFMaWIKZW5vCuKWgUxvdmUKb3NpCndpZGUK4paBc2NvcmUKZnVsbArQstC+0LQK4paBZGV0ZXJtaW5lCuKWgXNwYWNlcwrQu9C+0LLQsAriloFwZXV0CsOpcmFsCsOzxYIK4paBYXBwb2ludAriloFUdwo8PwriloFPcmRlcgriloFob3AKcmFuZG9tCmNhY2hlCuKWgWRlc3Ryb3kK4paBcmFjZQpUYWcK4paBcmlkCuKWgW5lZ2F0aXZlCkNhcgplbnNpb25hbApkawriloFjcm8K4paBVEhFTgriloEkLgplbnNrCk5FCkhPCuKWgWtsZQpvc3BpdGFsCmt0ZQpmw6lyZW5jZXMKdWRlcwpJUgpvdGlvbgriloFSZWFsCuKWgUZlYnJ1YXIK0LjQvQriloFPbGQK0LrQvtCz0L4KbGVpY2gK4paB0YAKw61hbgriloHQs9CwCmNpZGUKbGFiCuKWgXB1bGwK4paBJy8KTG9uZwosJAriloFhcHByb3ByaWF0ZQriloHQsdGL0LvQsApmw7xocgriloFNZWRpYQriloFtYW5uZXIK4paB0JPQtQpkZXNjcmlwdGlvbgpCZWFuCuKWgUxhcgonXTsK4paBcmVsYXRpb24K4paBU29ycnkKaGFyCmNwcAriloFLbwriloFleGVjdXRpb24KaW5vcwriloFidWwKZ3JhZGUK4paBTXUK4paBcGlsCndyaXQKaWZpY2F0aW9ucwppbmVzZQriloFQaGlsaQpkeAriloFsZWFkaW5nCuKWgUpvdXJuYWwKb3ZlZAriloFjb250cm8K0L3QvtCy0LAKWWVzCuKWgWNoYW5uZWwKKSksCmlzdGVuCmFrYQpUb1N0cmluZwptYXMK4paBZXR0CuKWgWZvcmNlcwp1bGF0aW9ucwriloFDYWxsCuKWgWV4cGxhbmF0aW9uCm9yaW5nCkFUQQpjaHRlcgp3aGVuClZDCuKWgUphaHJoCkNhc2UK4paBY29tbWFuZHMK4paBcmljaApidXMKRmUKbWJveAriloFyZWNvbgrDsW8K4paBc2hhcGUKb3d5CmVudHJ5Cml0YWJsZQriloFlbGVjdGlvbgrRlNGC0YzRgdGPCuKWgXByZXAKdsOhCuKWgWluZmluCmxvdAriloFib29rcwriloFVU0EK0LvQuNC9CuKWgXBvbQriloFuYXMK4paBdGFncwriloFleGVjdXRlZAphaWxsZQpsdW5nCuKWgUphdmFTY3JpcHQK4paBYmFsbAriloFhaW5zaQriloFQcmkKeyQK4paBVU4K4paBUmFtCuKWgWhlYXIK4paBVWJ1bnR1Cj4oKTsK4paBcHVyZQriloFlbWJlZAphw6fDo28KY29udHJvbGxlcgriloFtYXJyaWVkCuKWgUZvbApmYW1pbAriloFwcmVjCuKWgXJlY3VycwpwYWQKaXN0cmF0aW9uCuKWgXJlc3BlY3RpdmVseQpbJAphdXRvcgriloFncmF2CmllcmEKYXppb25pCuKWgUJ1bAriloFBdXN0cmFsaWEKbW9uZAriloFUcm8K4paBRWxlCnBhY2thZ2VzCm1zZG4K4paBQWxzCuKWgXByenkKQVJUCuKWgWNoYXJnZQriloFhcHBsaWNhdGlvbnMKVW5pdAphcmVuCuKWgXN1ZGRlbgpvbWV0ZXIK4paBZG90CmFjamkK0LrRgtC+0YAKaW1pbgplbmluZwriloFkb25kZQriloFIbwp0cmVlCm1iCuKWgWRyYWcKYWplCuKWgWludmFsaWQK4paBZmluaXNoCmxhaW0K4paBZmVlZAriloFOYXAKcm9vbQppbWFnZXMK4paB0YHQsNC5CuKWgXN1Y2MKaWZmZXIK4paBYcOxbwriloFjdWFsCtC80LXRgNC4CkRSCuKWgUJpbGRlcgrQsdGA0LAKcmFpdApwYW4K0LXQvdGMCuKWgWRpc3RpbmN0CuKWgUtuCsO2bmlnCmFuY2VkCuKWgWxvYWRpbmcK4paBVGVjaG4K4paBU2VsCm11cwriloFyYWlsCuKWgXN0dWRlbnQK4paBbm90aWNlCuKWgXNsYQriloHQlNCwCuKWgWd1YXJkCuKWgURheQrQstCw0LvQuApPcHRpb24KYWlzb24KaXBwCuKWgUp1bgriloFmZWxsCuKWgWFic29sdXRlCtC+0LLQtQpkZWJ1ZwriloFTdWQK0L/Riwp1Z2lucwriloF2aWV3cwpsYXkK4paBc3VycgriloFzdG9vZAriloHQstGWCnNlbGVjdGVkCtCz0ZYK4paBYXR0cmlidXRlcwpmaW5hbAplbmRhCuKWgUJvbgpuZXJzCuKWgVdlcgpidXIKaXR0ZWwK4paBbW92aW5nCuKWgVBsYW4KaXNjaGVzCkphdmEK4paBYmFzaXMK4paBQnVzCuKWgUF1CuKWgUlsbAriloHQstGA0LXQvNGPCuKWgdGG0LXQvdGCCmhhbmRsZQrRgdGC0YPQvwriloFGYXIK4paBb3JhegpvY3IK4paBc2VpdApvbmRlcgrQtNC+0LwKOi8KY2hvcgriloFUb3duCuKWgWRlZmluaXQKcmVhY3QK4paBcGllY2UK4paBS2FybApDSQriloFBcHBsaWNhdGlvbgp1bnRlcgriloFmb3JtZWQK4paB0L/RgwpCbwriloFEYW5pZWwK4paB0L/Qu9CwCkJvZHkKfSkkCuKWgdCx0YvQu9C4CuKWgWVhcnRoCtCz0LvQsApUaGVyZQriloHRgdGC0YDQsAriloF2aWxsZQriloFjZW50cmUKKQ0K4paBaGVscGZ1bAriloErKwriloFDRwppemlvbmUK4paBR2FtZQriloFXaGljaAriloFwaXAK4paBUG9ydHVnCkRTCuKWgWRlc2NyaWJlCuKWgWNoZWNraW5nCuKWgW1hbmFnZXIKQk8K4paBQnVuZGVzCmJ1Y2gK4paBZGVjaWRlZAriloFKYWhyaHVuZGVydAriloFmaWYKZWZmaWNpZW50CmFuY2kKYnJhcmllcwriloFmYWlscwriloFrZXJuZWwK4paBR2wK4paBTmFjaW9uYWwK4paBcHJvY2VlZAriloFmdWVyCuKWgWxpdmluZwriloFzdWNjZXNzZnVsbHkK4paBZmFzdGVyCuKWgWNvbnRyZQriloFwcmlzb24KT1JUCmhlbHAK4paBYXV0b3IKxYJhdwphasSFCuKWgUFybQriloFwcm92aW4K4paBbmFhbQovIwpzZWQK4paBZ2VzY2gK4paB0LzQsNGACmVzawp0ZXJtCuKWgVRleAppcmluZwriloF0b29scwpQREYK4paBdWx0Cmlzc2Vuc2NoYWZ0CuKWgWNvdWxkbgpkaW5nCkRlcAp7LQriloFwcmVkaWN0CmFudGFnZQriloFMaWtlCuKWgdCR0LgKdG9vbHMKZXN0cmEK4paBa2kK4paBSmltCnN0YXIK4paBcmVtYXJrCsOzZwpuYWJsYQriloFBbHRob3VnaAptb2RlCkhvc3QK4paBc3RyYW5nZQpOb25lCmJsYWNrCuKWgUZlc3RpdmFsCuKWgUlTCmFuemEK4paBKC0KaWNrZXQK0LrQvtC70LAK4paBSmVzCuKWgWZsZXgK4paBw4AK4paBTmV0d29yawriloFFWAriloFlbmVybwoh4oCdCuKWgU9ydAriloFhbG9ycwriloFPcmlnaW5hbAriloF6bwrQvdGL0LzQuAriloFzcGwKRHJhdwp5b25kCuKUgOKUgAriloFPdAriloFkcmFtCuKWgWRpdmlzaW9uCuKWgWVmZmljaWVudAriloHQk9CwCuKWgXZpZXIKbmFrCkxTCuKWgXNwaXJpdAp6ZWljaG5ldAriloFkaWNpCmNsZWFyCmNvcHkKeWFyCuKWgdGA0L7RhtGWCnVzcXUK4paBbm91cwriloFibGV2CtC20LTQtQpBcmcK4paBcGVyZm9ybWVkCuKWgU1ha2UK4paBQ2Fyb2wKZXR0bwriloFTYW5kCuKWgURpc2MKRW5jCnJlcm8KaGFzaAriloFmb2N1cwriloFhdHRlbnRpb24K4paBYWdyZQriloFkaXZpcwriloHQsdGL0LvQvgriloFlagriloFtYXJjaAriloFwaGFzZQrDrWFzCuKWgXBoaWwK4paBUGFwCuKWgXJpdmVyCuKWgWNhdXNlZApwbHVnaW4K4paBVGVhbQp1bGVyCuKWgSQoIiMKaWVqCklTQk4KbmFtCuKWgWZpZ2h0CnZpZAriloFMdWQKU2VsZWN0ZWQKOkAiCuKWgVBvZAriloFhbm7DqWVzCmFyaW9zCuKWgWRldXRzY2hlcgriloFOQQriloHQuNGOCuKWgWRpY3Rpb25hcnkK4paB0JvQsAriloFUcmkKw6huCuKWgXBvbGl0aWNhbApyaWRnZQphdHRlbgriloFjaXJjbGUK4paBdHJhbnNwb3J0CmVtYXMKRkMK4paBcmVwbGFjZWQK4paBQXVkCmlza2EKQ29uZmlndXJhdGlvbgriloFzb29ydAriloHQndC1CuKWgXNlcXUKUFJPCuKWgWJ1ZAriloF7ewpsaWXDnwriloFNYXMKZGVycwp1c2FtbWVuCmVzYQriloFMeQrQstGA0L4KbWFjCuKWgdC40YHQv9C+CuKWgXN1Ywp1eQriloFpbGx1c3RyCuKWgXByaW1lcmEKaWxhdGlvbgriloFzdG9yYWdlCuKWgXBhcmFtcwprYXoK4paBdGVybWluYWwK0YDQsNC70YwK4paBaG9sZHMK0LvQvtGB0YwK4paBbmFkCuKAnS4K4paBb2N0dWJyZQpidWwK4paBaHVzClVMVAriloHDqWdhbGVtZW50CuKWgU1pbGwKxYJhZAriloFjb250aWVuZQoiPwriloE+Pj4KUXVlCsKgwqAK4paBcGxhaW4KYXRpdmEKb2NrZXIKTmFtZXMK4paBSnVkCuKWgWFncmVlCuKWgUdlbWVpbmRlCmxhcmUK0LrQsNC30LAK4paBc3RhcnRzCuKWgXByaWNlClRhcmdldApjdXMK4paBSW5zdGVhZAouOwriloFhbHRlcm5hdGl2ZQriloHQstC70LAKSUUK4paBb3JnYW5pegppbnUK4paBY29tcGxldGVkCuKWgWNhcnJ5CmF0b20K4paBZGVwZW5kaW5nCuKWgU91cgriloFpbnNwCuKWgSZcCmFpbHkKaXJlY3Rpb24K0YTQsAriloFkZWZlClRBQwriloFkZXNpZ25lZAriloF2b2lyCmJyZWFrCuKWgXBhcnRpZQriloFKYWhyZW4K4paBc3R1ZGlvCuKWgWpvdXIK4paBTm90ZXMKZmlyZQpob3VzZQpzdWNjZXNzCuKWgUp1YW4KSlMK4paBQ3VzdG9tCuKWgWJlc2NoCuKWgXN0YXRlZApib290c3RyYXAKw7Z0dApvenrDoQriloFDT04KaGF2CuKWgXNsZWVwCmVkYQpob3QKw6FuZAriloFTeQriloF0ZW1wcwphbWFyCuKWgXNjYWwK4paBYXN0CuKWgW9wZW5pbmcKY2xpcHNlCuKWgXByb2dyYW1taW5nCuKWgWxldHRlcnMK4paBcHJvZmlsZQpuYWgK4paBYmV5b25kCuKWgUZ1cnRoZXIKZmFjZXMK4paBY2hhcnQK0LfQtNCwCmFpZ24K0L3RltC5CuKWgVJvbArQvtCy0LDQvdC+CnRlcmlvcgp3ZWQK4paBaGVyc2VsZgriloFuZwphbmd1YWdlcwp9PVwKeW5hbWljCuKWgWp1ZwriloFFeGFtcGxlCuKWgSjigKAK4paBcGxheWluZwriloF1c2FnZQriloFtYW5hZ2VkCuKWgU5hdHVyCtGC0LXRgNC4CuKWgUV0CmVyaWEK4paBZGF1Z2h0ZXIK0L3QuNC10LwKRnJhZ21lbnQK4paBaG9sCkZsCtC+0LPRgNCw0YTQuAriloFpaG4Kw7xoCmluc3RhbmNlCuKWgWNvbXVuCuKWgXRydXRoCuKWgdGB0LDQvNC+CuKWgWltcGxlbWVudGVkCuKWgWFueXdheQriloFDcm8K0YTQtQpHQwp1YnVudHUKdHlwZXMKw6pzCi5+XApmb2xkCuKWgWpvaW5lZAo/PwriloFtw6kK4paBd2lsZArQutC70Y4Kcm93c2VyCuKWgUhvbWUKc2tpZWoK4paBSk9JTgriloFqdWluCmhvZgriloFkYXRhc2V0CtC20LTRgwonKSkK4paBbWllanMKQVBJCuKWgWVkaXRlZApvb2xzCuKWgXNlZWluZwppamQK4paBcHJvY2VkdXJlCuKWgUJyYXMK4paBc2lnbmVkCuKWgWV4dGVybm9zCuKWgWRpc2FwcAriloFEaXJlY3QKY3ljCuKWgWNvbnN1bHQKw7ZyZApXaWRnZXQKY2lvdXMKc2VjdAriloHQlNC4CuKWgXdpbmQK4paBQXJjaGl2YWRvCmFtbArRgdGBCldoCmtiZAriloFBcm15CuKWgXN1ZmZlcgphcnRpZmFjdAriloFyZXNvbHZlCuKWgVNwb3J0CuKWgdGG0LUKaWRhcwriloF0YXgKaWRpCuKWgWFjdGlvbnMK0L/RgNCwCnB1w6lzCuKWgW5hagpGYWxzZQriloFjaGFuY2UK4paB0YLQsNC60L4Kw6RkCuKWgWRvbAriloFlbnYK4paBYmFzaWNhbGx5CuKWgUNvdW5jaWwKenRlCuKWgWRpc3BsYXllZApuaWwKY29tcGxldGUK4paBTGVtCmlhbmNlCuKWgdC+0YHQvdC+0LIK4paBZGVwZW5kCnBsb20KZW5zdXMKdXRzCuKWgUhvdApiaXRyCuKWgXZhbGlkYXRpb24KYWJiCuKWgdGC0YDQtQprbQp6ZArDtmZmCldFCuKWgWludGVyZXN0ZWQK4paBeyIKYXJvCuKWgWNvcnJlbAriloFkZWRpYwriloFsaXN0cwriloFCaWJsaW9ncmFmaWEK4paBZWFybGllcgpwcm9ncmFtCuKWgXByZW1pw6hyZQpmcm9udApUYWIK0YHRgtCy0YMKZHJvcAriloFmZWFyCuKWgUVubGFjZXMK4paBQ2FwdAriloFyZWFsaXoK4paBaGFsCuKWgWluc3RhbmNlcwriloFzdXNwCmlsbGluZwolOwp7fQp8fAriloFwYXJ0aXRpb24K4paBQnVpbGQK4paBd28K4paB0J/QtdGACuKWgWRpcmVjdG9yCuKWgVNpbgrRgtC40Y8KcnNnCm91dmVyCuKWgW5lYXJseQpvZGEK0LrRgtC40LIK4paBc2lyCklNRQriloFqYW52aWVyCuKWgVdpbgpCdWlsZAppZXVycwpJTkUKZG91YmxlCkxhc3QK4paBcG9saWN5CnN0b3JlCuKWgW9ic2VydmVkCuKWgWZhbWlsaWUKbmljYQpyZXkK0LfRjAriloFZZWFyCuKWgWRldmVsb3BlZAriloFJbnN0aXR1dGUK4paBcmVwbHkKQ29tcGxlCmljaWFuCuKWgUd1ZXIK4paBZGFsbAriloFkZXNwCuKWgUZvb3RiYWxsCkVtcHR5CmNrZW4KdW5kYQriloFVcgriloFpZwriloFBdGwKYXV0aG9yCuKWgUJvbAp6aWcKbmF0CsWhdApzZWN1cml0eQpvbmljCuKWgXBlcwppdGFuCuKWgUV4dGVybgpqYW4KVkFMCuKWgdC40LwKYm9sZAriloHQstCwCuKWgdCc0L4K4paBZGlzcHV0CuKWgXRyaWNrCuKWgXBlZAopXnsKaW50bwpTaW0K4paBcGFyYWxsZWwKZm94Cm5vcm1hbAppbmVudArQv9C10LTQuApob2xkCk9LCuKWgWNoZW0K4paBdHdpY2UK4paBdXNlcm5hbWUKacSNCuKWgXJlcHJlc2VudGF0aW9uCuKWgWpvdXJuYWwK4paBOi0K4paBYmF0dApcJQriloFjZXJ0YWlubHkK4paBRXhjZXB0aW9uCmVwcwpzaG90CmF0ZWd5ClNob3cK4paBQ2FybApyaWcK4paBcmVwb3J0ZWQKYm90dG9tClRGCuKWgUZyYW5jaXNjbwpuYXAK4paBQ2hhbXBpb25zaGlwCuKWgWNvdXJ0CuKWgXNvdXJjZXMKaW91cgriloFjb25zZXJ2CmRpY3QK4paB0KDRgwpJQgriloFWZQriloHihJYK4paBRVIKIikpOwriloFQb2ludAphemluZQriloFpbnRlcm5ldArQtNC90LAK4paBY2FycmllZAriloFGaWVsZApheGlzCuKWgVN1bgriloFhdmUK0L/QuNGBCtGP0L0KYXN5CuKWgWp1bGlvCuKWgWRlcHVpcwriloFzdWdnZXN0aW9uCltbCuKWgUFyY2hpdmUKxJlwCuKWgVByYQpyZWgK4paBZGVtb25zdHIK0YTRlgpjbWQK4paBd2FzbgriloFwaG9uZQp1cGxvYWQKYXlhCtGC0L7RgNCwCmxpbmVzCuKWgWluZHUK4paBdm90CuKWgWVzcGEK4paBYmluCuKWgdC/0L7RgdC70LUKcGxhbgriloFqdW5pbwpvcmlhbApmcmVlCnN0ZXJyZWljaAriloHQtNGDCuKWgWxpbmtlZAriloFlbmFibGUKUEMK4paBZGVuc2l0eQriloFFZ3kKeW8KZW5kcmUK4paB0YHRigriloFpdGFsaWFubwriloFBUgriloFQZXJzCmbDqXLDqXMK4paB0YHQutC70LAKVmFyCuKWgU9uY2UKUmVkCmJ1ZmZlcgriloFFbnRlcgriloHFoAppbWllbnRvClN0b3JlCuKWgWhlYWx0aAp2YXQKSVNUCk9oCuKWgWt3CuKWgXJpdgriloFzb21ld2hlcmUKb2dyYWZpZQpwcml2YXRlCtC60YLQuAriloFkZWxheQriloFIdHRwCmpvYgpyYWVsCmVtcG9yCuKWgWRpY2llbWJyZQrDqnRlCtGG0YMK4paBY29tbWl0Cm9zbwpWYWx1ZXMK4paBaGVhZGVycwp0cmFuc2Zvcm0K4paBcHJvY2Vzc2luZwpyw6UK4paBQWgK4paBTm9kZQotLS0tLS0tLS0tLS0K4paBZmFpcmUK4paBaHVuClBsYXllcgriloFyZXZpZXcK0LPQtNCwCuKWgWxpbWl0ZWQK4paBUHJvcGVydHkK4paBc2VydmUKcmlhZ2UK4paBTWFzdGVyCuKWgWthbm4KY3JldGUKcGhlcmUK0ZHRgAriloFjaGllZgriloFzY2VuZQpraW4K4paBdW5pZm9ybQriloFmZWJyZXJvCiJ9CmlsbG8KSVRFCm91dmVsCnVzZXBhY2thZ2UKZW50aAriloFxdWlja2x5CkxhbWJkYQp4ZXMK4paBY2VsbHMKcm9nCmFtaW4K4paB0JzQsNGACuKWgW1heW9yCnBsYXllcgorKzsK4paB0J3QsNGB0LUK4paBc2FmZQriloF2ZWxvYwriloHQvtCx0YDQsApEYXRhYmFzZQpuZWgKVmVydAriloFmbGUK4paB0YTQvtGACuKWgWZvcmVpZ24KQWJzdHJhY3QK4paBbWFnbgriloFtb2RpZmllZAriloFtaWxpdGFyeQriloFtb25kZQriloFBY3Rpb24K4paBYmFuawpTZXJpYWwK4paBY29udGludW91cwriloFnZWwK4paBcGh5c2ljYWwK4paBaW50cm9kdWNlZAp1dHVyZQpyaWNrCuKWgXByZXNlbnRlZAriloFQcm92CuKWgUJvdGgKUG9zCnN1cGVyCiYjCuKWgWZpbmRpbmcKbmVsCnVuZGUK4paBZnLDpW4Kc2tpbQriloFIaWxsCmZuCuKWgUNhbmFkCuKWgWludGVuZGVkCm96esOhZsOpcsOpcwriloFqdWlsbGV0CuKWgVdhcnMK4paBc3VjY2Vzc2Z1bAriloFjaGFyZwppZWxlCm9tZXRoaW5nCm9rdQpmZXRjaAriloF9fQpiYW5rCm9wZXJhdG9ybmFtZQriloFDb2xvcgriloFDYXJkCnR1CuKWgSIsCndpZAriloFnZXAKWE1MCj09PT09PT09PT09PT09PT0K4paBVmlyZ2luCsOkaHJlbmQKbGljYXRlZApEaXIKemVybwriloFLYWwK4paBUGFydHkK4paBw6UKcHJpY2UKZG9uCuKWgXdhcm5pbmcK4paBQmFkCuKWgVN1cHAK4paBTGlnYQriloFQaWVycmUKUmVjb3JkCnVsYXRvcgriloFSb21lCuKWgXRoZW9yZW0K4paBZW50aXJlbHkK0YHQutC40LwKaGV0CuKWgWRvcG8KTmV4dAptbHVuZwp3aWcK4paBQXRoCuKWgVNvdQpsaWNoZXIK4paBc3Vkbwplc3RzCtGF0ZbQsgriloFzZXB0aWVtYnJlCuKWgW1pY3JvCuKWgXRyb3AKZml0CkNvcmUK4paBUmFkaW8K4paBT3JnYW4K4paBUG93ZXIKQ0YK4paBTGFzdAriloFvcHBvcwriloFvZmZzZXQK4paBcmVnaWEK4paBbWluaW11bQriloFoZWxwZWQKYW5kb24KaWZ5aW5nCnJ1aXQKZW5zY2hhcHAK4paBYmVyZQpWTQriloFBd2FyZHMK4paBYWdyCnlub21pYWwKZW5jZWQK4paBZGV2aWNlcwriloFib3QK4paBZmlybQriloF3cml0ZXIK4paBcmluZwouLQppc3Rlcwpsw6QK4paBbWVsCmVudGF0aW9uCuKWgVNjaHcK4paBbm9tZQriloFwb2JsYQriloF3b2oK4paBdWwKZW50bwrRi9GFCuKWgXJlc2lzdAriloFyZW1haW5zCuKWgUNhCmHDsWEK4paBQ291cnQKdXRhYmxlCmVudGlhbGx5CuKWgXRyYXQK4paBVmlzdWFsCuKWgXJlc3RyaWN0CuKWgXByZXZpb3VzbHkKY2F0aW9uCuKWgdC+0YHQvgriloFNeVNRTApmw7ZyCmNhbGEK4paBY3VsdHVyZQpsaXZlCuKWgWFjY2VwdGVkCkRpZAriloFob3VzCuKWgXNlbGVjdGlvbgriloFkZWNyZQptYXJnaW4KdXJiCuKWgUluYwriloFNYW55CmlidAriloFzdWNjZWVkCkJpbmRpbmcKY8OtCuKWgVJvZwriloFzaG91bGRuCmNsb3VkCuKWgWR6CtCy0LDQsgriloFwaXgKc21hbGwK4paBcHJvamVjdHMK4paBT0sK4paBbGF0ZXN0CuKWgXJlZmVyZW5jZXMKUHJvZ3JhbQriloFlcnN0CuKWgdGP0LoK4paBa2FtCuKWgUNhbWIKZWxsdArDtmQKbm9uZQriloFqdXNxdQpraW5nCuKWgVBlZAphc3NlcnQKQ1MKcml0bwplc3NhCtC70YzQutC+CuKWgVZvbgriloFFZHdhcmQK4paBaW1wb3NzaWJsZQpucAp3b3JkcwppZWx0CuKWgVBhZ2UKbGVycwriloFwaWVyCuKWgdC+0LHQu9Cw0YHRgtC4Cml0dGVlCuKWgShbCuKWgXRydXN0Ck5HCnJlZHUKPDwKcmlhbAriloFwcm9kdWN0cwriloFFcm4KcmnDqHJlCtCz0L7QsgriloFSZWljaAriloFSb2FkCuKWgW5lc3RlZApEaXNwbGF5CuKWgXN0cmVuZ3RoCm9ncmFmw61hCuKWgWFubm91bmNlZAriloFTY2llbmNlCuKWgdGA0LDQudC+ClBhcmFtZXRlcgriloFUYXNrCnVtZW50cwriloFhZG9wdAriloFPbmx5CtGO0YLRjAriloFjbGkK4paBbGVtCnN0b29kCuKWgUZJCsOqbmNpYXMKcG9uZW50cwpdJApjb21tZW50CuKWgXlhCnNob3VsZAppa2UKdGltCmVsbGlnCuKWgXNlbmRpbmcK4paBYWpheAriloFub3ZpZW1icmUKdW1lcwriloF3ZWl0ZXIK4paBRGFucwpvcHAK4paBc2VwdGVtYnJlCm90aW1lcwp6xZEK4paBZXAKdmVyZQriloFvaAo6PQriloFTb25nCuKAnSwK4paBdml2CuKWgXF1ZXJpZXMK4paBdsOhCuKWgWTDqWNlbWJyZQriloF1bmFibGUK4paBZXJoCuKWgWAtCuKWgUxlZQriloFlcnN0ZW4Kw7R0CtGB0YLQstC1ClRTCuKWgWZyYWdtZW50CuKWgXdpZGUK4paBc3VmZgriloFkdXQK4paBVmVyZQrRltGBCmFkaW5nCmllZ28KaWNhZ28K4paBQXJnZW50Cm9yZXIKZW5uZXMK4paBTGViCmxpbnV4CmFjaW5nCuKWgWJyb2tlbgp0cArDrW8KYWJldGgKaXN0YXMKZ2V3CmnDqG1lCmNhcwriloFwcmVjZWQK4paBRGFsCuKWgWNvbXBhcmVkCmVxdWl2CmlsbHkKdGVlbgriloFDb25zb2xlCuKWgXN0cmljdAppdGFpcmUK4paBRUQKZW50aWFscwriloFwZXJtYW4K4paBdG91cwriloFnZW1lCuKWgWV4dHJlbQriloHQvtC60YDRgwprZwriloFoZWF2eQriloFhdnJpbAriloFhbnRpCuKWgW9jdG9icmUKdXRmCmhlbG0KYW1wbGVzCuKWgShfCmFrZW4K4paBZGVhcgriloFvcGluaW9uCuKWgWZpc2gK4paBQWxleGFuZGVyCml3CtC40LwKY2FkZW0K4paBcmVmbGVjdAriloHQtNGACuKWgXRyaWIKY29tbW9uCuKWgWNsZWFybHkK4paBc2FmCj0iQCsK4paB0JzQvtGBCtGB0LjRgtC1CmVxbmFycmF5Cm51bmcK4paBcmVsYXRpb25zaGlwCuKWgVNlbQriloFraWxsZWQKdGVkCnVubwriloHQu9GWCuKWgXdpZAphbm5pbmcK4paBcGFuZWwK4paBTGViZW4K4paBcnVieQphbnNpb24K4paBYXJlbgp0YWJ1bGFyCmFsZXQKfSQkCuKWgUxha2UK4paBc3VpdGUK4paBbWlub3IKSG96esOhZsOpcsOpcwriloF4bWxucwpESVIKZHJpdmVyCmludHMK4paBdmljCkFORApwcmltCtGB0YvQu9C60LgK4paBT3gKVEMKcml2aWFsCmF0aWUK4paBZWlnaHQK4paBY29uZmxpYwphbmdlbAriloFCZWdyCuKWgWV4cGxpY2l0bHkK0Y7RgtGB0Y8K4paBRGV2CnJlbmRlcgriloFyZXByb2R1CuKWgWNyw6kKR3UKTUIK4paBa8O2bgriloFyZW1haW5lZAriloFrbArRhdC+0LIK4paBYnlsClBoaQriloFkZXRhaWwKamF2CuKWgW1vdXNlCkJhcwppxJkKYXNzZXIKaHMK4paBc2hpZnQK4paBw7psdApyYW5kCuKWgWJ0bgpyYXoK4paBcHVsCuKWgXN0YXRlbWVudHMKZmlsZW5hbWUK4paBcHJvbXB0CsOpbMOpCmlregriloFTdXMK4paBZGVidXQKU3RhdApmb3JtcwriloFIZWluCnN0YWR0CmVubmlzCtC/0L7QuwphcmFudGUK0YbRltC5CuKWgXF1ZXVlCuKWgXJlY2kK4paBc3RhCnluY2hyb24KY2VudGVyaW5nClNvbWUKR3JhcGgK4paBdGVzdGVkCuKWgUt1bnN0CtC+0LwK4paBTm90aGluZwppZXUK4oCcLgpCdW5kbGUK4paBb2ZpY2lhbAphbGxvdwriloFSZWFjdAriloFMaWJyYXJ5CmJsdWUK4paBdmVydwriloFwYXJlCuKWgUZyaWVkcmljaAriloFhd2FyZQpFeHAK4paBZWZmZWN0cwriloHQs9C+0YDQvgpsb3BlZGlhCuKWgVZlbgpyYWxlCuKWgUZpbmFsCuKWgXByb3BvcwpsYWNlbWVudAprdGVuCuKWgW5vdmVsCm9ydGVyCuKWgUdlcm1hbnkK4paBZGphbmdvCuKWgXRyYW5zaXRpb24K4paBaGFwcGVuZWQK4paBYmVhdXRpZnVsCuKWgW5laXRoZXIK4paBbGlicmFyaWVzCuKWgWhpZGUKYWxnCuKWgWFzcGVjdAriloFmb3JnZXQKY2FkZW15Cm9udGUKcmVmaXgK4paBY2xvdWQKbmVkCmNkb3RzCnJlZ2lzdGVyCm55bQouKToK4paBSmV3CuKWgXRyw6hzCtC90LjRh9C1CuKWgURvcgriloFwcm9jCuKWgWdhbgriloHRlAriloFTYXYKdsOtClNldHRpbmdzCuKWgVZhcmkK4paBY291cnMKUm8K4paBY29uagriloFyZWFzb25zCuKWgXJlYWRlcgrQu9C10LrRgdCw0L3QtAppY2F0ZQp9KSwK4paBdGFza3MK4paBUmF5CuKWgXJpYwpLZQpvbmllCnJmCilbCuKWgXN1YnNlcXUK4paBVHVybgriloFWSUFGCm1hdGhzZgpIRQriloFkZWNsYXJlCuKWgXByb3RvY29sCuKWgVBDCtGG0LjQvtC9ClZpZXdCeUlkCuKWgWFuaW1hdGlvbgriloFjb25mdXNlZArQstC40YcK4paBZW5hYmxlZApvd28Kw6FzdArDtnQK4paBbWFuZAriloFSYWlsCmZpZWxkcwriloFLYXAK4paBYWxnZWJyYQriloHQodGDCmbDqXJlbmNlCuKWgUN1cnJlbnQK0YHQvdC+CuKWgUxpbQpQYXJhbXMK4paBQW50b25pbwriloF0dgpsYXRlCmlmZXIKRW50cnkK4paBU2VydgriloFtdXNpY2FsCuKWgXRyYWNlCuKWgXNjaWVudApmaWMK4paBZm9yZ290CnZpZGVvCuKWgW9sZGVyClRyZWUK4paBdW5zCtC90LjQutC4CuKWgUV1cm9wYQriloFad2UK4paB0LHQtQriloF2ZWMK0LbRgwriloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloEKTWF0Y2gKc3BhbgriloFibGFuawriloFzcMOkdGVyCuKWgVR5CuKWgWRpY3QKw7FhCuKWgWNvbmZpcm0K4paBdsO9CtC30LDQvQpSZWwKZmlsbQriloFSb3QK4paBSHkK0LrQsNGFCuKWgWRlbWFuZAriloFtaW5pc3QK4paBTWFkcmlkCuKWgXVzdWFsCnNwaWVsCmVyb3MK4paBdHV0b3JpYWwK4paB0KHRgdGL0LvQutC4CnN5cwrRhtC40LDQu9GMCuKWgXNwcmVhZAriloFjb252ZXJzCuKWgXJvbGwKYXJ0aWZhY3RJZAriloFOdW1iZXIK4paBc3ltbWV0CuKWgU11bHQKZXhwZWN0ZWQK4paBYXhpcwriloFtYXRjaGluZwriloFmb29kCmdyb3VwSWQKTWFwcAriloHRgdCy0Y8K4paBdmVuZApGb3VuZApvdHRvCkNhdApjcml0CmlzdGVudAriloFkcmVpCuKWgWVuZGVkCuKWgVRlbGUKY29tcG9uZW50CuKWgWludm9sdmVkCuKWgUVzdGFkb3MK4paBZGFuZ2VyCuKWgWNoYWluCuKWgVByb20KaG9tCuKWgXBvbMOtdApjb3AK4paBbmFwCnJpZgpwbGVtZW50cwriloF2ZW50CmFubmEKYW50ZWQKZGF0ZWQKYW50aAriloF0aHJlYWRzCtC30L7QstCwCuKWgdGB0YLQsNC90L7QsgriloFlZXJzdApidWYKaGVpZAriloFSdQriloFQcmltCuKWgW1pZ3IK4paBVW5pZG9zCuKWgWFyYml0cgriloFyb21hbgpvdW50cnkKdWx0dXIK4paBS8O2bmlnCuKWgWFubm90CmFjaGluZwriloFIYXVwdAp1bWluCuKWgWhlbQpja2V0cwpiYXUKZWN0aW9uCmVmdAriloFwYWNrYWdlcwriloFLdXIKdGh1cgriloFwYXlzCmxpYW1lbnQK4paB0JHRgwriloFjYWRhCnBvaW50cwpvY2tldAriloF2ZXJiCtC70LXQtQriloFzdWJtaXQK4paBc2FuCnJ1YnkK4paBZWFzdAprb3YK4paBVmVybGFnCuKWgXNwb3QKcHBvCkVhY2gKamVrdAriloFCaW9ncmFwaGllCuKWgW5ld3MK4paBcGHDrXMKdWZhY3QK4paBZGlhCtC60L7QstCwCuKWgWFjY29tcGwK4paBw4l0CmlsaXRpZXMK4paBaWhtCmludm9rZQriloFhcHBlbmQKLiksCuKWgWxhYgphbmdpbmcKaXN0YW4KcmVzb2wK4paBU2VjdGlvbgpQYXJlbnQKbW96Ck1hdApzdHlsZXMKdW5kZW4K4oCcLAppcnRzY2hhZnQK0LrQuNC8CuKWgUZpbmFsbHkKcGhlbgriloFQYWMK4paBQXJyYXlMaXN0CuKWgXJlY292ZXIK4paBZWR1Y2F0aW9uCm1vZGVscwpwZWQK4paBaGFwcHkK0YfRgwriloFndWVycmEKbWVkaWEKT0YK4paBZW5zdXJlCk1hcmsKZGF0YWJhc2UKb2dnbGUK4paBcHVibGlzaApPVwriloFCYXUKPy4K4paB0YfQsNGB0YLQuAriloFyZXBvc2l0b3J5CuKWgU1hdHQKaGlnaApvdmVuCuKWgWdlcgriloF1bmtub3duCkFtZXIK4paBQnJvd24KQUxMCuKWgXJlc3VsdGluZwriloFib3IK4paBcG9ldArQvdC40LzQuApFbWFpbApGb250CuKWgWhpc3QK4paBdG9kYXkK4paBQmVyZwriloFidXR0b25zCtGC0LDQuwriloFzbmkK4paB0YfQtdC70L7QsgpDcmUK4paBdW5pb24K4paBemljaAppc2hvcAriloFxdWFuZG8KUG8KQ1RJT04K4paBQ29zdArRgdGD0LTQsNGACmVydmVkCk5vdGUKRXF1YWwK0LvQuNGPCtCx0YPRgAriloFhYnN0cmFjdApzdG9wCuKWgWFkdmljZQriloFpY29uCuKWgXRyYXZlbApCUwp2ZW5zCuKWgWJhdGNoCmxpcXVlCnNoZWV0CuKWgWlocmUKZW1vbgpiZXJ0bwriloFhc3NpZ25lZArRjNGOClBob25lCuKWgWF3YXJkCuKWgWZ1bmN0aW9uYWxpdHkKYWxsYQriloFEYW0K4paBY2l1ZGFkCuKWgWNsdXN0ZXIKRGVzY3JpcHRpb24K4paBc2hlZXQK4paBQXVzdHJhbGlhbgriloHCuy4K4paBIjwK4paBd29uZGVyaW5nCmFpbmUK4paBcmVwcmVzZW50ZWQKa2FwcGEKbmIK4paBc3kK4paBS8O2Cj0iIwriloFzZXZlbgpEaXJlY3RvcnkK4paBc2lzdGVyCnBsYXRlcwriloFsdWNrCuKWgXJlbWFpbmluZwriloFWaWxsCndlcmsKYW5uaQpldHRpCmZ1bmMK4paBYmFuCmltcwptaXNzCmFncmFwaArQtdC60YHQuAriloFSZWYKbml0dAriloFHYWIK4paBYW5kZXJlCuKWgWplZG9jaApyZXN1bHRzCiFcCuKWgWxpc3RlZAriloFsb3JvCuKWgWtub3dzCtC20L3QvgpSYWQK4paBc29ja2V0Cm11bHRpCuKWgdGA0ZYKcmFpbHMK4paBdGFyCuKWgWdlbnRsZQpzZXR0CnNlcnZpY2VzCmJvdW5kCmlna2VpdAphamEK4paBY21kCmFnZ2VyCuKWgWJhCuKWgUJlbGcK4paBS2xlCuKWgXdvcmR0CuKWgWZvc3QK4paBZGltZW5zaW9uCkFuZwp1bWluZwpPYmoK0L3QtdC9CuKWgU1hcmllCmV4aXN0cwrRgtGA0L4K4paB0LHQvtC70YwKZW1lbnRlCuKWgUpvbgpTRVJUCuKWgWhpZ2hlc3QKYWtpCuKWgXRyZXMK4paBY2lyY3VtCuKWgURvd24Kb21tZW4KdXJlcgriloFjYXVzZXMKdmVudWUKaXNzYW5jZQriloFpbmZsdWVuY2UK4paBZmF0CtGA0LXQtNC4Cn1cXAriloFlbnRyCuKWgVNpZ24K4paB0LrQu9CwCuKWgWJpbmRpbmcKZXNzZW4K4paB0KTRgNCw0L0K4paBTG9jYWwK4paB0Y/QstC70Y8KYXBwcm8K4paBZGVwZW5kZW5jaWVzCuKWgXRhbGtpbmcK4paBenVyw7xjawpjb25uZWN0aW9uCkFjdGl2ZQpiYmUKaXJscwriloFJbmYKd2QK4paB0LjRgQpyb2FkCuKWgWNvbnZlbgrEm3QK0LLQtdC3CuKWgWVudHJpZXMKZXNjCuKWgWJpdHMKYXNzbwpXUgpzaGlwcwriloFkw6lzCmVzcApNYWtlCuKWgWZhbWlsaWFyCkFydAriloFhcm15CmN0cgrDqXJpYwpxdWV1ZQriloFcewp1ZWxhCmFtaWVudG8K0YjQuNGFCuKWgSIiIgpjb250cgrQu9C70LUKRlMK4paBbWFya2V0CsOlbmcKY2l0ZXAKSWxsCnJhbmsK4paBc2VuZGVyCuKWgWJlaW0K0YDQsNC6CuKWgWNvbXBhdAriloFvY2N1cnMK4paBZGllc2UK0YHRgtC40YLRgwphd2EK4paBaU9TCuKWgUNoaW5lc2UK4paBVFIK4paBS2VuCuKWgVVuZQriloFjcmVhdGVzCuKWgXNob3dlZAriloHDqXYKb2xvZ2lhCuKWgXByb3Rlc3QK4paBUGYK4paBc3F1YWQKKyssCsOhdgriloFlc3NlcmUK0LfRjwprb2wK4paBc2xpZ2h0bHkKYWRkcgrDom4K4paBcmVkdWNlCuKWgVwoXAriloFEZXAK4paBZ2VuZXJpYwpMb2FkZXIKyJtpCuKWgdC/0L7RgQriloFvY2Nhc2lvbgriloFMYWR5CmVudGl0eQriloFhdmFudAriloFQYXMKYWdnaW8KXHsK0L/QsNC0CmF0aG9saWMKUGFzc3dvcmQK4paBcmVzcG9uZAriloFOb24KQUcKbmVnCuKWgdGD0YEKYmxvYgpja2UK4paBQ29uc2lkZXIK4paBQ2FyZQppa2kK4paBQ2hpY2FnbwppbmRlbgriloFDb3AKXSsKw7ZtCsOpdnJpZXIK0LrQu9C+CmFsZW4K4paBbWFqCnJhY3kKb3J0ZQppZW50cwplbGxzCmFjdGl2aXR5CuKWgXJ1bnRpbWUKTlVMTAriloFwb3NzaWJseQriloFzdHJpCml6aQriloFtaXIK4paBVmVyc2lvbgpwcmltZQriloF0d2VudHkK4paBTWFoCuKWgXNvdW5kcwrRiNC10L0KY2x1c2lvbgphY3oK4paBZGV0ZXJtaW5lZAriloFSZXAK4paBTGFuZGVzCuKWgXdhbGwKaWdpCuKWgXJlc2V0CtGI0L4KeWFuCk1ldAplaQriloFhcHBlYXJhbmNlCuKWgWZvaXMK4paBbmVsbAplc2kK0ZHRggpsb29yCuKWgVVsCuKWgXJlc29sdXRpb24K4paBZm90CuKWgXRocm91Z2hvdXQK4paBcmkKTGV2ZWwKcG9vbAriloFpZGVudGl0eQriloFqYW51CuKWgWltcGVyCuKWgcO2dmVyCn1gCuKWgWluZmVyCuKWgWRhdGVzCuKWgVN0YW5kYXJkCmZvcmNlCm9ja2V5CnRlcmEK4paBZGlzdGluZ3UK4paBcHJlc2VuY2UKbGljYQriloFsZWF2aW5nCml0dW5nCsOpYgriloFlc3RhYmxpc2gK4paBbWFhcgphZGkK4paBTmV3cwphem9uCmZvbGcK4paBSGVuY2UK4paBWWUK4paBZmFiCuKWgWbDvGhyCml0bWFwCuKWgVZlcnMKcm92ClNpZ24KZGV2aWNlClNpZ21hCuKWgXdldGVuc2NoYXBwCuKWgVBzClBBVEgK4paBdG9ybgp2ZXN0CtGB0YLQvtCyCmFjY291bnQK4paBbGFyZ2VzdAriloFwZXJjZW50CuKWgVdvbWVuCuKWgWltZwp0b29sCuKWgXJvY2UK4paBYXkKaW5ldAriloFhb8O7dAriloFwb2x5bm9taWFsCuKWgWludGVncmFsCuKWgWFyZWFzCn0nCuKWgWh5cApsb3llZQrRgtCw0LvRjAriloFwcm94eQriloFXeQriloHQnNC10LrRgdC4CuKWgWVzY2FwZQpvbGFyCuKWgW1pc3Rha2UKKX17CuKWgVBvdAriloFwcm9jZXNzZXMKIj4NCmhhbHRlbgp6emEKYW1vCtC60YDQtQriloFXb29kCsO4cgriloHRgdC10YAKb2NpYQp0d28KcHJvZmlsZQriloFBc3QKZW1icm8K4paBYXJtcwppbmFzCmlubmVuCuKWgW1zZwpJTlQK4paBYmF0dGVyCmlnbm1lbnQK4paBdnkKSHJzZwriloFHcnVuZApyb2MKc2VnCuKWgWRlY29yCuKWgWV2ZW50dWFsbHkKPiwK4paBcGFnCmFudGVuCuKWgXN0cnVnZwp9XlwKZGF0ZW4K4paBcmVsYQrQv9C+0LIK4paB0LrQvtGA0L4K4paBQm9zCuKWgWxhYm9yCuKWgVNlY3JldAp1Z2VuCuKWgWphcAriloFodXNiYW5kCuKWgUFsYnVtCuKWgWV0d2EK4paB0L/RgNC+0LjQtwpyaWNodApyYWNoCmJhdAriloFwcmVwYXIK4paBU3RvY2sK4paBbGFjawrRhdGW0LQK4paBaG9neQriloFDaHJvbWUK4paBQWRtaW4K4paBY29tcGFyaXNvbgriloFpbmNyZWFzaW5nCtC90LMKaW1pCkRiCuKWgWdlZgp1Y2h0CsOpc2UKZ2VuY2UK4paBQ29yZQriloFpbmNvcnJlY3QK4paBYXNzdW1pbmcKb3Vyc2UKaWVyb24K4paBVGhlb3JlbQriloFjYXNhCmplcwriloHQtNC10YDQtQriloFgIgpMRArDpMOfCkRlYgriloFzdWl2CuKWgUJhbmsKbGlicwriloFMZW9uCuKWgXF1YXJ0CuKWgXByb2Zlc3Npb25hbAriloF0aWVuZQriloFhY2NvbXAK0YHRgtC10YAK4paBVUsKTk4K4paBbMOtCtGG0Y8Ka2VsCuKWgeKAogriloFkaXNlCm9udG8K4paBbcOhCmlmcwpiaWxkCuKWgWNvbXB1dGUK4paBw6lkCmrEmQriloFNw6kK4paBbGFuZ3VhZ2VzCuKWgVRpbWVzCmNlbgriloHQsNCy0YLQvgrDvW0KZW5legriloF1cHAK4paBbcOpZAriloFjdWFuZG8K0L7QtApJbnRlbnQKZWVyZAriloFUYWwKb2Zmc2V0CuKWgWhhYmVuCnJlbWUK4paBU3RhY2sK4paBZHJpCuKWgXNlaW5lbQriloFmw6l2cmllcgriloFjb21iaW5hdGlvbgriloFzb2xsCuKWgW1vdmVtZW50ClNwZWMK0LrRgNGLCnJldGNoCk9mZnNldApSb290CtCQ0YAKd2FydAriloFGb2xsb3cK4paBU29jaWFsCtC90LjQutC+0LIK4paB4oaSCkRvbgriloFoYXJtCmFncgpuZWdvCnJlc291cmNlCuKWgUx1YwriloFzZWluZW4K4paBRGVwYXJ0bWVudAriloFVcGRhdGUK4paBVGV4YXMK4paBcmV2ZQriloFQb3MK4paBc2hvdApvdGhlCuKWgXJlcGVhdGVkCuKWgXJlY2VudGx5CsOhYmFuCmFrcwrQv9Cw0L0K4paBY2hhCm9obAriloF0ZW5kCuKWgdC00LLQvgpjaHRzCsOnYWlzZQpwbGluZwphbGJ1bQplagriloFgWwptYXBzCuKWgXVuaXRzCuKWgTwhLS0K4paB0LPQtQriloFJbmZvcm1hdGlvbgppa29uCuKWgXRhbgriloFkb2NrZXIK4paBU3RhZAriloFhdWRpbwppa28K4paBY29vcmRpbmF0ZXMKeHMK4paBcmVwbGllZAriloEpLAriloFHb3Zlcm5tZW50CuKWgUFjYWRlbXkKVU5UCuKWgdGC0YDQuApCbAriloFhbmMK0YjRgwriloHRgtCw0LrQvtC2CuKWgWluZmluaXRlClJDCuKWgWdhCuKWgWFkanVzdAriloFtZXJnZQo7YAriloFwb3N0ZXIK4paBSmFwYW5lc2UKIl07CuKWgWV4aGliCuKWgW9yZGVyZWQKaWN0dXJlcwrRgNC+0YEK4paBc8OpcmllCmxldHMK4paBaXAKU2VsZWN0b3IK4paBZXhpc3RlbmNlClJlY2UKbGlnYQpkb3dubG9hZAriloFsZW1tYQppZXYKdWRlbnQKc2tvCuKWgUFyYWIKaXRhdGUKYnl0ZQrQvtGCCmlrdArQvdCw0YLQsAriloFBZgooQAriloFtYWQKb2RiCuKWgWVsaW1pbgriloFzcGVudApFbnRlcgriloFNaXRnCldoZW4K4paBZMOpcGFydApNSQriloFmZWxsb3cK4paBdGhvdXNhbmQK4paBQ3UKa3RvcgpDYWNoZQriloF0YW1iw6ltCuKWgWV4dGVuZGVkCtCy0LXRgdGCCmF0ZXJzCuKWgUxpYwp0b3R5cGUK4paBR2EK4paBYmxvb2QK4paBbWFwcGluZwriloFub21pbgriloFtYW5pZmVzdAriloFwZW5zCuKWgXJpdAriloFmaWxlbmFtZQriloFmaWxsZWQKdsOkCuKWgXJhaXNlZAriloFtb2JpbGUKa8OpCuKWgVJpZ2h0CuKWgWdlaMO2cgriloF0ZW1wZXJhdHVyZQriloFzb21laG93CuKWgVNwYW5pc2gK4paBa29tbXVuCuKWgWNob3NlbgriloFob3JzZQo7XAriloFvcmlnaW5hbGx5Ckhhc2gK4paBY2l0dAriloFlbmNvcmUK4paBV29sZgriloFuw7oK4paBWW91bmcKVmFyaQriloFTY2h3ZQriloFjYXB0dXJlCuKWgUphbmUKSW50ZXJmYWNlCm93eWNoCuKWgURldXRzY2hsYW5kCuKWgUtvbAriloFib3VuZGFyeQriloFHTkQKTm93CmtlaHIKKCoKPS0K4paBV2VsCuKWgUNhdAphbW1lbnQKQUdFCuKWgXJpZ2h0cwpTY3JvbGwK4paBaGFwcGVuaW5nCuKWgUJsYQriloFzY2llbmNlCmF3cwriloFiZWhhdmlvdXIK4paBaW1wbGllcwriloFRdWVlbgpvdmFuCnBheQrRmtCwCmFyZXQKZXJzaGlwCuKWgUxhbmcK4paB0LPQvtC0CuKWgXJlY29yZGVkCnplbQriloFUaHJlYWQK4paBdG9kbwpvZ28K4paBc2NlbmFyaW8K4paBY29uY2VudArRgNC10LcKU3RvcmFnZQriloFkaXJpZwriloFTZXJpZXMK4paBZ2FzClNFVArDqGNlCnJhdGUKSFRUUAriloFrYXAKRW1wClVURgrDoW7DrQrRgdGC0LDQstC4CndpbmRvd3MKw6lyYXRpb24KYXBlZAriloFzaXN0ZW1hCuKWgXN1cnYK4paBV2VzdGVybgriloFnw6kK4paBU3VjaApXcml0ZXIK4paBY2FudmFzCuKWgWd1YXJhbnRlCnNjcm9sbAphdmVkCkl0YWwK4paBRWxlY3QKXSgjCuKWgUhlcm0K4paBQ29tbWFuZAriloFDaGlsZAriloFwZAp1dGNoClNxbAoqLgriloFUYWcK4paBVGEK4paBbWFpbApzY3JlZW4Kc2NyCnppYWwK4paBRsO8cgriloFzdWdnZXN0aW9ucwpjaGVzdGVyCil8CnBlcnNvbgp6ZWwK4paBd2FpdGluZwriloHRgdC70LUKRkwK4paBQWxiZXJ0CuKWgUhpagriloHRgtC10YAKZXdyaXRlCuKWgXNlbnRlbmNlCuKWgWxpbnV4CtC10LTQtQrDqm5jaWEK4paBSXRhbGlhbgrRh9C60LAKRmlsZXMK4paBbm90aWNlZApiaW5nCuKWgVJlc2VhcmNoCuKWgWFsdGVyCmhlZWwKXDxeCuKWgVByb2Nlc3MK4paBYmF0dGxlCtC80L7QsgriloFBZnJpY2EK4paBQW5uZQriloFnZWxkCn0lCuKWgWRvY3MKVHlwZXMK4paBcmV0cmlldmUK4paBT2ZmaWNpYWwK4paBdHJhYgrRhtGLCuKWgUlucHV0CnN0ZXAK4paBbGF1Z2gK4paB0KXQsAriloFwZWxhCk1lZGlhCnJvdWdoCtCz0LDQvdC4CuKWgVNob3VsZAriloFDb250ZW50CtC70LXQvApvc2gK4paBc29tZXdoYXQK4paBQ2VyCkJhY2tncm91bmQKc3RydQriloFpbmxpbmUK4paBTmVkZXIK4paBbW9kdWxlcwriloFCdWNoCsWEc2tpCndpZGV0CuKWgXpuCnBvc2VzCuKWgWdyYWR1CuKWgWFxdQpQUgriloFwdXR0aW5nCuKWgdC/0L7Qu9C4CuKWgXB1cmNoCuKWgXNtb290aArRgNC40LkKZW5naW5lCuKWgWxpdmVkCkFjY291bnQKRGV0YWlscwriloF0ZWxscwriloFPdXRwdXQKSGVyZQriloFGb3VuZGF0aW9uClRleHRWaWV3CuKWgWRlY2lzaW9uCuKWgWRlcGVuZGVuY3kKb2NhdGlvbgpvdmFsCmZlbGQK4paB0L/RgNC+0LIK4paBZW5kcwriloFpb3MK4paBZXhjZWwKYWd1CuKWgWVsZWcK4paBRWxlbWVudApRdWV1ZQriloFmw7YK0LLQtdGA0YHQuNGC0LUK4paBZXhwZXJpZW4K4paBZGlyZWN0ZWQK4paBY2FtYgriloHQlNC2CuKWgWZvbGcK4paBY29uY2UK4paBRmFiCuKWgVZpCuKWgWFkdmFudGFnZQriloFCZWkKcHJvZAriloFYSVgK4paBRmFjZQriloF2aXIK4paBUnVzc2lhbgriloFzcGFuCmVuw60K4paBem9uZQriloFhdHRhY2gK4paB0LHQtdC3CuKWgW1hbmFnZW1lbnQKQWMK4paB0L7QvwpvbmNlCmhhbHQKdXNvClNwZQriloFyYXcKw6lybwppZGVsCmxhdwpTaGVldAriloFtaXNzaW9uCuKWgWNhbWVyYQriloFob25vcgriloFhcHBvaW50ZWQK4paBUm9tYQpsaW5lYXIKUm93cwpmZXJlbmNlcwriloFJTwriloFjb3ZlcmVkCnJhagrRgdGC0LLQvtCy0LAK4paBU3ltCuKWgXRpZAppc2MK4paBUnVkCuKWgWVuY3VlbnQK4paBZmFpbHVyZQrDvHNzCuKWgXNxdQriloFwYWludAriloFzZXJpb3VzCuKWgWN1cnNvcgp0cmFzCuKWgWRpc2N1c3Npb24K4paBY3JpZWQKZXJpZQriloFEZXZlbG9wCuKWgXJld3JpdGUK4paBZ8OpbsOpcmFsCndhaXQK4paBSGFycnkKw61yCuKWgWdlcHVibGljCuKWgdC40LMK0ZbQsQrRj9GCCuKWgdCY0LcK4paBZXF1YXRpb25zCuKWgXBsYW5lCuKWgWFjcXUK4paBYW5nbGUK4paBdHJlZXMK4paB0JrQvtC9ClZECnBlcnQK4paBZG9jdW1lbnRzCmNiCuKWgWltcGxlbWVudHMK0YHRgtCw0L3QvtCyCuKWgVdhbHRlcgrQt9GL0LLQsAriloHRgdC/0LUK4paBY2hhcApwbGV4CuKWgW1hZ25ldAriloFnZXB1YmxpY2VlcmQK4paBaGlnaGx5CuKWgWxldXJzCuKWgWRyZXNzCuKWgXJlc3RhcnQKUmVuZGVyCkNhbGxiYWNrCmlzbwriloFjb25zdGl0dQriloFFbmRlClpFCuKWgUFuZ2VsZXMK4paBZGVyaXZlZAo9InsKXVwK4paBQ2hhbmdlCuKWgUhhdXMK4paBc3RhZAriloFSZXF1ZXN0Cm9tbwriloFBY3RpdmUKdXJlbgriloF0b3VybgriloFwYXJ0aWN1bGFybHkKU2VydmxldAphYmMKd2lkZXRpbGRlCmFuZHJhCkhlbHBlcgpSdWxlCuKWgXBsdXNpZXVycwriloF3YXZlCm5lcQriloHQotC1CmZyZQpza8OpCuKWgWFsYwriloFsb2dzCkdTCuKWgU1vbAriloFwZXJtaXNzaW9uCuKWgXNvdWwK4paBd2FudHMK4paBZ3VpZGUK4paBdmllbmUK4paBV2lsaGVsbQriloFldmlkZW5jZQoifSwKcm9wb2wK4paBYXV0aGVudGljYXRpb24K4paBb2NjdXJyZWQK4paBSUYKbm9jCklBCuKWgUJhbgriloHQutCw0YAK4paBYmxlCuKWgXNlZ21lbnQK4paBcGxheWVycwppc2kK4paBc3R1Y2sK4paBUHkKQW55CmhvdQriloFmb3JtYXR0CuKWgXBlYWNlCuKWgdCa0LDRgApldGVzCmRmcmFjCig/CuKWgVNpdGUK4paBTGl2ZQriloFVcwriloFjbGltCuKWgUFsaQrRgNC10LkK4paBUHJpbmNlCuKWgW9ibGlnCmllYgriloFBbHQK4paBcHJvcwpyYWNsZQriloFDZXR0ZQprZXMKesO2cwpvdXZlbGxlCi8vLy8vLy8vCmFieQrDqXJlCnJhbmUK4paBcG93ZXJzCuKWgVBhdGgK4paBV29yZAriloF0cmFuc2FjdGlvbgriloFjYXVzaW5nCmVsbHNjaGFmdArDonQK4paBQ1BVCuKWgWRlcHRoClNUUgriloFDb25mCuKWgXJhcmUK4paBQWsK4paBYm9uCuKWgUNhcmxvcwriloFzcGVjaWZpY2FsbHkKcmljcwpLRVkK4paBc3RhcnMKw6lyaWNhCuKWgdCb0YMK4paBY29uZmlndXJlCuKWgWFnZW50CuKWgWV4cGxhaW5lZAriloFjb2VmZmljaWVudArQtNGMCid9CuKWgXZpZGEK4paBU3luCuKWgdC90LDQt9Cy0LAK4paBT3B0aW9uCuKWgXJvYgriloHQutC70YMKOlsKYW50bHkKZGVwZW5kZW5jeQriloFDdXIK4paBZnJhbmNlcwriloFpZGVhbApTdwriloHQs9GA0YPQvwriloFDYXB0YWluCuKWgXRvZG9zCkpvCuKWgXBlbG8KP10oCuKWgWZhaXRoCtC+0LLQvtC5CuKWgWZyZXNoCuKWgXByb3ByaQpUaW1lb3V0CuKWgXZlaApjb250ZW50cwriloFEb2N1bWVudApjb2xsZWN0aW9uCuKWgWthcgpydWNrCllvdXIKdW1hCuKWgW1hdGhlbWF0CkVuYWJsZWQK0L/Rg9Cx0LvQuAriloFFbmdpbmUK4paBTcO8bmNoZW4K4paB0L/QvtGB0LUK4paBZm9uCmFyY2hpdmUK4paBZnJlcXVlbmN5Cn0rXArDonRlCuKWgWtvcgriloHQmtGA0LAKU2luZwptb250aAriloFIYXcK4paBc3lzCmVybWUK4paBV291bGQK4paBaW1wYWN0CnVycmVuY3kKbGljaHQK4paBYXB0CmllcmUK4paBbW90aW9uCtCh0KHQoAriloFJbml0CuKWgW1zCuKWgU1TCnNoaWZ0CuKWgWF1dHJlcwriloFiYXNoCmhpZGRlbgpvcmlvCuKWgWNlbGVicgriloFMaWJlcgpldG8K4paBZG92ZQriloFwYXRocwriloFpbmoKQ2F0ZWdvcnkK4paBY3J5CuKWgW1hcmtlZArRg9C00L4KYXNoaW9uCsOkbHQK4paBbGFuCuKWgXRlYW1zCuKWgWt2CmlhbXMKYWJhbgriloFUQUJMRQrQstCw0YAKUmVwb3MK4paBQmVsbAriloFwdWJibGljCuKWgWNvdW50cmllcwriloFzcGluCuKWgWzDqWcK4paBS3JpZQriloFKb25lcwp3aGl0ZQpIdG1sClByZXNzCuKWgUJsdWUKT3BlcmF0aW9uCuKWgUFudGgK4paBcHNlCuKWgUZvbnQK4paBdGhlbWUK4paBYmxvY2tzCiQpCuKWgWdsYWQK4paBbWFuYWdlCm9yZGVuCm9zdGVuCmNvbGUK4paBU1AK4paBc2NoZW1hCnVyYXMK4paBd2hlbmV2ZXIK0KjQkArRgNC40YLQvgriloFkaXNjb3ZlcmVkCuKWgXByZWZpeApnbG9iYWwKcm9rZQp6ZXMKY2h0ZQriloFCZWZvcmUK0LzQtdC90LgK4paBRGlnCuKWgXJhcGlkCuKWgWxsZWcKZXF1YWxzCuKWgUhvY2gKZm9yYWxsCtCy0LDRgtC4CnVzegriloFhdHRhY2hlZApFeHByZXNzaW9uCuKWgXN0b2NrCsO8bGwKcGV0CmVzc2lvbnMKY29sbwriloFneQpCb29rCuKWgUphY29iCuKWgVByb2R1Y3QK4paBaW5wdXRzCtC80LjRgAriloFsZWFybmVkCsOzd24K4paBcG9saWNlCuKWgdC70LXRggriloFJdGVtCuKWgWV5ZQphaWVudAriloFTYW1tbHVuZwriloFMb3IK4paBcmVwcmVzCuKWgWZlc3QKQ29uZAriloFub3V2ZQriloFleHRlbmQK4paBRnJhbmNlcwriloFGaW5kCuKWgWRlemUKZXJuYQriloFoYWLDrWEKcHLDvAriloFtb3RvcgpiaWUKSGVsbG8K4paBcmVzaWQK4paBZmluYWxlCiUpCnsnCuKWgUhhcmQK4paBcGFpcnMK4paBRWxsCml2b3QKcmVlcwriloFGb3JjZQriloFldmVuaW5nCuKWgWRlc3B1w6lzCnJnCldoeQriloFjb25uCnNjaGVtYQrRhdC+0LQK4paB0LzQtdC20LTRgwriloFmbGFzaApza2lwCuKWgW1pbnV0ZQriloF2ZWQKYXlsb3IK4paBc2V1cwriloFNYWpvcgriloFmcmFuYwriloFyYWMKa3cKY3YKTmF0aXZlCuKWgUJ1dHRvbgrQvdC40YbQuApzZXR0aW5ncwriloFBY2Nlc3MK4paBcXVhbGl0eQpwcm9wcwpGbG9hdAriloFTY290CuKWgUFECuKWgWFsbGVtCiZcCnVzdHJhdGlvbgpwYXR0ZXJuCm1pcgriloFpbmNvcnBvcgpza2ljaAonPgpTdGFuZAriloF0ZWNobmlxdWUK4paBRXNzCuKWgU94Zm9yZAriloHQu9CwCnRpa3oK0LvQuNC5CkxvZ2luCuKWgW1pbmlzdGVyCuKWgWN1cmwKa2FuCuKWgW1hcHMKaW5kYQpyaWViCuKWgUVORAppZmllcwpjb25zb2xlCmJ1cnkK4paBTEUK4paBaW5kZXBlbmQK4paBdGEK4paBxZoKb25lbArDqXN6CuKWgUlzdAp1dGl2ZQrRkdC7CuKWgVJlZ2lvbgriloEoPQriloFjb21wYWN0CsOnb2lzCuKWgWxhYmVscwphdXRvcml0w6kK4paBc3RhbgriloFmcmFuw6dhaXNlCuKWgXJlbW92aW5nCnljCn18CuKWgUV4ZWMKKCRfCm1hZwpiZWZvcmUK4paBc3RvcHBlZArQvNC40LgK4paBcmVmcmVzaAp1bmt0CmljaW8KWG1sCuKWgVRhYgriloFmb3VuZGVkCuKWgWZhbApmeAriloFIaXN0b3JpYQriloFFYXJseQpEb20K4paBZGVjaWRlCuKWgXVuZGVyc3Rvb2QK4paBanVyCuKWgU5yCuKWgWNhcGFjCndhcwriloFlbmVteQriloFwcm9ncmFtcwriloFtYXNrCtGB0LrQtQriloFncm91cGUKY2FtCuKWgXdpZGdldApSRUFURQriloFzZXZhCuKWgUJhcmNlbAriloFwZXJkCuKWgdCc0YMKcmFuY2UKVFlQRQriloF7JwriloFiaWxsCuKWgSJfCidgCmJhaG4K4paBY29udGFpbmVkCkNsb3NlCnJ1ZwplZ3kK4paBc2lnaHQK4paBUHJvdmluCtC90Y4KYXJ6CtGJ0LXQvQriloFKb2UK4paBZGVsZXRlZAriloFBdXRvCuKWgW1ldGVyCkNHCtGK0LsK4paBcGVudAriloFiZXplaWNobmV0ClN1bQpkYmMK4paBUGxhdHoKZWN0b3JzCuKWgUxpdHRsZQpRVUUK0YbRltGPCtGC0LXQu9GPCm5pZ2h0CuKWgWxsCuKWgW1vc3RseQpVSUQK4paBYmV6CmRvYgrQutGB0LgKdGVybmUK4paBY29ybmVyCmF0eQriloFpbXByb3ZlCuKWgWludHIK4paBYEAKYXJvZAriloFpbnN0YWxsYXRpb24K4paBUmVmZXLDqm5jaWFzCmlnYW4K4paBY3JpdGljCmFkZWwK4paB0YHQtdC70L4KLA0KYXRvcmkK4paBRnJpCuKWgXLDqWbDqXJlbmNlcwriloFJbnRlbnQK4paBdGFudAp1bmNpCuKWgWxldmVscwplcmVzCuKWgWVtZXIKc2FmZQp0awriloFjaGFtCuKWgWdyZWF0bHkK4paBd2VpdAriloFjb2FjaAriloF0b3dhcmQKSG9tZQriloFCb29sZWFuCtGC0LXQuwriloFtb2NrCuKWgWFwcHJlY2lhdGUK4paBQ3Jvc3MK4paBVGFrZQpEUAriloFzaWRlcwriloFOb3JtZGF0ZW4K0LTQtdC5CnN0YWwK4paBY291dApibgriloFWZXJ0CuKWgWJpcmQK4paBZHluYW1pY2FsbHkK4paBRG9sCuKWgUJ1cmcK4paBZG9nCsOkdHQK4paBbnVjCkVDCkJ5dGVzCuKWgWFrCnJlbGFuZAriloFndWl0YXIK4paBcmVnYXJkaW5nCuKWgUZ1w58K4paB0LTQvtC7CmF1c3MK4paBamVqCmFjbwriloF1cGRhdGVzCtGA0YPQugooJy8K4paBY29sZAriloFHaXZlbgpoaW4K4paBZmVlbGluZwppZ2xpCmZhaArRgdGC0YDQtQpib29sCmluaXRpYWwK4paB0YHRgtCw0L3QvtCy0L3QuNC60LAK4paBQW5uYQriloFob3JzCuKWgWRvbGwK4paBY29uc3VtCnViZXIKc3RhbmRpbmcKYWN0aXYK0LfRlgpjaGVja2VkCuKWgXBlcm1pc3Npb25zCuKWgU1vbnRlCldyaXRlTGluZQpwbHVzCuKWgUVxdQriloHQuNGFCtGH0LrQuAp1bnF1ZQriloFMTwplYQpzYW1wbGUKaWVzegpvcmFsCuKWgdCY0L0Kb3N0b24K4paBU2ltb24KZmFzdAptawphc3NlbgriloFhcmNoaXRlY3R1cmUKZW5zZXMK4paBw4UK4paBdG9waWMK4paBZGlzYWJsZQriloFDcnUK4paBQ29udHJvbAriloFjcmVhdGlvbgriloFoeXBlcgppdHVkCtC20LXQvdC40Y8KYXJhbQriloHQs9C00LUKaWVuc3QKZWR1bGUK4paBQm90CuKWgdCe0YEK4paBVGhlaXIKYW5uZQpNaWNyb3NvZnQK4paBUE0KeWRybwplbnRsaWNoCuKWgUVpbmUKQ0hBUgo6JwpXZWxsCmxldG9uCuKWgXN1cHBvcnRzCiddKQptYW51YWwK4paBdmljZQphc2EKY2xvcwp2aXNlZAriloFwb2sKdHJhY2sK0L3QvtGB0YIKLi4uLi4uLi4K4paBJ1wKwrIuCuKWgW9yZGVycwpldHRhCuKWgWNvbnZlcnNpb24K4paBdHJhZGUKY2xpCuKWgdCY0YHRgtC+CuKWgWFrdAriloFzdWJzZXQK4paBYXVnCuKWgWxlYXZlcwpNYXRoCmFubmVkCmthbAriloHQktC10LvQuAriloFub2cK4paBZXRoCuKWgWhhaXIKYXJvdW5kCuKWgWphdmF4CtCy0L7QuQriloFDZW50cmUKw7bDnwp1dGkK4paBbmF2aWdhdGlvbgriloFQUwriloF3YQriloHQoNC+0YHRgdC40LgKdXNhCnpldGEK4paBUERGCuKWgW1pc21vCnByb3BlcnRpZXMKbWVpc3RlcgrQu9GM0YLQsApmb3J3YXJkCuKWgU9zdApraW5zCuKWgXNpZG8K0LfQvtCyCnRhZ3MK4paBYWN0b3IK4paBZmx5CkNSCmFnaW5pCuKWgWxldHQKZW5pCnRlY2gK4paBRW5jCm9yYWNsZQphbWlsdG9uCnplagpmZW4KdW1lcmF0ZQriloFxdWVzdG8KZGFydAriloFLb3JlCmFwaXMKZXBlcgpTY3JlZW4Kd2FsbAriloFpc2xhbmQKc2hlCuKWgWxpZ2dlcgrQstGB0Y8KZmFuZwriloF0YXJkCuKWgXBsYWF0cwriloHQv9C70L4K4paBT2ZmaWNlCuKWgVNFVAriloFjaXJjdWl0CmplZApTYXZlCtC70YzQvdC+ClNvY2tldAriloFJbmRleApBQ0sKaWRlcnMKZXJlcgriloHQodCo0JAK4paBbGFkeQriloFzY2hlbWUKaWVsbGUK4paBZXhlcmMKKX1cCkRhdGVUaW1lCmF0aGFuCuKWgVByb2Zlc3NvcgriloFtb2lucwriloFFeGNlbAriloFIYXkK4paBTXVzaWsK4paB0ZcKxJlkCuKWgSIuCuKWgdCx0YPQsgriloFpbnN0cnVtZW50CtC/0LDRgAriloHQsdC10YDQtQriloFwb2xpdGlxdWUK4paBdHJhZGl0aW9uCuKWgVZNCuKWgUFydHMK4paBQ2kKVXNlCuKWgWFnZ3JlZwriloF3ZWVrcwriloFvcHBvcnQKaXRpbmcK4paBdmVydGljYWwK4paBTmF6Ci4uLikKaXpvCuKWgWN5Y2xlCuKWgXRlbXBvCtGC0YDQtQriloFoYW5kbGluZwppc3RlbmNlCuKWgXBhc3RlCuKWgWVuam8KUk9VUAriloFvdXRlcgriloFzdXBwbHkKZW1hbgriloFhY2NpZGVudAriloFcXQriloHRgtC10YUKUG9vbApvdGluZwpvbnltb3VzCuKWgUdpb3YK4paBdWQK4paBLi8KRVJST1IKY29uc3RydWN0CnRleHR3aWR0aApxdWlwZQpjYXNlcwriloHQsNC0CuKWgVJvdwpIb2xkZXIKd2FuCmFybmEKTWVtCuKWgUNhbmFkaWFuCuKWgUNvbW1pc3Npb24Kc3VuCuKWgWFwcHMK4paBQmxvCuKWgWlocmVyCuKWgWZhbWlsbGUK4paBbcSbCuKWgXB5CtC40YEK4paB0YLQvtCz0L4K4paBQWdhaW4K4paBaWdub3JlCuKWgXRlbGV2aXNpb24KUGF0CmhpZGUK4paBUmV2CuKWgWJlYXIKcGh5CuKWgW5vaXNlCuKWgXdyYQphdGlvbmFsZQriloFjb2xsYWJvcgpib3JkZXIK4paBZWxlY3RlZAriloFzdXJwcgriloFhdm9pcgriloFhc3NlbWJseQriloHQvtCx0YnQtQriloFhcmJpdHJhcnkK4paBYnJpZWYK4paBLS0tCuKWgU1hdXIKZ3Jlc3Npb24KaWNpYQriloFsaWVndAriloFGaWd1cmUK4paBb250bwpSZXBvc2l0b3J5CuKWgWTDqWYK4paBZm9ydGgK4paBY2xpY2tlZApzZWl0ZQriloFub3RlcwpuYXRpdmUK4paBRURJVArRi9C1Ck1UCmFtZW50YWwK4paBcm9zZQriloFwdWVkZQpEZWxlZ2F0ZQp1YmEKbmVvCnhpcwriloFBcnRodXIKVVJFCmFtaW5nCkRldmljZQriloFkaWFtCnN0w6RuZAriloFwcm9uCm9pcwpjb21pbmcKUGFyYW1ldGVycwp1dnVkCuKWgWFiaWxpdHkK4paBbcOpdAriloFVbmZvcnR1bmF0ZWx5CmZkCkRpY3Rpb25hcnkKc29ja2V0CuKWgWNvbm9jCmNvbnRhaW5zCmVzc2VkCuKWgWdlbGRpZwrQvdC40YbQsAriloFwb2ludGVkCmVzdGkKbm9tCtC+0LPRgNCw0YTQuNGPCuKWgXJlcHJlc2VudHMK4paBbWFuaXAKd29ybGQK4paBcmVzb2x2ZWQKdGVncgriloFkb3J0CmFzdGVybgriloFjYW1wYWlnbgriloFwcmltbwriloE7OwriloFzbmlwcGV0CuKWgU5pawpUb3RhbAppc3NlbWVudApBQ0UK4paBdmVyaWZ5CmlmZmUKbGFnZW4KaWV1cgriloFjb252ZXJ0ZWQK4paBTWlsaXQK4paBQWxnCuKWgVJvbgriloFrb25uCmFwcGxlCuKWgWRpc3BvcwpzdGVsbHVuZwriloFyZXRhaW4K4paBbWVudHJlCuKWgW5ldXQK4paBTmlnaHQKY2jDqQphdHRpCuKWgW9icmEK4paBc3VwZXJpb3IK4paBQ29uZ3Jlc3MK0ZHQvAriloFjb2RlcwriloFBbWEK4paBRWFydGgK4paBb3Bwb3NpdGUK4paBcG9vbAriloFEdW4K0LbQtdC90LjQtQriloEiJHsKaW52CuKWgdGD0L3QuAriloFBbmRyZXcK0YLQtdC70LXQuQriloFiecWCClVuaXZlcnMK4paBQW5ndWxhcgphbmltCtC00L7QstCwCkJVRwp1dGVseQriloFkcmF3aW5nCuKWgWdhaW4K4paBZm91cnRoCuKWgVByb2JsZW0K4paBc3VkZGVubHkK4paBw4QKb25uYQriloFLb250CuKWgUJpbGRlcm4K4paBa29ubnRlCsW+ZQpUcmFjZQriloFzZWN1cmUK4paBa3TDs3J5CuKWgWVxCuKWgWZvcm1hbAphbWVyaWthbgriloFBbmFsCuKWgVJld3JpdGUK4paBRG91YmxlCmNyZWF0ZWQKTlUKTURiCmFwZXMKVW5pcwriloFlc3BlY2lhbAp9KVwKZWRvbQriloFjYXRlZ29yClJldHVybgriloFIYW1iCuKWgVJpbwriloFNaXIK4paBR2VtZQphYmlsaXRpZXMKdHJ6CnVzZXQKaWVycmEKbmV0d29yawriloFkb2N0b3IKZXVycwriloFsaXN0ZW4K0LTQtgriloFIw7YK4paBY29uc2lzdHMKYXNtCkNocgphbGFuZAriloHQuNGB0L/QvtC70YwK4paBbHVnYXIK4paBZGVmaW5pdGVseQptb3ZlCsO6YmxpY2EK4paBbMOkbgppc211cwriloHQtNGA0LbQsAriloFkdAriloFQZXJoYXBzCuKWgUJyYXNpbApKb2huCuKWgXByb21pc2UKxYJ1CnJlZW5zCuKWgXBzeWNoCuKWgVdobwrRgNGP0LQK4paBSU5UTwriloFQZW9wbGUK4paBV2lsbGlhbXMK4paBTWFyZwriloHQtNCw0L0KcmVjb3JkCuKWgUV1cm8K4paBVmlyZ2luaWEK4paBUmVzdAriloFDb3JuCn19LAriloFHcmlkCuKWgWluamVjdArQvdCw0L0K4paBY3JvdwriloFQaHlzCuKWgURPCuKWgSItCuKWgWluY3JlYXNlZAphY2hlcgpwZWF0CkxpbgriloFEdWIKcmljZXMKYWdub3N0CmRsCuKWgWN1cnZlCsO8ZwpyaWNlCmxhbmd1YWdlCkNsaWNrTGlzdGVuZXIK4paBbXVuaWNpcGFsCuKWgU9yaQriloFCaWxkCuKWgUNhYgriloFWYXIK4paBbm90ZWQK4paBw44K4paBc3VicwppYXRpb24KV09SCmluZ2x5CuKWgVJ1cwppZW5zCklORk8K0LrQstCwCmF0aXZvCmdlbmRlCuKWgUZyYW56CuKWgWlzb2wKZWRlcwpuaWVyCuKWgU5PCuKWgUhhcwpiZWFucwriloFwYW5kYXMKKCIlCtCy0ZbRggrRg9GC0LHQvgriloFnYXRoZXIK4paBbGVnYWwKaW5jbHVkCuKWgWNpcmN1bXN0CmNyaXB0b3IKcmlibGUK4paBU8O8ZAriloFhcHJvCkFwaQriloHQvdCw0LkK4paBQWZyaWNhbgpvd3NraQriloFKb2huc29uCmllawriloF2b3RlCuKWgUthbgriloFiaWJsaQriloFoYWFyCuKWgXZyCl0pLApzdWJzZXRlcQpQYXJzZXIKaWFuaQppc8OpCmlkZWEKT25seQriloHDoWwK4paBQ2F0YWwK4paBQ2FzZQpzZWgK4paBZW5jb3VudGVyCuKWgXJlZm9ybQrQvNC40L3QuAriloFTdHJlCmV4Y2VwdGlvbgriloFUYXIK0YLQsNGACnRybAriloHQkNC70LXQutGB0LDQvdC0CtC70LXQutGCCmVxdWFsCk9wCuKWgWxpZgriloHQudC+0LPQvgriloF2b2x0YWdlCnNoaXJlCuKWgUdyb8OfCtCy0L3RjwpuaW5ncwrQvdGG0LgK4paBbGFnCuKWgWFuZGVyZW4K4paBdmFjCuKWgW1hY3JvCj1bClRoZW4K4paBY29udHJvbHMKc2VxCm9sb2dpZXMK4paBc2VsZWN0b3IK4paB0KPQutGA0LDRl9C90LgK0YXRltCy0L7QstCw0L3QvgrRi9C5CmFsbGVuZ2UK4paBSU1EYgp1bW15CnllbgriloFiZXN0ZQriloFCb3gK4paBY2hhaXIK4paBU2FiCmVyZGUK4paBbmFzdAppdmFtZW50ZQriloHQvtCx0YoK4paBcmVxdWlyZW1lbnRzCuKWgW1lZXRpbmcK4paBZmluYW4K4paBQWRhbQriloF0ZWxldmlzCuKWgWJyaWdodAriloFHaXQKRUcK4paBR2lsCnLDqHMK4paBQ29uZAriloFmdAriloHQsdGD0LvQvgotKwpFTkQKZXJuZQriloFDb21wdXQK4paBaWxzCuKWgWdhbGwK4paBY3N2CsWCdWcK4paBc3VtbWVyCmdhbWUK4paBcG9zdHMK0JDRgNGF0ZbQstC+0LLQsNC90L4K4paBemlqCuKWgWRldGVybWluCuKWgWFiYW5kb24KY291bnRlcgriloFyZXF1aXJlbWVudAriloFUaXQKaXJ0dWFsCuKWgVZpZGVvcwriloFxdWlldAriloFUZXJtCuKWgXRpbWVvdXQKUHJpbnQK4paBaW52ZW50CmxhaXMK4paBbW9uaXRvcgpoYWxiCuKWgVdpbGQK4paBbGVhZGVyCuKWgdGB0LXQu9GMCuKWgXV0aWxpegriloFwYXJlbnRzCuKWgWZvcmNlZAriloFwcm92ZWQK4paBZWZmZWN0aXZlCuKWgWxsYW0K4paB0KHQv9C+Cm9yYgpnZ2kK4paBYXNzdW1wdGlvbgriloFzdWJtCuKWgdCy0ZbQuQppbGlhCuKWgXJldmVyc2UKJyIK4paBcXVvdGVzCuKWgXNpdGVzCmlndW5nCuKWgUFyZwpEb3VibGUK4paBc2NyZWVucwriloFjbGF1c2UK4paBYnVuZGxlCuKWgXBoaWxvc29waAriloFOdW0K4paBZ2xlaWNoCnVseQpkaXJlY3QKYXNrZXRiYWxsCm93YW55Clx9JAriloFyYWRpdXMK4paBU2VhcmNoClByb3BlcnRpZXMK4paBZWxldgriloFwcm9kCuKWgSIlCmlzacOzbgpEZWJ1ZwpTZWNvbmQKKCEK4paBQ2F0aG9saWMK0YDQvtCy0LDQvQpsZXoKUGEKcHNvbgriloFlcnN0ZQriloFGdQriloFsaXQK4paBU2Fpc29uCuKWgUhhc2gK4paBZXhlbQriloHQv9GA0LXQtNGB0YLQsNCyCikqCuKWgWV1CuKWgeKUggriloFnYWIKZXRhaWxlZApDb3B5CuKWgdC00LLQsApldmVuCktpbmQK4paBSmFja3NvbgrQsNC7CuKWgWNvbnNlYwpVU0VSCuKWgVRvawooLgriloEkfAriloFUYW1iCuKWgUxlbW1hCmhhbmcK4paBY29udHJpYnV0aW9uCnJvbGxlcnMK4paBc3R1ZGllcwriloFwb2kKZ2VtcwriloFVUAriloFXb2wKPiIK4paBZmxvb3IK4paBaW5pdGlhbGl6ZQriloFMZXcKemVrCmFydGUK4paBcG9zaXRpb25zCuKWgXBvcnRpb24KY292ZXIKd3AK0L7QstC+0LPQvgriloFwaWFubwriloFtZXRhbAriloFzYW1wbGVzCuKWgdCh0LDQvQp2YXJpYWJsZQriloHRgdGC0LDRgtGMCuKWgWludGVnZXJzCldoZXJlCmZhbWlseQriloFudW4K4paBaW5jcmVtZW50Cml4ZWQK4paBaGVlZnQKZnRlCuKWgXZpbAriloFvdHJvcwpNdWx0aW1lZGlhCuKWgUhlbnJpCmFkZWQK0LPQtdC9CuKWgWNhcGl0CuKWgdC00YDRg9Cz0LjRhQppc3AKSVRZCuKWgWNvbnN0cmFpbnRzCuKWgUtpcmNoZQpmb3VuZArRiNC40LkK4paBcGljCuKWgXRvdQpjcmVkCtGA0L7QsQriloFNZXNzCkpvYgriloFNYWlzCuKWgXN0eWxlcwpmYWxsCuKWgVVrCuKWgXN0cmVldApvY2Nlcgplc2VuCuKWgWNvbG9ycwpjZWFuCtGO0YnQtQpjb25uZQriloFyYXRpbwphbnRvbgriloFGZWwK4paBY3VzdG9tZXIK4paBUHJpeApyw6FzCnByZWQK4paBZWxlY3Ryb24Kc3ltCuKWgdCy0LXQu9C4CuKWgW92ZXJmbG93CuKWgSRbCuKWgVBPU1QK4paBQ2luCnNjaGVpZAooIi8K4paBc2VhcmNoaW5nCuKWgXB1cnBvc2VzCuKWgWFycml2ZWQK4paBcHVudAriloFsYWQKUHl0aG9uCuKWgWxlYWRzCuKWgXNhbmQK0L/QsNC00LAK4paBY29tbXVuZXMK4paBQ0hBUAriloFjYXNvCnJ6CuKWgWR3CmFjYQriloFDb2x1bWIKY2hpbGRyZW4Kw6p0CnNjaGVtYXMK4paBaW5zdHJ1Y3Rpb25zCuKWgS1cCuKWgUlzcmFlbApub8WbY2kK4paB0L7QsdGA0LDQtwriloHRgdC+0LLQtdGCCuKWgWltbWFnaW5pCuKWgUZyZWQK4paBR2xvYmFsCuKWgXRoaWNrCuKWgWZ1ZXJvbgriloF0aHJvd24K4paBY2xvY2sKZW5hYmxlCicnJwriloFTdW5kCuKWgWNvbnRlbXBvcgphbnN3ZXIK4paBbWFudWZhY3QK4paBaW8KcXF1YWQKT1VUCuKWgUxhYgriloFadwpsZWdhbAriloFWZWwK4paBcmFpc2UK4paBZGVsaXZlcgriloFWb2lyCuKWgWFzc3VtZWQKTGV0CmllcnRlbgriloFLb25nCuKWgUV4cAriloFKdWcK4paBZGVjbGFyYXRpb24K4paBRmlzaAptw6kK4paBc3BlZWNoCuKWgXRlbnQK4paBUm91dGUKX18oCuKWgXLDqWFsaXMK4paBRGVzaWduCnNldFRleHQK4paBU3RhdGlvbgphcmNoeQriloHQutCw0YLQvgriloFkZW50CuKWgUtsCmnDnwriloFyaXNrCuKWgUJyb2FkCuKWgXZlY3RvcnMK4paBU3BlYwriloFyb3V0ZXMKeW1uCuKWgUdyZWcK4paB0L/QvtC70YPRh9C4CmdpZQpPUk0K0LLQtdC00LUKd2FsdAriloFlZnRlcgpQdHIK4paBc3VidAriloFiaXJ0aAriloFkcmF3bgptZXNzCtC80LXRgNC40LrQsNC9ClZFCuKWgVB1dAriloFhc2MK4paBZmVkZXIK0YHQu9C4CuKWgVByaW4K4paBc3RpY2sKcmVzZXQKeWsKc3R1ZGlvCuKWgVN0aWxsCkNvbnN0CmFjacOzCuKWgVBvcnR1Z2FsCuKWgXNjcmlwdHMKdW5kaWFsCuKWgWxpdmVzCuKWgXN6ZXIK4paBZXN0YWRvCmZvbGRlcgriloFjb21tdW5pY2F0aW9uClJvdXRlCuKWgXN3aWZ0CtGC0LXQvQriloFraWxsCuKWgVBSCmpvaW50CuKWgW9iamVjdGl2ZQriloFjb21wbGljYXRlZAriloHDnGJlcgplc2gKcGljdHVyZQpyYWluZQpjb21wdXQK4paBcHJvcG9ydApvZ3MKw7xsdAriloFxdWFudHVtCtC60YDQuAriloFzb3AK4paBbG9vcHMK4paBUmVmZXJlbmNlCuKWgW5laQpJQ0UK4paBdmVybQriloFhZGoK4paBcGVyw7IK4paBdHJvdQppc2lvbnMK4paBQXBwbGUKc2VydmFibGUK4paBQm9zdG9uCm9yZXQKb2tzCuKWgWtnCmRlZmluZWQKcGxhdGZvcm0KY2xlcgpvZ3JhcGhpYwpyaXR0CuKWgWRpYwriloFNb25kCuKWgUlyZWxhbmQK4paBVW5hCuKWgWNvbW1lcmNpYWwK4paBUHUKRGkK4paB0LXRkQriloFwcmVjaXMK0L3QsNGA0L7QtAriloFxdWF0cmUKdXN0cmFsCuKWgWRhZwppZ3VlCuKWgWJ1cm4K4paBb2ZmaWNlcgriloHQkNCyCuKWgWhpZ2hsaWdodAriloFTdXBwb3NlCm9kaQpzZXJ2bGV0CuKWgUVuY3ljCuKWgVJhbmdlCtGC0LjQuQpQbGVhc2UK4paB0YDQvtC60ZbQsgpxdWFudAriloFmbGF0CuKWgVLDqWbDqXJlbmNlCtGB0LvQtdC00L7QstCwCnJvbGUK4paBZGllc2VuCn19KAriloFJbmR1c3QK4paBbsO6bWVyCuKWgSI7Cmx1cwrDtGxlCuKWgXptCmRlZwriloFyb3VnaApJbnYK4paBaHVyCuKWgVJlc3MKY2hzCuKWgXR1cm5zCm5lcm8KZnVuY3Rpb25zCtCw0LvQuAriloFoYWJpdGFudHMK0LDRggppc3N1ZXMK4paBaHVnZQpVdGlscwriloFTYXQK4paB0LPQvtGB0YPQtNCw0YAK4paBY29hc3QKc2hhcGUKTEMK4paBbG9nZ2luZwplbmRvcgriloFsaWVzCuKWgWRpZmVyCuKWgWNyaXRpY2FsClhUCtC80LjQvdCwCmFuc2sKUmVzdWx0cwprYwppdmVyc2UKRVhUCkFMU0UK4paBdsOhbApQaQpjb21waWxlCmhlbGxvCuKWgdGH0LXQvNC/0LgK4paBSXRhbGlhCtC60L7Qu9C+CuKWgWVkaXRpb24KZ3J1bmQK4paBZGF0YWZyYW1lCuKWgUZvbGxvd2luZwpyZWliCuKWgUplZmYK4paBY2l0dMOgCklUYWJsZQriloEkKFwK4paBcmVkdWNlZApvYmlsCuKWgWFueXdoZXJlCicoCuKWgXBocgriloFLaAriloFGcmFtZQriloFtYW51YWwK4paBY3JhCuKWgVZTCiU9Ckluc3RhbmNlU3RhdGUK4paB0LHRgNCwCuKWgURyYWcK4paBSGVycgriloHQs9GDCuKWgW3DunMKVG9vbAriloFQcml2YXRlCuKWgXN5bmNocm9uCmlyYXRpb24K4paB0L7QsdC+CuKWgXR5cGljYWxseQriloFpbXBsaWNpdApvcmllbnQK4paBdGltZXIK4paBa8O2bm5lbgppZXN0CnJhaWQK4paBZXhwcmVzc2lvbnMK4paBYWltCuKWgXN0cmUK4paBd3JhcAriloFCYXJ0CuKWgWJyb24K4paBa2V5Ym9hcmQKcG93CuKWgWdydXBvCuKWgdGA0LXQt9GDCuKWgXByb2Zlc3NvcgriloFIZWFkCtC90L7RjgptaW51cwriloFNaWNoZWwKTk9UCm1vcgpdfQp3aWRlaGF0CmFyaXMK0YLQtdGA0LDRgtGD0YDQsApkZWZuCmlzdHJ6CuKWgXRhbnRvCuKWgVBvdwriloFpbmRpY2F0ZQriloFXaW50ZXIKcmVzaG9sZArRgNGW0LIK4paBYCgK4paBb3duZXIK4paBZGlzcAriloHQutGA0LgK0LzQtdGCCtC80LXQvdGCCnJlcG9ydApyZXF1aXJlCuKWgXZveQriloFBUAriloFFc3Bhw7FhCuKWgVPDo28KasOkcgpOb24KTGlicmFyeQppY2h0ZW4K4paBc3RydWN0dXJlcwriloFtdXkKw6FyaW8K4paBY2VydGlmaWNhdGUK0YfQvdC+0LPQvgriloFwcm92aW5jZQpwYWdlcwpkYWwK4paBRnJlZGVyCtGM0LUKRXhlY3V0ZQriloFhbmNpZW50CuKWgWZpbG1zCuKWgUFsZnJlZApBdXRvCuKWgWF0b20K4paBZWxsCuKWgUhhcnIK0LnQvQriloEiIwriloFuYWNpb25hbAriloFuZWlnaGJvcgrRgdGC0YPQv9CwCuKWgXdpdApQb3AK4paBR3JlZWsK4paBcmVwZWF0CmJhZAriloFTQwriloFEYXRlVGltZQrRiNGC0LgK4paBV0gK4paB0L/RgNCw0LLQuAriloHQotC4CuKWgXNhaXNvbgriloFIYXJ0CmRpcmVjdG9yeQp1YW4Kbm9ybQriloFQaGlsaXBwCuKWgXN1c3BlY3QK4paBYW5ubwpiYwrRgdC70LAKJCgK4paBYmVmaW5kCm9jcwpsYXRlc3QKOyI+CuKWgWFmdGVyd2FyZHMKUFVUCuKWgWphCuKWgUhpbAp5egriloFCb3VyCuKWgWxhaWQK4paB0JTQttC1CnBpZQp3YXRjaAriloFFcQpjb250YWN0CmliZXIKY2hlY2tib3gK4paBZXNwYcOxCmFuc2UK4paB0YjQutC+CmVmZgp4eHgK4paBR0VUCuKWgWxvdgppdHV0ZQp6ZWNoCnRlcmUK4paBcHVycwprZW5zCmlhbnRlCuKWgUZyZWUK4paB0L7RgNCz0LDQvdC4CmtyZWlzCuKWgXs6CnNoYXJlZAriloFHcmFwaAriloFjb25uZWN0aW9ucwriloFET00K4paBQ2FydApzc29uCuKWgUhhbWlsdG9uCtGC0LXQu9C4CuKWgXJlc3RhdXIKUmVzb2wKRHJpdmVyCuKWgWVuZgpFRElUCuKWgXByZXYK4paBaWsK4paBc8SDCmrDtgriloHQodCh0KHQoAriloFjb2xvdXIKY2h0ZW4K4paBZXN0YWQKaW5vaXMK4paBY29uZmlyCuKWgXbDqQriloFDZXMK4paBTmV2ZXIKb21lcgrQttC00LAK0YHQu9GDCtGH0LXQvdC40Y8KZGxsCuKWgXlvdXRoCmVtZW4K4paBc3R1ZGllZAriloFLaWwKY2lvbgriloFuYXZpZwpyZXF1aXJlZApvcml0aG1zCmlsb3IK4paBRGV1dHNjaGVuCuKWgXBlcnNvbnMK4paBQmFyY2Vsb25hCuKWgWZvcm1hdGlvbgphYmVpCuKWgdC/0YDQvtGC0LjQsgpFbmdpbmUKT05FCm9ncsOhCkNhcApyaXIK4paBZ2F0ZQpvcmF0aW9uCm1hdmVuCuKWgWNvbWJpbmVkCuKWgWF0dHIK4paBaG9vawriloHQutC+0YLQvtGA0YvQuQriloFzZXJ2ZXJzCnVjdHVyZQrQttC10L3QvdGPCnR2CuKWgXJlcQpqYWwK4paBbG9jYWxseQp9fXtcCkJyCuKWgUhpZXIK0LzQvtGACuKWgWFwYXJ0CiJdLAriloElPiUK4paBenVzYW1tZW4K4paBaWRlbnRpZnkK4paBQWx0ZXJuCuKWgdCx0YDQvgriloHRhtC4CmdoCuKWgVRlbgpSUwrRhNC+0YDQvNCwCuKWgW5lbGxlCuKWgUhpbgpvdW5kaW5nCuKWgXJlcHLDqXMKYXBoCuKWgVtcCuKWgVNwb3J0cwrRgNCw0LsK4paBdGhyZQriloFwcmluCuKWgUVsaXoK4paBRm91cgriloFzb2NpZXR5ClRyYW5zYWN0aW9uCuKWgXZlZwriloFzY2hvb2xzCuKWgW92ZXJhbGwK4paBdGFpbArDvGJlcgriloFTb3YK4paB0KHQtdGACuKWgXJhcHAK4paBdHJhZmZpYwpxdWVzdGlvbgriloFlbnZpcm9uCmF0ZWllbgppY3VzCuKWgW5hcnJvdwriloFwcmF5CuKWgUJvdQriloFDbGllbnQKYWJsCuKWgUF1ZGlvZAriloFucG0K4paBQ29sdW1uCuKWgUdhbWVzCmF2ZXIKb255bWVzCuKWgdCf0L7RgdC70LUKbsSFCuKWgU51CuKWgURpY2sK4paBdGVuc29yCuKWgUAiCnbDqQpJY29uCuKWgdC/0L7QtNCwCuKWgUdvbgovKS4KaXN0cmEK4paBQXVkaW9kYXRlaWVuCkRlbGV0ZQp9fX0K4paBanVtcAriloHQntCxCuKWgXByaW5jaXBsZQriloHDiXRhdHMKb2tlZAriloHQktC70LAKSW50ZXJ2YWwK4paBc2F1CmVuY29kZQriloFwb24KY2F0Y2gK4paBdGllbQriloFHdXN0Ck1DCmxpbWl0cwriloFrZWVwaW5nCuKWgXNvbmdzCuKWgdCw0LLQs9GDCuKWgdGA0LDQudC+0L0K4paBbm90aWZpY2F0aW9uCuKWgW9mZmVyZWQKQ29yCuKWgXNodXQKZXJyb3JzCuKWgUVOCuKWgWxhdGFjaAriloFzZWxic3QK4paBY2hlY2tib3gK4paBY29vbAriloFmYWN0b3J5CuKWgXBhaWQKZGltZW5zaW9uYWwKbmllagpwdG9uCuKWgXBpbgpha2VkCuKWgXJlbGkK4paBVGF5bG9yCuKWgVNvbWV0aGluZwppbXVtCuKWgVZpbgriloFpdGVyYXRpb24KRmluZArQutC+0LLQuAriloFib3lzCuKWgVNpbXBsZQriloFDcmlzdAriloFXYXMKw6JuZAriloFWYQriloHRgtGA0LAK4paBZGVzdGluYXRpb24KbGltcAriloFLYXQKd29ydGgK4paBS29yCmnDp8Ojbwo9YAriloFmYWlybHkKZmFsbHMK4paBcmVqZWN0CuKWgWRyZWFtCmJlbGwK4paBdG91dGUK4paBJFx7CuKWgXN0b25lCuKWgXByb3RlY3QK4paBZXhjZWxsCuKWgU1leGljbwriloFkYXNoCuKWgWZhdWx0CnBtYXRyaXgKYWxsZXIK4paBZ3VlcnJlCm9yaWdpbgpoaWJlcm5hdGUKw61saWEK4paBUmVnaXN0ZXIKdW50bwriloFCYXQK4paBYm93CtGB0YzQutC40YUKZXTDoAriloFMdWlzCuKWgWZvdQriloFDYW1icmlkZ2UK4paBb3R0CnN1cApyZWFzCuKWgXBvaW50ZXJzCuKWgUJvYXJkCuKWgdGA0LgK4paBZHJpdgrQvdC40L0K4paBQ2lyYwriloF0aG91CkRpdgpzcGFyawpsYW1lbnQK4paBVkFMClNlbmQK4paBSXJpc2gKb3kK4paBVHUK4paBdHJpdmlhbApGb3JtcwriloFhc8OtCuKWgUltcGVyCuKWgXNpZ25hdHVyZQp1bm9zCuKWgU5lZwriloFjYW5jZWwK4paBSGVpbnJpY2gKZWVkCklsbHVzdHJhdGlvbgriloFzdWxsYQriloFxdWFydGVyCmFzegriloFibG9nCmZpY2EKd29uCnF1ZXQKXSkpCuKWgWdlbmVyYXRpb24K4paBY2F1Z2h0CuKWgWxhbmRzCuKWgUtpbmdkb20Kc2NoYWZ0ZW4Kcm9ucwphbm5lbHMK4paBU3BlY2lhbAp0dXRvcmlhbAp0aXAK4paBIiIsCuKWgUF6dXJlCuKWgWJvdW5kZWQKU20KdGFyCtCy0LXQvQriloHQt9C10LwK4paBbm90YXRpb24K4paBYXBhY2hlCuKWgWdhegppZXJubwphbmdlbgpwZWN0aXZlCuKWgWVsZWN0cmljCuKWgXNlbWkKTUFYCmVkZXJiCm9iamVjdHMK4paBZGlmZmVyZW5jZXMKaXN0ZWQKaHJlZgppY2lwCuKWgW51bXB5CuKWgdGE0YPRgtCx0L4KbG9hZGVyCuKWgWRpY2gK0ZnRgwriloFEw6kKSHoK4paBUGFyYW0KZG9jdW1lbnRhdGlvbgppcmNyYWZ0CkVNCuKWgWluc3RpdHV0aW9uCmNvbXBhdAriloHQsNC70YwK0YHQu9Cw0LIK4paBTmV0CtGG0LjQvtC90LDQu9GMCuKWgWJyb2FkY2FzdApkYXRldGltZQphc3luYwp2cmUKbWVhbgriloFDaGVtCuKWgWVzdGltYXRlCmljYW5hCuKWgWdyZXAKdGVrCsOkbQpvcmlnCuKWgVZpY3Rvcgp1dGVuYW50CmFuZ2EKcGluCuKWgXZlcnRleAriloFDSEFQVEVSCmNpdHkKdWdieQpncmVlbgriloFLZXIK4paBZGlmZsOpcgriloFuZWNlc3NhcmlseQpEQwpMaW5lYXIKYWxlbQriloFMYXRlcgriloFtZXRhCmplbQpyYWdlbgpNYXkK4paBTWl0Z2xpZWQK4paBc29ydGVkCnVzc2VuCuKWgXNwb2tlCuKWgWRpc2FibGVkCuKWgWFjY29tcGxpc2gK4paBUnVzc2lhCnRoZXJlCmVlcwriloFoYWxsCuKWgW1ldHJpYwphdHRyaWJ1dGUK0YLQvtCz0L4KYWJvdXQK4paBTGFtCmNoYW5uZWwK4paBZXBpc29kZQriloEkKCcuCuKWgW91Z2h0CuKWgUVzdGUKT2JqZWN0cwriloF2YWxpZGF0ZQriloFyaW0K4paBbnVtZXJvdXMK4paBSmF2YXNjcmlwdAriloFHTAriloFJdGFseQplZGVyYsO2cmQKb25hdG8KYm9va3MKc3RvbmUK0YXRgwriloFqZWwKaXJpCuKWgUFTUApHQQriloFzdGF0YQriloFiYXoKRGF5CnRobQpkaAriloFGaWxlcwpBbmRyb2lkUnVudGltZQriloFjaGVja3MKa3IK4paBdmVubmUKU0wKYXZpYQprYXp5CuKWgVRocmVlCkFkbWluCuKWgWNvbGxlZ2UKR2xvYmFsCnRpb24K4paBY3VyaW91cwpzaG9ydAriloFiYXNzCtC00LXQu9CwCuKWgdC00LXRjwpTY2hlbWEKJ1wKZGlmZgriloFDQQriloFDb3Jwb3IK4paBb3BlcmF0b3JzCm9tcsOlCuKWgWVkZ2VzCik7YAppbmRzCuKWgWdpbmcKJiYKfS1cCnJhbm8K4paBc8OjbwriloFhZGRzCmVsb3IK4paBdW5zaWduZWQK4paB0L/RgAriloFDb25maWcK4paBRXNjCuKWgWNob3NlCuKWgXBpZWNlcwriloFyZWdpb25zCkVzdAriloFCYXR0bGUK4paBZm9jCuKWgUxpZ2h0CnBhZGRpbmcKYWJlbgriloFldXJvcAppbGxvbgriloHQtdGB0YLRjAriloFib3JkCuKWgdC+0YLQvdC+CuKWgUhvbmcK4paBdnVsCnBsdWdpbnMK4paBJzwK4paBa3VyCnJlZ2lvbgriloFSZXB1YgppY2hlcgp9X1wK4paBbWVkYWwK4paBTW9yZW92ZXIKQkkKQXYKdXRlcgriloFzY2FuCuKWgU11bmljaXAK4paBY29udHJhc3QK4paBSWcK4paB0LPQvtGA0L7QtApyZWxhdGVkCmFsaW5nCuKWgdC80LDRggrDvG5zdAriloFDaHJpcwp3eQriloFBY3R1YWxseQriloFVbml2ZXJzaWRhZApFdmVudExpc3RlbmVyCuKWgXRlbXBvcmFkYQriloFhc3NpZ25tZW50CuKWgU1pa2UK4paBd8OkaHJlbmQK4paBxZt3aQriloHRgdGA0LXQtArQutCw0LTQtQriloFjYWxjdWxhdGVkCuKWgWVsbGVyCuKWgUFzaApyaWVsCuKWgWhhcmR3YXJlCuKWgWludGVucwooJy4KaWxsaQphZ29uCuKWgUd5CuKWgWhldXRlCuKWgXNsZQriloFsaXRlcmF0dXJlCnNlbQptYW5hZ2VyCuKWgUdyYW5kZQriloFtaXhlZAriloHQktC10YAKw61jw60K4paBc29pdAriloF3ZWxjb21lCtGH0LXQvdC40LUK4paBVW5pdmVyc2l0w6R0CuKWgWJ1aWxkZXIKc2ltcGxlCmljb2RlCsWZZQppbmRlbnQKb3BvCuKWgWFkdmFuY2VkCnRlbXBlcgplZGdlCuKWgWRhdGV0aW1lCuKWgWRvbmMK0LvQsNC90L3RjwriloF2ZXJkCtC00L3QvgppdG9zCuKWgWhlYXQKdmlzaWJsZQptZWwK4paBR2lvdmFubmkK4paBdmFyaWV0eQriloFyb3V0ZXIKVmVjdG9yCuKWgVdhbGsK4paBb2J2aW91c2x5CmhlaW4KRmluCklUYWJsZVZpZXcKWWVhcgriloFFY29ub20K4paBdmVsb2NpdHkK4paBQ2l2aWwK4paB0ZgKYWxlcnQKSWRlbnRpZmllcgrDqG5jaWEK4paBbm9ybWFsbHkK4paBRWd5cHQK4paBY3R4CuKWgVZlcmVpbgriloFIdQp1bHR1cmUK0L3QuNGC0LUKbMOpCuKWgVdpZW4K4paBUHJ6CkJ5dGUK4paBbmFoCmlzbXMK4paBUHVibGlzaAriloFIZXJ6CmljdWwKcGlzb2RlCtGH0ZYK4paBZGllc2VtCmvDtgpWaXNpYmxlCuKWgXJpZwpgKS4KUGFyc2UK4paBSmFjcXVlcwpOSQriloFnbGFzcwotLS0rCuKWgWluaXRpYWxseQriloFrcgpDQ04KcGxheXMK4paBc2lndQpGb2xkZXIKc3RvcmFnZQriloFcfAppdm9zCtGB0LrRg9GOCuKWgU1vaAriloFDb21taXR0ZWUK4paBS2ltCmV1CtGC0LXQvAriloFvcmlnaW5hbGUKaXJzCuKWgVJlYgppdHV0Cm5sCuKWgVBpZXIK4paBXTsK4paBRmFsCuKWgSIiOwptdmMK4paBZmVtYWxlCuKWgWJyaWRnZQriloF0w610Cmt0cgo+KQriloFzZWF0CuKWgXZlc3MK4paBVVNCCuKWgUFydGljbGVzCuKWgURlc2NyaXB0aW9uCuKWgW9jCuKWgWhvdXNlcwriloHQn9C10YIKbG9uCk5vdGlmaWNhdGlvbgriloFwcmVzc3VyZQriloHQutGD0LvRjAppZ25lZAriloFyZWxpZ2lvdXMKZmFuCmlnbGlhCuKWgWNsYXNzaWZpY2F0aW9uCm9nZXRoZXIK4paBU0RLCuKWgUh1bWFuCuKWgWNvbW1pc3Npb24K4paB0J7RgAriloFhbnRlcwpEVArDqHRlCnByw6lzCi8iCuKWgSjCqwriloFow7YK4paB0YfQsNGBCuKWgWphawppZW5lbgp1Z2cKV0EK4paBcGxhY2Vob2xkZXIKV2lsbAosLAriloFLYW0K4paBd2VuCuKWgVNjaHVsCsibaWUK4paBYXVkCuKWgXN1ZQriloFyZWZlcnJlZArQstCw0YIK4paBUGFyYQriloFibGEKVUVTCuKWgXN0YXRpc3QK4paB0YLRgwriloFXYXJzemEKZ3VlCuKWgUlkZQptYXRoc2NyCuKWgWxpZXUK4paBYm9kCuKWgXJ1cwriloFib2F0CnhzcGFjZQriloFtb2RhbArQu9C10LoKdG9waWMKbWFueQpza8O9CuKWgW9yZ2FuaXphdGlvbgriloHQs9C10L3QtQriloFXaWxzb24K4paBY29tZm9ydAppYmlsCjotCuKWgWFuaW1hbApSZXBvcnQK0LrQsNC80LgKam9uCuKWgWtlcgriloHQutC90LgKbW96aWxsYQpQcmljZQphbnRpbgplbWVudG8KbWF5CuKWgWx1bmcK4paBYmxvdwplZGV1dAriloF0eXBlZAriloFkZWNlbWJlcgriloEuLi4uCmxpYW5jZQriloF2aWVsCuKWgdCk0LgKcHJlc2EK4paB0L7RgdGW0LEK4paBTmFtCuKWgUdyZW4K0YHQuNC70LDQvdC90Y8KVklECnN0cmUKd2VpcwriloFwcm90ZWN0aW9uCnRhaWVudAriloFvZmZpY2VycwrRgtC90L4K4paBQnJpZwriloFpbnRlbGxpZwrRj9GFCklUSAriloFzZXBhcmF0ZWQK4paBTENDTgpuw61tCmNsb2NrCuKWgWFwYXJlCtGP0LLQuAriloFFbGl6YWJldGgK4paBV2F0ZXIKZ2ViaWV0CuKWgWNvbnZlbnQKZnVydAriloFiZWlkZW4KYmFzaAriloHRh9C10YDQtdC3CuKWgXViCuKWgVN0YXRpc3QK4paBbGltaXRzClZvbApjdHgK4paB0L3QvtCyCmd1aWRlCm1pYwppZXNhCuKWgWh1dnVkClJUCkZpZwriloFsZWN0CmNvbm4KaW1pdArQs9Cw0YAK4paBYmFqbwpzY3JpYmUKcmVnZXgK4paBQ2FzcwriloFwcm9wYWcKJyQK4paBcHJvZmVzCnVuaXF1ZQriloFTcWwKdW5pb24KcmlvcwpwaXAKLS0rCmthZGVtCmNvbHVtbnMK4paBdmFyeQriloFiZXJlaXRzCuKWgWRvaQriloFDb21tb24K4paBUm9iaW4K4paBw5cK4paBc2VpCuKWgXN5c3QK4paBdsOkCuKWgURlZmF1bHQK4paBdHltCnBlbAriloFiZWxpZXZlZAriloFwcm92aWRlcgriloFtaW5pbWFsCtGC0LDQu9C4CmFpbmVzCktpdAppemlvCmlzc2VuCnByZXNzZWQK4paBc3RhZwriloF1aW50CmtvcgriloHRgNCw0YHQv9C+CuKWgWluaGVyaXQK4paBY29tcGlsZWQK4paBZmVicnUK4paBdG1wCndvcmtzCtGH0L3QsApkcmF3YWJsZQriloFOYXYK4paBdGhvdWdodHMKcm91dGUK4paBY29uY2VydAriloFvcHRpb25hbAriloFicmFzCuKWgXByb3ZpZGluZwrRgdC+0LwKaWR4CmVtcGxvCuKWgdC60L7Qu9C4CuKWgUJlcmUK4paBRWxzCtGA0LXQvNC10L0K4paB0LTQtdC60LAKY291dApsYXllcgriloFnbG9iCmZvcmVhY2gK4paBRWR1Y2F0aW9uClBPCuKWgWltcHJvdgriloFjbGllbnRzCmdyb3VwcwriloFrb250CkRlbApyZXR0CuKWgXN1cAriloFtb2cKdGFuCuKWgWNvbXBsCmlydHkK4paBbm91dmVhdQpvc3oK4paBTmF2eQpiZXJlCm1hc2sKb3bDqQp6aWwKUEVSCuKWgXBvYmxhY2nDs24K4paBZGV0YWlsZWQK0LvQtdGCCuKWgWZhbWlsaWVzCmFiZXQK0LXQstC40YcKw6RuZGVyCuKWgcOlcgriloFwZW5kYW50CuKWgWJpbAriloFoaW50Cm9kZW4K4paBZXhwYW5zaW9uCuKWgXBvbnQKYXNhbnQK4paBS2luZAppamkK4paBQXV0aApsYWltZWQKcmVmbGVjdApdPQpieXRlcwpob3ZlcgriloHRhtC10YAKZ3JhZGxlCkFyY2gKYXBlc3QKw6FzYQpDYXJkCuKWgXRlbXBvcmFyeQriloFkw6lwYXJ0ZW1lbnQKY2xhc3NlcwrQttC40LLQsAriloHRhdGD0LTQvgriloFtb2xlClJZCkxQCuKWgXBlYwpyb2R1Y3Rpb24K4paBR3VhcmQK4paBUGFybGlhbWVudAriloFpbnN0YW50aQriloFub3RhbW1lbnQK4paBRG91ZwriloFNYXJzaAoufgriloFcIgriloF0aMOpCuKWgWxpYnJlCmRvZXMK4paBZMOpYnV0CuKWgVVuaXQK4paB0YHRgtGDCuKWgWxlYWd1ZQriloFxdWFsZQriloHRgdC+0YHRgtCw0LLQu9GPClNlY3VyaXR5CuKWgWFwcGFyZW50bHkK4paBdHJvb3BzCmljYW5vCuKWgU1CCmVuemUKbG9hZGluZwriloFkaXN0cmlidXRlZAp3cml0ZXIKcmVzb3VyY2VzCmjDtgp1dGlscwriloFwcmVwYXJlZApjaWVyCm9wb2wK4paBbMOkbmthcgpoZXMK0L3QstCwCuKWgW9wZW5zCmFnb2cKaW50ZXJmYWNlCuKWgUZ1bmQK4paBcGVudHJ1Cm7DrWNoCuKWgWNvbmZpZ3VyZWQK4paBV2Vic2l0ZQriloFsaXN0ZW5lcgppdmVsCm7EmQptaW5hCuKWgWludmVzdAriloHQvNGW0YEK4paBZGF2CuKWgXBhdGNoCnBpZWxlcgriloFFeHRlcm5hCnRmCuKWgWVyZWQK4paBQXNzZW1ibHkK4paBc291dAriloF2ZXJrCm1lcnMKdG9nZ2xlCuKWgXVwZGF0aW5nCuKWgUtlbnQKZWNhCkZBVUxUCuKWgXRpdHJlCuKWgUtlbm4K4paB0JzQuNGF0LAK0YHRgtC+0YAK4paBcG9kZQriloFTZWIK0YbQtdCyCkVZCuKWgXNpbHZlcgriloFjYXBhY2l0eQriloFjb21wbGV0aW9uCuKWgVBlZHJvCmZlbAp2YW5vCnpldWcK4paBaW50ZXJpb3IK4paBUmVzcG9uc2UKw6lkaWEK4paBV29ybGRDYXQK4paBY8SDCnF1ZWwKU29sCtGW0YHQu9GPCuKWgURvbWluCuKWgWN1bQpjZXAK4paBTXVzZQriloFNYXLDrWEK4paBZnVuY3Rpb25hbAriloFhZGFwdGVyCmNvbmZpZ3VyYXRpb24K4paBdGlwbwriloFCcnkKdnkKVUwK4paBdHJhdmVycwohKAriloFhYnNvbHV0ZWx5CtC70YLQsArRgtGC0Y8K4paBSVQK4paB0LLQvtC10L0KeWNsZQpiZXN0CuKWgWNvbnN0cnVjdGVkCuKWgdGE0LjQu9GMCmNpZG8KZXhpdApnYXJ0CuKWgXByb3ZpbmNpYQp2ZXoKY2lwbAriloFGYWNlYm9vawriloF5ZWxsb3cK4paBU3VtbWVyCuKWgXBvaW50aW5nCuKWgXBvc3NpYmlsaXR5CuKWgWxlZ2lzbAriloHQvNC+0LYKZGVybgrQutC+0L3QvgriloFtZWNoYW5pc20K4paBQmVybmFyZApleHByCtC70L7QstC4CuKWgWRpZ2l0cwriloFkZWxlZ2F0ZQpvZ3JhbQriloFEaWN0aW9uYXJ5CmlzeQriloFzcG8KLyQKY2x1ZGVkCuKWgU1WQwriloF0w6ltCuKWgXByaW50ZWQK4paBR290dAriloFPbQphbnNhcwriloFEdXJjaAriloFJZGVudApRVQpodG0K4paBU3VsCiddLgriloFkdXR5CuKWgUF1dGhvcgriloFuxJsKb3dlZ28KcHVzCmVtYmwKRXhlY3V0b3IKQkwK4paBTWVucwpkaXNwYXRjaAriloFNaWQKYXBwcwpUcmFuc2Zvcm0K4paBRGF0CuKWgWltcGwKb3V4CmhvbG0K4paBSW5zCuKWgUVtcGlyZQrRgNGD0L8K4paBQXBhY2hlClNJT04K4paBcGFzc2FnZQojIyMjIyMjIyMjIyMjIyMjCuKWgWV4cHJlc3NlZArQvdCw0LQK4paBb2wK4paBaGF2aWEK4paB0LHQvtC70LXQtQriloFlbmpveQpmb3JtYW5jZQriloFkaW1lbnNpb25zCuKWgdGH0LXRgApTZWUK4paBbW91dGgK4paBZ2F1CmllbmN5CuKWgUNhcm9saW5hCkRpc3QKcmFkaW8KbGltaXQKLz8K4paBQmFsbArQvdGW0YHRgtGMCk1lbWJlcgp3YXRlcgriloFtdXJkZXIK4paBc3RhbmRpbmcK4paBVklJCkNlbnRlcgpwcGEKdXJlYXUK4paBTGVpcAriloFvYmpldAriloFBY3Rpdml0eQplbWJlcnMKdnIK4paBY29uZHUKQ2VsbHMKaW51cwriloEnLAriloFhZnJhaWQK4paB0YXQsAriloFWaWMKdGVzdGluZwpUdWJlCuKWgXZhc3QKUE0KbmloClNTTgriloFDaGlsZQp5bHZhbgriloFCb3cK4paBcmVsaWdpb24Kb3BoZXIK4paBQ29sbAriloFkaWdpdGFsCnppb25pClNlY3Rpb24K4paB0YDQtdC30YPQu9GM0YLQsApGb290CmNvbnZlcnQK4paBcmVjZWl2aW5nCkNvbnRhY3QK4paBaGVybwpzYW0K4paBcG9zdGVyaW9yCm93aQpBbnQK4paBZmxhZ3MK4paBWmVhbGFuZAriloFib3VuZHMK4paBd2hlcmVhcwppbmZsClBsYXkK4paBZGVtbwriloFnaWJ0CuKWgWhvc3BpdGFsCuKWgXZvbHRhCtC70ZEK4paBZmFzaGlvbgriloFleGNlZWQKZWxlbml1bQpJdGVyCmtyaWUK4paBaW50ZWdyYXRpb24K4paBT3RoZXJ3aXNlCmFkdQpTaGUKb25kZQp1aW50CnJhZGl1cwriloFyYW0K4paBw6FsYnVtCuKWgdGC0YPRgAriloFkeQriloFPdHQK4paB0L/QtdGA0LgKcmV2CnJpb3IKw61kCmlyYXQK4paB0LLQutC70Y4K4paBaW1wb3J0YW50ZQriloFEdWtlCuKWgWNhdXNhCuKWgU1hdGhlbWF0CuKWgWRpcGxvbQriloFOaWNvbAriloFleGNsdXMK4paBZGVidWdnaW5nCuKWgUdoCm9yaWdpbmFsCmx5bgriloFQbGEKc3VpdGUKY2hhdAriloFlc3R1ZAp1ZWxsZQriloFwZXJ0CuKWgWltcG9ydGFuY2UK4paBYXBwcm9hY2hlcwriloFkbGEK4paB0L/RgNC+0YQKUHJlcwo8XApwcmVmaXgKU1NJT04K0YDQvtC00LgKY291bnRyeQppdHplcgriloHQutC+0YAK4paBc2luZ3VsYXIKZ292CtGA0LjQvQriloFGQQriloFtYXRyaWNlcwpvbGFyZQpuaWthCnBvd2VyCmxsYQriloFkZXNpcmUK4paBZmFtaWxpYQrQtNC+0YAK4paBZmFuCmdlbmVyYXRlZAriloFDb3MK4paBxbxlCuKWgURpZXNlCm1vdgriloFkZW5vdGUKIildCm91dmVybgphbWFuCuKWgWluc2VyCmlqawpvdHRhCmVyYWwK0LTQtdC70YwKKCktPgriloFwb2RlcgppZ2VzCuKWgU9ubGluZQriloF3ZWlyZAppYWMK4paBcXVlbHF1ZXMKw6hyZW50CuKWgXRlbAriloFMYXRpbgp2ZXJ0ZXIK0LvRj9GACtGA0L7QuAriloFwZGYK4paBa2V5d29yZApIYW5kbGUKQWZ0ZXIKcmVjZQriloFpZGVudGljYWwKc3R5bGVzaGVldAriloHRgdGC0LDQvdC+0LLQuAriloFrYQpjZW1lbnQK0YLQtdGCCuKWgWNoYXQK4paBTXVuCmHFgmEKQU5UCm9sw7NnCuKWgWZhbnQK4paBZm9yZXN0CuKWgdCy0LjQutC+CmN1c3MK4paBc2VocgpwYWcKb3RpYwriloHDoWxsCtC80LDRgtC4CuKWgSInCisiCkFuaW1hdGlvbgrRhdC+0LTQuNGCCmF6dQriloFwbGF5cwppemlvbmkK0LzQuNGH0LUK4paBYm9tYgriloFtZXJlbHkK4paBaG9sZGluZwriloF3ZW5uCuKWgW1lZGljCuKWgXNwZWFraW5nCm9uZ29kYgriloFDYW1wZQppbml0eQriloHRj9C90LLQsAooKWAuCmx1c3MK4paBSGlzdG9pcmUK4paBb3BlcmF0aW5nCkNoYW5uZWwK4paBYWNjdXJhY3kK4paBYm9zCuKWgWV2aWRlbnQK0YbQuNGOCmV2ZW50cwp0ZXh0cm0Kb3JlaWduCuKWgWlpCmhyZW4KbG93ZXIK4paB0YLQvtC8CuKWgUFib3V0CuKWgWFqCmVyaQrRgdGC0YPQv9C4CuKWgWRpZ2l0CuKWgVNwYWluCuKWgURhdGVuCuKWgWZvcm1lCuKWgdGI0YLQsAriloFCYWNoCm5vbnVtYmVyCuKWgXJlY29tbWVuZGVkCuKWgXJlYWRzCmhpc3RvaXJlCuKWgXNhbmcK4paBPz8K4paB0YHRgtCw0LsKc2NvcmUKZmFzCuKWgWN1YgriloFncmV3CuKWgWNlbnRybwriloFiZWthbm50CkV2ZW50cwpCRVIKaGV3CtGB0YHQsAriloFtYWpvcml0eQrDrnRyZQplbmNpCuKWgVF1ZXJ5CuKWgWt0w7NyZQppxIcK4paBY29tcGxleGl0eQriloFGcmFuw6dvaXMKY29uc3RyYWludArRg9GA0L3QsArilZDilZAK4paBaXRlcmF0ZQpsZXR0CnBlcm9yCuKWgU5lZGVybGFuZApzaGFyZQriloFpbmNsdQrDpG5nZXIK4paBTmljCtGH0L4KRnVsbAriloFyYXBwb3J0CmVjbGlwc2UK4paBaW5kdXN0cnkKaGVhZGVycwriloHQoNC4CmNoc2VsCuKWgXBvbGljCnNjaGllZAolLApPRAriloFKYWsKKHtcCmFsaWduZWQK4paBZnJlcXVlbnRseQriloFzdW9pCuKWgWVzc2VudGlhbGx5CuKWgVJpYwriloFyZXBvcnRzCuKWgWRlY2ltYWwKcmFyCuKWgUZvbwriloFLYQriloFEQwriloFzaW1wbGVyClBhbmUKP30KU29ydAriloFwb3NpdApjZG4Ka3R1cgriloFhd2sK0LfQtdGAClBGCnV1cgriloFSb3NzCuKWgW1hbnQKTmEKQ29ucwopKSkpCuKWgXRlY2huaXF1ZXMKaW1wbAriloFkcm9wcGVkCuKWgUxpc3RhCuKWgUJhc2ljYWxseQplbnRhbAriloFjZWx1aQriloFzdHJhdGVneQriloFXYWxlcwpuYW4K4paBZ21pbgriloFncsO2w58K4paBZWVyc3RlClRpbQpudGVuCnJlc3AK4paBc3RhYmxlCm5vdgpyb2IK0L3QvtGYCuKWgW1hcnJpYWdlCmdldFN0cmluZwpBdXRob3IK4paBR3JhZgriloFkaWFncmFtCmdpYQpOZXR3b3JrCuKWgWNvbXBvc2VkCuKWgW1pc3NlZAriloFNZWcK4paB0L/RgNCw0LLQvgriloFob21vbnltZXMK4paBQm9va3MK4paBZW5jb3UKcG9ydGUK4paBcm90YXRpb24K4paBZmlyCtGC0LXQu9GM0L3QvgriloFndW4K4paBQWZmCtC90L7QugriloFGdcOfYmFsbAriloFTdG9yeQriloFDaGFwCuKWgSkuCuKWgVNlaXQK0LzQvtC9CuKWgXTDqWzDqQriloFjb3BpZWQK4paBY29uc2lzdGVudAriloFkcmluawriloFDaGFtCuKWgW1hdHRlcnMK4paBcmVuZGVyZWQK4paBaHlwb3RoCsWTdXYK4paBbWVlcgriloFwYXJzaW5nCuKWgVBSTwpzZXJpZXMK4paBesOhCnN0cmHDn2UK4paBQm9vdAriloFyZXBvCndvcgriloFTdHJlYW0K4paBQU4K4paB0L/RltCyCuKWgVNNCuKWgUFybgriloHFvQriloFbXTsKUmVzb3VyY2VzCuKWgWVsYWJvcgriloFFdGgK4paBbGlzdGUK4paBcmVsYXRpdmVseQpjaGFudAo9IiIK4paBbGlmdApDTgpTZXJ2aWNlcwpNRU5UCuKWgdC40LPRgNCwCtCx0YDQtQriloFKb3JkCuKWgXRlYwrRiNC60LAK4paBU3VwCuKWgWluZmx1ZW4Kb25kcwpoYW5kbGVyCuKWgWJhbmRhCuKWgXZlcnRpY2VzCuKWgXphcAriloFjb3JkCmFsdGVyCnplbmlhCsOidGVhdQriloFrbm93aW5nCuKWgUFyZ2VudGluYQpBcmVhCtCw0L3QtQpmYwo9Ii8K4paBTWlrCmF0xIMKaWV1eAriloFkZXV0c2NoZW4K4paBdHJhZGl0aW9uYWwKZGVjb2RlCnZleAriloFzaXplb2YK4paBRnVuCuKWgXBhcnNlcgriloFGbG9yaWRhCuKWgWJ1aWxkaW5ncwriloFNYW51ZWwKcmlsZQriloFsb2dnZWQK4paBc3Ryb25nbHkK4paBcmV2b2wK0L3QtdC1CnhpY28K4paBRmFpcgpjYXJ0CuKWgVdvcnQK4paBSmVzdXMKZW1lcwpzY2hyaWZ0CklucHV0U3RyZWFtCndhZAriloFncmFuZGVzCuKWgW7Dum1lcm8K4paBT3R0bwppZW50ZXMK4paBZmFtb3VzCm9sb2duZQpKZQrQvdC40YgK4paBR3VlcnJhCmJhcmEK4paBY2FkCmVsdmUKYnJhY2UK4paBSnIKc3RhYmxlCkVDVApsZW1tYQptZWRpYXRlCuKWgXZpbgriloFtb251bWVudAriloFjdgriloF3aW50ZXIK4paBdHJhbnNmb3JtYXRpb24K4paBTmljawpzdHJvbm9tCuKWgWZyYWcK4paBaW50ZWwKcmFjdGlvbgriloFjb25zaWRlcmluZwriloFGbGUK4paB0LvQvgriloFBcHLDqHMK4paBQU0K4paBSHVtCuKWgW11bmRvCk5FUgriloFCZWxvdwriloHQs9C+0YDQvtC00LAKYXJ0ZXJzCi0tIgriloHQn9C1CsOudAriloF0eHQKYW5nZXJzCuKWgXRoeQpDTEEKaWJsZXMK4paBcmVxdWVzdGVkCuKWgUFsZXhhbmQK4paBZmFjdG9ycwriloFwcm9kdWNlcwpuaW5nZW4K4paB0YHQvtGB0YLQvtGPCuKWgW9wdGltaXphdGlvbgpjaG9kCj5gCuKWgVdpa2lwCm5vc3RpCuKWgWNvbXBldGl0aW9uCuKWgUhhbm4K4paBem9uYQpkYwpkZXNpZ24K4paBWnUK4paBZXNwZWMKZXF1YWxpdHkK4paBQWJiCuKWgWRldmVsb3BlcgriloEiXgriloFTaG9ydAriloFwbGFucwriloF2aXQKaXphYmxlCmJ1cmdoCmFnZW0K4paBUHJpbnQKw612CuKWgXN1aXRhYmxlCnBpY2tlcgpQcm9maWxlCmFuZHkK4paBcXVvdAriloFEdXJhbnRlCuKWgUZyYW5jaWEK4paBdGFydAriloFWZW5legriloFkaXNwYXRjaAriloFvYnNlcnZhdGlvbnMK4paBxbwKSW52YWxpZAriloFvY2N1cnIK0YLQutC4Ck1lbWVudG8K4paBU3lkCuKWgXRpZW1wbwriloFzdGFmZgriloFzZWN0aW9ucwriloFzc2gK4paBTkdDCsOrbAriloFlcnJlCuKWgWRpdmlkZWQK4paBV2l0aG91dAriloFkdXJhbnQK4paBamFhcgriloHiiJIK4paBc29sZGllcnMK0YPQvdC6CmxhcHNlCuKWgVZhbGxleQriloEoOgpyZXJhCuKWgWTDqXZlbAriloFww6lyaQriloFjYWxjdWxhdGlvbgriloFrZWluZQplcnRhaW4K4paB0YLQtdC70LUK0YDRg9C0CuKWgWN1bAriloFjbG90aAo7fQriloFwcnplZApNb250aApQaWNrZXIK4paBU1YKYXJpYW4K4paBUmV2aWV3CuKWgWhhbmcK4paB0L7QutGCCuKWgUZyb250Cm90bGluCuKWgXRyYW5zbGF0aW9uCuKWgW1vZG8K4paBc3RhdGlzdGljcwriloFOdWUK4paB0J3QuNC60L7Qu9CwCk5VTQriloFzaGlwcwriloFSZXBvcnQKe1sKRWZmZWN0CmllcmkK4paBcGFydGllcwpwbGEKcncK4paBV29ya3MK4paBaXJvbgriloFhdHRyYWN0CuKWgWNvcnQKbsOhCuKWgVN0ZXZlCuKWgWJlbmUK0YLQvtC9CsOtY3VsYQpUd28K4paB0LPQu9Cw0LIK4paBVmlkZW8K4paBcG93ZXJmdWwKYXVjaAptYW5kZQrDpGNoc3QKTGF0CuKWgXpuYQriloFmaWd1cmVzCuKWgWFsaWFzCm5leAriloFjYXRlZ29yaWVzCmNhbGxlZAriloFTaW1pbGFyCuKWgWdpcmxzCnBlegriloFqb2ludArRgNC+0LPQvgppa2VuCtGH0LjQvdCwCmFuY2lhCuKWgXRpamQK4paBUm9zZQriloFhbGdvcml0aG1zCuKWgXByaW50aW5nCm5lYQriloFleGVjdXRpbmcK4paBbGFtYmRhCuKWgXJlZ2lvbmFsCuKWgUNvcGEKRm9vCnBoeXMKem0K4paBTGF1cgriloFjYW5kaWRhdGUK4paBSmEKenltCkV4YW1wbGUK4paBc3BpZWwK4paB0LTQtdC5Cm5laG1lbgprZWl0ZW4K4paB0YHQtdC90YIKaW50ZW50Ci4oCuKWgdC/0LXRgNCy0YsKcHJvbQriloFuYXQK4paBaW1hZ2luZQpjYWxsYmFjawpjb21wb25lbnRzCndpdGhvdXQK4paBYXF1ZXN0ClN1cHBvcnQK4paBcmVzcG9uc2libGUK4paBamVnbwpsagp3aWxsCmxlYW4KZWxhbmQKb2xvZ8OtYQptYwpQcm94eQriloFvY3VwCuKWgdC90LDRhdC+0LTQuAriloFydWIK0L3RltCyCuKWgUZhbGwKYW1vcwriloFFcAplbnRyZQpmYWlsCldvcmxkCuKWgUVkaXRvcgriloFleHBvcwriloFmaW5kcwriloFDdWx0dXJlCkxFQVNFCuKWgW1vdmllCjw9Cm9tZXRyaWMKZWxpbmcKbnVtZXJhYmxlCm91cmQK4paBU2VhCuKWgWJpbGQK4paB0L7RgdGC0LAKYmxvCuKWgWxvc2UKYXRldXJzCm91cmVkCuKWgUJhdHQKKCk7DQriloFwb3oKcG9zdHMKcGVuZApjZXJ0YWluCtC90LjQutC+0LwKSnVzdAp3ZWJraXQKZGVtw6FzCn5+fn4K4paBaW5kaWNhdGVzCuKWgXBhcmsKcmlxdWUKdm9kCuKWgUNoYW1wCmZ0d2FyZQpPUFQKZGphbmdvCnJlbGVhc2UK4paBw4gKU1IK4paBcG9saXRpY2lhbgriloFyb2kKYXR1cmVuCuKWgURldXRzY2hlCnRhZ29uCuKWgU1vdgpvYmllcm5vCuKWgWRhw58KdXRoZXIKaW5kaQriloFXaWtpcGVkaWEK4paBYW5vcwriloFvYnNlcnZlCmVsbHkK4paBcmFpbHdheQphdG9uCuKWgWVudW0KaHVzCuKWgWluaGFiClBzaQpvaXJlCuKWgdCl0L4K4paBU3BhY2UK4paB0JDRgNGF0LgK4paBYW50ZXJpb3IK4paBxYEKaXNvbnMKSWwK4paBYW3DqXJpYwpsYXBzCuKWgUJCQwpRVUVTVApDb25zdHJhCm1vbnQKw6RmdAriloHDpHZlbgp1YmVybgo8IS0tCuKWgWNvZGluZwp0aGVvcnkKYXRoZWQK4paBQXJiZQriloHRiNC4CmZvckVhY2gKb21vcnBoaXNtCmRldGFpbHMKYWNoc2VuCmludGVncgpWb3IKVW5rbm93bgphY2VhZQppbnVlCmVzb21lCuKWgUZpcgpjaGFpbgriloFleHRyZW1lbHkKbXVsdGljb2wK4paBU3dpZnQK4paBYWRkcmVzc2VzCmhzcGFjZQriloFSb2dlcgriloFkZXNzZW4K4paBY29uc2VxdQp1YWxtZW50ZQriloFQcmVtaWVyCuKWgVJlY29yZAriloFCcm9uCmtpcgpzZXgKaW50ZXJuCuKWgWJlbmVmaXQKdW1lbgriloFiZWNvbWluZwriloFsaWcK4paBcG9wdWxhCm9zYwriloFjaXYK4paBZ3JlYXRlc3QK4paBcHJvY2VzCl0qCuKWgdC80LXRgdGC0L4K4paBJyQKaGVsbAooIlwK4paBbmluZQriloFGYWMKdWxwdApqb3VycwriloFDb3B5CuKWgWFjdGl2aXRpZXMK4paBRGVtb2NyCkVzClN1Y2Nlc3MK4paBRXN0YQppdHVsCmlzdGkK4paBQmVkCmphcwriloHRgtC10LwK4paBSHVuZwpHYW1lCuKWgWhlYXYKb25uw6llcwriloFicmFuY2hlcwpib3JnCuKWgXZsCuKWgXNsb3dseQpGYQpHb29nbGUKZW1pCuKWgWNpcmN1bXN0YW5jZXMK4paBJyUK4paBVW5kCuKWgVZpY3RvcmlhCuKWgVR5cApydXB0ZWQK4paBcmVsYXRpdgriloFzbG8K4paBcGFkcmUK4paBZGFpbHkK4paBb3J0aArRh9C90LjQuQriloFmcmFuesO2cwriloF0ZWlsCuKWgVNlY3VyaXR5Cm9yZG9uCuKWgXN3ZWV0ClNJWkUK4paBQ2VsCsOodHJlcwpvbW1lcwriloHRgdGWCuKWgWVmZm9ydHMKxIV6CuKWgW9obmUK4paBU291dGhlcm4K4paBYXBwcm94aW1hdGVseQrRhtC10L0KKCcjCuKWgXNhdmluZwpuYnNwCuKWgXRyYW5zbGF0ZQriloHDjm4KbWVtYmVyCuKWgWxhd3MK4paB0LbQtdC9CuKWgdGB0LjRgdGC0LUKdGMKPlwKZWx0ZQriloFlaGVtCuKWgWNvbnRyYWQK4paB0YDRg9GBCtGM0Y8K4paBTWlkZGxlCnF1aXAK4paBY2hlegpGaWVsZHMK4paBcGVybWl0CmlrZWwK4paBd2lyCuKWgXRyaWFsCuKWgXZlcnNjaGllZAriloHRhNC10LIK4paBbWFsZQriloHRj9C30YsK4paBbnllbApha3RlcgriloFkZW5vbWluCmNlcHRvcgriloFXYXQK4paBZmlubwriloFYVklJSQpyeXB0aW9uCmRlc2MKYXBhCtC70LXQvdCwCuKWgWtvbAriloHQhAriloFkZXBlbmRlbnQK4paBQ3JhCuKWgXN0b3JtCuKWgdCT0LXRgAriloFwaXBlCuKWgWF0dGVuZGVkCuKWgXZpdGEKdXppb25lCmN6YXMKb25kYQriloFib2xkCkNvbHVtbnMKaWNpw7MK4paBY3rEmQriloHQuNC30LLQtdGB0YIK4paBQ2xvdWQK4paBd2FybQriloHRgdGLCuKWgdGB0YLQtQriloFwcm9kdWNlcgriloFMdWR3aWcK4paBTm9ydGhlcm4KxYLEhQpOU1N0cmluZwriloFIYWQK4paB0JjQstCw0L0K4paBRWcK4paBSW1wCtGI0ZYK4paBQXVjaArRgtC+0LoK4paBSGl0CuKWgXF1aWVuCuKWgWRlcGFydG1lbnQK4paBZXJoaWVsdAriloF1aQriloFTcHIK0YHQtdGACm91cnQK4paBU3RlcGhlbgp0ZWFtCuKWgXppcAriloFCYW5nCuKWgWdyb3d0aAriloFqYW0K4paBS2FpcwpibWF0cml4CuKWgUFzaWEK4paBcsOpZ2lvbgo9LwriloFQYWNpZmljCuKWgWF1dGhvcml0eQriloEjWwrRgtCw0LzQuAriloFldmVyeW9uZQriloFhdHRlbmQK4paBdGltZXN0YW1wCuKWgXRyaWVzCuKWgWZmCtGI0LXQuQriloFkZXZlbG9waW5nCm9sdAp1cHMK4paBbW9tZW50bwriloFTYWluClRlcm0K4paBY2VsbGUKR1IKTW91c2UK4paB0YfQtdC70L7QstC10LoK4paBQ29sbGVjdGlvbgrDonRyZQriloFXcml0ZQriloFQb20KWy0KQ2FtCuKWgWxvY2F0aW9ucwriloFKc29uCmVsbGVkCnNlbGVjdG9yCnJlcGVhdApjdG9ycwpvdHRlCtCy0LjQt9C4CsOkbmRlCuKWgWFjaGlldmVkCuKWgW1haW5seQpfX19fX19fXwohKQriloHRj9Cy0LvRj9C10YLRgdGPCuKWgWNpdGllcwpzaW5nbGUK0LPRgNC1CuKWgVBhawriloFhbGxvd2luZwpmZXJyZWQK4paB0LDQv9GA0LUK0YXQvtC00Y8K4paBYnJvd3NlcnMK4paBZXNjcml0CuKWgW1vdW50YWluCuKWgW5ldHdvcmtzCmtpbmQKbGl2ZXIK4paBY2xvc2luZwriloFza2lwCsO6dAriloFkdXJhdGlvbgrDqXRhaXQK4paBc2NyCkJCCsOzcmlhCuKWgUt1bHR1cgriloFvdXRwdXRzCm11bHRpY29sdW1uCuKWgWJlbG9uZ3MKZmVhdHVyZQp1Y2t5CuKWgWp1bGkK4paB0YDQsNC50L7QvdCwCtC30LLQvgpmYWN0b3J5CkZ1bmMK4paBdXR0ZXIK4paBVE9ETwriloFvYnQKYXRlZ29yaWVzCuKWgWNvbWJpbmUK4paBV2FsbAriloF1bmRlcmx5aW5nCmFyb25vCuKWgVByb3RlCmPDs3cKc3RhbgriloFHZXcK4paBb3B0aW1hbAriloFBcmNoaXZsaW5rCuKWgVNjcmlwdAriloFkZXN0cm95ZWQK0YXQtQriloFGaXJlZm94CuKWgXNvbGUKTGF5ZXIK0YLQutGDCuKWgXN0b3JlcwriloFkaXNwbGF5cwppc2hpbmcK4paB0L7RgdGCCuKWgWluc3RhbnQK4paBZWzFkQriloFoYWJpdGFudGVzCuKWgUVpbndvCuKWgWFsaQriloFFUlJPUgriloFhaGVhZAriloFnb2FscwriloFtw6FyCuKWgXPEhQriloFtYXJ0CtC80LjQvdC40YHRgtGA0LAKRnIK4paBVmlsbGEK4paBTWFyYwpyb3B5CmFncmFtCmhhcGUK0LzQtdC5CuKWgUFMCuKWgWNvbm5leGVzCuKWgUVudHJlClN0ZXAK0LvRltCyCuKWgURlYXRoCuKWgXJpc2UK4paBZm9zCuKWgWxldgpnYWJlCuKWgWJyb2tlCnByb2R1Y3RzCuKWgW1lZGkK4paBZGlzcG9uClBhY2thZ2UKSW1hZ2VWaWV3CuKWgU5hZwp1asSFCldvcmQK4paBa29sZQrDn2VyCilgLgriloFyb2wK4paBw60K0YLQtdC5ClByb2dyZXNzCmJlYW4K4paBc2VtcHJlClN0YXRlbWVudApVUERBVEUK4paBbW9uZGlhbGUK4paBd3JhcHBlcgriloFDaGFydAriloFvbkNsaWNrCtGH0LXQvdC90Y8KTE9HCnNvbWV0aGluZwriloFJTlNFUlQK0YnQtdC90LjRjwp1ZXQKd2VycApyb3VuZAppY2hlbgriloFYVkkK0LfQvdC4CuKWgWF2ZXZhCuKWgVN0b3JlCuKWgXhzCnJhY2h0CnNjYXIK4paBb3BlcmEK4paBZGVncmVlcwriloFjaXRpegrDpHNpZGVudAriloFjbGFzc2ljYWwK4paBSmVyc2V5CuKWgWVyc2NoCuKWgXRyZWF0bWVudAriloHQvdCw0YHQtdGZ0LUK0L3QvdGPCuKWgWJvb3N0CmFtb3VudAriloHRgdC+0LfQtNCwCsOpcmlldXIK4paBdGVsbGluZwpIYXMK4paBaW5pdGkK4paB0J/QuApldmFsCuKWgU1hdGNoCuKWgWNvcnJlClBvaW50ZXIK4paBcGFzc2VzCmNvbXBhbnkK4paB0LDQvQphY2hlcwriloFzaWdsbwrQvdC10LwK4paBZXhjaGFuZ2UKY2l0bwriloFCYWIKRG9jCnplxZsK4paB0L3QsNGA0L7QtAriloFjb25mbGljdAriloFub3ZlbWJlcgplYXUKw7Z2CuKWgUh1YgriloFwb2NvCmVuc2EKc2NobGllw58KbGFzc2UKZGF0YXMK4paB0YHRgtC4CnVuaXZlcnMKZWtzCuKWgUNobwriloFjw7QK4paBKC4KZXduxJkK4paBQ2hpZWYK4paBY2hlZgriloHRg9C/0YDQsNCyCnVsaQriloEnJycKbmFwc2hvdAriloFyZWxhYwrDqWdlCnd0CndlbmQKb3NpbmcK4paBaGFjZXIK4paB0YTRgNCw0L0KYXV0cmVzCuKWgWZpbHMKZXJlZAriloHQn9C+0YHQuNC70LDQvdC90Y8K4paBdGhlcm0K0LXRgNC20LAKc3VjaAriloFpaHJlbgriloFlbmNvbnRyCuKWgWxvdHMKbG9nbwriloFXaQovKArRiNGa0LUKREFUQQriloFQbGF5ZXIK4paBTGVpcHppZwriloFyZWxhdGl2ZXMK0YDQtdCyCuKWgW5ld3NwCj8sCuKWgVN0dXR0CuKWgWR1YWwK4paBY29tcGFuaWVzCuKWgXphbQpwdXRhdGlvbgriloFpbmVxdWFsaXR5CuKWgXRyZW0KaGlwcwphbmNoCuKWgcW7CtCx0YPRgNCzCuKWgWNvcGllcwpkYXNoCtCy0L7RgApzcGllbGVyCuKWgVJldm9sdXRpb24KZXN0eQriloFqdW50bwriloFJbmRlZWQKb2thbApjdHJpbmUK4paBRm9yZAriloFDUkVBVEUK4paBd2FsbHMK4paBYXV0ZQpTVQp3aHkKcGxlbWVudGF0aW9uCnJvdXQKTWF0cml4CuKWgXNhZArQsNC90LAK4paBUGljCi7igJwK4paBQUMK4paBRmVzdAriloFkZXNrdG9wCuKWgVBheQpvbWV0aW1lcwriloFUYWsK0YDQsNCxCuKWgVNldmVyCuKWgW5vcnRoZXJuCmFudGVyCuKWgU1vZGVybgp3YWwKew0Kb25saW5lCsO2awriloFicml0YW5uCiRfCuKWgWphcgpUTAp4eHh4Cm1lcmdlCuKWgU5hbWVuCuKWgUtFWQriloFyZWZlcnMK4paBaGluCuKWgVZvbGtzCnN0ZWxsZXIKdmlhdGlvbgpvbmlvCmlnaHRlcgpDb21wYXQK4paBQ0UK4paBcHLDswriloFlbmN1ZW50cmEKdGhlb3JlbQriloFwdWJsaQriloFEZXZlbG9wbWVudArQvdC0CuKWgXJvcwriloFzaHIKc2VhdQriloFnZW5lcmF0aW5nCuKWgWRpZmZpY3VsdHkK4paBRXhwcmVzcwpBbGlnbm1lbnQKZGV1dHNjaAriloHQktC70LDQtNC4CuKWgXN1Z2dlc3RzCuKWgUZhbWlseQpiYmkKXSkuCnN0YXcK4paBcHJlc2lkZW50ZQriloFzdGVzc28KaW54CnNldHVwCuKWgWNvbmZvcm0K4paBZnJvCj1cIgriloFkw6UKaWNpb25lcwriloFldm9sdXRpb24KcHJvdGUK4paBcHJpbnRzCuKWgVBvbnQK4paBY29uZnVzaW9uCuKWgdCZCuKWgWRlbGxvCuKWgW1hbmlmCkRlZmluaXRpb24Kw6FyYQptYWxzCuKWgXNhbGUK4paBZHJvcGRvd24KQ2hhaW4KQW1lcmljYW4K4paBbWsK4paBQmV6CuKWgUZ1ZQriloFORQrQs9GA0LDRhNC4CmRvY2tlcgriloFeewpBc3NlcnQK4paBaG9yaXpvbnRhbAooQCIK4paB0LTQstGDCnByb3h5ClVyaQpnZW5jeQriloEiWwriloFRdAriloFOYW1lcwriloFldmFsdWF0ZQohLwriloFlaW5nZXMK4paBc3ludGgK4paBWW91VHViZQriloF0dXJuaW5nCuKWgUVyaWMK4paB0LHQu9C4CuKWgWtsdWIKcGxvcmVyCuKWgXNwb3J0cwriloFzaWEK0L7RiAriloFkYWkK4paBZXVyb3BlCmljaWFucwppbmdzb21yw6UK4paBZHJlCuKWgXdvcmthcm91bmQK4paBc3VpdAphbWJpZ3UK4paBcXVhbnRpdHkK4paBc2VndW5kbwpTeW1ib2wK4paBbW9yYWwKQ2hhcnQK4paBZGFtaXQK4paBYXR0ZW1wdHMK4paBZG9ubgpqb3MK4paBZXJlCuKWgWhvbW1lCnNpbXAKcnlwdGVkCuKWgWFjdHMKaW5uZXJIVE1MCuKWgXRvdXJuYW1lbnQK4paBc2t5ClRpbWVyCuKWgW1pbGxpb25zCl4rCmFnZW50CicpKTsK4paBb3N0CuKWgWdsYQriloHQv9C+0LzQvgriloFmw7xuCtGB0YLQstC+0LwKZXduxJl0cnoK4paBTcOpeGljbwriloFsdWIK4paBw4lkCmlmaWsK0YfQtdGB0LrQuNC5CuKWgWltbWVyCmVuc2VuCmFubnkKaW5saW5lCuKWgWdvdmVyCmF1YwriloFyZXByZQriloFoaXN0b3JpYQpBZwriloFwbHQK4paBUHJpbmNpCmltZXRlcgrFkXMKxaFlCuKWgVVFCkVxdWFscwpEaXNwYXRjaApsZWdlbgrQu9Cw0LfQuArRh9C90L7QuQriloFzdGVsbArFhHN0CuKWgWNyaQriloFJbmRlcArDqGRlCn1cKQriloF3eXN0CuKWgWZpZ3VyZWQKQVRDSArDqWJlbgpsYWNodAriloFzdWNjZWVkZWQKZ3J5CuKWgXByZXQK4paBU2FmCuKWgSIpOwplaAriloFvZmZpY2llbArQutGA0LDRl9C9CndpbmQK4paBc2NhdHRlcgriloFGb3gKaWNpb3VzCk1hbnkKdXBlcgriloFDb252ZXJ0CnN0ZXJkCuKWgVN0ZWluCuKWgdCe0YIKfV57KApiZXR3ZWVuCmhpcmUK4paBb25DcmVhdGUKOzwvCmJhYmx5ClNZCm1vdAriloFEaXJlCml0ZWN0dXJlCtGC0L7QuQriloFjb29yZGluYXRlCigiIwriloFzw7xkCk9CCuKWgW1vcnRlCuKWgXdlYXRoZXIK4paBaGVseQriloFwcml2aWxlClJFTEVBU0UKYXRlbAriloFyZWNvZ25pemVkCuKWgVRob3VnaArRgdGB0LjQuQptZW1vcnkK4paBY29tcGlsYXRpb24KYml0cwriloF3ZWQKfX1fewriloFHVUkK0L/QvdGPCuKWgXNvdXRoZXJuCuKWgWhheQpvdmnEhwpsYXVmCuKWgUVMCuKWgUZ1bGwK4paBSGFtYnVyZwriloFNaXR0ZWwKRFUKYXBwcm94CkhTCuKWgdC/0YDQvtGG0LUK4paBbWFnYXppbmUK4paBTWlnCuKWgWNsaWNraW5nCmVudHIK4paBYXV0cmUK4paBdMOpCuKWgWjDoQrRgdGC0YsK4paBTUEKYXBweQpzdHbDrQriloFzZWxvbgriloFnZWsK4paBU2wKZnJhc3RyCkxpYgriloHQlNGDCuKWgWZhY2luZwriloHRgdGC0LDRgAriloFEdXRjaAphdGFyCuKWgWtlZXBzCuKWgVBhdHJpY2sKaWxpbwriloF2aWcK0YLQstCwCuKWgUZlZGVyYWwK4paBcGFyYWdyYXBoCuKWgWludGVyYWN0aW9uCuKWgW9jY2FzCuKWgUlyYW4K4paBbWFjaGluZXMKKCgpCnVyaWVzCuKWgdGA0L7QtNC4CuKWgdCw0LzQtdGA0LjQutCw0L0KdXBwCuKWgWljZQriloFTYXkK4paBc2FpbAriloFCZWdpbgpmaWNvCm9nYQriloFkZXNhcgriloFkdgriloHRgNCw0LTQuApvaGVuCmVyZWkKw6FuYWsK4paBZGFhcgppZmllcnMK4paBdGhlZQriloFieWxhCtCy0LDQu9CwCmFuZHJvCuKWgdC80L7Qu9C+CuKWgXRvdGFsbHkKaW9tCuKWgWFlcgpuc3lsdmFuCuKWgWNvcnBzCuKWgXRyZWF0ZWQK4paBY29tdW5lCk1pY2gKdm9pY2UKcGdmCuKWgWFueAriloFQaGlsaXAK4paBZWsK4paBTWVuc2NoZW4K4paBZGVyZQriloFwZXJtZXQKTWFpbAriloFWw6kKZW50ZWQK4paBYnVuY2gK4paBUGlldAphdHRhY2gK4paBcG9ydGUK0LTQsNGCCuKWgUJyaXRhaW4KRW5jb2RpbmcK4paBYDwKU3BhY2UK4paBcmFwCuKWgXBvcHVsCmZsb29yCnNwZWNpZmljCmNsZWFuCuKWgWNvbnF1CmZiCuKWgWludHJvZHVjZQriloFFbnRpdHkK4paBZXJmb2xnCmF0b2wKaWVudG9zCtC60LjQv9C10LTQuAriloFVdAriloHQsdGA0LgKZWR1bGVyCuKWgWNvbmNlbnRyCuKWgWNoZXIK4paBdXBncmFkZQriloFwaWN0dXJlcwriloFGYW1pbGllCk11cwpMb29rCuKWgWVyYW4K4paBZ3JhbQriloFXbwpucG0K4paBU2FsdgriloFjZAriloHQktGLCndhaGwKdHJhaW4KY2hlbQriloFQaWwK4paBQ29ubmVjdArEjWUK4paBaGFzdAriloFNdWx0aQphdHRhCuKWgVNvdW5kCnNvbHV0ZQriloFxdW90ZQriloFvYnN0CmNjaW9uZXMKaWJseQriloFicmFuZAriloFjb252ZXJzYXRpb24K4paBdG91dGVzCuKWgVJ1YgppZW5pYQppcml0CuKWgdCQ0L3QtAplZHVsZWQK4paBVG90YWwKRGlnCmVyZW0K4paBc2tpCkRlc3QKWVkK0LXQtNC4CmFseQriloFiYWNrZW5kCnVsdXMK4paBZmVhdHVyZWQK4paBcGVyc29ubgriloFzY2hvbgp0cmFjZQriloFJREUKw6FqCuKWgWFuaW1hbHMK4paBc25vdwp1dmUKdWVydG8K4paBZHJldwriloFZZWFoCuKWgVN2ClwsXAriloFTZXJpZQriloFzZWNvbmRvCuKWgUxlYmVucwriloFhY2NvcmQK4paBQ2V0CmVyYWRlCuKWgWRlc3BpdGUK4paBQ2FybG8K4paBemV3bsSZdHJ6CuKWgWxpc3RhCm5pY28K4paBQ29ycG9yYXRpb24KdnNwYWNlCuKWgdCy0L7QudC90YsK4paBc3RhbmRzCuKWgXdvcnNlCuKWgXNpbXVsdAriloFwcmFjdGljYWwKQ09MCmNoYW5nZWQK4paB0JjRgdGC0L7RgNC40Y8K0LHRgNC4CmluZG8K4paBTGV3aXMK4paBcGF0dGVybnMKaWZpY2EK4paBc21hcnQK4paBY29uY2VybmVkCsibaWkK4paBSGVsbG8KcmVsbAriloFMZXgK4paB0LLRgtC+CuKWgWNvbmRpdGlvbmFsCm90dGVkCuKWgXNob290CuKWgVdlZAriloHQvNCw0YDRgtCwCmF1ZAriloFhbnRlCmllbnRyYXMK4paBcGFwZXJzCuKWgXBvcnR1ZwriloFNYW5hZ2VtZW50CuKWgWV4ZXJjaXNlCuKWgUJlZ3JpZmYKY29tbWl0CuKWgXJlbmRlcmluZwriloFjemFzCkRyb3AKZXJnCuKWgW11bAriloFUYW4KaWVybwriloFsb2NhbGUK4paBaW5hdWcKZHVtcArRhtC40LkK4paBc3ltYm9scwppbnRhCuKWgWF3YXJkZWQK4paBc3VzdAriloFTZW5kCtGX0LIKUmVzdAp6dGVuCtC70LjQvApyaXZhbApQT1JUCsO2bGtlcgppbWF0ZWx5CmlndGUK0YfQvdGL0YUK4paBdGVycmEKw7ZnbGljaAriloFIb20K4paBaGV4CmRvbmUKYW1wcwriloFjZXQKUFJFCsO2c3QK4paBZmVtbWUKU2VsZWN0aW9uCuKWgXphdwpzcHIK4paBaG9yc2VzCuKWgXNuYXAKVGV4dEJveAriloFFY2xpcHNlCnVsbGUKb3d5bQriloFjb21lcgpuZWNlc3MKY29vawplbmdlcgotLT4K4paBcMWZw60KcGFuZGFzCuKWgVBsdXMKeWxsCuKWgXRlcnJvcgriloFjcmltCuKWgXphawppc3N1ZQpwYW5lbApzdmcK4paBcmViCkN1c3RvbWVyCnN3aXRjaArQvtCx0YDQsAriloFDaGFtcGlvbnNoaXBzCmNsbwphdHRlCuKWgWFueW1vcmUK4paBZXhjZWxsZW50CuKWgW9wcG9ydHVuaXR5CuKWgUJhaG4K0YfQuNC9CmV0aW5nCuKWgWluY2lkZW50CnRvbQpQZXJzCmJiZW4K0YHRgtCy0LXQvdC90L7QuQrQuNGFCnJvdXRlcgriloFuZXdseQriloFzaWxlbmNlCuKWgUdOVQriloFSYWlscwriloFBbWIK4paBUXVhbAriloFTY2hhdXMK4paBU29obgriloFBTEwK4paBcm95YWwK4paBwqMKd2nEmQriloFlbnRmZXIK4paBUmVtb3ZlCuKWgWhhcmRseQpVc2luZwrQu9C+0LMK4paBSWNoCuKWgWRlcm5pCuKWgUNvbm5lY3Rpb24KZmlzaAriloFJbmZvcm0K4paBRW5lcgpyb2l0CkJiYgpWaWV3TW9kZWwKVmlkZW8KaWxleQriloHQvNC90L7Qs9C+CuKWgUdlbQriloFjb21wcmVoCmVudW1lcmF0ZQp1bGFzCuKWgUJhaAriloFZZXQKQlIK0YXRgNCwCuKWgWNvdW50eQriloFIaXN0CuKWgdCT0YMK4paB0IgK4paBbWFyaQriloFDbGFyCkJpdG1hcAriloFDegriloFtw6VuCuKWgW1lcmUK4paBbXVzaXF1ZQphbHNvCmRhdGVzCuKWgURWRAriloFnb2wKZm9ueQriloFDYXN0bGUK4paB0YTQsNC80LgK4paBYXJyYW5nCuKWgUJ1c2luZXNzCuKWgUthegriloFvc2MK4paBc2Vjb2xvCuKWgWFmZmVjdGVkCuKWgUhlYWx0aApyZWIKZWRpdG9yCuKWgW93bmVkCnRsCuKWgXbDrQrRh9C90LjRhQrQutCy0LgK4paBZGV2aWVudApNdXRhYmxlCuKWgXRlZ2VuClJlZ2lzdGVyCtGU0Y4K4paBY2FyYWN0ZXIK0LvQu9C4CuKWgW5vdXZlbGxlCm9rbwppY2h0ZXQK4paBZXZvbAriloFIYWIK4paBbWlsaXRhcgriloFwdXRzCmVuZGlmCuKWgURhdmlzCuKWgVNjb3RsYW5kCnJlZ3VsYXIK4paBQ29udGV4dAppc3BpZWwK4paBR2FsbGVyeQoiLA0K4paBYXJjCuKWgUlORk8K4paBY29kCtC00ZbQsgriloF2YXJjaGFyCuKWgXRvdWpvdXJzCmF0aWFsCuKWgWhhbm5vCuKWgdC/0YDQvtGE0LXRgQriloFsYXVuY2hlZAriloHQvdCw0YHQtdC70LXQvdC90Y8K4paBdG9uCmF1c2VkCuKWgdGW0LcK4paBdMO2CuKWgVB1cgriloFvbHltcApBUk4Kw7NtCuKWgWF1Z3VzdAriloFmdXJuCuKWgUNvbG9tYgriloFTdGFhdHMKaG9yYQriloHQvNC+0YAKY2FudmFzCuKWgWdyYXZlCuKWgWNvbXBvc2l0aW9uCmFjamEK4paB0LrQvtGC0L7RgNGL0LUK4paB0YfQvgpHZW5lcmFsCtCw0L3RlgriloFKb2hhbm5lcwrQutCw0YAK4paB0YfQsNGB0YIK4paB0JLQsNGB0LgKc3NoCuKWgXJlcGxhY2luZwriloE8PgrRhtGW0LIKbGF1cwplbnkKw6RobAriloFtYXJnCmNpZW5jZQriloFpbnN0cnVjdGlvbgriloHQutC+0ZjQuApFZGl0b3IK4paBZnVuZGFtZW50YWwKbXVuZAriloFleGNlcHRpb25zCuKWgXBsYXRlCuKWgUxpcwriloFkZXJlbgpwcmVwCuKWgWphbnVhcmkKU2NvcGUKeW5hc3QKcnYKb3JzegriloFUb255CuKWgdC00ZYK4paB0L7QtNC90LAK4paBc2FiCm90aQpqZWwK4paBZ2VuZXJhdG9yCuKWgScuCuKWgXNoYXJwCuKWgdGC0L7Qu9GM0LrQvgriloFhY2NvdW50cwriloHFvmUK4paBZm9yYW0K4paBZ291dmVybgpUSU1FCuKWgVNvdmlldAriloFHw6kK4paBZXhwZWQK4paBb3JkaW5hcnkK4paBQ29uc2VydgriloFjb21wbGEKdGVpCuKWgWNhcHRhaW4K4paBU2FtdWVsCuKWgURhcmsK4paB0LLRltC9CuKWgWRlbGlnaHQKcmVjaHQKZGlhCmVzc2VzCnVscArRiNC60LgKYmV6CuKWgWRldGVjdGlvbgriloFjb29raWUKYW50cnkKTXVsdGkKb2JhCuKWgWpveQriloFzYWZldHkKfF4KcG9kCmFkw6ltCuKWgUNocm9uCuKWgURqYW5nbwriloFlaGVtYWwKa2gKw6hsZQriloFwb2MKQm90dG9tCmxhdW5jaApuZW0K4paBR1JPVVAKbsOtaG8K4paBR2liCnNkawpCRQriloFHZW5lCuKWgVN0YWZmCuKWgXN1YnNlcXVlbnQKaWNpb24K4paBdmljdG9yeQriloFjYW5vbgppemFyCml6aWEK4paBbWF0ZQriloFsYXllcnMKc3VkbwpzY2h1bGUKcGVyaW1lbnQKw7xsZXQKQVJDSEFSCuKWgdGC0LXRgNGA0LjRgtC+CuKWgW1lYXN1cmVzCuKWgXpvdQpvcHNpcwrQvdCw0LzQuAp0Ym9keQriloFlc2UKc3RlcmRhbQriloFwaG90bwp5bmNocm9ub3VzCnNldG1pbnVzCuKWgWxvYWRzCuKWgXBsZWFzdXJlCuKWgW1laWxsZQp9XCwKcXVhbAriloFmYXZvdXIK4paBcm9kCkRlcgrRgNCw0LHQvgriloFwcmVzc2VkCnLEmQppZXZpbmcKbWF0ZXJpYWwKdmlydAriloFjYXBhYmxlCtGB0LvQvgp1c2hlZAriloHQv9C+0LHQtQp1c2V0dHMKdW5zaWduZWQKa8OzdwriloFvdgplZ2ViZW4K4paBYXBwbHlpbmcK4paBZ2FsYXgK4paBT3JhY2xlCuKWgVN0dXR0Z2FydApJbmZsCmFjaHVzZXR0cwriloFkZWVsCmxpcmUK4paBc3RhdHVuaXQK4paBUG9saXRpa2VyCuKWgWJlYXV0eQopPgriloFDb2x1bWJpYQriloF6ZXduxJl0cnpuZQriloHQv9GA0L7Qs9GA0LAK4paBZHgKY2tub3cK4paBZHViCnVuw6RjaHN0CmZpbmRWaWV3QnlJZAriloFNYW5kCsOhbGwKbmFpcmUK4paBZGVzdGluCmlzdGluZwphZ2dpCmNoYXJ0CuKWgWp1c3RpY2UKU2ltcGxlCuKWgXVuZm9ydHVuYXRlbHkK0ZbRgAriloFxdWVzdGEK4paBR292ZXJub3IK0Y/QsgriloFtw7pzaWNhCuKWgWVxdWlwbwriloFEZXN0CmVsZWN0ClN0YWNrVHJhY2UK0LfQvtC8CnByb2MKZW50aW4KYWRvcmEK4paB0JvRjgriloFyZWdpc3RlcmVkCkhMCmZhY2Vib29rCuKWgXN0b3JpbmcK4paBQ3VycmVudGx5CuKWgXF1YWRyClN0YW5kYXJkCnRyaW0KZWFycwpzZW5kZXIK4paBVmFzCuKWgWVkaWZpYwriloFCw7xyCuKWgUNvdW50cnkKdGhhCjsiCm5vcgriloFEb2N0b3IKcnVtZW50CkdlbgriloFCdWVuCnJhZGUK4paBa3VuCm5hdmlnYXRpb24KUGF5CuKWgWNhcHR1cmVkCuKWgXN0cnVjawp2ZW5pcgrDqW1lbnQK4paBVHJlZQriloF4eAriloFuYXJyCtC70YzQvdC+0LPQvgriloFpbnN0YWxsaW5nCuKWgWFzc29jaWF0aW9uCuKWgWluc2VydGVkCmVybmVyCnZhbGlkYXRlCuKWgWx1dAriloFnbG8K4paBdGVjaG5vbG9neQriloFQbGFjZQokPwriloF6dgrRgdC70ZYKRVAK4paBYXRtb3MKdWdvCsOpcnQK4paBV2VyawriloElfQp0ZWxlClNwYW4K4paBUmFqCuKWgVBlcnNvbmVuCuKWgUNhbnQK4paBY29tYmF0CuKWgW9ic2VydmF0aW9uCnBhcmFtZXRlcgriloFhZ3JlZWQKcHVyCuKWgXNoYWRvdwriloFnxYIKS2V5cwpDcmVkCm91cmkK4paBcGFsZQppY2vDqQriloFXZWVrCuKWgVByaW1lCj4uCkluaXRpYWwK4paB0L7QtNC40L0K4paBJycsCuKWgdGD0YfQuAriloFJbnYKY29sYQpjaWJsZQriloFUaGVhdHJlCuKWgWJlbQriloFzYXRpc2Z5CnhsCuKWgdGA0LDQt9Cy0LgK4paBcGl4ZWwKbMOhbgriloF0d2VlCsOnb24K0L3QtdC90LjRjwriloFBVArDqGdlCuKWgU1vcnQK4paBbXlzcQpmdGVuCuKWgdC/0LXRgQrDqW1hCuKWgVNlcnZpY2VzCmN1c3RvbWVyCuKWgUFXUwrRitGCCuKWgUFjaAolLgriloFjbGFyaWZ5CuKWgdGD0L3QuNCy0LXRgNGB0LjRgtC1Cnh0dXJlCnVtaQriloFzw6UK4paBUGVsCnNlcmlhbApVUkkK4paBcmcK4paB0YHQvtGB0YLQsApjaGVzdHJhCl0uWwp3ZW4K4paBTG9uZHJlcwriloFhbnlzCkRhdGFTb3VyY2UK4paB0YDQsNC50L7QvdC1CuKWgXJlaW4K4paBbWV0YWRhdGEKdW1ibGUKYXJiZWl0CmhuZXIKY2llbnQK4paBbm9ydGUK4paB0L7QvdCwCuKWgXNjb3JlZAriloFyYXkK4paB0YTQtdCy0YDQsAriloFwcm90YWdvbgriloFTYWMK4paBY29tbW9ubHkKTGluZWFyTGF5b3V0CuKWgWFwcGxpYwriloHQvNCw0Y8K0JfQsAriloFhY2Nlc3NpYmxlCmlld2VyCmZsYWcK4paBUsO8Y2sKw6R1CuKWgWVyYW5vCuKWgWF1dGhlbnRpYwriloFSeQriloHQvdC10YHQutC+CuKWgWVtYmFyZ28K4paBZHJ5CuKWgXJlYXNvbmFibGUK4paBTW9kdWxlCuKWgWFjY2VsZXIK4paBaW50ZXJ2aWV3CuKWgUNyZWVrCuKWgWFscGhhCnNlcmllClRoZXkK0Y7Rh9C4CuKWgUhvZgriloFDUgptb2RhbAriloFzZXF1ZW5jZXMKY2xvc2VkCil9JAriloHQp9C10YAK4paBT1JERVIKUmlnaHRhcnJvdwpoYXVzZW4KfX1fCuKWgXRhbWLDqQriloFtYWduZXRpYwriloFNY0MK4paBd2lubmluZwp1bmRlcmxpbmUK4paBQmlsbGJvYXJkCm5haW8K4paBbGlxdQpkaXNwbGF5c3R5bGUKdGltZW91dAriloFjb25zaWRlcmFibGUK4paBZWJlbgppZmZlcmVudAphbnUK4paB0KHQvtCyClsoCuKWgTotKQpsZWl0dW5nCmZvcm1lZAriloFNYW5hZ2VyCuKWgW9uY2xpY2sKVFkK0YLQsNGFCkNWCnJ1bnRpbWUKcG9xdWUK4paB0JvQvgpUZW1wCmxvYWRlZAriloEhPT0K4paBc2luZ2VyCmZhcgriloFDb21wbGUK4paBw5ZzdGVycmVpY2gKUG9saWN5CuKWgXdvcmtlcgpXcmFwcGVyCm9iaQriloFkaXNjdXNzZWQK4paBYnV5CuKWgdGP0L3QstCw0YDRjwriloFEaW4K4paBZ2VkCtGB0LrQvtGYCkV1cm9wZQriloF0YWxsCmhvcwrQu9Cw0LPQvgriloFCbG9jawriloFpZGVudGlmaWVkCkxpc3RWaWV3CuKWgWF0dGVtcHRpbmcK4paBdHlwaWNhbApwc3VtCm9zdGVyCuKWgdC20YPRgNC90LAKUGUKbWVyY2UK4paBdW5leHBlY3RlZApodWkKbGV0dGVyCuKWgW51ZXZvCuKWgdCw0LHQvgriloFWQUxVRVMK4paBSXoKRmxhZ3MK4paBVFJVRQppemFjacOzbgriloFncm93aW5nCmVzdHJlCuKWgXBvbHkK4paBU3RvbmUK4paBVklJSQriloFsb2NhbGhvc3QKw6RobHQK4paBZW1iZWRkZWQKamRiYwriloFjb252ZW50aW9uCuKWgXNjYWxhCtGB0L7QugriloFhbmFsb2cK4paBIisK0YbRjgpvY2MK4paBbGl0dApQTgriloHQsNC60YLQuNCyCmF0dHJpYnV0ZXMK4paBRmVyZAriloFhenVyZQrImXRpCsOxb3MKcGluZwriloF0ZWFjaGVyCn0mCmlwZQriloFOb2IK4paB0LjQvNCwCkJpbmQK4paBbWFnaWMK4paBVHJhbnNwb3J0Cml4ZWwK4paBY29tcHV0ZWQKYWduYQplcnN0CkhBCldhaXQK4paBYXV0aG9ycwriloE7KQpjbGFtCuKWgVBlbm5zeWx2YW4K4paBZHJ1ZwriloF2YWluCuKWgWVtcGxveWVkCuKWgWluZGl2aWR1YWxzCuKWgWFuZ2UKdXRhdAriloEkLQpjb3JyZWN0CuKWgWV4cGVyaW1lbnRzCkFyZ3VtZW50CuKWgUlCCuKWgXDDqHJlCuKWgUJyaWFuCmJlcmdlcgpNYWMKaWFzdApQZXJtCkNhc3QK4paBe307CuKWgVN0dWRlbnQK4paBc3RhdHQKYWxnZWJyYQriloFlcXVhbHMK4paBcHJvamV0CuKWgXByw6lzaWRlbnQKQWN0aXZpdHlUaHJlYWQK4paBZWluegplbmlhCnJlegplc3Npb25hbAriloHQsNCy0LPRg9GB0YLQsApvdmVycmlkZQpuZXdzCuKWgXBsYW5ldApubgriloFXaXMK0YLQstC10YAK4paBVmFsaWQK4paBR2VmCtCz0YDQsNC0CuKWgWVpZwphbnRvbQriloFNZWlzdGVyCmZsYWdzCmZmaWNpYWxlCtGI0LDRjwotLAphdGlvbmVuCm1vdXNlCnN0YW5kYXJkClNpbmdsZQriloFib2wKaXNpcwriloFmcnVpdApjb3Vyc2UKaXRhbnRzCuKWgcOpdGFpZW50ClRleHRGaWVsZAriloHRhNC+0L0K4paBYWlyY3JhZnQK4paBSVNTTgriloF3ZXN0ZXJuCuKWgXJlcHJlc2VudGluZwpFc3AK4paBRWxzZQriloFzaXplcwriloFzYXRpc2ZpZWQKb3RvcwpVRApGaW5hbArDs2oKw6h2ZQriloFSb3kKZmZlbgriloFzYWx0CuKWgUxhYmVsClNrCuKWgdC60YDQtQriloHQm9C40YLQtdGA0LDRgtGD0YDQsAriloHRgdC8CkF0dHJpYnV0ZXMKYXllCtGB0YzQugriloHQstGL0YHQvgotKQpvc2VzCmNhbGN1bAriloFDYW5ub3QKR2VuZXJpYwplbW8K4paBQXV0b3IK0LvRkdC9CtC70LDQs9CwCnZvdGUKbGljYXRlcwpydXMKw6lsaQpvcGYKYXRpcXVlCnNjYWxhCuKWgU9oaW8K4paBQnJpdGFubgriloFiZWYK4paB0JXQstGA0L4K4paBQ2FyZWVyCmlzw6llCsOzdApib3NlCuKWgdCR0LXRgAriloFDb250cm9sbGVyCnBvbGUK4paBYWxsZW4K4paBaGFjawriloFleHRlbnQK4paBY2FsY2kKTWVyCuKWgXN1bW1hcnkKTWFydAriloFoaXN0b3JpY2FsCmltYXQKYnVkCuKWgUZPUgpleHBvcnQKZWRpCk1hcHBpbmcK4paBQXkK4paBUnVieQriloFkZWZpbml0aW9ucwriloF7JAriloF5b3VycwpyaWFzClRvdWNoCuKWgUdhegriloFBdXRvbQriloHQuNGB0YLQvtGA0LgK4paBZGVsZW4K4paBS2luZGVyCn19JQriloFwZXJmb3JtaW5nCkZSCuKWgVNpZwriloFCcmFkCmJyYXMK4paBSmFyCnBrZwp3cgriloFQYXlzCk5DCuKWgW9wcG9zZWQKVHJ5CuKWgdCy0LXQt9C1CuKWgUJvZwriloF3cml0ZXMK4paBc3RvcmllcwriloFtYXRlcgriloFzdGFnaW9uZQriloFzdHkK4paBY29tcGF0aWJsZQpoZWFzdAriloFHdXkKZWdyw7xuZAriloFpZGVudGlmaWVyCuKWgWhlYWRzCtC/0L7Qt9C4CuKWgXN0dXAK4paBdGYK4paB0ZjQvtGICuKWgUh1Z2gK4paBY2FyZHMKb3Z5CuKWgVRvYXN0CmFsbGFzCuKWgXDDumJsaWMK4paBYXNzdW1lcwriloHRh9C10LzQv9C40L7QvdCwCnljbGVyCuKWgUp1bmlvcgriloFGaWNoCuKWgWVzdGltYXRlZAp6ZXJ3CmRpYWxvZwrRiNC40L0Kc2hlbGwK4paB0L3QuNGFCuKWgXBpdGNoCtC00L7QuwpvdXR1YmUK4paBU2FudGkKT25DbGlja0xpc3RlbmVyCuKWgU1hZ3lhcgriloF2dWUKacOjbwriloFgIwpjb2xsZWN0CuKWgVJvdQphbmFseXNpcwppc3Ryem9zdAriloFEaWdpdGFsCuKWgWNyaXN0CnJpZXJlCuKWgWNhbXBvClVzCuKWgWNpcmNhCuKWgUNvbXBvbmVudAriloFOU1N0cmluZwpwZAriloFwcmluY2UK4paBaW52b2tlCuKWgU1hcmluZQpBbGxvdwplc3RpYwrRgNC40YHRgtC4CmJvbmUK0YLRg9GA0YsK4paBcGFzc2lvbgrDoWNpw7MK4paBb3JuCtCy0LXQtAriloFpbnZhcmkK4paB0L3RlgpSZW1vdmUKZW5jaWVzCmlsaWIK4paBRGlyZWN0b3IKIiIK4paBQ29uc2UKZ29vZ2xlYXBpcwrDs2sK4paB0KPQutGA0LAK4paBSGF2aW5nCkRvbWFpbgppZXJ6CtC90L7Qu9C+0LPQuApDaG8KdW5kZWZpbmVkCmFsbG9jCuKWgXBpZWQK4paBZnJhY3Rpb24KYmlhCuKWgdC/0L7Qu9C+CnVnbm8KbWluaXN0ZXIK4paBcHJpbmNpcGFsZQriloFyZWZ1c2VkCmJyb3dzZXIKKiwK4paBSG9zcGl0YWwK4paBdW5pdmVyc2FsCuKWgUVybnN0CndobwriloFHYXJkCidfCmNvbmRlCuKWgVt7CnNvYgriloFDcml0CuKWgdC00LXQutCw0LHRgNGPCuKWgXB1bnRvCuKWgWVpbmdlc2V0enQK4paBdMO2cgriloFOaQriloF3b3JyeQriloFsZWdlbmQK4paB0LHRg9C70LgK4paBa29tbQpyaWprCmVmZmVjdApPcmkKUkVTCuKWgVBldGVycwriloFCYXJvbgriloFHb3QK4paBaG9uZXN0CsOkcmUKw6FzegriloFub2JsZQriloFjb25jbHVzaW9uCuKWgWZvcm1hdHRpbmcK4paBb3R0bwriloFkZWxlZwrQvNCxCnB0b3AK4paBc2VuZHMKdXJuYW1lCuKWgWZlc3RpdmFsCizigI4K0YDRg9GBCuKWgWRvY2gKc3ViamVjdAriloFjYXJlZnVsCnF1ZW50CuKWgUxvYWQKdGVtcGVyYXR1cmVuCuKWgXJ1ZQpNZW1vcnkKyJthCmlvbmEK4paBZGVudHJvCuKWgWJlZ2FubgriloFBcXUK4paBc2NpZW50aWZpYwprYcWECtC70L7QugplbGRlCuKWgVRob3NlCnF1aWVyCmFjdMOpcgriloFBdWZsYWdlCiknCuKWgWdyYWRpZW50CmludGVnZXIK4paBSW1wb3J0ClNLCuKWgVN0YXR1cwriloFleHBsbwpBRQpTaGVsbAriloFQYXVsbwouwrsKfTwvCmZsZXgK4paB0LrQvtC80L8Kb25kZW4KYWNjZXB0CuKWgW1pZWpzY2UKSHViCmFsbGVuZwpXTgriloFpbXBsZW1lbnRpbmcK4paB0LvRgwriloFjb25mdXNpbmcK4paBSW5zdGFsbAriloFyb3UK4paB0L/RgNC+0LXQugpBY2Nlc3NvcgrRmdCw0YjRmtC1Cm9kaW8K4paBYXBwbGllcwrRjtGJ0LjQuQriloFNdW5kaWFsCsOJdGF0CmlldG5hbQpodW0K4paB0YHQsdC+0YAKb3JkaW5hdGUKRnJhbmNlCuKWgXByZW5kCmVsdGVtcGVyYXR1cmVuCuKWgXRyYWJhagpBeGlzCuKWgdC80L3QvgpwcmltYXJ5CuKWgVNlaXRlCnBlcm1pc3Npb24K4paBb3JkZW4Kc2luY2UK4paBaWMK4paBQnJhemlsCuKWgWJhcmUK4paBTmFyCuKWgUp1cgriloFmcmVlZG9tCuKWgW1lZGljYWwKaXNjaG9mCuKWgdGB0L8KaWXFvAriloFib290c3RyYXAK4paB4oCmCuKWgWZhY2lsCmNvcmQK0LLQsNC90LUK4paBQWxsZW4KYXZpZAppbmdoYW0KemFzCuKWgWluc3BlY3QKaXR0ZW4Kb3N0aQp1aApjw6kK4paBIyMjIyMKY2l1cwpvbXkK4paBU2VpbmUKYnJlcwriloFnZW51cwpPdGhlcgriloFHb2xkZW4KbXVsCuKWgdCh0L/QvtGZ0LDRiNGa0LUK4paBZ2VubmFpbwriloFjYXJlZnVsbHkKYWFsCuKWgWFuYWx5dApuZXVyCuKWgXN0cmV0Y2gK4paBT2NjCm9sYXMK4paBZmlyZWJhc2UK4paBZXhwZWN0aW5nCmJhc2ljCmNvbmRpdGlvbgpwcm92CuKWgVdhc3NlcgriloFjb25jYXRlbgriloFldmlsCuKWgWNvZWZmaWNpZW50cwpXZXN0CmlyeQpwaGFzCuKWgUphbQpmb2lzCuKWgWNvbnNpZAriloFtYWludGVuCm5pbQplc3Nlcgplc3oKdW50YQp1ZXN0CuKWgWNyZWRlbnRpYWxzCl87CkRpbQrQv9GA0LXQtNC1CuKWgULDvApidWlsdAriloFBY2FkZW0K4paBYXVkaQriloF0dsOlCmluYW5kCuKWgVRoZWF0ZXIK4paBZ2VucmUKw6dvcwpncmVzcWwK4paBd2VhcAriloFSYWIK4paB4oCZCuKWgWFkdWx0CuKWgWTDqW0KYGAK4paBc3RhYmlsCuKWgWNvcnJlc3BvbmRzCuKWgUVhc3Rlcm4KdW5uZWwKV29ya2VyCuKWgWNvaArQu9C60LAK4paBTWFzc2FjaHVzZXR0cwpwaW8K4paBcG9ydHMKYWdnCuKWgURlYnVnCuKWgWJyZWF0aApNSU4KVmFyaWFibGUKYmF0Y2gK0YHRgdC1CuKWgXByZWcK4paBcm9sZXMKcGFzdGUK4paBcmVmZXJlbmNlZAphZHJhdArRh9GRCmJpbm9tCuKWgWRlZmluaW5nCuKWgUJ1ZGFwZXN0CuKWgdC00LLQuAriloF0YXVnaHQK4paBaG9sZQriloFxdWVsbGEKTXNnCmFza2EKc2NhbgriloFwcm9wb3NlCuKWgdCR0LjQvtCz0YDQsNGE0LjRjwp7e1wKdGV4dHQK4paBQWxiCuKWgVN5ZG5leQriloFiYWNrdXAK4paBY3JlZGl0CuKWgdGE0YDQsNC90YbRgwpzdGF0cwpcIjoK4paB0J/QtdGA0LUK4paBYWNjb3JkaW5nbHkK4paBTGVuCnpuYQriloFSZWdpb25hbAriloHQuNC30LTQsAriloFqw7oKaGlzdG9yCuKWgWVudGl0aWVzClN0YXIK0L7QvdC1CiddWycK4paBTm92YQpkaWUK4paBYCcK4paBb2J0ZW4KYW5zdAriloFSZWxpZwriloF0cmlnCuKWgdGA0LXQttC4CuKWgVBlcnNvbmFsCuKWgXRvbmUK4paBYWlkClZpc3VhbApTdWJtaXQK4paBbW92ZXMK4paBQnJpZGdlCuKWgUJveQriloFhY2N1cmF0ZQpvc3RhCmF0dG8K4paBZGVmZWF0ZWQK4paBZGF0YWIKZ2lueAriloFMaXYKbHl3b29kClRXCnJpdW0KaXBwZWQKRmFpbApSRVFVRVNUCuKWgWlnbm9yCuKWgXNpdHRpbmcK4paBbW9sdG8K4paBZW5kcG9pbnQKdWNpw7NuCuKWgWNvbGxlY3Rpb25zCuKWgdCi0YMKdGVtYnJlCuKWgW7DqWNlc3MK4paBaW50ZXJhY3QK4paBb3RyYXMK4paBY3VycgriloF0cmFja3MK4paBZmFtw61saWEK4paBbnVtZXJpY2FsCmxlZ3QKXS8K4paBTWFyaW8K4paBdG9ydApiZwpzc2wKdGV4dHR0CuKWgXNwYXJrCtC00LjQuAriloFwcm9iYWJsZQolJSUlCnBoaWEKXSxbCuKWgWJveGVzCuKWgWFjYWRlbQriloFTbG8Kw6R1ZGUK4paBd2l0bmVzcwriloFlZGl0aW5nCtC70LjQvdCwCuKWgWxvb2t1cAriloFCdWNrCtC00L3RjwriloFqb3VycworKyl7CuKWgWluZGljZXMK4paBZmxpZ2h0CuKWgWNvbXB1dGF0aW9uClBsdWdpbgriloFyZWFsaXplCmlzc2V0CuKWgWRlcml2YXRpdmUKbGluZXdpZHRoCmJ1bmQK4paBdGhvcgriloEuPQriloFzw60K4paBQ2xpY2sK4paBU2ViYXN0Cj4nCmhhdmlvcgpsZWkKdWxmCuKWgWdlb21ldHJ5CnByZXYKZW1wbAriloFMw6kKYW5zb24K4paBQWxpY2UKcHJvdG90eXBlClJFQUQKaWN1bGFyCuKWgdCx0ZYK4paBZGV1dHNjaGUK4paBUmVwcmVzZW50CnNpdGVzCuKWgU1lYW4K4paBZGlzcwriloFadXIK4paB0L/RgNC10LcKUEFSCuKWgScjCuKWgURyYQrRgdC+0L0K4paBc3RlaHQKbWFya3QK4paBZWFzZQpEcmF3aW5nCj0lClN0b3AK4paBc2VydmluZwriloF0YWvFvGUK4paBRE5TCuKWgWxpdGVyYWwKRGllCuKWgdCy0L7RgQriloFzZW5pb3IKYWNpb24K4paBdWJ1bnR1CuKWgUZyYW5rZnVydAriloFTdW5kYXkKw6FiCuKWgWpvdXJuZXkKaXNzYQpiZXJyeQriloFzZXAK4paBaW9uCndlcnQKb3JzesOhZwpzZXJ2ZQriloFNaWxhbm8K4paB0LLQtdC60LAK0YDQsNGFCuKWgdC40Y7Qu9GPCuKWgW1hbmVyYQriloFzdGF0aW9ucwriloFhZG9wdGVkCuKWgWFueWJvZHkKVkVSU0lPTgpGRQpkb3JmCi4uLiwK4paB0L7QsdGA0LDQt9C+0LLQsApMb2dnZXIK0YTQuNGG0LjQsNC70YwKV1JJVEUK4paBaGFtCuKWgUZ1dHVyZQpvdGVuCuKWgUFHCuKWgXRyYWluZWQK4paBTmljaAriloF1bml2ZXJzaXR5CuKWgU9seW1waWNzCuKWgWRvaXQK4paBY3VsdHVyYWwKQ29uZgriloFDb25mZXJlbmNlCm9ybm8K4paBTVAK4paBYm91CmNpbgpIaWdoCmFubnRlCuKWgWRpc3BsYXlpbmcK4paBY2hhcHRlcgriloFGcmF1ZW4K4paBcmVhbGl6ZWQK4paBYXR0ZW1wdGVkCuKWgXByZWZlcnJlZApEYXQK4paBdHJvdXZlCuKWgWludGVudGlvbgriloFOb3RpY2UKdGltZXN0YW1wCiooCuKWgdCo0LAKYW5hcwpjbGEKaXN6CnRibApBcnIK4paBaW52ZXJzZQriloF0ZXJyaWJsZQriloFvY2N1cGllZApKQVgKPC0K4paBUGhpbG9zb3BoCuKWgUNvcnBzCmJ1aWxkZXIK4paBYmVnaW5zCuKWgWNlbnN1cwou4oCZCuKWgXByb3ZlbgptZXRyaWMK4paBaW5jcmVhc2VzCndpY2gK4paBQUJDCnByb2plY3RzCuKWgVRob3IK4paBY29uZmlkZW5jZQriloF1ZmZpY2lhbGUKZWxtCuKWgWdhcmRlbgriloFyb2J1c3QK4paBY29zw6wKaWVkegriloFJc2xhbQriloFBZGRyZXNzCuKWgWRpdmlkZQriloFFdQpjYXRhbApkZXRhaWwKZXBlbmRhbnQKZmcK4paBYmV3CuKWgWZpcwriloFCTwriloF3c3AK4paBcGlwZWxpbmUKaGQK4paBU2Vzc2lvbgpsw6RuZAppdmVhdQplc3RyCuKWgXBhcnRpY2xlCuKWgWxhcmF2ZWwKcGljCuKWgW5hdQriloFmaW5zCuKWgVZpbAriloFmdXMK4paBcXVhc2kKb3BlcmF0aW9uCuKWgWFsbGVyCuKWgWFuYWx5CuKWgdCe0L0K4paBTWVzCuKWgdC+0L/QtdGA0LAK4paBaGFuZGxlZAriloFkZXByZWMKdHRvCuKWgUVrCuKWgXN0cmFuCuKWgWFuZ2xhaXMKanVyZQriloFTaWx2ZXIK4paBY2xvc2VseQplbmtpbnMKYW5vcwpzdGVkCuKWgdGB0LXQvdGC0Y/QsdGA0Y8KYnJhbmQK0L3RjNC+CuKWgXByw6lzZW50CnJvawptb3VudAriloFBbnRob255CuKWgUZ1cnRoZXJtb3JlCmluaGEK4paB0LDRgNGF0LgK4paB0YDQsNC30LvQuAriloHQvtC60YLRj9Cx0YDRjwriloFwaW50Cm7DvQpwdHMK4paBaXRhbGllbgriloHRgNC10LPQuArQu9C10LcK0LTQuNC90LAKYXRoZXJpbmUKSW50ZXJuYWwKUXVlc3Rpb24K4paBc2V0dGxlbWVudAriloHQktGB0LUK4paBZm9sZGVycwrQtNGA0LgK4paBdmFsb3IK4paBTWlsbGVyCuKWgUFzc2VydAriloFwYXRpZW50CuKWgU5pZWRlcgriloFFUAriloFBZ3IK4paBb25kZQriloFzY29wCnNlcXVlbmNlCuKWgVBMCuKWgXNlZWsKamF2YXNlCuKWgVZlY3RvcgriloFuw6EK4paBY2F0ZWdvcsOtYQpjbG9uZQpOUgphdmFpbGFibGUK4paBQmVzY2gK4paBZWNsaXBzZQp3aWNrbHVuZwpkZXBsb3kKZW5pZQriloEiKQrDpHN0CuKWgXN5bmMKQ09ERQriloHQp9C1CuKWgWZsb2F0aW5nCi9gCuKWgXJldGlyZWQKZGViCuKWgXBhcnRpY3VsCuKWgWNvbGxlY3RlZAriloFkb3dubG9hZGVkCm5pY2UK4paBQnVmZmVyCuKWgUFjY291bnQK4paBbWFnZ2lvCuKWgdGA0LXQtNCwCuKWgXNhbGVzCuKWgXN0YXR1bml0ZW5zZQriloFLaQriloFGZXJyCkxvY2sK4paBSXNhYmVsCmNsYXIK4paBcG92CmF0cmEK4paBRnJhdQriloFzb3J0aW5nCuKWgXBocmFzZQriloHQsNC/0YDQtdC70Y8K4paB0LTQtdGP0YLQtdC70YwK4paBQW5kcsOpCmRlZmluaXRpb24Kd3JpdGluZwrDqXLDqQrRidGDCuKWgU9yZAriloFydW0K4paBVHVyawriloFJdmFuCnRoZWxlc3MK4paB0LPQuAriloFzYWtlCuKWgUJhc2VkCmRlY2sKb3J1cwriloF0dXR0aQriloFibGFuCuKWgdCf0YMKRGV0YWlsCuKWgdCd0L4K4paBU2t5CuKWgXByw6hzCtC80L7QuQpjb2xuCtGH0LXRgdC60L7QuQpldGkK4paBYXJyb3cK4paBQ2hhCmNobWFyawrFk3VyCmZhYgrQutGD0LvRjApHcmlkVmlldwriloFCYWNrZ3JvdW5kCnNuCuKWgXNlZ3VpdG8K4paBbmljCmNvdQrRgtGW0LIK4paBYnp3CmFkZEV2ZW50TGlzdGVuZXIKc3luYwphenpvCmFic3RyYWN0CmFzc2V0cwriloFEcnUK0LfQtApvcmRuZXQK4paBYmlnZ2VyCuKWgWluaXRpYWxpemVkCtC60LDQtwpvZ2VuZQp2aW91c2x5CuKWgWd1aWQKc2NoZWlkdW5nCuKWgVplbnQK4paBZnJhbWVzCnJpZWJlbgriloFpc3N1ZWQK4paBZG93CuKWgWRlc2NyaWJlcwppbHN0CuKWgWNyaXRlcmlhCuKWgWdlbnRsZW1hbgpCYXNpYwpuZXoKRGV2Ck1vdmUK4paBZXN0YWJhCuKWgXNldHRlbWJyZQpjaXJjbGUK4paBZmFpcwriloFteXN0CuKWgWFyY2hpdgpkeW5hbWljCmrDoAppdGFzCuKWgdGP0LrQuNC5CuKWgWRvcgriloFBbWF6b24K4paBbmVjZXMK4paBTWFyY2VsCuKWgWVsbGEK0YDQvtC6CuKWgVBlbm5zeWx2YW5pYQpjdWxhcgpQYWNrCml0YWdlCuKWgUJ1cm4K4paBUk8K4paB0L7QvdC4Cn4kClRlWAphc3NpZ24K4paBYmVhdAppZGVuc2UKYWNlbnQKQWxlcnQK4paBc3RyYXRlZwriloFtw6VuYWRlbgpMT0MK4paBY2F0YWxvZwpwcmludFN0YWNrVHJhY2UKKCkpLgp1c3RlZAriloFGcmFtZXdvcmsKRUNLCuKWgWF0w6kKRnJhbWV3b3JrCuKWgWF0dGFja3MK4paBQmVydAriloHRgtGA0LDQvQo6JQphcnNpCm5vdGF0aW9uCuKWgWxvZ2ljYWwKd2VldAriloF2aXNpdGVkCmJydQriloFzdXJwcmlzZQpeXgppbmFsZQpyZW1vdGUKJ30sClN5bnRheAppYW5lCm9ubmVuCuKWgWJyZWFraW5nCnBhcnNlcgphcGsK4paBTWlndWVsCuKWgcKnCuKWgWFjdGluZwriloFnZWJydQpBdEluZGV4CtGO0YLRjNGB0Y8K4paBb2ZmZXJzCuKWgXByYWMK4paBZ3JhbnQKdGVybm9vbgriloFhY3F1aXJlZAriloFOeQriloFjb21tYQpuw61rCuKWgVN0ZXAKaW5uZXJzCuKWgVNBCuKWgXdhdApkYXlzCuKWgXJlY3RhbmdsZQpkYXIK4paBdHJhYwriloFJbmRvbmVzCuKWgWZlZWRiYWNrCuKWgWJyZWFrcwpwYXJ0aXRpb24KaWNhbnMK4paBTm90aWNlcwriloFpbXByb3ZlZApwaGFuCuKWgWRpZmZlcmVudGlhbApzY3JpcHRzCuKWgVhJSUkK4paBTGFib3IK4paBcHJlY2lzaW9uCuKWgXNlZWQKYnVuZGxlCmlkZW50cwpocmUK4paBRG91Z2xhcwp1bGQK4paBc2Vjb25kYXJ5CuKWgWJyaWcK4paBY29uZmlybWVkCuKWgWNsYWltcwpSb2xlCuKWgUpld2lzaAriloFwxZllZAriloFob3RlbAriloFjb21wdGUK4paBcmVjdXJzaXZlCl0oIykK4paBcm90YXRlCuKWgWNocm9tZQppbmVhCiU7DQriloFFbnZpcm9ubWVudApwbGF0egriloFTaW5nbGUK4paBc2V2ZW50CuKWgXBvc3RpbmcK4paBZGVhbGluZwpwYXJhbWV0ZXJzCtCz0YDQsNGECkF1dGhlbnRpY2F0aW9uCnRvdWNoCkF6CuKWgWdyYXkKZW5jaW5nCmJvbGRtYXRoCuKWgdGB0LDQudGC0LUK4paBWmEKYW5qZQriloFwb2xhcgriloHRg9C70LgKa2lsCuKWgWhvdmVyCuKWgVJFU1QK4paBQ29tZQpqYgriloFHZW9yZ2lhCuKWgUVzdGFkbwpPdXRwdXRTdHJlYW0K0ZvQuAriloFkdW1wCuKWgUFnZQriloFzd28KbW9iaWxlCm9jY3VwCtGI0LXQs9C+CuKWgWNvbnN0aXR1dGlvbgpnb29kCmFrdQriloHQsNC90LMKaWVjawriloFQc3ljaAriloFyb290cwriloF2ZXN0CuKWgdCz0L7QtNCw0YUK4paBUmVww7pibGljYQriloFwaWFuCmlncmF0aW9uCuKWgXByw6ljCuKWgWdlbmVyYXRlcwpMWQooYAriloE9fgrRiNC10L3QuNGPCuKWgVJhaAriloFjb25uZWN0aW5nCsW+w60K4paBZsWRCuKWgWFwcGVsCuKWgVJhaWx3YXkK0LPQu9C4CuKWgWTDqXZlbG9wcAriloFhcG8KZnJhbgriloFpbW1lZGlhdGUK0LLQvtCz0L4KUnVubmVyCsOkZwpTb21ldGhpbmcK4paBZ8OpbsOpcmEKRXZlbnRBcmdzCmluY3Rpb24KZ2x5CuKWgUR1ZQriloFwcm9zdAriloFyZWZlcnJpbmcK4paBam9nCuKWgWV4ZWN1dGFibGUK4paBRHJlYW0KYWNzCuKWgUNvbGUKYW1wZgriloFCaXMK4paB0LjRjtC90Y8KbGllZGVyCtGC0LXQugriloF2YgriloFtb20K4paBOigK4paBZGVybmllcgonPT4K4paB0Y3RgtC+0LPQvgriloFuZXVlCuKWgdCn0LAK4paBd2VpdGVyZQriloFhbGxlZwriloFyZWFsaXR5CuKWgWp1ZGdlCuKWgUJhbHQK4paBdGhpbgriloFHZWQKaWV2YWwKbXgK0YbRltC+0L3QsNC70YwK4paB0LLRi9C/0YMK4paBSVgK4paBYmxpbmQK4paBTW90b3IK4paB0YjQsAriloFhcHByb3hpbWF0aW9uCmRhbQriloFmb2cK0LrQvtGACuKWgVdyaXQK4paBbGluZwriloHQv9C40YHQsAriloFNYXJzCm90dGkKRW51bQriloFUcmliCuKWgW1lcmMKenVuZwp2YW5jZWQKY2ZnCtC90LDRhQpzY2hlbgoiXS4KYmVrCuKWgXN0ZXIKanAK4paBUmFwCuKWgXJlY29yZGluZwriloFwZWludAriloFsZXRzCsOkbmdlCj4iOwriloHQvNGW0YHRhtC1CuKWgWNhdmFsCuKWgUNTVgriloFlbnRzdGFuZAriloFoZWxwZXIKZW5kZXQK4paBR3JhbQriloFEaWVnbwriloFCaXNob3AKVEFHCuKWgWVjYwriloFFZW4K4paBQVYKQ2l0eQriloFHdWlkZQpoaW5kCnJpY2FsCuKWgdCe0YHQvdC+0LIKQnVzCuKWgXp1bsOkY2hzdAriloF0aWNrCuKWgUNvbG9uZWwKVGhhbmtzCuKWgWZlcm0K4paBZ3JhbnRlZAriloF0aHJlc2hvbGQKb21vcnBoaWMK4paBSHVuCmVuaXMK4paB0L/RgNCw0LIK4paB0Y/QutGWClBHCuKWgXdzCuKWgXRlY2huaWNhbAplc3RybwprbMOkcgp2YXJzCm9jcmF0CuKWgdC+0L/RiNGC0LgKb25zbwppYmEK4paBU2F2ZQriloFwcm9ncmFtYQriloHQstGKCuKWgWludsOlbgo+KCkK4paBbWVqb3IK4paB0YHQu9C+0LLQsAriloFyZXBsYWNlbWVudAriloFpbXByCuKWgUZyYW5jZXNjbwriloFIb3RlbAriloFVUERBVEUK4paB0LzRg9C30YsKdWdzCnZhcmQK4paBZmF6CmludG9uCuKWgWFydHMK4paBS3kK4paBSWxzCuKWgXNlcmEK4paBVm9sdW1lCuKWgWdpdWdubwriloFhc3ltCuKWgVBpcgriloFOQVMK4paBVGFtCsSbbApTZXF1CmttYWwK4paBRWlucwriloHQutC+0LzQv9CwCm9iZQpvb3IK4paBaGVhcApjdGwK4paBc2VwYXJhdGVseQpyZWFkZXIK4paBc2lnbmlmaWNhbnRseQriloFMYWcKbm90ZXMK4paBc2VsZQriloFkZWRpY2F0ZWQK4paBSG9zdApjaG9pY2UKd2luZwriloFUaXRlbAriloFiZWZpbmRldApsYXJnZQriloFjb250ZW4KSmF2YVNjcmlwdAriloFkZXNlcgriloFHb3Jkb24K0YHQv9C1CuKWgXBhdHJpCuKWgVJhbmRvbQriloFSZXR1cm5zCtGL0LwK0YDQvtC80LAK4paBU3R1ZGllcwpTbAriloFmcsO8ClRFWFQKaW5hdGUK4paBVG9sCuKWgWV2ZXJ5d2hlcmUKYXJ0YQriloFvcmJpdAriloFBaXJlcwriloFJc3MK4paBdGXFvAriloFkaXZlcnNlCuKWgW51bWVyaWMKbWF6CuKWgW1pc2UK4paBYmF0dGVyeQriloFBa2FkZW0K0L3QtdC90LjQtQriloFzaW11bHRhbmUK4paBRGVhZAriloFjbHVzdAriloFvdHJvCuKWgWNlcmNhCigpYCwKcm96CsSDdAriloFNTwpyaWZ0ZW4KaW1wb3J0YW50CuKWgWplaG8K4paBZmluZFZpZXdCeUlkCuKWgWNvbnNlcXVlbmNlCuKWgW1lYXN1cmVkCmlzaGVzCuKWgXN6ZQppZW5kbwriloFXYWhsCnN0cmlwCkFSRAriloFvcGFjaXR5CldPUkQK4paB0JLRlgriloFMb2NhdGlvbgpyYWkK0L/QtdC9CuKWgXJpZgphdXNzaWFuCkZpbGVOYW1lCuKWgWRpc2NvCmlsZW4K4paBdmFneQpsaWNpdHkKQm9yZGVyCuKWgVRyYWNrCtCx0L7QvApmYWN0Cm9rYQriloFnaW9yCuKWgVhWSUkK4paBZMOkcgpTaXRlCmHFgm8Kc2vDoQriloFwaXhlbHMKdml0eQpqUXVlcnkK4paBc2N1bHB0CuKWgWNhcmdvCuKWgWRpcmVjdGl2ZQriloF3YWwK4paBY29ubmEK4paBVGhyb3VnaAriloHRjdGC0L7QvApTdGF0aWMKb21zbml0dAriloFydW5kCuKWgWNsYWltZWQK0LfQvdGPCnNoYQriloFyYWcKY3JlbWVudAriloFmw7xuZgriloFyaXZhbApyaW4Kc2xhc2gK4paBdGhpcnR5CnNsZWVwCtC+0LvQvtCz0LgKU00KZ2F0ZQppemF0aW9ucwp2aWsK4paBYmxlc3MK4paBSWxsaW5vaXMK4paBVEUKdXRpbmcK4paBc29sdmluZwpHRVIK4paBWElWCuKWgUluZGlhbnMKZXhwcmVzcwriloFIZWlsCuKWgW11amVyCuKWgWludsOlbmFyZQonXSk7CuKWgWF1cgpib29zdApHTwriloFuaW4KdG9rCmdvZApvdGVyCikkJAriloFkZXNjZW5kCtGA0Y4K4paBTGFuZ3VhZ2UK4paBZGl2ZXIK4paBQXNzdW1pbmcK4paBZnJlcXVlbnQK0YfQvdGWCuKWgUJpb2dyYXBoeQosWwp1cm0K4paBd2Fsa2VkCuKWgWZlZGVyYWwK4paBTWljaGlnYW4K4paBZmFjdHMK4paBSW50ZWdyCkxFUwriloFBbGFuCuKWgWNvdXAKQmVyCuKWgXBhcnRpY2xlcwrRm9C1CkluZmxhdGVyCisoCkJvdW5kCuKWgVPDvApBdWRpbwpjaXRldAp5ZWN0CuKWgW5yCnhlCuKWgUJydW4K4paBXywKYXZvcgriloFkaXNjaXBsCmFsbQriloHQvdC+0Y/QsdGA0Y8K4paBU1NMCuKWgUthaXNlcgriloFyZWNoZXIKeWdvbgriloFyZWdhcmRsZXNzCuKWgWNvbmZpZ3VyCuKWgXVubmVjZXNzCuKWgUNsYXJrClBIUAriloFGQUxTRQriloFwYWQKJH0K4paBdmFsdQriloFkaXNlYXNlCuKWgW1haW9yCuKWgWhvbW1lcwriloFFZGl0aW9uCnNsYW50CuKWgWVuZGluZwriloFzZXR0bGVkCnVydXMKaGVkClBhdHRlcm4K4paB0LPQvtC00LjQvdCwCuKWgVBoaWxhZGVsCnRpa3pwaWN0dXJlCuKWgWNvYWwK4paBc2VkZQriloFzYXRpc2ZpZXMK4paBdHJpbQriloFiYXQK4paBYW3DqXJpY2FpbgriloFsdWdsaW8K4paB0L/QvtGH0LAKZmZmZgriloFUYXJnZXQKZ2VuZXJhdGUK4paBWmllCsibaWEK4paBZ2FyZAriloF3b3JrZXJzCuKWgUpvYgriloF1cmJhbgphaGxlbgriloFCdWlsZGluZwriloFuZXUK4paBY2hyb24K4paBRWFybApncm8KVVNFCuKWgVhJSQriloF3ZWFsdGgKaW5hZQriloHQkdGA0LAK4paBbGliZXJ0Cmlyb3MKOiQKbGVlCmlldmVzCuKWgUp1c3RpY2UK4paBb2lsCuKWgUF0aGxldAriloFjbG8KU2NhbGUK4paBbGlwcwriloFhcHJpbAriloFpbXByZXNzaW9uCuKWgXBlcmNlCuKWgdGD0YfQsNGB0YLQuAp2aWwKw6ljaAriloFlcXVhbGl0eQriloHQvNC10YIK4paBYW5ub3RhdGlvbgplcm5hbAriloFNYWNoCuKWgWludGl0dWwKcHJvYmxlbQrRjtGJ0LjRhQpvcGx1cwriloF0aG91c2FuZHMK4paBY2FsY3VsYXRpb25zCnVtcHMK4paBdHJpYW5nbGUKcGhhbAriloFEb3JmCuKWgWRvbGxhcnMK4paBZGVuZW4KbMOocwpvbGlkCuKWgVJlc3VsdHMK4paBU3RhZGl1bQriloFEZXNwCuKWgUVpc2VuCmltaXIK4paBc290dG8K4paBxI1pCmF0YWJsZQpvcnVtCuKWgWNvbnZlcmdlbmNlCuKWgWpldW5lCm9raW5nCuKWgdC20LjQstC+CmFpbmluZwpwb2ludGVyCmN1bG8K4paBanNvdQriloFncmFiCmFrdGUK4paBaG9waW5nCuKWgU1hawriloFzYWcKb3JpZ2luZQriloHQv9C+0YHQu9C10LQK4paBVmVnCuKWgXRoZW9yZXQK4paBVHJ1Cm5lbWVudAriloFmYWNlcwpIb3IKSm9pbgphcmVsCuKWgdC+0LrQvtC70L4KSG93ZXZlcgriloFjYXRhbApib3VyZwriloFteXNxbGkKYWNpb25zCuKWgUluaXRpYWwK4paBcmFpbgppdHVyZQriloFTY2llbmNlcwriloFLcmVpcwouX18K4paBY2lucQriloFBdcOfCml0aG1ldAppdG9ycwphbWF6b24K4paBZ2FwCuKWgWlnbm9yZWQKYWR2CtC60L7RlwriloHRh9Cw0YHRgtGMCuKWgWNvcnBvcgrRhtC10YAK4paBY3JpbWUKdW91cwriloHQvdCw0LvQsNC30LgKRGF0YUZyYW1lCtCy0L7QtNC4CklnbgriloFMaW5jb2xuCuKWgW1lbm9zCuKWgUx1ZnQK4paBTGluZAriloFDb29rCuKWgW1hdGVyaWFscwphcHBlZAppZ25vcmUK4paB0L7RgtC60YDRiwpmcmllZAriloFnb3V2ZXJuZW1lbnQK4paBZmlyZWQK4paBc2NyZWVuc2hvdArRgdC10L0K4paBWygK4paB0L7RgNCz0LDQvdC40LfQsApHcmFwaGljcwriloHQv9GA0L7RgtC4CuKWgXBoZW4KY3JhZnQK4paBYnJhaW4K4paBQ29tbwriloFFdmVyeXRoaW5nCmFuZXMKSUdOCuKWgW5lZGVyYsO2cmQK4paBRm9yZXN0CnphaGwK4paBQW1vbmcKUXQK4paBdG9nZwriloF2YXJpYW50CuKWgWhpbGwK0L/QuNGB0LgKY29sb24K4paBZGljZW1icmUK0LPQvtGACuKWgVdpbmQKw7xuc3RsZXIK4paBPVwKc2F2ZWQK4paBbmVqCnVudGUKdXR0bwriloFyZWNlbnMK4paBc2ljawriloFkZXNlbgpVU1QK4paBd29yc3QK4paBQW5nZWwKb2RveAriloFQcm92aW5jZQriloFNYXoK4paBYWdyZWVtZW50CuKWgUJhc3MK4paBc2VndW5kYQpvbmNlcwriloFMaW5raQriloFDTAriloFqw6EKaXRlbWVudAriloHDoXJlYQriloFzY2FsYXIK4paB0KDQtdGBCmF3dApzaWVtZQriloFqdW5pCuKWgdGF0YPQtNC+0LYKaWt1cwriloFsaWQKcHBlbAphdmkK4paBYmFsYW5jZQppcHBpbmcKY3Vzc2lvbgrRh9C10YHQutC40YUKKCIuCkFsc28K4paBd2hpcwpIT01FCuKWgWJyb3duCuKWgWTDrWEK4paBcHXDsgpwbG90bGliCuKWgUphaHJodW5kZXJ0cwpESwriloFhbmNob3IKLi4uXQriloFBdXN0cmlhCuKWgW1hcmNhCuKWgWdlegppb3VzbHkK4paBbGF6eQp4YQriloFDaGFubmVsCuKWgW5ldWVuCmRhcwriloFzZWFyY2hlZAriloFzdGFhdAriloHQotCw0LoK4paBSm9zZWYK4paBU2hlcgpwb2lzCuKWgWVuZW0K4paBYWNjZXNzaW5nCuKWgdC90LXQutC+CuKWgWZ1cm9ubwriloFwc2V1ZG8KPz4K4paBZXN0YWRvdW4K4paB0JLQuNC00LgK4paBbW90aXYK4paBcmVjYWxsCmlzc29uCsOzYgopLS0K4paBRXJ6CuKWgdGB0LDQstC10LcKRGlyZWN0CtGB0L7QsQriloFzaG8KdsO2bGtlcgpBcApnZW5zCtC90LjRiNGC0LLQvgriloFBbXN0ZXJkYW0KdXNrCtC/0LvQvgriloFzaW11bGF0aW9uCuKWgUJDCuKWgVdvagphdXRvbQpBbGV4CuKWgWVjb25vbWljCtCz0L7QvAppa2FpCuKWgWFsdHJlCuKWgSctCuKWgVdlZwpOb3RGb3VuZArQudGB0LrQvtC5CuKWgWNvbnZlcnRpbmcKcGhhYmV0CmF0cmljZQpib3VybmUKYWxvbQriloFjb21wYXJpbmcK4paBWm8K4paBZmxhCtCy0LDRjwriloFlbnRyYQriloFjaGFyc2V0CmRldmVsb3BlcnMKw61zdGljYQp9PgriloFKYXp6CuKWgUhvd2FyZArRiNGC0LAK4paBY2xvbmUKZG9vcgriloFQaW4KKioqCuKWgXNpbGVudAplY3ljbGUKaXNjZQriloFtdWQK4paBRGlzcGxheQriloFsaXAK4paB0LjRgdC/0L7Qu9GM0LfQvtCy0LAK4paBY2hhcmFjdGVyaXN0aWMK4paBc2IKZmlyZWJhc2UK4paBQmV3CkNhbGVuZGFyCuKWgXVzbwrDqHNlCuKWgVJhdAriloFlc3BlcgriloF0aHJvd2luZwriloFyb2R6CuKWgXlhcmRzCuKWgWdyYXNzCuKWgW1hcmtlcgriloFLb3MKVGhldGEK4paBb3JnYW5pcwprZXJuZWwK4paBcGVyc29uYXMKa2VlcAriloFleGNsYWltZWQKb3NsYXYK4paBRW50ZXJ0YWluCtC90LXRgAriloFpbndvbgriloFSYW5kCnJlZHVjZQpmYWMKZXhwcmVzc2lvbgp5agriloFkaWZmZXJlbnRpCmFnbGlhCuKWgXRlbXBsYXRlcwriloFtxbEK4paBcHJ2CuKWgW1vaXMK4paBZ2V3YW5uCuKWgdCx0YPQu9CwCmJpYmxpCmRlbW8K4paBQW5kZXJzb24K4paB0YDQtdC0CuKWgXBvcnF1ZQriloFQb2xvZ25lCuKWgXRyaXAK4paBZXhlbXBsZQriloFJbnRlcm5hY2lvbmFsCuKWgdC60LDQvgpJbnNlcnQKZ2VuZXJhbApTRVNTSU9OCmJlcmdhCmjDpGx0CnVuYXMK0LzQuNGA0LAK4paBeWllbGRzCm1hcHN0bwpzcG90CuKWgStcCtC70LvQsAriloFwcmVjaXNlbHkK4paB0YfQu9C10L0Kc2hhZG93CkFyZQp1bmFsCuKWgWRpc3BhcgriloF0w610dWxvCm5lc3QK4paBTG93CuKWgXByb3QK4paBQ29zdGEKbmFtZWQK4paBZ2FpbmVkCmxlc2lhCuKWgWFkbWluaXN0cmF0aW9uCkltcG9ydApicmFuY2gK4paBc3ltcGF0aAp2b2oK4paBRUMK4paBbXVuaWNpcGlvCuKWgWFuaW1hdGVkCuKWgWRpcmVjdG9yaWVzCuKWgXJvb2YKesSFZAppbWV0CnByb3RvCmJsYQo6XQpoYXZlCmF0ZW0K4paBbnMK4paBc2VjdG9yCnRocmVlCm93YW5lCndlcnMK0L7QstC40YUKcmVuY2UK4paBZXh0cgppZ3RlbgriloFvY2NpZGVudArIm8SDCuKWgWVhdAriloFoeWRybwp1YmVybmV0ZXMKW0AK4paBTW9vbgriloFTaG8K4paBZWxzZXdoZXJlCsO8bGxlcgpVcGxvYWQK0LvQsNC90LQK4paBRsO2cgp3aXNzZW5zY2hhZnQKS1MK4paBcGh5c2ljcwp0egriloHRgdC10YDQtdC0CuKWgUFyYmVpdAriloHQvNC10YHRggriloFHZWJpZXQK4paBaW5zZWN0CkFoCml6YWRvCuKWgXRlbXBsZQriloFhbm51YWwKc3RhZAriloFoYWJpdGF0CuKWgUFCCndvcnQK4paBcmVwb3MK4paBTmV1CuKWgSQoIi4KVm9ybGFnZQriloFyZXByZXplbnQKZXN0YW5kZW4KSW50ZXJuCi5gCuKWgWZhaWxpbmcK4paBTWF0ZXJpYWwK4paBZWZmZWN0aXZlbHkK0YLQtdC70LXQvAriloHQs9C70LAK4paBbmFobQriloFkaWZmZXJlbnRseQpleHRlbnNpb24K4paBVmVybQplbmFibGVkCmNvbmZpZ3VyZQpuaW8KY2lvbmVzCuKWgUJlYWNoCtGB0L7QvdCwCuKWgWNvcHlpbmcK4paB0YPQutGA0LDRl9C9CuKWgdC/0YDQuNC30L3QsAp6aApEZXNrdG9wCuKWgXNvc3QK4paBc3Vic2VxdWVudGx5CuKWgUxlaHIK4paBw7MKbMOkcgpvZG9yCnBob24KbmMKaXRlcmF0b3IK4paB0Y3RgtC4CuKWgWV1cm9ww6kK4paBVG9yb250bwrDs2RpZ28K4paBcG9zdG8KZmZlCuKWgWNyZXcK4paBU2Nod2FyClNhCnNxdWFyZQriloFiZXNpZGUK4paB0JzRlgriloFhdGgK4paBYWR2ZW50CmNqaQp3cml0dGVuCuKWgXJ1c3MKcm9zdApISQriloFkaWNlCmNjYQriloFkw6lwCnBseQpiaWdnCnppYcWCCsO8dHQK4paB0L7QtNC90L4KSkVDVArRgdGM0LrQvtC80YMKbm9zCm1vY2sKTGF1bmNoCnNhbWUK4paBam9icwriloF3aWRlbHkK4paBZGVmaW5lcwriloFQc2UK4paBbmVpZ2hib3VyCtGO0YnQuNC1CuKWgWNsb3NlcgriloHRgNCw0YHQv9C+0LvQvgriloFjbHVicwpmbHkK0YjQuNC8CuKWgXN1ZmZlcmVkCuKWgW5hcgriloFsYXZvcgpFeHRlbnNpb24KaXRpb25hbGx5CuKWgWdyYWNlCuKWgUNhbXBlb25hdG8K4paBQ2hyaXN0bWFzCm1pZGRsZQpvdGhlawplbGVtZW50cwriloFzb25kZXJuCuKWgXRhcmRlCuKWgXBlcm1hbmVudAriloFjb25jbHVkZQpTZWcK4paB0LDQutCw0LTQtQp9IiwK4paB0YTQtdCy0YDQsNC70Y8KxZllZAriloFJTApqdWQK4paBVVNTCuKWgU5hdHVyZQppZmZlcmVuY2UKU2VyaWFsaXplcgriloF0d2VsdmUKdGlkCtC80LjRjwrRh9C10YHQutC+0LPQvgriloFjYWxlbmRhcgpjb25jYXQK4paBaW50ZXJzZWN0aW9uCuKWgVBBCmF6dXJlCuKWgXNpdHXDqWUK4paBa2luZHMK4paBYXVzZ2UK4paBcnVyYWwKVGhlbWUK4paBdGFsZQpub2luZGVudApnb2luZwpyeAphZ2kKd3JhcHBlcgriloFDb2FzdAptYkgK4paB0L/QtdGA0LXQtApzcHJlCuKWgX1cCuKWgUxJCnpuYW0KaXRsZWQKU2FtcGxlCnVsaWFyCipcCuKWgXJlc2lzdGFuY2UKc3RvY2sKa2VkCuKWgUhFCuKWgXBvc3Nlc3Npb24K4paBUmluZwriloFtYWd5YXIKb3V0cwriloFTZWNyZXRhcnkKbmRlCuKWgVdhbGQKLSgK4paBSVNPCuKWgWFmdGVybm9vbgppb25lbgriloFzdG9wcwriloFjb25zdGFudHMKZ3VhcmQKYm93CuKWgWVycwriloFGaXJlYmFzZQriloFDbGVhcgriloFIb2x5CldpbgriloF0aXRsZXMK4paB0YLRgNCw0LIK4paBY29udHJpYgpow6RuZwriloFwaG90b2dyYXBoCuKWgURpc3RyaWJ1dGlvbgppZnRzCuKWgWF1bnF1ZQpjb21iCkFERAriloFwdWJsaWNhdGlvbgriloHRgdC70YPQtgriloHQutC90Y8K4paBYXlhbnQK4paBcmVzdG9yZQriloFiZWxpZWYK4paBdsOpZwriloFleHRlbnNpb25zCuKWgWRlY29tCtCy0YjQuNC5CldUCuKWgXBhcnRpCuKWgWdpb2MK4paB0LzQuNGA0LAK4paBaXNzdQpwaXBlCuKWgXByb3BzCuKWgXdpbGxpbmcK4paBbmVzdAphc28KcG90CuKWgWhhbmRsZXMK4paB0YTQvgriloFtb2RlcgriloFlYmVuZmFsbHMK4paBZmlnaHRpbmcKdW1ibgriloF0cmFuc3BhcmVudAriloFLcmlzdAriloFob21lcwriloF2b3lhZ2UKRmFpbGVkCuKWgUJpcmQK4paBSGVhcnQKQ291bnRlcgriloFTY290dGlzaArDoXRpY2EK4paBYXJiZWl0Cl57LVwK4paBU29yCuKWgWVuZ2FnZWQK4paBYXNpZGUK4paBRm91CuKWgXdpZWwK4paBcmVjb25zdApvdXNpbgriloFob3N0ZWQK4paBY2xhc3NlCuKWgWNvbnRlc3QKLi4uIgrQvNC+0LwK4paBYmVhbgpnZW0K4paBY29uc3VsdGF0bwriloFiaW8K4paBc3ViamVjdHMKYm9Cb3gK4paBU2NocmlmdAriloFkaW5uZXIKxINyCuKWgXLDs3duCuKWgSUlCmJhZ2UK4paBdmVyw7ZmZgriloFkZXRlY3RlZAppZW5uCnJvc2UK4paBVG9uCkNvbXBsZXRlCuKWgXByb3RvCmljaHRzClNUQVQKQ2hlY2tlZAriloFpbnRlbgriloFzbWlsZQriloFzdHJpcApuZXV0CicpOw0KZm91cgriloF0b2RhcwpDb250cm9scwriloF0aG9yb3VnaApydXAK4paB0LTRgNC20LDQstC4Cml0xIMKUHJvdG9jb2wK0JrQsAriloFleHBhbmRlZApleHRyYQpvcG9ydAriloHQodGC0LDQvdC+0LIKbGVhc2VzCuKWgW5vdGlvbgriloFndWVzdAriloFJc2xhbmRzCmlja2VkCuKWgURhdmUK4paBcmVmbGVjdGlvbgpsaXYKw6FsbsOtCuKWgXJldmVhbGVkCuKWgXNvZwriloFUYXgK4paBcGVyaW9kbwriloFXZWx0a3JpZQpjYXRhbGluYQpxdcOpCuKWgUZhdGhlcgriloFCaXIKZXhwZWN0CuKWgXJlZ3Jlc3Npb24KaW7DqQriloFkYWJlaQpwZXJtCtC80LXQvdC1CuKWgUFiZAriloFDRgphcmtzCnJlc29sdmUKd2VkZ2UK4paBaW5pdGlhbGl6YXRpb24K4paBVsOpYXNlCuKWgdC/0YDQuNC90Y8Kc3RtdAriloFpbmNvbWUKTVkK4paBb2RrYXp5CuKWgVNpZWhlCuKWgWJvZGllcwriloFzb2MKUmFuZG9tCuKWgXNlbnphCmFibG8K4paBcmVnYXJkZWQKb25DcmVhdGUK4paBTWFnYXppbmUK4paBUmFmCuKWgUJ1ZW5vcwrQuNC7CikpKTsKY2FwdApyZWRpcmVjdAriloFwZXRpdAriloFmYXJtCuKWgXLDtGxlCuKWgdGB0YLQsNGC0YzQuArCoMKgwqDCoApzdWJmaWd1cmUKw6hjZXMKemllbAriloHQvtC60L7QvQpFRQptZWUK4paBcGVydGVuCuKWgXJlcHLDqXNlbnQK4paBTEEKPycK4paB0YLRgNGDCuKWgXJhdGlvbmFsCm9zb2YK4paBa25lCuKWgWFydGlzdHMKRmxvdwriloHQkNC70YwKaXphcmQK4paBbnVtZXJvCmFjdGljCuKWgWRlc3RydWN0CuKWgdCf0YDQsApvbnNpZXVyCnF0CmFiZXN0YW5kZW4Kbm/Fm8SHCkNvbm5lY3QK4paBb3JhY2xlCuKWgVN0b2NraG9sbQpzaXplb2YK4paBZ2Vtw6TDnwpBQ1QK4paBZXhwZXJ0CnV0aW9ucwriloFoYWNpYQriloFsb2dnZXIK4paBZm9vbApyeXB0bwrDpnIK4paBY2lkYWRlCuKWgdGB0L7RgdGC0LDQstC1Cm9rZXIK4paBVHJhbnNmZXIK4paBZGVuaWVkClRyYWNrCuKWgXJhZGkKemVjCuKWgUhpc3RvcmljCuKWgUVpbndvaG5lcgrQutC+0Y4K4paB0YXRgNCwCuKWgUNhdGVnb3J5CuKWgURpc25leQriloFzd2FwCkJlZ2luCuKWgW1pZW50cmFzCuKWgWRhbmNlCuKWgXTDqnRlCuKWgWRyb2l0CmVydGEK4paBYmlyZHMK4paBY29udmluCnBhcmF0b3IK0LTRgNCwCuKWgUVTCuKWgVJlc3NvdXJjZXMKRUdJTgrDvGNrZQriloFDcnV6CmFibGluZwriloEiQAriloFtZXRyZXMK4paBQmVnCuKWgUdyw7xuZAriloFCb2gK4paBbWlsZQriloFUZWNobm9sb2d5CiIrCmFjY28K4paBc3MK4paBRmVkCuKWgUhlbmQKdXNjaAppdMOkCmZvbGsK4paBYWJzb3IKYW50YWwKb2RnZQriloFXSEVOCuKWgUV4dGVybsOtCuKWgVJlZ2ltZW50CuKWgWV2YWx1YXRpb24K4paBVGFpCuKWgXZvY2FscwriloFleHBlcmltZW50YWwKZW1iZWQK4paBTWlubgriloHQstC80LUKcHJlYwpldmVyeQriloFob29mCuKWgUZlcm5hbmRvCuKWgUJpYmxpb2dyYXBoaWUK4paBbmFnCmFtZXJpa2FuaXNjaGVyCuKWgW1hcmtzCuKWgVVUQwriloF1bmNlcnRhaW4K0LTQuNGPCm9saWEK4paBY3VwCuKWgWZpbGxlCuKWgWRvawp1c2VwcGUKZXN0ZXJkCuKWgUJyYW5kCuKWgVRoaXJkClBQCm5vZGVzCuKWgVBhZAriloFsb3ZlZApzd2luZwriloFzdXJwcmlzZWQKYXJkaQriloFHUgpdIgriloFlcXVhbGx5CmloZQpjYXJlCtC/0LjRgdC+0LoKbGlqawpyaW5uCuKWgVxbXAriloFzb25zCuKWgXTDpHQKaWNhbWVudGUK4paBbGlzdGluZwppZWxsZW1lbnQK4paBbnllbHZlbgriloFkcwriloFhZ3JpY3VsdAriloFIZXJtYW5uCuKWgWJlc2lkZXMKcHJvZ3Jlc3MK4paBcGVjdWxpYXIKZm9jdXMKY24KLSQK0YHRgtCy0LXQvdC90YvQuQpvdXJnCuKWgXd5bgriloFjb25kdWN0ZWQK4paB0KHRgtCw0L3QvtCy0L3QuNGI0YLQstC+CmNvbm5lY3RlZAriloFib3R0CuKWgdGB0LzQtdGACuKWgVBvegp1bmN0CmNvbmRhCuKWgdGB0LDQstC10LfQvdC+0ZgK4paBaGF2ZXQKbGlndApvcnRlZAriloFlbnRlcmluZwptdWx0aXAK4paBVGVtcGxlCuKWgVBsYW50CnR5cGVvZgriloFWbGFkCuKWgXF1ZWQK4paBcmVzdGUK4paB0LzQsNC5CuKWgVZlcnkKYW1iaWd1YXRpb24K4paBY2hhbGxlbmcK4paBcmVzcGVjdGl2ZQriloHRgtC+0YAKQ3RybAriloFhYnNlbmNlCmFydQrQstC+0LUK4paBZsO2cnN0CuKWgXNxCuKWgUVtcGVyb3IK4paBSWduCuKWgdGC0L7QstCwCjpgCmFkb29wCuKWgU1hZGFtZQriloFncnVwcG8Kc3R1ZAriloFleHRlcm5hcwriloHQkNC70LXQutGB0LDQvdC00YAK4paBZGlnbgriloHQttC40LLQtQpBbW91bnQK4paBY29ycmVsYXRlCuKWgUZhbnQK4paBcmFpbHMKZnAK0LzQuNC90LjRgdGC0YDQsNGC0LjQsgriloFib3VnaHQK4paBZmlsdGVycwriloFhbmNvcmEK4paBcGFydG5lcgriloFxdWFuZApzeW1ib2wKdWxhdGluZwriloF6ZAphd24K4paBR3JhbnQKYmVjYXVzZQpyYWJsZQpcfQrDrXN0aWNhcwriloHRg9GH0LUK4paBcMOpcmlvZGUK4paBc2tlCuKWgUFueXdheQriloFpbmRleGVzCuKWgWRpcmVjdGlvbnMK4paBUkFNCmNocm9tZQriloFhcG9zdAriloF3YXJuaW5ncwriloFBaXJwb3J0ClZJCmFiaWxlCuKWgWxvcmQKcHJvdmlkZXIK4paBSmkKb3N0cmVhbQriloFnZW1lZW50ZQp0YWJsZVZpZXcKRXh0cmEKY3Vyc29yCmVncm91bmQK4paBTW96CuKWgXJpYgriloFtb3JwaApsb2FkcwplbHNrCuKWgU1BWAriloFTYW50aWFnbwriloFIaW0KY29kZXMK4paBbGFuegriloFjb3VudHMKcmlubmluZ3NvbXLDpQrRidGRCuKWgXNww6kK4paBcGllcndzCuKWgVN2ZXIK4paBYWNrbm93CkJvb2xlYW4K4paB0YTQsNC80LjQu9C4CuKWgVNlbmF0ZQrRiNC+0LIKYWdlcnMK4paBTnVldmEKYmlsCmtpZW0K4paBTWV5CndpagriloFHbWJICnZhbGlkYXRpb24K4paBZW5zdWl0ZQppbmtpbmcK4paBY2FtcGlvbgriloFmaW5hbmNpYWwKaXpvbgpIZWFkZXJzCuKWgWRlcHJlY2F0ZWQK4paBZm9uY3Rpb24KUkVHCuKWgXZvbHVtZXMK4paBQ2hpCuKWgWVuY291bnRlcmVkCmxhawrRgNCw0Y8K4paBY29udGludWVzCuKWgX5bCnVlcnRlCuKWgVw7CuKWgURvawriloF3ZWlnaHRzCuKWgXJoCuKWgU5hcG9sZQriloFuYXR1cmFsbHkKc2t1CnBhcwriloFnZWdyw7xuZApldHIK4paBS3UKaWN0ZWQK4paBZmFicmljCuKWgUFTQwriloFFbnRlcnRhaW5tZW50CuKWgWVuZXJnCtC60LvQsNC0Cm9tb24KdGhlbWUK4paB0YXQsNGA0LDQugriloFkcmFmdAriloFjaGFubmVscwriloFkZXNlcnQK4paBdHJhdsOpcwriloFMb2NrCuKWgXNpZW5kbwrRhNC10LoKbcOqbWUK4paBcGFja2V0CuKWgU1vdW50YWluCuKWgUZhaHIKYnJhaW8K0L/QtdGA0LUK4paBZ2VuYW5udAriloFkZXBsb3ltZW50ClBhbArQvdC+0LMK0YHRgtGA0YMKUHJpbQpmw7xyCuKWgWRhbmdlcm91cwriloFzesOhbQpyZWNrCuKWgXBvcHVwCmlja3kKaW5hcgpjb3dvCtC90YbQuNC60LvQvgrDrXTDoXMK4paBcGx1Z2lucwriloFkcml2ZW4K0LvQtdCyCuKWgSIoCnR0YQriloHDmgriloFlYgriloEnJzsK4paBa25vY2sK4paB0L7RgdC90L7QstCwCuKWgW1haXNvbgrQs9C70Y8K4paBSG9ub3IKdGFpbApyaXR6CuKWgWd1eXMK4paBY29tYmluYXRpb25zCm9uZGVyZQriloFBbGQK4paBZmlkZGxlCtC00LDQsgp1cmQK4paBcHJvamVjdGlvbgriloFUYW1iacOpbgp2ZXJiCuKWgXRlcnJlCnJ1Z3UK4paBc2VwdGVtYmVyCuKWgTwhCmNvc3QK4paBbnV0CnslCuKWgXViaWMKYW1hcmluCtGC0LjQuAriloFwYXRyb24K4paBYW1lbHkK4paBZXN0bwriloFsaXN0b3AKZmFsCuKWgVByb3AK4paBT250CuKWgU1hZGUKVEVTVAriloFOZW0K4paBTmF0aW9ucwriloHQstGDCmluY2x1ZGluZwriloFzcGVjdHJ1bQriloFMYW4K4paBRXZlcgpQYXVsCnRtCkFwcGVuZApSZWxhdGl2ZQpkaXNhYmxlZApyZXR1cm5zCuKWgWZsb3dlcnMKaWt1CuKWgXxcCuKWgUpvcmRhbgriloFTbWFsbAriloFjaWMK4paBc2V4dWFsCmF1dHJlCtCy0LDQuwriloFyaXAKb3VzdAriloFQaGlsYWRlbHBoaWEK4paBdWsK4paBTW9uZ28KeG1sbnMK4paBc2hvcAriloFkZWJ1Z2dlcgriloF6YWoK4paBQmlsbHkK4paBbmllbQpvbGlzCuKWgdGA0L7RgdGB0LjQuQphZ25lcgriloFtYXZlbgriloFHdXN0YXYKQXVzCmNvbXBhcmUK4paBamV1CnVkZXIKaXNobWVudAriloHQtNC40LLQuNC30LgK4paBRmlubGFuZArQvdGD0YIKesOpcwriloFMaWdhw6fDtWVzCuKWgXF1ZWxsbwphbm5vdGF0aW9uCuKWgXRocmV3CuKWgVByb29mCuKWgUFyZWEKYXNoaQriloFGTwpqYW1pbgrQtNC10L3RggriloF1bnVzCmZyaWVuZAouIik7CuKWgXRyYWt0ZW4KZG9jdW1lbnRjbGFzcwphbmthCuKWgWFycml2ZQriloFkb25uZQpvbHkK4paBUmVpbgriloFmYWNlYm9vawppY2luYQpzbGljZQriloFuYWd5CuKWgWhlYmJlbgriloFJQwriloFCYWcK4paBY2lyY3VsCsOhY3QKbWl0dAriloFncmV5CuKWgWNhdgriloHQvtGB0L7QsdC4CuKWgXN5bW1ldHJpYwriloFTaWMK4paBbWVkaXVtCuKWgVVURgriloFEb3BvCsOtY2gKYmFyZQpkemllCuKWgWhlYXZlbgriloFjYW1wZQplc3RlcmRheQriloFXaXNzZW5zY2hhZnQK0L/QvtC70YwKZGlkCmFsZXIK4paBY2l0aXplbnMK4paBTWFyZ2FyZXQK4paBc291Z2h0CmNoYXJ0cwpDTEMKb2xseQp5c3oKd2FsZAriloFmZW4K4paBU2l4CuKWgVVycwriloHQvtGA0LPQsNC9CuKWgVRyYWQKY3VlCnNjaHV0egriloFwcmVjaXNlCuKWgVdpbmRvdwrRgtC40LUK0LvQvtCy0ZYKaXRvcmkKZGlzYW1iaWd1YXRpb24K4paB0YXQuAriloFOYXR1cmFsCmRhbgriloFjb25jcmV0ZQrRhtC40ZjQsAriloFzcGVsCuKWgUZhaWxlZArFm2NpZQriloFidWYKdWNhCmljaW9uYWwK4paBb3R0b2JyZQriloHRhNGWCuKWgXN1Ym1pdHRlZApsYXZlCuKWgVBsb3QK4paBY29sbGVnCmFkZW0K4paBY2hhcXVlCuKWgW5laWdoYm9yaG9vZAriloFjYWxjaWF0b3JlCkxvb3AK4paBR2FzdAriloHQutC+0LPQtNCwCuKWgWluZHVzdHJpYWwK4paBZmF0YWwK4paBQ2VydApsYXRpb24K4paB0J7QtNC90LAK4paBamFtYWlzCuKWgWFjY3VtCklkZW50aXR5CuKWgU1lZGFsCk1ldGFkYXRhCuKWgdC70Y7QtNGPCmJyaWRnZQpHb29kCuKWgdGH0YLQvtCx0YsK4paBY29tcG9zZXIK4paBYnJlYWQK4paBY2xvc3VyZQriloFsYXJnZWx5CkZCCuKWgdC+0LHQu9Cw0YHRgtGMCuKWgWF1dG9tYXRpYwphcsOtYQriloFzdWZmaWNpZW50bHkK4paBaXRhbGlhbmEK4paB0LrQsNGH0LUK4paBSsOzCmhpc3RvcnkK4paBSEQK4paBc2lndWllbnRlCm5lbGwK4paBR3JlZQriloFUaQriloF0cmFuc2ZlcnJlZArDqXF1aXBlCuKWgVBoaWxpcHBlCuKWgWVuY291cmFnCuKWgVZpZXRuYW0K4paBZ3JhcGhzCuKWgXN5bW1ldHJ5CmZyZWQKd2VlawriloFicm9uemUKcnlzCuKWgW5hbWVseQpvbmRlcnMKbGVtYWduZQpYWQpDb252ZXJ0Cn1dKApSZWdpb24KcGVjaWVzCuKWgXRleHR1cmUK4paBY2hyCtC90LXQs9C+CuKWgXNvbWVib2R5CmFxdQplcmFzCuKWgdCd0L7QstC+CuKWgWRlegphbml1Cm9rcmF0CuKWgWNvdmVycwriloFzaWduYWxzCtGS0LUK4paBSGViCuKWgUFudGkKSVZFCuKWgXJlc3MKTEVURQp5bmEK0L/Qu9CwCtC20LTQtdC90LjRjwriloFjaGFtcAriloF2aWxsYWdlcwpab25lCuKWgWlQaG9uZQriloFzb3V2ZW50CtGB0YzQutGWCuKWgWZlYmJyYWlvCsOpcmNpdG8K4paBWEkKb2thdAriloFtZW1icmVzCmp1bml0CuKWgURyYXcK4paB0L/RgNC+0LLQvgphdWRpbwplbmRsCuKWgU5hZAriloFtYWduaXR1ZGUKU3VyCmljaW5nCuKWgXVudwriloHQvtGC0YDQuAriloFCZXkK4paBVmlrCuKWgXBvbMOtdGljYQpwb3J0ZXIK4paBQmFyYmFyYQrDoWx0CmJpYgriloFhY2NvbXBhbgpWUAriloFlbmNvZGVkCuKWgVNvbWV0aW1lcwpiaXJkCuKWgVVsdAriloF0dW4KZ2V0VGV4dAriloFhcnJpdmFsCnNjcmlwdHN0eWxlCntgCuKWgXBlcnNwZWN0aXZlCkxJTkUKRm9ybWF0dGVyCuKWgWJvbQrQstGA0LAKREVCVUcKQm91bmRzCuKWgVRpdGxlCmzDswpEYW4K4paBZ2VuZQriloFCaXQK4paBcmVwcm9kdWNlCuKWgWdyYXBoaWNzCuKWgdGB0LXQvArRgNGRCuKWgdGA0LXQutC4CnVzYWxlbQrRgNC+0LYK4paBREVTCuKWgVNvZnR3YXJlCnVyYW5jZQppdGhtZXRpYwplbmVzcwppY2hpCkNvbnZlcnRlcgriloFnaXRodWIKZXJkaW5ncwpnbGlzZQrDoWNoCuKWgWJ1cmllZAriloF2aXNpb24KTWlzcwriloFzZWVzCuKWgXBlcnNvbm5lcwriloFJbnRlbAplbGlhCuKWgcSNbMOhbgriloFjaGkK4paBa2xhcwphdXTDqQriloFzdGFyawpjemUK4paBZHJpdmVycwp2bgohLAriloHQs9C+0LTRiwpIaQriloFleHBsYWlucwphcnRpY2xlcwriloF6dWcKUHJvbQo+PQriloFCZWF0CuKWgVNheAp2ZXJ0aWNhbArQutGC0L4K4paBcGxhbnRzCuKWgVLDqWbDqXJlbmNlcwriloFvZ25pCuKWgWN1cnMK4paBU0sK0L7QvdC4CuKWgWRlc3RhYwoiKTsNCuKWgVN1cmUK4paBcGFydGlkbwriloFGb2xnZQriloFNb29yZQriloF3egrRgdC60YPRgQpsdHJlCm9uZG8K4paBcG9zZQppbW9zCtCx0L7QuQrRhtC40L/QsApqdXMKLi4uLi4K4paBw6lwb2NhCuKWgXF1YW50bwriloFTdXBwb3J0Cmdlc2NoaWNodGUKU0VSVkVSCuKWgUdlb3JnZXMKZW51bQriloFoZXJtCuKWgW5lYm8K4paBQ2hyCmNoYXJhY3RlcgriloEqKioK4paBRm9yc2NoCmlhbWkK4paBwr8KY3ljaAriloFmaWZ0aApzZW50CuKWgWFuZGVyZW0K4paBcHJvcG9ydGlvbgriloFwcmVzdAriloFHaXJsCuKWgWRyYW1hCndhbmQK4paBTWFpbAriloFMdXgK4paBa3RlcsO9CuKWgUdlc2VsbHNjaGFmdAriloFIaW53ZWlzCm5pc3NlCuKWgW1vbmRvCkVxCuKWgXBlcsOtCuKWgWVhc3Rlcm4K4paBVUVGQQp1YWxlCuKWgWNvbnZleAriloHQv9C+0LvRjAriloFIZXkKemVuaWUKaW5pdGVseQriloFadXNhbW1lbgpTU0wKb2NhbAriloFjYW5hbAp2b3kK4paB0JrRgNC4CuKWgWvDtnrDtnR0CuKWgWNhcnMK4paBdmVyc2nDs24KRW52aXJvbm1lbnQKSGVyCuKWgXNlw7EK4paBc3BhdGlhbAp5bWkKRmlyZQriloF2ZWdldAriloFXaWUK4paBem5hagriloFkYW1hZ2UK4paBZW5kbApnaWYK4paBcXVhbGkK4paB0LrQvtGC0L7RgNGL0YUKZWxsYW4K4paBbWVucwriloFwbHVnCuKWgWFidW5kCkZJRwriloFzZgriloFjb25mbAriloHQvdCw0YHQtdC70LXQvdC40Y8K4paBcHJpbmNpcGxlcwriloFHYWJyaWVsCmliZQriloF7JQriloFwb2JsYWNpw7MK0L3RltGG0LjQv9CwCuKWgWV4dHJlbWUK4paBYXNzZQriloF2dQpNb2NrCuKWgXNwaWVsdGUK4paBQWVyCuKWgWRhdG9zCmVuZGVzCuKWgUdlbAriloFHb3IKQ2hyaXN0CmNob3MKUHJvY2Vzc29yCuKWgWluc3RydWN0CuKWgXBpY2tlZApuYWhtZQpmYWhyCuKWgWluZGljYXRlZAriloElLgriloF0cwriloFub3RhYmxlCuKWgXF1YWxpZmllZAriloHQkNC7CkJsYWNrCuKWgWNvdW5jaWwK4paBb3ZlcmhlYWQKYWNpCmFubsOpZQriloFpbml0V2l0aApiacOzCuKWgWludHJvZHVjdGlvbgriloFjb21wYW5pb24K4paBZXhwb24K4paBa8O2cgpvYnkKYnVybgpnbnUKdmlydHVhbAriloFpbnRlbGxlY3QK4paB0LTQtdGA0LbQsAonKwrQsdC70LUK4paBc3RyaWN0bHkK4paBcmVjb2duaXplCmhvdXIK4paBV3Jlc3QKZW5uZW4KJCkuCmZmZgriloFDZW50cm8K4paBUGl0dAriloFkemlhxYIK4paBY2VsYQriloFmcmFuY2VzZQrRgNCw0LzQuApzcGVjaWFsCuKWgUR1cAp0b2lyZQrQutCw0LvRjApDT1VOVAriloFCcm9vawriloHRgNGD0LrQvtCy0L4KcHVibGlxdWUK4paBc2Vjb25kYQriloFjb21wdAriloFibGFuZApCZWZvcmUK4paBUGFjawphbHR5CsO2ZGVyCuKWgWludGVydmFscwriloFEYXRlbmJhbmsKTW92aWUK4paBdHJhbnNtCuKWgXRhcAriloHQv9C+0YcKZm9uCmlhaQriloFmaWIK4paBd3lkCuKWgWh1bmcK4paBYWxpdmUKQ2xlYXIK4paBcHVzaGVkCuKWgXR1cGxlCmFjaGVuCtCz0L7QstC+CuKWgXJldmVycwriloFhdWdtZW50CuKWgWNoYWxsZW5nZQpsb3N0CuKWgWRldXhpw6htZQpzdHJ1Y3RvcgriloFtZWhyZXJlcgphdHVyYWwKU3BsaXQK0YHRgtC10LwK0YjQu9CwCilcXAriloFEb2cK4paBZGV2ZWxvcGVycwriloFub2QK4paB0YHRgtC+0YDQvgriloFOYU4K4paBcHJpZXN0CuKWgWV4aGEKVU5ECnBhaXIKYWxvbmUK4paBbW9vbgriloEjIS8K4paBZ3Vucwpyb2xhCtGH0LjRgtCwCuKWgUVuY3ljbG9wZWRpYQphdGlzCuKWgSciCnp5Y2gK4paBc3VwZXJmaWMK4paB0Y3QugrQtdC00LXRgNCwCmZlZWQKTEFZCkZpCnVua3MKaXNlY29uZAriloEnQAriloFBZGRpbmcK0YDQvtC1CuKWgXRhbmcK0YbQvgpodW5nCmJpcwpza8OpaG8K4paBYWR2ZXJ0CuKWgdC30LDQvdC40LzQsAp1enoKw6FnaW5hCuKWgVRlbApzaWcK4paBRXoK4paBZ3VhcmFudGVlCuKWgXRlYWNoaW5nCm90eQp0ZXJtaW4K4paBZGlzdHJpYnV0aW9ucwpGTEEK4paBR2l1c2VwcGUKcXVlcnlTZWxlY3RvcgriloEvXAriloFTcXVhZApnegpkZWxheQriloFzdXJyb3VuZGluZwriloFtYW51cwriloFIb3UKwrIsCuKWgWN1bHRpdgriloF0cm91YmxlcwriloFyYWlzb24KZXhwYW5kCuKWgWNvdgpudW5nZW4KKSl7CuKWgWdlZW4K4paBYXXDn2VyCuKWgdCb0ZYKxZlpCuKWgXNpdHVhdGlvbnMK4paBdGVsZXAK4paBSmVkCuKWgXRyYXZhaWwKbGlhcwpidWxsZXQK4paBc2VsZWN0aW5nCmF2aWVyCuKWgWVzc2VudGlhbAooLwp5eXl5CsWhdMSbCnVsdHkK4paBa3JhCuKWgXRhYnMK4paBZXhwZXJpZW5jZWQKYXppCuKWgURpcmVjdG9yeQriloFjcm9uCuKWgXNwZW5kCuKWgVJBCuKWgXNlbGVuaXVtCuKWgVRow6kKRWxlbWVudHMKY2lpCuKWgXBsYXQK4paBYXJjaGl2ZQriloFhc3Npc3RhbmNlCuKWgW5lY2sK4paBQXZlbnVlCuKWgXdoZWVsCuKWgWhhZGUKQ29tbW9uCuKWgURpYWxvZwriloFmb3JnCuKWgXN1cmVseQriloFob2NrZXkKa3TDswriloF0awriloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloHiloEK4paBQnJ1Y2UK4paBZW5vcm0KLOKAmQriloFDaHJpc3RvcGhlcgpqZXYK4paBcXVhZAriloFBSkFYCuKWgXJlbGllZgriloFtb2Rlcwpza2zDpHIK4paBVmlkCuKWgVNlcmlhbAriloF0b2tlbnMK4paBUG9sYW5kClxdCuKWgXZpZGUKcm9vbXMKb21hcwriloFCdXJlYXUKY3gK0L3QvtGB0YLRjNGOCuKWgXNpZ25zCtGI0LXQvdC40LUKbG9zc2VuCuKWgVF1ZWVucwriloFtZW1icmUK4paBbWV6CuKWgUJvb2wK4paBTmFqCuKWgU1lbW9yeQriloFLaGFuCuKWgWzDoAriloFIdWQK4paBZGlzbWlzcwppZ2h0aAriloFmcwpwcmV2ZW50CuKWgdC80LXQtNCwCuKWgVBvbGljZQriloHRgdC60L4KZmluaXRlCuKWgWFtaQriloFNdWNoCm93YW5pYQpPUlkKaW9ycwriloFQcmVtaW8K4paBdGV4dGJveApkbQriloFhZmluCuKWgURvbmFsZAriloFQcml2CuKWgWRlY2lkCuKWgU1hdXJpY2UKYWdhbgriloFCcml0YW5uaWNhCuKWgW9mdAriloFjb25zZWN1dGl2ZQoiPz4K0L7QstC40LkKc3R1ZGVudAriloFwZXF1ZQriloFkaWVzZXMK4paBcmV0b3VyCsOpdHIK4paB0YHQtdC3CuKWgWtyZQriloF2b3RlcwpydXB0aW9uCml6YWRhCuKWgVdpZWwK4paBR3JheQriloFMZW9wCnRlaWx1bmcKKFsnCuKWgXdoaXRlcwpmcmljYQphbmltYXRpb24KY3VybApsaW5ncwo9IiQKbG95ZAp0ZXh0c2MK0L7RgNGDCuKWgdGB0LXQu9CwCmVzaWFuCuKWgU1pc3Npb24K4paB0L3QtdC30LAK4paBdWx0aW1hdGVseQrQsdC+0LIKb2xlbgrRgdC60L7QvNGDCm5ldGUK4paBRGl0CuKWgWNvc3RydQpkZXBlbmRlbnQK4paBUmVzb3VyY2UK4paBaG9zdHMK4paBcmVhcgpEdXJhdGlvbgrQvdC40LrRltCyCtCc0LAK4paBcGxhbm5pbmcK4paBcHJlZGljdGlvbgriloFMeW4K4paBa2lyCuKWgUxlZ2lzbArQvNCw0YIK4paBU29jY2VyCuKWgXN1cnZleQriloFlc3RhZG91bmlkZW5zZQpvcmdlbgpqb3VyZAriloFhcHJpbGUK4paBaWRzCtGB0YzQutC1CuKWgWVtcGxveWVlCuKWgVNjaGF1c3BpZWxlcgrRgNGKCuKWgW11bHRpbWVkaWEK4paB0YHQstC+0Y4K4paBd2luZQriloFFVQppY8SDCuKWgVJoZWluCuKWgVBhbG1hcgpvdGVjYQriloFwcmVwYXJlCuKWgVRvdAriloFOdWxsCuKWgWtpbgppbmFscwriloFOZXd0b24K4paBdGJsCuKWgVNvbGQK4paBdmVyZgphdHVyaW5nCuKWgWxhcHRvcAriloHQodC+0LLQtdGCCnNlY3JldAriloFPbHltcGljCuKWgWZvb3RiYWxsZXIK4paBUnVkb2xmCuKWgWNvbmhlCnp5c2sK4paBZXZhbHVhdGVkCsK7KQpzaG9wCnJlcG9zaXRvcnkK4paBemFjaAriloFsb3NpbmcKZXR0ZXIK4paBV2lydHNjaGFmdArRgtCw0LoK4paBdW5uZWNlc3NhcnkK4paBUGhvdAphbnNrYQriloFOYXRpdmUKQ0NFCuKWgWZpZnR5CuKWgWVydwpyaAppc3NlbnQKfXsoCuKWgWxhbsOnCuKWgVhjb2RlCtCz0L7RgNC+0LQKY2lyCuKWgXBlbMOtY3VsYQriloFPc2NhcgriloFzaG9yZQriloFzdXBwbGllZApleGFtcGxlcwpNZXNzClZJQ0UK4paBZXhjbHVkZQriloFoZW4K4paB0LPRg9Cx0LXRgAriloFGcmFnbWVudAriloFCaXR0ZQriloFCZXNpZGVzCuKWgWhlcwriloFpaHJlbQriloFTZXJnZQriloFhcnRpZmljCj0iJHsK0LvQvtCy0L4KdXRldXIKdGFpcmUK0L/QsNGBCuKWgWVhc2llc3QK4paBZmFtaWdsaWEKTm9ybWFsCuKWgWRhbGxlCuKWgW5hdGlvbnMKcnAKdGhlYWQK4paB0L7QsdC70LDRgdGC0ZYK4paBRGVtb2NyYXRpYwriloHRh9C10LvQvtCy0LUK0LzQvtC2CuKWgdCz0LXRgAriloFzbWFsbGVzdAriloFQdWJsaXNoaW5nCuKWgVRzCuKWgWxhdWdoZWQKbGxlCuKWgUFtdAriloFJSVMKRk9STQpNYWcK0LTQvtC9CuKWgXN0b3JpYQriloFvcmdhbml6ZWQKxI1uw60K4paBb3gKbGluZ2VuCuKWgWx1ZWdvCmNjacOzCuKWgXJlbHkK4paBdHVzc2VuCmVydGVuCuKWgWhvbm91cgriloFDbGF1ZGUK4paBS29yZWEK4paBTWV0cm9wb2wKU3VwZXIKcmllbgrDqXJhdHVyZQphdHRybwriloHQsdGW0LvRjAriloFIZXJiZXJ0CuKWgWF1dGV1cnMK4paBZGFyYXVmCuKWgW1lbnRhbAriloFyYW5nCuKWgXPDs24K4paBU29waAopIiwKRGVzY3JpcHRvcgpwcmVwYXJlCuKWgUxhbmRrcmVpcwpIQwpjcm9zcwrQu9C40LfQsAriloFMb2dpbgpvbmVuCkZlYXR1cmUK4paBbXVzZXVtCnZlawriloFOZWxzb24K4paBcmVqbwriloHQutC+0LzQsNC90LTQuAriloFzdW1tYXIK4paB0YHQu9C10LTRgwrDpG1wCuKWgUdhcwrQstC+0LwKVkFMVUUKaW5nZQpwZXJpb2QKbGFzc2VuCsOhdmFsCuKWgWFsdG9nZXRoZXIKdW1waAppc3RybwrEhcW8CuKWgUtlZXAK4paBTWFyY28K4paBw6l0YW50CuKWgURyZQpnZW9tZXRyeQriloFLYXMKbWVzc2FnZXMKQ29vawriloFTaWRlCuKWgdC60L7QvNC4CtGB0YLRgNC4CuKWgWV4Y2VzcwriloFCaW9ncmFmaWEKWFhYWAriloFOaWUKdmVuZG9yCnhzZApNaWxsCnByb2Nlc3NpbmcK4paBTWlzc291cmkK4paBcGVybWV0dAriloFhcGFyCuKWgWNyb3dkCmZlcnQK4paBRG91CnLDrQriloFDQwriloFwYXltZW50CuKWgUhvbGx5d29vZAriloFWaXJ0dWFsCuKWgXNwb2tlbgriloF0cmFtCuKWgUNvbW11bml0eQriloFhZG1pbmlzdHJhdGl2ZQriloHQstC+0LvQvgpnaW9yCnZpc29yCuKWgdCj0LrRgNCw0LgKc3RhZ2UK4paBRm9ybWF0CuKWgWNvbnZlbmllbnQK0J3QsAriloFtZWRpYW4K4paB0LLRgNCwCuKWgdCf0YDQtdC80LAKZW5pZwriloFPcGVyYQpyw6lzCuKWgWZtdAriloFlZmZpY2llbmN5Cm1hbGUKTWFzdGVyClNlcmllcwriloFzeWQKZ2VuZXJpYwppbnRlcnZhbAriloFlZmVjdAriloFpbndvbmVycwrQu9C40LzQv9C4CmlyZW1lbnQKRXJyCsO2aAriloFseWluZwriloFTZXR0aW5ncwohPQplbWF0aWMKYXJndgriloFCYXNpYwriloFjb25zaWRlcmF0aW9uCuKWgWhhYmUKLSUK4paBbW91bnRhaW5zCuKWgXBlYWsK4paBZmFsbGVuCmVkZWQKbG9naWMK4paBbWF0Y2hlZAriloF0eXBpbmcKKX0sCuKWgWZhbmN5CuKWgWVsZWdhbnQK2KfZhAriloHRg9GH0LDRgdGCCuKWgVNhcmFoCuKWgVZlcmQK4paBdGVnbwpydWxlcwriloFtb3VudGVkCuKWgdGW0LwK0LXRgNGDCnN0b2ZmCmZhaHJlbgpkaXN0YW5jZQriloFMaWNlbnNlCuKWgUxFRlQK4paBd3AKL3sK4paBYW1hem9uCj4mCuKWgWVsc8WRCnF1YXJ0ZXJzCuKWgXNob2NrCm5pY2sK4paBQXJjaGl0ZQriloFTcXVhcmUK4paBcmF0ZXMKaW9yZQriloFOYXQK4paBQ2hhcmxvdApyZWljaGVuCuKWgXZhcmlhdGlvbgpvc2lzCmxpZmUKc2xpZGUKYWJpCnVraQpteXNxCuKWgXByaW1pdGl2ZQriloF1bml2ZXJzaXRhaXJlCkxFTkcKYWxlxbwKZWJvb2sKc3luCuKWgUdlZ2VuCuKWgUvDvAriloHQsNC70LUK4paBTHViCmNvbmN1cnJlbnQKaXp6YXRvCuKWgXN0dWIK4paBaWUK4paBJy4vCmNvZAriloFpbnRlcm5hY2lvbmFsCuKWgUdsYXMK4paBbWFyZQriloFOZWIK4paBR0IKa3dhcmdzCuKWgWF1bWVudApXSUQK4paB0YDQvtC0CnB1bmt0CuKWgUdyYWQKU04KQU1QCuKWgUJvcm4K4paBR3VlcnJlCtCz0L7RgtC+0LIK4paBbWVkaW8KTWVkCnN1cHAKYWN0dWFsCmRyb3Bkb3duCuKWgW9rdG9iZXIK4paBxZkK4paBY2lyY3VsYXIK4paBc2tpbgriloFlbXBoYXMK4paB0LPQvtC70L7QsgriloFwdWUK4paBaW5mb3JtYXRpb25zCuKWgVdvbGZnYW5nCuKWgXVzZWxlc3MK0LjRggriloFKb2FuCuKWgdCx0L7RgAriloFHbGFkCuKWgUtub3cKa8OpbnQKc3BlZWQK4paBS2V2aW4KdW5mdAriloFhcnF1CuKWgUNhc2EKKC4uLgriloFyYXBpZGx5CuKWgXByb2JsZQriloHQktC40LrQuNC/0LXQtNC4CsW+ZW4K4paBTmViZW4K4paBTWV0ZXIKQ2hpbGRyZW4KY2VtCmlnb3MKYWp1CuKWgVJldHJpZQriloFIZWxsCuKWgWdpZwriloFjb250cm92ZXJzCuKWgXpvb20K4paBY2VucwriloFhbGN1bmkK4paBSGVhZGVyCk1ldGEKUmVxdWlyZWQK4paB0LjQvdGB0YLQuNGC0YMK4paBc2t1cAriloFpbmdsZXMKw6lnbApiaWoK4paBdMOpcgriloFjb21wYWcK4paBY29tbWl0dGVkCuKWgXByb2Nlc3NlZApMb3dlcgriloFGb3JlaWduCuKWgXNlcQpzaGVldHMK4paBRmVtCmhvegppbmtzCuKWgWthbGwKdmFyaWFudAriloFsaWJybwriloFjbGlja3MK4paBZ29iaWVybm8KaWVnZWwK0LzQvtCz0L4KZ2VtZQriloF0b3dlcgriloFwYXJpc2gK4paBVENQCuKWgWxzCuKWgW5naW54Ck5hTgriloFEaXIK4paBQmVncmlmZmUKYXJpZQrDrW1wCmljaW9zCuKWgXNoYXJpbmcK4paBY2luw6ltYQpiZWMKUkVECuKWgUtyYQphYm9sCuKWgWZsdXgK4paBZXhwZW5zaXZlCuKWgdGB0YPRidC1CuKWgWBfCm9jegrQu9C40YHRggriloFhY3F1YWludAriloF3aXNlCuKWgXBvdXZvaXIK4paBZGV2YW50CuKWgW1vbWVudHVtCmltbWVyCuKWgUNvdXBlCmluZGV4T2YK4paBZG9lc250CuKWgdC30LDQsgriloFsaWNlbnNlCuKWgcOiCkNTUwriloFyaWNlClRlYW0K4paBYW5vCmxpdAriloFtZXJnZWQK4paBQ2VsbArQu9C7CmJveQphc3RzCuKWgXNlbGwK4paBZ3Jvw59lCuKWgXZpcnR1ZWwKQ2FuY2VsCuKWgXNqCmdtZW50Ci48CtGH0LDQuQppw6sKYWtoCml6ZXJzCnByaXQK4paBVGliCuKWgWVsYWJvcmF0ZQriloFmw6kK4paB0LzQtdC00LgKTEVOR1RICuKWgXByaW1hcmlseQriloFzY29yZXMK4paBY2FycnlpbmcK4paBbGFrZQpjb21wb3NlCuKWgVRvd25zaGlwCnVuZ2UK4paBYWxiZXJnYQphbnljaApxdWVsbGUK4paBQXJrCuKWgXByaXMK4paBdm9sbArRiNC70LgKVmFsaWRhdGlvbgriloFjZXV4CuKWgXBvcHVsYXRlCiINCuKWgWZlbW1lcwpBTkcK4paBRGVzcGl0ZQrQstGL0LUKaXNrZQp6dWcK0L3QsNGH0LAK4paBaGF0dGVuCklOU0VSVApFbXBsb3llZQriloFtb21lbnRzCuKWgcO6bHRpbWEK4paBaG9sZGVyCmJsYW5rCkNvbGxlY3Rpb25zCmF0aGVycwriloFncmFkZQriloFhZmZhaXJzCi4kJAriloFkZWx0YQriloFKdWdlbmQK4paBZXNwYcOxb2wK4paBT1VUCuKWgW1hdGhlbWF0aWNhbAriloFtb25nbwriloHQpNC1CnVsaW5nCuKWgXJldm9sdXRpb24K4paBY29pbgriloFzdWJjbGFzcwoiPT4Kw6RjaGUK4paBcHlnCtGJ0LDRjwppbGxlcnkK4paBY29tZW56CmRlcHRoCuKWgWPDqWwK4paBcmVzaXplCuKWgVNhbWUK4paBc3RyaWsK4paBdGlyCuKWgXNjYXJjCuKWgU1lbWJlcgpzdWJzY3JpYmUKw7PFvArDunRib2wKZXhjZXB0CuKWgWRyaXZpbmcKa2llCnpvbnkKw6htZXMKRGF2aWQKaXNzYW50CuKWgdGC0YsK4paBw6lsZWN0CuKWgXJlbmFtZQriloFSdW5uaW5nCuKWgWludGVyZmFjZXMKLy8vLy8vLy8vLy8vLy8vLwriloFXYWxrZXIK4paBc29jacOpdMOpCuKWgWFza3MKYnJpZAriloFqZXdlCuKWgXNlaW5lcwriloFhZ2VudHMK4paBTVkK4paBTGF3cmVuY2UKZGVzcwppZXNlbgriloHQu9GO0LTRj9GFCtC/0YDQsNCy0LgK4paBYW5jZXN0CuKWgXdlbGNoZQpyYXVtCuKWgW9yYgpzY2FsCuKWgUxlYXIK4paBd2VhcgriloFzbGF2ZQriloFyZW5hbWVkCsSNZW4KbWFzdGUKYW5nbGVzCuKWgUFtw6lyaWNhCuKWgXRpCuKWgWRlbXNlbAriloFiZW5lYXRoCmJpbmFyeQriloFlZGljacOzbgriloFraWxvbWV0CnVpdHMK4paBY3VhdHJvCuKWgWVudHJhbmNlCm9uZGlzc2VtZW50CuKWgWJhZwriloFBcm1lbgppam8K4paBTG9ycwriloFkZW1zZWxiZW4Kw6ptCuKWgWRpc2NyZXRlCuKWgXByb21pbmVudAriloFKYXkKZGVjb3IKREwK4paBZMOtClN0cnVjdAriloFQcm9kdWN0aW9uCnRoZXkKYXJpdXMKc2Nobml0dAriloFDb3UK4paBbGV4CnlvdXR1YmUK4paB0YDQsNCx0L7RgtCwCnN0YXRpb24Kc2VwCuKWgW1pcnJvcgriloFoaXRzCuKWgUJlY2sKYXRpY2FsbHkK4paBTGF6CuKWgXdpbm5lcgpERVgK4paBSU5UCn1eey0K4paBd2VnZW4KbWFkCkFuZ2xlCnppbmcK4paBQmF5ZXJuCnNhbArDpGdlcgriloFidXN5CuKWgXN0w7ZyCuKWgWZvbGsK4paBcHJpeAriloFhbGxvY2F0ZWQK4paBcHQKYWZmZW4KY2x1c3RlcgriloFjb21wbGVtZW50CsOhcnMK4paBQW1lcmlrYQrRgNGW0LkK4paBdmFsbGV5CuKWgXJvb21zCuKWgW1vaQouIiwKOzs7OwriloFsb3dlc3QKbm9nCuKWgWxhbmRldAriloFwcm9ncmFtbWUKY2hpbwriloFXw6RocmVuZArDoW5kZXoK4paB0LTQvtC70LYK4paBb3V2Cm9tw6FueQriloHQktC40LrQuNC/0LXQtNC40LgK4paBc8OzCuKWgWVsZWt0cgpEZXNjCuKWgUJlYXV0CtC90LDRgAriloHQvNC+0LbQtQpQaWVycmUKZXNvdGEK4paBb3BlcmF0ZWQK4paBZm9ydGUK0YDQuNGBCuKWgW9wcG9zaXRpb24KYWxpYQriloFTeWwKZ2V0TmFtZQrQstC10LvQuApmaWsK4paBY29tcHJvbQriloFUZXh0VmlldwpTcHJpbmcKbWV0YWRhdGEKZW5ndQovLAriloFjYXJyaQppc3RvbAriloFkaWFnb25hbApsaXN0YQppemVuCuKWgXJlbmRlCmdjYwpiZWNrCmxpdXMKaXJhbApSZXNvbHZlcgriloFwZXJjZW50YWdlCuKWgWF0dHJhCnN0cmluZ3MKd2nEhXoKb2RzCtCy0L7Qu9GOCsSZxbwK4paBbmV3c3BhcGVyCmltaXRlcgpBQkMK4paBTWFuY2hlc3RlcgpbewpBZ2VudAriloFXb3IK4paBS2F0aAriloHQv9C+0LLRlgriloFlbnRvbmNlcwriloFuaXZlYXUKYXR0ZWQKbGVhcm4KYXRpcXVlcwriloHRg9Cx0LgK4paBcXVpbmRpCmJpbmRpbmcK4paBaW1wb3J0ZWQK4paBSG9ybgplbWJlcmcKY29tcGxleAriloFuZXVyYWwKaW5mb3JtYXRpb24K4paBcmVjb2duaXRpb24KaW5ndAriloFpbmhhYml0YW50cwp2dWUK4paBQmV2w7Zsa2VyCuKWgWN1cnZlcwriloFsZWIK0LTRltC5CuKWgXNvdwriloFzZW50aW1lbnQKUEgKcmFjaGUK4paBLSgK4paBZXN0YWJsZQriloFGZXJkaW5hbmQK4paBw6ljcml0CuKWgXByaW1laXJvCuKWgXRleAriloFpbnRlcm1lZGlhdGUKdmVyYWdlCmlidXMK4paBc2VydmVzCml2YXMK4paBYnJ1CuKWgWx1bQphdHRpY2UK0YfQvdGL0LkK4paBRHJlcwriloF2aWRlb3MKZHVyYXRpb24K4paBYWJpdAriloFlZ2cKb2dyYXBoaWNhbAphbHBoClNUQVRFCuKWgdC/0LDRgNCwCnJlYWRpbmcK4paBdmVoaWNsZQriloFmb3J0dW5lCnVsdGF0cwriloFTdG9yaWEKbWlkdArFgsSFY3oK4paBTWVtb3JpYWwK4paBdmFzCuKWgdC30LDQvQriloF1dGlsaXR5CuKWgW9ic2MK4paBcmVsYWNpb24K4paBcnVuYXQKUmVsZWFzZQp0YWtlCuKWgU9saXZlcgriloFTaWQKdWxvcwriloFHYXJjCuKWgdGA0L7Qt9GC0LAK4paBU2FrClB5CmbDvGhydAriloF0cmFiYWwKKnsK4paBemVzCuKWgXN6ZXJlCuKWgXZhcmlvcwriloFvdHJhCuKWgWV2YWwK4paBc2l0dcOpCuKWgXdvdW5kZWQK4paBVmluY2VudAriloHQstC40LrQvtGA0LgK4paBZW5jb2RlCk1vZGFsCuKWgWZvcmIK4paBZHluYW1pY3MK4paBZGVwb3MKYXJkZQriloFzdHJlZXRzCuKWgUtvbW0KPSQoCuKWgdC/0L7QstC10YAK4paBZG9pcwriloF2aXR0CuKWgWF1dG9tYXRpc2NoCuKWgXJlbG9hZAriloFWZXJ3YWx0CmJlcm8K4paBaHViCuKWgW1vcwriloF0dXR0bwriloFGcmVkZXJpY2sKxYJvdwphbnRhZ2VzCmFxdWUKcGFwZXIK4paBZWluaWdlCmApLApkagriloFQbGUK4paBJSwK4paBQml0bWFwCuKWgWZyaWVuZGx5CuKWgXRydWx5CuKWgXN0cm9rZQpyb3BoCuKWgWVuZ2wK4paBY29mZgriloFkdXN0CuKWgUphaHJlcwpwcGkK4paBd3lzCmZhY3RvcgpzY2hsdXNzCuKWgdC00LXRgNC10LLQvdGPCuKWgVBhc3QK4paB0LTQvtC80LAKQ09NCuKWgXB1ZWRlbgriloFnaWZ0CuKWgUdsYQriloF0cmlnZ2VyZWQKw6lseQrDvGzDqXMK4paBT2xpdgriloF2ZXJzbwriloFsbGUK4paBR2xpCuKWgUx0ZApvYQriloF0ZXJyaXRvcmlvCm9yZHJlCuKWgWRlY2sKZHJhCmFzenQK4paBY29uY2VybmluZwriloFBZGRpdGlvbmFsbHkK4paBa3RlcsOpCuKWgWdydW5kCuKWgUdlc3QK4paBbWlzdW5kZXIKcHJldArilIDilIDilIDilIAK4paBcmVwdXRhdGlvbgp6aWEK4paB0YPRgdC/0LUK4paBZXNjYXBlZAriloFQcmFnCnBlcmZvcm0K4paBYXVzdHJhbAriloFWYXRlcgrRh9Cw0YEK4paBcmFjZXMK4paBQnl0ZQpNYXNrCuKWgVRlcnJpdArRgdGC0Y4K4paBVm9jaQriloFGaWNoaWVyCuKWgdCd0LDRgdC10LvQtdC90L3RjwriloFVbnRlcnNjaGVpZHVuZwp0ZWVudGgK4paBcGlsb3QK4paBamkK4paB0LTQstGD0YUK4paBb3JpZW50YXRpb24KaW5kcmUK4paBRG9ydArDp2FzCtC/0LvQuAriloFyZWFjdGlvbgriloFjb25zaXN0aW5nCuKWgWZlcnJvCtGC0LjRgdGC0LgKeWFyZAriloHRgdCy0ZYK4paBaW50ZXJwcmV0YXRpb24KacSFCnJhaAriloFmYW5kClB1YmxpYwriloF1bml2ZXJzZQriloFyZXRpcgriloFjb25zY2lvdXMKYXJxdQriloF3YXN0ZQriloFCaWIKeWNsZXJWaWV3CuKWgWxpc3RlbmluZwpnbGVpY2gKbmllanMK4paBY29ycmVsYXRpb24K4paBcmVjZWl2ZXIK4paB0YPQtNCwCuKWgWNvdXJhZ2UKdWNocwpmYXNzCuKWgWNodW5rCuKWgUFuZmFuZwriloFncm/Dn2VuCmNvbnRpbnVlCuKWgVdhcnN6YXdhCmjDqQppeQppdmVtZW50CuKWgc6xCuKWgWV4cG9zZWQK4paBemFobAriloFzYWNyCuKWgUxvb2tzCuKWgWVhZ2VyCmVudGVuCkN1cnNvcgovXwppeGEK0YDQtdC70LAK0LfQvdCw0YfQsAriloHRhNCw0LzQuNC70LjQtdC5CuKWgWFyZ2VudAriloFBbmRlcnMKxZN1dnJlCuKWgUlzYQrQvNC10L3RgtCwCuKWgWFkdmVycwpyaWN0aW9uCkdQCuKWgdC/0ZbRgdC70Y8K4paBcHJlc2VydmUK4paBR2FyZGVuClJhdGUKYXByw6hzCuKWgXJlYWRhYmxlCmluZHUK4paBc2tpbGwK4paBaGVscGluZwpvZ3JhcGhpcXVlCmNsaW5nCm9sb2dpc3QK4paBRmlsdGVyCuKWgWZpbmdlcgriloFWYWxsCuKWgVBvbGlzaApsZwriloFGYW1pbGllbgriloF3YXRlcnMK4paBcHNldWQKYXphCl8pCkFSWQriloHRgdGA0LXQtNC4CuKWgU11c3QK4paBQm9kCmFub24K4paBbGFkbwriloF0aWdodAppbWVuCmFwcGVuCmZyYW1lcwppbmdlcnMK4paBQ09WSUQK4paB0LfRlgriloHRgdCy0LUK4paB0YbRjAriloFMZWZ0Cl1dOwrRh9GMCtGE0LjQutCwCuKWgdGB0LvQvgriloHQv9GWCuKWgWV4aXN0ZQriloFBdGxhbnRpYwriloFtYWludGFpbmVkCuKWgWlycmUK4paBYW5uw6llCuKWgWNvbW1lbnRlZArQstC10YDQvgpiZXJ0YQriloFMYWQK4paBVXBvbgriloFwYXVzZQptaWxsCm9wdGVyClVLCtGA0LXRgQrQvdGG0LjQutC70L7Qv9C10LTQuAriloFhbG9uZ3NpZGUK4paBcm9ib3QK4paBZmVydAriloFtb3kK4paBYWRlCk1hcHBlcgopLT4KaWd1YQrDqXRpcXVlCtGC0LrQsAphbGlhcwriloHQvtGA0LgK4paBTWFnbgriloFnZWjDtnJ0ZQppbWIKKX17XAriloFXaWtpcMOpZGlhCuKWgXVycwriloFlbmRlCmxlYgriloFHQwpIb2wKYW5jaW5nClVuaW9uCuKWgXRlbsOtYQpUVAriloFlc3RhdGUKaMOhCuKWgdC/0L7Qu9GWCnVsdGFuCuKWgUhvY2tleQp1bHNlCuKWgWNob2ljZXMKc2NoZXIK4paBW10sCuKWgXBvdGVudGlhbGx5CuKWgcOcYmVycwriloFhZG1pdApDb21tZW50CtGB0YLRjwriloFWaWVuCuKWgdGG0ZYK4paBcGVybXV0CmNnaQriloFjcsOtdApDb25zb2xlCmN0aWMK4paBb2tyZXMKYXdrCmZvb3RiYWxsCm91ZXN0CkNUWVBFCm9sb2dpcXVlCuKWgWNvbnN0aXQK4paBaW50ZXJlc3RzCuKWgVByb2dyZXNzCuKWgU1lbnUK4paBdGFrw6kK4paBQXNpYW4K4paB0LfQsNGJ0LgK4paBeW91bmdlcgriloF3aXNoZWQK4paBU29ydAriloFhdWRpZW5jZQphbWJhCuKWgWdlaMO2cnQK4paBS2Fuc2FzCnlhdW1lCuKWgVByb2Zlc3Npb25hbArDomNlCuKWgWZhdHRvCnRvZAriloFkYXRhc2V0cwriloFmYXJlCuKWgXdhdmVzCn4vCuKWgW1lYXN1cmVtZW50CuKWgXdvbAppbmR1c3QK4paBc3RydWdnbGluZwriloFwdWxsZWQK4paBY2FyYXR0ZXIK4paBRXh0ZXJuZQriloHQtNC10LnRgdGC0LLQuApjbnQKbGljaGVzCuKWgVBvc3NpYmxlCuKWgWZhY2VkCuKWgWh5cG90aGVzaXMK4paBa2lsb20K4paBbsOkcgpib29sZWFuClBZCmFtcGEK4paBa2lzcwriloFhc3Rlcm8K4paBbmVnbGkKYW1lbnRzCuKWgVN0dQphdMOzCuKWgUNvbnN0aXR1dGlvbgriloFpbnRlcnBvbAriloFVbmFibGUK4paBcGlzCuKWgXBhcmMKIl0pCnBsZXIK4paBYXV0b3J5CuKWgWFsZ3Vub3MKeXduYQp9KSkK4paBZmFsbHMK4paBw6lxdWlwCuKWgWVtaXQK4paBcHJvZmlsCmdldHMK0YTQvgriloFNaWxpdGFyeQriloFub21icmV1eApvY3QKUmVwbGFjZQriloFzZWFzb25zCuKWgWNow6J0ZWF1CuKWgXR5cGVvZgpwb2xpdAriloFyYW5kCuKWgXF1YXIK4paBZXJzdG1hbHMK0YHQuNC90LgK4paBcGF5bG9hZArQn9C+CtC60ZbQvQpyZXBvCuKWgVBhdgpTY29yZQplcnZlcwriloFzb2xsdGUK4paB0LzRltC2CsOpYmVjCuKWgWNsaXAK4paBTmljZQriloFuZWJlbgriloFhc3Nhc3MKaXRvcmllcwriloF1bml0eQriloHQtdC9CuKWgUluc3RpdHV0CuKWgWludGVybmF0aW9uYWxlCuKWgdC90LDRg9C6CuKWgWNvbWFuZAriloFrbGVpbmUK4paBYWRqYWNlbnQK4paBZGVsaXZlcmVkCuKWgdGI0LUK0LfQtdC8CuKWgWNvdAp2aXN1YWwK0LLQsNC10YIK4paBQ2Vuc3VzClxfCuKWgXRlcnJpdG9yeQrRh9C40LsK0YfQvdGL0LUKZmx1dHRlcgpEaWRMb2FkCkRvY3VtZW50cwriloFkb2IKQnJlCmFuaW1hdGUK4paBYml6CuKWgWJhdGEK4paBU1UKZXNvCuKWgXByaW9yaXR5CnbDoW4KaXJhcwriloFjaGFyZ2VkCuKWgU1pY3JvCmF0b2lyZQrRh9C10YAKYWJhZAp1cnUK4paBdsWhCmRpcmUK4paBVHdpdHRlcgriloHQvNC10YLQvgopLi4K4paB0KbQtdC90YIK4paBZW50d2ljawriloFNaW5kCuKWgdGE0YPQvdC6CkZ1dHVyZQpsc3QKxYJvxbwKZmxpCnRlbnNvcgriloF0b3BvbG9neQriloFhcnRlCkVSVAriloF2YXJpYW5jZQpJbWFnZXMK4paBKEAKQXJyYXlMaXN0Ck9DCuKWgdCU0LXQvNC+CmF1Y291cAriloFkZW5vdGVzCmltb24K0ZrQuAriloFQcnp5cAriloFaYWcK4paB0LTQuNGA0LUK4paBU2ltaWxhcmx5CtCx0YDQvgriloFtaWxpdGFpcmUK4paB0YLQvtC80YMK4paBSm9obm55CuKWgdCc0LXQutGB0LjQutGDCtGb0LAKU3VwcAriloFqdW5pb3IKb2x0cmUK4paB0JzQvtGB0LoK4paBYWRtaXR0ZWQK4paBcmVsaWdpb3MK0LfRj9C5CtC10LPQvgriloF0ZWFycwppbmdvCm9kdQppdmVuZXNzCuKWgWxvZ28K4paBw7psdGltbwriloFhbGltZW50CuKWgVVJVGFibGVWaWV3CikhCuKWgW5qCmxldHRlCuKWgXJlc2lkZW50CuKWgXRlcm1pbmUK4paB0YPQttC1CuKWgdCh0YLQtQpvZmZpY2UK4paBY2FydGUK4paBbGl2cmUK4paB0JzQvtGB0LrQvtCyCuKWgWVsZWN0aW9ucwrQt9C40LTQtdC9ClRyaWdnZXIK4paBQmVuamFtaW4KYWRkQ2xhc3MK0YHQutC+0LMK4paBT2JzZXJ2YWJsZQpDbGEKZ2VtZWluCuKWgWNvbnNlbnQK0LLRgNC4CuKWgXVuZm9sZAriloFnb3Zlcm5vcgrQvdCw0LsK4paBdG9kYQpSZW1vdGUKYXJpYXMK4paBaW5zdGFsCmZpeGVkCuKWgWRlY2F5CuKWgdC00LXRgNC10LIKeHl6CuKWgURBVEUKaW1hcgpudGlsCuKWgXN0YXJ0dXAKYWxpb24K4paBa29sZWoKY2lvcwriloFyYW5nZXMK4paBc3R1cGlkCuKWgWltcGxlbWVudGF0aW9ucwriloFybQrDqW5lawriloFnY2MK4paBc2PDqG5lCk5hdmlnYXRpb24K4paBwqAK4paB0LrQsNC9CuKWgXRvd25zClVzZXJuYW1lCuKWgdGE0LUK4paBbGVhZGVycwpvaXQKd8OkcgriloFkdW1teQriloFhc3Npc3RhbnQKeyRcCtCx0ZbRgAriloFyb3kK4paBTGF5b3V0CuKWgUp1bmcKTGluZXMK4paBSG9sbGFuZArQv9C+0YAK4paB0JPRgNC4CuKWgUJlbmVkCuKWgdCf0L7QtAp4bHMK4paBR29sCuKWgUFsZWtzCuKWgWVqZW1wbG8K4paBc2V6b24KYXJkaW5nCmZvb3Rub3RlCuKWgUNvbmdyw6hzCnJlZmVyCtGB0LrQsNGC0LAKSXRlcmF0b3IK4paBb3Vyc2VsdmVzCuKWgU1pYwriloFjw7NkaWdvCuKWgdC/0LvQvtGJ0LAK4paBXCQK4paBQ2hhcmxpZQpOb2RlcwriloFwdXp6CuKWgUlkZW50aWZpZXIK4paBZmx1dHRlcgriloFwcsO8CuKWgW9ydAriloFDb3J0CmFzdGljc2VhcmNoCuKWgdCh0LLRjwriloFCdWxsCnVkZW0K4paBYXBwYXJlbnQKOi0tCuKWgdCl0LDRgAriloFMYXAK4paBY29tcG9ydAptYXRpY2FsbHkK4paBY3VyaW9zCuKWgdC80L7QttC10YIK4paBQmgKYXBwaW5nCuKWgWJhc2tldGJhbGwKemV0ZWsK4paBcnVudAriloFNaWxhbgpmZWN0aW9uCnLDrWEK4paBS2luCuKWgXNsb3dlcgpib3RoCuKWgUluc3RpdHV0bwriloFIaXN0b3JpY2FsCuKWgXLDs3duaWXFvAptYXRjaGVzCnljaQriloFlc3DDqGNlCuKWgVNjaHdlaXplcgpOVApTRgphY2lhCmZvcmdlClBvaW50cwpudW1iZXJzCuKWgWZhbGxpbmcK4paBaW5oZXJpdGFuY2UK4paBRXJzdAriloFjdXN0b21lcnMK4paBYWN0dQriloFtaWdyYXRpb24KXCcKUGxhbgpNcgpvdGh5CuKWgXVwZ3JhZArQsdC40YDQsAriloFPZmZpYwriloFXYWl0CuKWgXRvbGVyCmFyZG9uCuKWgXNsaWRlCilfCuKWgdGB0YLQsNCyCuKWgW51Y2xlYXIK4paBQmlsCm93bmVyCuKWgUhhcnJpcwpJbmZvcm1hdGlvbgriloFww7MK4paB0LLQutC70Y7Rh9CwCuKWgW51b3ZvCuKWgUNhdgriloFEZXNjcmkK4paB0LDQugrDs2R6dAriloFyZWFjdGpzCuKWgUFkYW1zCuKWgUFsdGVybmF0aXZlbHkK0YHRgtGA0YPQugopYCwKc3Vic3RyaW5nCuKWgW1hc3NpdmUK4paBaGVhdmlseQriloHRgdC10LfQvgriloFBbmEK4paBdmFsZQpQYWQK4paBRWl0aGVyCuKWgXJzCmFuY2hlCuKWgXVwbG9hZGVkCuKWgSgvCuKWgdGB0L/QvtGACuKWgXJlZHVjdGlvbgriloFUb2t5bwpncmVuCuKWgW1pZ2xpCuKWgWl0ZXJhdG9yCnN0YXYK4paBc3VwcG9ydGluZwriloHDtnN0ZXJyZWljaAriloFOU0xvZwppc3RpcXVlcwpyaW1pbgpNT0RFCn19fVwK4paBZXhwbG9zCtC+0YLQtQriloEo4oCeClNhbAriloFzaW1wbGVzdAriloFnacOgCuKWgdGC0LDQvQriloFjeWwKYmlyCuKWgW1lYXN1cmVtZW50cwpDcmVhdGVkCmVyZWsKbG9va3VwCndpcnRzY2hhZnQK4paB0JLQvtC70L4KdGltZXIKZGVycgriloHRgdGC0LDQu9CwCuKWgXNjZW5lcwriloFwZXJzdQpsaWVzdAriloFzY2hlZHVsZQp0YWwK0LvQtdC90L4K4paBcGFpbnRpbmcK4paBaW1wcm92ZW1lbnQKc29mdHdhcmUK4paBZ292ZXJubwriloFIaXIKRXhlY3V0aW9uCuKWgU9rYXkKUHJvcApsb3N0ZXIK0L3RltGG0LjQv9Cw0LvRlgriloFwZXV2ZW50Cm9sdQriloHQpNCwCnJvbGxvCuKWgdC60L7Qu9C+CuKWgWNhcnJpw6hyZQriloF0b2dnbGUK4paBKCRcCuKWgWFnZ3JlZ2F0ZQriloHQkdGWCnRleHRhcmVhCk9rCml0dG8K4paBc3RpbQriloFyZWN1cnNpb24K4paBRmVkZXJhdGlvbgopX3sKYXRlZ29yCuKWgWRpc3RyaWJ1CkNsb3VkCuKWgW1hZHJlCuKWgWl2CuKWgUxpZXV0ZW5hbnQK4paBc3Vic3RhbnQK4paBbGVhZgriloFLb250cm9sYQpWQQriloF0b21iCtGN0L0KYXRvZXMK4paBZ29kaW5lCuKWgSM+CkNlcnQK4paBZW1wcmVzYQpQcm9wcwriloFwbGFubmVkCuKWgXJhbmRvbWx5CmrDpGhyCmVsZW0K4paBT3BlcmF0aW9uCipgCnByb3RvY29sCigpKSk7CndlbAriloFwcmF3CuKWgdGB0LjQvAriloF3b2IK4paBaGFjZQriloFuZWFyZXN0CmRpc2FibGUK4paBQ29tbXVuCuKWgXJldmVsCkZyZWUK4paBYnJhY2tldHMKSU9FeGNlcHRpb24K4paBYWx0bwriloFtYXJyeQriloFhdWMKKSxcCuKWgXR5cG8KZWRhZAphcsOhCmljYXRvcgp0YXR5d25hCuKWgWJ1ZmYKb3JkZXJzCuKWgWFzeW5jaHJvbm91cwriloFlY29uCuKWgWZldQriloFJcm9uCuKWgXJpc2luZwpSYWRpdXMKY2xrCuKWgXp3ZWl0ZW4KYCcK4paBdW5pcXUK4paBRk0K4paBQnJhbgriloFmbHUK4paBc2Vuc2l0aXZlCnVycmUK4paBSXRlcgriloFTZWluCuKWgWRpZmVyZW50ZXMK4paB0L3QtdCz0L4KY2hpYQriloFBbmxlaXR1bmcKYXR1cmRheQriloFzaG9ydGVyCuKWgXRyYW5zbGF0ZWQK4paBUsOpcwriloFyb2RlCmRyYWcK4paBbGFuZ2UKQmkKw7xiCmxldXIK4paBb3JkZXJpbmcKYWxvdXMK4paB0JrQvtGACmFyY2hhcgpkZXN0cm95CmVydmF0aW9uCl1dLApBY2Nlc3NvckltcGwK4paBYXV0b3J5dGF0eXduYQpTZXF1ZW5jZQriloFwcm95ZWN0CuKWgWJyYW4K4paBKCsK4paBS2FiCuKWgXplbQriloFDYWxjdWwK4paBc2V1bAriloFOaWdlcgriloFjaGlhbQp0aHJvdwriloFQbGFuZXQKYmlsZHVuZwriloF6b25lcwp0cmFuc2l0aW9uCtC70LXQvdC40LkK4paBbWFwcGVkCm9uYXV0ClBhaXIKaWxpYW4K4paBTW9yZ2FuCuKWgXVudG8Kam91CuKWgWhpZAriloFNZXRhCuKWgWVsbGVzCkxvdQpyYW1hCmdlb3JkbmV0CuKWgXNjYXJjZWx5CuKWgW1pbnQKRm9jdXMK4paBQWx0ZXIK4paBZGlvCuKWgWFtcGwKacOocmVtZW50CuKWgdC40YHRgdC70LXQtNC+0LLQsApMRUQKYWxnb3JpdGhtCuKWgdGB0LDQudGC0ZYK4paBIiIpCkhpc3RvcnkKcGsK4paBV2hpdAriloHRgdC40YHRgtC10LwK4paBS2lyY2hlbgpyw6AKQVBQCuKWgTwlCmFudGluZQriloFEaXNrCmNvbnYKd2VsdAriloFGdXQK4paBTm9tCm9yZG8KZWxsaWoK4paBcmVjZWl2ZXMKY293Cnl0dQriloFvYnJhcwriloFwdXJjaGFzZQriloFlYXJuZWQK4paBYWNjZXNzZWQKYXhpCuKWgU1hbnMKaXZhbgriloF0dXZvCuKWgVRyYWNlCnJpbW9uaW8K4paBZGVzZW52b2wKw6lyaXF1ZQriloFyZXN1bHRlZAriloFjb21wdXRpbmcK4paBaW5zcGlyZWQK4paBUHJpemUKKiIKQ29tcHV0CuKWgWV4dGVuc2l2ZQrDqGcK4paBUG9ydMOhbHkK4paBY2FzdGxlCuKWgSouCuKWgXBob3RvcwriloF2b2V0Ck9ORwriloFBbGxlCuKWgXRocmVhdGVuCnN0w7x0CuKWgWFsYnVtcwriloFkZW5zZQpmbGF0CmNvbnRpbnUKU3ViamVjdAriloFyZWFkb25seQpPcHQK0L/QuNGB0LrQvgriloFBYmVyCuKWgVBvc2l0aW9uCuKWgVRvZGF5CuKWgW1pbmkK4paBQmVmCmxpc3RlbgrRgdGC0LLQtdC90L3QvtCz0L4KU1VCCm9zc2EK4paBUG9wZQriloFKaW1teQriloHQlNGA0YMKdW5nc3NlaXRlCuKWgXRyZW4Kb3B0aW0KaXRzY2gK4paBc2FtdAriloHQuNGB0L/QvtC7CiY9CuKWgVByenlwaXN5CuKWgdC/0YDQvtC00L7QuwpDcgplcm1hbm4K4paB0LzQsNGC0LXRgNC4CuKWgUh1Z28K4paBRGV6ZQpUUlVFCuKWgWRlZmVhdAriloF3YXRjaGVkCuKWgUdlbnQKQVVUCm9yb3VzCuKWgdC+0L/RgNC10LTQtQpvcmllbnRhdGlvbgriloFkaXN0aW5ndWlzaGVkCuKWgW1lc21vCuKWgXNsaQrQvNC10L3QsAptaXR0ZWwKZ2VyaWNodApldG9uCi0+ewriloF3b250CuKWgXdlZwriloFjbGFzc2lmaWMKaWx1cwriloFNRAp0YXNrcwriloFjaGltCmF3YWl0CuKWgWdhbmcK4paBd2nEmQp0aHJvdWdoCuKWgVJ1c3NlbGwK4paBZ3Vlc3NpbmcK4paB0LDQutGCCtCx0LvRlgpjYXRlZ29yaWVzCtGB0YPRggriloFGZW4K4paB0LzRg9C2CuKWgW5ld2VyCuKWgUFzeW5jCuKWgXRlcm1lCj4vCtC/0LDRgNCwCuKWgVRydXN0CuKWgU9wdAriloFkYWgK4paBd29uZGVyZnVsCmFkcmF0a2lsCuKWgdCT0YDQsAptYXBwaW5nCuKWgWRpc2NvdmVyeQriloFCRQpFbmFibGUK4paBRnJpZW5kCtGB0L3RjwriloFjb250cm9sbGVkCtGH0L3QvtGXCuKWgWNvbnRyaWJ1dGlvbnMKasWhw60K4paBTGV2CuKWgWZyYW5jw6lzCuKWgW1pYwp6aWsK4paBYWxlbQpjYW5jZWwKIScK4paBZ3JhdAriloFCZWdyaWZmc2tsw6RyCkNhbWVyYQppZmljYWNpw7NuCnLDs2QK4paBQXJub2xkCuKWgWJlemVpY2huZXRlcgriloFmb3VnaHQK4paBZGVwdXQK4paBRHJvcAp0YXgKZGcK4paBSG9wCkdOCuKWgUtpcmNoCuKWgdCR0LDRgApJbnZva2UK4paBZXJoYWx0ZW4K4paBdmVlbAriloF3b3JkcHJlc3MK4paBSU5ORVIKdHJhbnNhY3Rpb24K4paBZMOpasOgCkZhY3QK4paB0L3QsNC00LzQvtGACuKWgWFuZ3VsYXJqcwriloHDoXQK4paBYWxhcAriloFQcmljZQriloFlZmZldAriloFzcGhlcmUKQ2xhc3NMb2FkZXIK4paBcnVnYnkK4paBa2luZ2RvbQriloFNdXQK4paB0LrQuNC90L4K4paBcmV3YXJkCmNpdAriloFwcmVzZW50ZQpTdG8KQ2hhcmFjdGVyCmxvZ3MK4paBY2VudHJhbGUK4paBbW91dgriloFva2F5CuKWgWFwbGljCk1vcmUKw6lueWVrCuKWgUvDtmxuCm5ldHQK4paB0LjRgdGC0L7RgNC40LgK4paBZGVzY3JpYmluZwriloFzb2xkaWVyCuKWgU5lZWQKTGlnaHQK4paBIlw8CuKWgWhhdgplcm1vCuKWgWluZmVyaW9yCmxlYQriloFnZwriloHQutC+0L3RhtC1CmZyYWdtZW50CnNiCkNvdW50cnkK4paBdsSbCuKWgUJlbmcK4paB0K3RgtC+CuKWgdCy0L7QtNC+CtC80LDRgApTVFJJTkcK4paBw7pqCm11bHRpcGxlCnN0YXRlbWVudAriloFpbnZvbHZlcwriloF0ZWNuClN0dWRlbnQKZ3LDqQriloFsZWFuCuKWgWJyaW5naW5nCuKWgU1lZGljYWwK4paB0L/RgNC+0LPRgNCw0LwK4paBVm9nCuKWgdC20L7QsgriloFTcGlyaXQKbnRoCuKWgXN0YW5kYXJkcwriloFQcm9maWxlCuKWgWV6CuKWgdGC0LXRgNGA0LjRgtC+0YDQuNC4CuKWgXN0ZW0KdWlsCuKWgU9nCkJ0bgpuYWwK4paBbmVhcmJ5CuKWgXByb2R1Y2luZwpjcml2CuKWgWFzc3VtcHRpb25zCuKWgVNwYXJrCuKWgUxvdAppdHVkZXMKYWZrYQpmaXZlCmF0aW8K4paBZGlzdGluZ3Vpc2gKcm9jawrDqWdsaXNlCuKWgXJhcHByZXMKPlw8CtC70ZbQuQriloHQvNC40L3QuAriloFpbnRpdHVsw6kKfX0oXAriloFSb3V0CuKWgUJvcmRlcgriloFvdmVycmlkCkhPU1QKcml0dGVuCnNheQriloHQp9C4CmljaHR1bmcK4paBc3RyYWlnaHRmb3J3YXJkCm9iYgriloFUZXJyYQriloFbOgpCZW4K4paBY29tcG9zaXRlCikrXAriloFjcm93bgpkaXJlY3Rpb24K4paB0L3QtdGB0LrQvtC70YzQutC+CuKWgWF2YWlsCuKWgXB1cmNoYXNlZApob29rCmV0aWVzCuKWgWZhc2UK4paBUnVtCuKWgWdlbm9tCuKWgWTDqXQKb3fEhQptcGVnCuKWgdCG0L0KZGVza3RvcAriloFpbmplY3Rpb24KYWdsZQriloFFZGQKX3soCuKWgUhlbQp1dG9zCnByb2oK4paBc3VwZXJmaWNpZQpQbG90CuKWgURvY2tlcgrDpHR6CmtyZWljaAriloF1bmNsZWFyCuKWgVVuaXR5CuKWgXN0cmVhbXMK0LLQuNC0CuKWgXNpbXBsaWZpZWQKRmlsbAriloFzYW50CuKWgUtvbW11bgriloFkdWMK4paB0LTQstC1CuKWgW9icwrFvml0CuKWgUphbmVpcm8K0LHRjwriloFwcmVzc28K4paBTWluaXN0cnkK4paBYnVyc3QK4paBcmVhY2hpbmcKbGl0ZXIK4paBcmVzcG9uc2VzCuKWgUV1ZwriloFzb2QK4paBQ29yZAriloFQZXJtCnBhcnRzCtGG0LjQvNCwCnZhcmlhYmxlcwriloFmb3Jnb3R0ZW4KRmVybgpvc3TEmXAKdmwK4paB0KHQvApraW0KYWrEhWMK0L3QsNC70YwK0LPQu9C1CmhlbHBlcgpkdXAKZXV3CmZyYQplbGxpdGUKYW55YQriloFyZWlnbgpnZXNhbXQK0YHQtdC00LAK4paBUnlhbgriloFmb3JtYXR0ZWQK4paBQm9yZwp3YWxrCuKWgdCw0LsKYWdub3N0aWNzCuKWgUNhcGUK4paBRnJhbmNvCuKWgWZ1Zwo6KQrRjtC3CkZldGNoCuKWgXJvdWdobHkK4paBTWlzCnVldG9vdGgK4paBVmVuZXp1ZWxhCuKWgWFzdHJvbm9tCiIpYApvbWJyZXMK4paB0LrQvtGC0L7RgNC+0LkKw7NwCm93ZWQKSFIK4paBQ2FtZXIK0LrQuNC1CnBhcmlzb24K4paBQmlqCnRlbXBsYXRlcwplbnZpcm9ubWVudAppemHDp8OjbwriloHDqXIK4paBcGxlbnR5CuKWgVR5cGVFcnJvcgriloFmb3J0eQrQutC+0L3QvtC8CuKWgVNlZAriloF0aGF0cwriloFncmF2aXR5CuKWgXNwaXJpdHVhbAriloFkdXBsaWNhdGVzCuKWgWVuY3J5cHRpb24K4paBcmV2ZW4KZ2V0SW5zdGFuY2UKw6RsbG9yCmRpc2sK4paBdGhybwriloFOYWsK4paBcG/FggriloFoZXJhdXMKaW52YWxpZApzQnkKQm9vdAriloFidWNrZXQK4paBUGFyc2UKaGV4CkNvbm5lCuKWgUNvbXB1dGVyCnp5awriloFpbmR1Y2VkCuKWgUJydW5vCuKWgWFkZHJlc3NlZAptYW5pYQriloFpbmNsdXMKb3VuY2VkCnNjcmlwdHNpemUK4paBRXBpcwriloF2b2NhbAriloFKb25hdGhhbgrRg9C8CnN0YWRlbgriloFDaGlsZHJlbgrQv9C10LkKSXRhbGlhCnJlaWJ1bmcK4paBbm9zdAriloHQtdGJ0ZEK4paBV2Vya2UK4paBYWN0cmVzcwriloFNaW5uZXNvdGEKcmlrZQriloF0ZWsK4paBcHJpbWVpcmEK4paBZnJhdAriloFDb25maWd1cmF0aW9uCuKWgWJpZAp0cmlnZ2VyCkNvbnRlbnRzCuKWgWNvbnN0YW50bHkKISEhCuKWgWRyZWFkCuKWgWh1bmRyZWRzCmlzdGlzY2hlCuKWgWNhcmRpbmFsClRBQkxFCuKWgWVzdG9zCmFzc29jCmdyYXkK4paBU2NobG9zcwriloFzY2hlCmNvbmcK4paBa29qaQrDqHRlcwriloFFcmEKb21pCuKWgVNSCuKWgXdyYXBwZWQK4paBdHJ1bmMK4paBYWgKZWdvcwpva2kKbW91dGgKbG9nZ2luZwriloFmYXNjCuKWgVNhbXBsZQriloFjb250ZQriloF2aWxsYQpjb21tZW50cwriloFiYXRhbAriloFHYXJjw61hCuKWgU5vcnRlCuKWgXdlY2hzZWwK4paBTXVzZW8K4paBZW5mYW50cwriloF3aGlzcGVyCm5ha2UK4paBamVkbmFrCmzDqnMKZW5kZXJzCuKWgcOkbAriloFWQgriloFjb29raWVzCnpldGkKYXR1bQriloFkZWR1CuKWgWFycmFuZ2VkCmxhegriloFjdWVudGEKeW1sCuKWgWZsYXYKTVIKZW1ldArQsdGW0LvRjApjbXAKaXR1dG8KemV0dAriloFlbnZpCuKWgWtvdAokOgp1cHBlcgriloFBbGJlcnRvCmtiCkFuYWwKw7ZydAriloFbLQriloFmw7xocnRlCmlhaAriloFUdW4K4paB0LjRgdC60YPRgQp1d2UKaXNwZWNpZXMKUHViClN5bmMK4paBQ29sb21iaWEKYWtlcnMK4paBSW1wZXJpYWwKb3ZpbmcK4paBaW50ZWxsaWdlbmNlCuKWgWVxdWlwbWVudAplaW4KZGFnZ2VyCuKWgUVkZ2UK4paB0KDQtdGB0L/Rg9Cx0LvQuAphZHJhdGtpbG9tZXRlcgriloFBbnRvCuKWgWNoYXJnZXMK4paBT2NlYW4K4paBc2ltcGxpZnkK4paBbWllc3oKcnVubmluZwriloFMYWMKZ2Vub21tZW4K4paBcmVwcmVzZW50YXRpdmUKPS4K4paBUHJlZAriloFzcGl0ZQpjaWFsZQriloFuYXZlCuKWgWV4dGVucwriloFuZXV0cmFsCuKWgdC60L7RgtC+0YDQsNGPCi48LwriloFDUwp1a3kK4paBd2hpbHN0CuKWgWxpbmd1CmV4dHJhY3QKemVpY2hudW5nCuKWgUZlbGQK4paBdmFsdWFibGUKdXJhYmxlCuKWgUplbgriloFzdHJ1Z2dsZQriloFjb21taXR0ZWUK4paBV29obgriloFzcWxpdGUK4paBVGVtcAriloFDT1VOVApjb25zaW4K0LzRltC90ZYKdXNhZ2UK4paBcXVlc3QK0LTRj9C9CmVhcmVkCuKWgVNjaG5lCuKWgWRvZAriloFyZWNodAriloFrYW8KQ2FwdApsYWJlbHMK4paBZWxsb3MK4paBaW5kdXN0cmkK4paBQ29sb3JhZG8K4paBY29udHJhcnkK4paBRHVtCkJlbAriloFWZW50CuKWgWF1dGhvcml0aWVzCllFUwplbnNlZAp1bWJuYWlsCml6emF6aW9uZQprb3UKcmljYQriloFzZWN0CnRlc3RzCuKWgUtsZWluCuKWgWxlZ3MK4paBUGlldHJvCmZ1CnRoeQriloFiYXN0CuKWgXRlZGVzCmV0dGVzCuKWgXJlcGV0CmFjcmUKcmV0dG8K4paBcmVtYWluZGVyCuKWgUdlZwriloHQk9C+0YAK4paBUmVjaHRzCuKWgWZpbHRlcmluZwpvdXNzCuKWgWRlcGxveWVkCuKWgXByw7xmZQriloFiaXRtYXAK4paBc292aQriloE8JT0K4paBZW50ZmVybmUKa2lsbAp0YWJzCkV4cHIK0LrQvtC80YMK4paBUmVwdWJsaWNhbgriloFTaXplCuKWgXBvbGwK4paBcmllbgriloHQutC70YPQsQrDqW5kCuKWgUJpbwriloFwZXJsCuKWgUFuZHJlYXMK0LLQuNC9CuKWgWRpc3RhbnQK4paBRmlubgriloFNaXRjaAriloElewriloFjaGFybQriloFNdWwKcGVyYXRlCuKWgXNjaWVuY2VzCuKWgW1vbm90CuKWgWRlYmlkbwpyaXpvbmEKaWVjCuKWgWFsYXJtCuKWgXByb21vdGVkCuKWgWxldHp0ZW4KYXRpbgriloFjb25jbHVzCmhlcnIK4paBw6ljaAplZGlzaApnb3IK4paBc3R5Y3oK4paBaW1wcmVzcwpydWl0cwppZXJ1bmdzCuKWgXBhcnNlZAriloFyw61vCuKWgVBha2lzdGFuCmlnbmVyCuKWgXdhdGNoaW5nCuKWgWRhdGFiYXNlcwplZGluZwriloFTcGVjaWZpYwriloFnZW5lcmFsZQpsYXgK4paBTG9va2luZwriloFib25kCuKWgXZpc3RhCuKWgWVjCuKWgWdydWQK4paBZGVsZXRpbmcKdGFjCuKWgWphenoKam0K4paBcMOzxYIKTGFuZ3VhZ2UKZGVsZWdhdGUK4paBcmVnaXN0cnkK4paBU2hhcmVkCtGB0YLRgNC+0LkKTXVzaWMK4paBdmVzc2VsCi5ACuKWgVfDvHIK4paBZmVkCuKWgWVyZWRldAriloFHw7YKdXB0CuKWgXBsZWFzYW50CuKWgXRhYmxlVmlldwriloFjb3VudGluZwriloFLcmllZ3MK4paB0L/QvtC70YPRh9C40LsK4paBXSwK0LLQuNCwCuKWgWHFvgpUb0xpc3QK4paBQWR2ZW50CuKWgXNrZXRjaApwbgriloFzaWVyCuKWgdC90LDRhdC+0LTQuNGC0YHRjwppb3AK4paBbHkK4paBU2NobApDb250cmFjdAphc3NvY2kK4paBUGVhcgriloF3aGUK4paBRGVsZXRlCuKWgWVsZW0Kw6R0dGUK4paBxI1lc2sK4paBTUMK4paBc2hvdXQKYWtlc3BlCuKWgWRlZmF1bHRzCnBlbmFzCsOycmlhCuKWgWhpZXJhcmNoeQppcHQK4paBRWxpcwpsaWtlbHkKUm90CuKWgWNvdwriloFzdHJpa2UK4paB0LHQtdGA0LXQt9C90Y8K4paBZW5zZW1ibGUK4paBUHNldWQKVmlydHVhbAriloHRl9GXClJPT1QK0YHQuNGPCuKWgdGB0L7QsQriloFpbnZlcnQK4paBc3dpdGNoaW5nCmh0YWNjZXNzCuKWgdC90LDQs9GA0LAK4paBTm9ybWFuCuKWgWluZ2zDqnMKIVsKb3VzZWwKRE9DVFlQRQriloFzdXBwcmVzcwriloFhY2NvbXBhbmllZAriloFCw6kKaW1wbGllcwpudXQK4paBU3ludGF4CmluaG8K4paBdGFtCuKWgWZvY3VzZWQKYXZhbm8K4paBQmFkZW4KaGFkCuKWgSh7ClR5CuKWgdGA0L7RgQriloHRh9C+0LvQvtCy0ZYKb2dlCmpzcApCbHVlCuKWgXN1YXMKYXBlcnMKU2hvcnQKUmVuZGVyZXIK4paBc2VuZG8K4paBQ2VjCuKWgWBfXwriloFNdW5pY2lwYWwKZG90bmV0CuKWgWJldgriloFEQQpNZW51SXRlbQriloFhbXAK4paBdXJpCuKWgWZpZXIK0YHQu9C10L0KKSwoCmN1bGVzCmlsbGFzCkxPQ0sK4paBZGVyaXZlCnViZW4K4paBR1QK4paBTWFjawriloFzY2hvbGFyCil9fQrQt9C8Cj46OgrRiNGR0LsK4paBcHJpbmNpcGFsZXMK4paB0YbQsNGACuKWgXRpZWQK4paBYWx0YQriloFDaXQKbGluZWQKbWFqb3IK4paBcHVuawriloFjaW5jbwppY2vDvQriloFyYWdnaQp0eXBlbgrRgtC10LvRjNGB0YLQstC+CuKWgWNvbmZlcmVuY2UK4paB0YHRltC70YwK4paBaGV1dAppxaEK0LXRgtCwCnZlbG9wZQpoYm94Cm5vd24K4paBemFyCmt0aXYKaWXDnwriloHRgdGC0YDQtQriloFFdmVudEFyZ3MK4paBSXJhCuKWgVZCQQriloFTYW50bwriloFGYWNoCuKWgUZGCuKWgVJheW1vbmQK0LzQtdGGCmltcGxlbWVudGF0aW9uCuKWgWJyb3RoZXJzCuKWgWPDtHTDqQriloFjb250cm9sbGVycwriloFDbGUK4paBY2FibGUK4paBY29uZmVyCuKWgXstCuKWgWN6xYIK4paBRmlsaXAKYXRvcmlvCuKWgXdpY2h0CuKWgWJlYXVjb3VwCuKWgUxpdAriloFzZXNzaW9ucwriloFTdWNjZXNzCuKWgXJvdXRpbmcKbml1CuKWgVZpY2UK4paBa3JpdAp1cGRhdGVkCuKWgUludmFsaWQK4paBTWFubnNjaGFmdAriloFhb3MK4paBdHVkaQriloFkZXNwcsOpcwpxdWEKQ29udGFpbnMKQ29tcGFueQriloFwZXJzb25hCmFkYXB0ZXIK0YHQvdC4CuKWgXZvagriloFlc2NyaQphZ3QK4paB0YHRgtCy0L4K4paBZGlzdHJpdG8KYXBhbgriloFhc3BlY3RzCuKWgXphbAopXntcCuKWgXN5c3TDqG1lCuKWgdCw0L3QsAppdW1zCuKWgXByZW1pZXJzCuKWgdC/0L7RjQriloFtw6hyZQriloFHdW4KYXBpbmcK4paBUmFpbgriloFpZ3VhbAriloFwcm9jZXNzb3IKJylgCmJsaW5nCuKWgW1pc20KYnLDoXoK4paBY2xvc2VzdAriloFSZWFkaW5nCuKWgdC/0L7Qv9GDCmNvbm8K4paBa3VsdAriloEhIQriloFFeHByZXNzaW9uCuKWgWluZHVjdGlvbgphaHJlbgriloFjcAriloF2aW9sZW5jZQppZW50w60KY2VudGUK4paBRG9iCmphY2sKc29uZwpidWNrZXQK4paBZGVwb3J0CtC60LjQvNC4CmxtCuKWgWlubm9jCkNoYW5nZXMK4paBcHJvaGliCmFuZ29sCmlzZWNvbmRzCuKWgdC/0L7RgAriloFoaXAK4paBcMWvCmVuZG9yZgriloFzY2hlZHVsZWQK4paBRmx1ZwphY3lqCuKWgUZpbG1zCmF0aGVkcmFsClBvd2VyCmFyZGluCmthcAppY2tlbgpyZXNpemUKZXVzCnJyCtC70Y/QvQriloFIYXYK4paBb3JhCkZST00K0LvQvtGB0Y8K4paBdGVydWcK4paBV2lkdGgK4paBYWNjZXB0cwrQsdC10L0K4paBbWljaAriloFDemVjaAriloFCZWRldXQK4paB0LLQuNC0CsO0bWUK4paBTG9vcApzcGVjdArDvGsKZXN0b24K4paBc2xvdAriloF6b3N0YcWCYQriloFDaGFybG90dGUK4paB0YHQvtGB0YLQsNCy0LvRj9C10YIK4paBUHJvbWlzZQriloFlcG8K4paBZGljdGlvbgriloFGcmFua2xpbgriloFSaXYK0YDRg9CzCmNpZGEK4paBRXhwbG9yZXIKY29va2llCuKWgWZvcm1lcmx5CuKWgW11bmljaXBhbGl0eQriloFTdGVmYW4KbGlzdHMKQ09NUApMZW4K4paBU3RhYXQK4paBTkJBCmRlbnMK4paBb3NjaWxsCiEuCuKWgVBPCsO0bmUKZXNlcwriloHQvdCw0YbQuNC+0L3QsNC70YwKdm9vcgriloHQutC+0L/QuAriloHQv9C+0LfQuAp1bHUKQ29uc3RyYWludAriloHRgdCy0L7QtdC5CuKWgWFsZ2VicmFpYwrRh9C90Y8KRGljdAriloFhcHBlYXJpbmcK4paBcHJhdgriloFVbml2ZXJzYWwKQnJvd3NlcgriloFTaW5nYXAKZW5uZXNzZWUKXV8K4paBU29mCuKWgUNhZApvdW5jZQriloFjb3N0cwpde1wKLi4vLi4vCtGB0YzQutGW0LkKw7xobAppZXR5CtC/0YAK4paBaW50ZXJwcmV0ZWQKYWpuCmNvbG9nCllTCm1hbnMK4paBbWV0cmljcwriloFyZWdpc3RyCmlzdGFuY2UK4paB0J/QvtC70YwK4paBYW5vbnltb3VzCuKWgWluc3RpdHV0aW9ucwriloF6ZG9iCnByw7xuZwriloHQsNGA0YLQuAriloFlc3RhdAphY2NpCuKWgWFjYWRlbWljCuKWgWNoaWVzYQriloFHaWFuCmNvbnRyaWIKdW1lZAriloFHaXIK4paBYmFzZWJhbGwKbnVtZXJpYwpHZW5lcmF0b3IKR00K4paBdGlueQriloFkaXN0aW5jdGlvbgrQs9C10YAK4paBcnVzdAriloFGSUZBCuKWgVByb3BlcnRpZXMKXi0K4paB0Y3QutGBCuKWgVN0YW5pcwriloFBamF4CmVzY2FwZQriloFjb25zcAriloFDaGVuCuKWgU5hdmFsCkJpdAriloFiw6J0CtGB0LrQuNC80LgKZHJpdmUK4paBUm91bmQKcGhvdG8K4paBTGV2ZWwK4paBZ2VnClRvbQriloFNb2JpbGUK4paBVHJvcApEaXJlY3Rpb24KaXNhbgopXnstCuKWgVNldHRpbmcK4paBUHJvYmFibHkK0LvRjNGPCuKWgWFzc2V0cwriloFhdHRlCuKWgWJ1bGsKw6lzdAriloF3aW5nCm5pdXMK4paBd2lucwriloFsdWQKdXNoaW5nCuKWgWRldmVuCtC+0LPRgNCw0YQKYnVyZ2VyCuKWgWVtYmFyCkZpbHRlckNoYWluCuKWgXR1bQriloHDtnNzCuKWgW5vbW3DqQriloFwaXIK4paBbHVjCmRibwphZ3VlcwriloFhbGNhbgpvdXdlbgriloFTdGFubGV5CtGG0LjQsNC70LgK4paBZ3Jvd24K4paBcHJlc2VydmVkCuKWgXNvbGFyCuKWgdCd0LDRgdC10LvQtdC90LjQtQriloFwZXJmb3JtYW5jZXMK4paBQ293CuKWgWVuZ2luZWVyaW5nCuKWgXNjYWxpbmcKYXRvbWljCmVuZGFuY2UK4paBYWNlCsOkbmdlbgpBbmltCnBoYXNlCnpidXJnCk9sZAriloFzZXJ2YW50CuKWgWdlbWVpbnMK4paBT2JzZXJ2CnRyYW5zbGF0ZQriloFjb3ZlcmluZwriloFlc3TDoW4K4paBcHJvYmxlbWEK4paB0YPRgdGC0LDQvdC+0LIK4paBbGxldgriloFjemVydwrDqWFsCm1legpSRUUKRVJSCtGC0YPRgNC4CnNlZ3UK4paBcHJvZml0CuKWgW11bHRpcGxpY2F0aW9uCmtvbW1lbgriloFmYXV0CuKWgWNhbmRpZGF0ZXMK4paBVXJpCuKWgUxhdXJhCuKWgXNhcAriloHQstC40YHQuNC90LgK4paBQmV0d2VlbgpmYWRlCuKWgXJlc2VydmVkCuKWgWludm9sdmluZwriloFNYXJlCuKWgUNvbnRhaW5lcgriloHQvdCw0LfQvdCwCuKWgURFQlVHCuKWgWh1cnQK4paBUG9sc2tpCuKWgWx1eApDQgp3YWNoCuKWgdC/0LXRgNC40L7QtAriloFDYXRoZXJpbmUK4paBZ2Fuegp1Y2h0ZQriloFjb25zdW1lcgriloFjcm9zc2VkCm9yZGVyZWQKYXdheQp0ZWNobgriloFzdWJzY3JpCuKWgXNob3J0Y3V0CuKWgdC/0YDQvtC40LfQstC+0LQK4paBc2ltdWx0YW5lb3VzbHkK4paBcmF0aW5nCuKWgUtpbmdzCuKWgXJlbGF0aW9uc2hpcHMK4paBU2V4CuKWgVRvb2wKYWdoCmFjdGVycwpsb2dnZXIKaG9tbWUKZW5nZXJzCuKWgVJpCmVhcmFuY2UK4paBYXBwZWFyYW5jZXMKUmVhbAriloFwYXNzZQppY2xvcGVkaWEK0YfQutC+CnRlcnJlCuKWgU9udGFyaW8K4paB0L/QtdGA0LXQtNCwCmZvb3RlcgphcmNoaXZpCmlmaXoK4paBUHJvdGVzdAriloFMSU4KdW5uYWJsZQriloFjZW50dXJpZXMK4paBQmF5ZXIK0YbRltGOCtC+0LLQuNC9CuKWgUFuZHJlYQpzZWxlY3Rpb24K4paBY2FsbQriloFtb2RpZmljYXRpb24K4paBc2hvcnRseQppbmFpcmUK4paBZnVzaW9uCuKWgWZlZWxpbmdzClBLCuKWgVJvYmVydG8K0LPQvdC1ClNoYXJlZAriloFtZWhyZXJlCuKWgU5pZW0Kb21wCkVudgriloFBcnRpY2xlCuKWgVBvawriloFWQVJDSEFSCuKWgWRpbAriloFhZmZvcmQK4paBY29uZnJvbnQKb3dhbmllCuKWgW1pbmlzdHJlCmFkZXNoCuKWgVBvbHkK4paB0KDQsNGB0L/QvgriloFHcnVwcGUK4paBSGVsZW4K4paBY2MK4paBcG9ydHJhaXQKYmV3CuKWgWJldGEK4paBV2lyCuKWgUF1ZGlvCuKWgShcPApyaW9yaXR5CuKWgW5pdAriloHQv9GA0LXQtNGB0YLQsNCy0LgK4paBVmllCuKWgXfDvHIK4paBSG9sZAriloFTYWQK4paBVG9jaHRlcgriloFvbHRyZQriloFBY3RpdgriloFKYXNvbgriloF3aWVrdQriloFyZWdhcmRzCuKWgXRhc3RlCmFnbm9zdGljCtC70LDRgdGPCuKWgVNlbGYK4paBYXByCuKWgURlZXAKc2NvcApBY3RpdgriloF0eXBlZGVmCkNvbnRlbnRWaWV3CmNvbXBpbGVyCuKWgVJvdGgKeGMK0LfQuNC6CuKWgWxhcmdvCuKWgVJlbmEKaGVpdGVuCuKWgXBsYXRmb3Jtcwp1bGxhCuKWgWdsYW5jZQriloFtYXNjdWwK4paBbWV4CuKWgUpvcmdlCuKWgWZ1bmNpb24KY2hvb3NlCuKWgXJldmlld3MK4paBQWxiYW4K4paBR2xvCuKWgVNwZWNpZXMK4paBRmFtZQriloFSb2xsCuKWgVB1ZXJ0bwriloFcKQp5bW5hcwplbnZpcm9uCuKWgWlwaG9uZQriloFXcmVzdGxpbmcKYcWCeQriloFJbmRpYW5hClJhZGlvClZTCuKWgWluZGVwZW5kZW5jZQrRgtCw0LkK4paBZGVjb2RlCldoaXRlCuKWgWpvdXJuCsOtY3VsbwriloFCYXJiCuKWgUV2YW5nZWwK4paBQW5keQriloFXZWxjb21lCuKWgURldmljZQpnZWYK4paBcmVtZW1iZXJlZAriloF2YXJpYXRpb25zCuKWgUFkb2xmCml0YWluZQriloHQvdCw0LTQvNC+0YDRgdC60L7RmAriloFzdGVhbQriloFjb25jZXJucwriloFgfAriloHQsdC40L4K0YLQtdC70YzRgdGC0LLQsAriloFxdWF0dHJvCmV4dGVuZAriloF0cmFiYWpvCmVuYmVyZwriloFzY2VuYXJpb3MKw6JudAriloFrb21tdAriloFkb21lc3RpYwriloFCYXNrZXRiYWxsCuKWgUNvb3Blcgpzb2NrCtC00LXRgNC20LAKPXtcCuKWgWluaWNpCuKWgVBoaWxsCuKWgdCz0LXQvdC10YDQsNC7CmFyY2hpdmlhdG8K0YrQvQpSb2IK4paBdG9uZwriloFjaGFyYWN0ZXJpc3RpY3MK4paBYW1hegriloFNb2RlCuKWgWluYXVndXIKd2VocgpyYW50CmlvbmFsaQriloFNb3RoZXIKTWEKw6lxdQriloFLZWxseQpjaWxlCuKWgWJlc3RlaHQK4paBZXN0aW1hdGVzCnJ1Z3VheQriloFBbnMKTWFkCuKWgdC90LDQsgriloFkb25uw6llcwriloF0cm9waWNhbAriloFTZXZlcmFsCmVsdGVyCuKWgVBobwprZW0K4paBQ3VzdG9tZXIK4paB0YHQutC70LDQtNGWCuKWgWNvdXJzZXMKUGxhdGZvcm0KbmF2YmFyCmxlYXJuaW5nCuKWgVN3ZWRpc2gK4paBemFzdAriloFMaWcKbWFuYWdlbWVudAriloFsb2QKdWZmbGUKVGV4dHVyZQphcmdhCsOhdHVtCuKWgUREUgrQvdGW0ZcK4paBU29jacOpdMOpCuKWgWRvbWFpbnMK4paBcGVybWl0dGVkCuKWgWV4dGVybmUK4paBcXVlbHF1ZQp2dAp5bWFuCuKWgVdhcmQK4paBYWdsaQriloFhbmRyYQpTbmFwc2hvdAriloFtw6UK4paBeWVhaArQtNC10L3QsArEmXB1CmFza2VsbAriloFSw6lwdWJsaXF1ZQppbmplY3QK4paBJzsKw6RubgriloF6ZWxmCuKWgUVudHdpY2tsdW5nCsOhcmlhCm9ub215CuKWgXN2aWwKaWVzZQriloFjb25zZXIK4paBbmltCuKWgXLDqXN6CuKWgdCY0YLQsNC70LgK4paBcGFydGljaQriloFMaW9uCnNyCmFsd2F5cwriloHQktC70LDQtNC40LzQuNGACtGH0LXRgdC60LjQtQpbLAriloFEZWZpbml0aW9uCm5hbnQKb2VtCklkcwriloHQstC90LUK4paBWy4uLl0K4paB0L3QsNC/0YDQsNCyCuKWgUdPCuKWgcOlcnMK4paBdXTDoW4K4paBb3V0cm9zCuKWgXJlZ2nDs24K4paBTW9uZwriloFmaWxtZQriloF0cmlwbGUK4paBc3BvbnMKRGV2ZWxvcAriloFvdXRjb21lCuKWgUJpYmxlCuKWgdC40LzQtdC90LgKQ2FudmFzCtC/0YPRgtCwCmN1cnIKw6Fzb2sKKXtcCm5pbmdhcgpgOwriloFGbGFzaAo6IwptdXN0CmNwdQriloFmb3JtYXRzCkhhcgriloFlcGlzb2RpbwriloFSb3NhCuKWgWTDqHMKZW1pdApyaXRlcmlhCkFubm90YXRpb24KRmxhZwpnbWFpbAriloFOb3JtYWwKb2xsYXJ5CuKWgWZvc3MK4paBY29uY3VycmVudAriloFjcmFzaGVzCuKWgdCy0LjQtNC1CuKWgU1pbm9yCuKWgVNpdAriloFTTgriloFzY2FyCuKWgWZlbWluCuKWgXNwZWNpZmljYXRpb24Kc29hcAriloFvcGVyYXRlCuKWgXByaW5jaXBhbG1lbnRlCuKWgWF1c3QKaWJpbGUKaXRpbWUK0LvQtdC20LAKaWZyYW1lCuKWgWNvbmNlcHRzCuKWgXRhY2sK4paBdmlzcwriloFjYXJib24KdGVyeQriloFuYW1pbmcK4paBT3J0cwppZGVudGUK4paBQ2FwaXQK4paBZXhwcgriloHQvdCw0YHQtdGZ0YMK4paBU2VsZWN0ZWQK4paBaGludGVyCuKWgWlmcmFtZQriloF6YgppbmRleFBhdGgKY29sbAriloF3cnplxZsK4paBYWNodAriloFncmFkdWFsbHkK4paB0YfRgwrQt9C10LkKaGFmdAriloF0cmFuCuKWgWxhcXVlbGxlCnl0aWNzCklERQriloFweWdhbWUK4paBUGFja2FnZQriloFjbGFzc05hbWUKQmFsCnBlcmwK0YLQuNC90LAKT2NjCuKWgWluZnJhc3RyCuKWgUNoYW1waW9ucwriloFjbGFzc2ljCuKWgVJhdwriloFwYXJ0aWFsbHkK4paBVGVkCuKWgXN0b2xldApyYWluZWQKV0hFUkUK4paBdmFsbAriloFKdWxpYQp6YXQK4paBc3Vycm91bmRlZApTRUUK4paBd2Fsa2luZwpCYWQKRk9SCmNvbnRyZQriloFQYWxlc3QKw6F0aWNvCuKWgWVuZ2luZWVyCuKWgXBhcnRuZXJzCuKWgUpld3MKaWxlcnMK4paBY2VyZW0K4paBaW50ZXJhY3Rpb25zCmFjdQpzdHkK4paBUHJpbmNlc3MKc2hhcnAK4paBU2luZ2xlcwriloHRl9GFCmNoZXoKUmVjZWl2ZXIK4paBcGF0aWVudHMKc3RyaW5naWZ5CuKWgWNvbXBldGVkCmJleQokOwriloFCZApoYWRvb3AK4paBRGl2aXNpw7NuCsO2bGQK4paBcmVzdHJpY3RlZAriloFjb21tYW5kZXIK4paBSGlnaHdheQriloHEjGVzawriloFteXRoCtGH0LDQvQpyYWhhbQriloFlbnF1CuKWgXBvZwriloFjb211bmEK4paBcHJpbnRsbgriloHQutGA0YPQvwriloFkZXBvaXMK4paBc2VhdHMK4paBbmVpZ2hiCtGG0LjQvtC90LAKYWdpbmUK4paBY2xvdGhlcwriloFQcmlvcgpCcmFpbgpGRkZGCic6JwpmZWF0dXJlcwriloFmaWxlc3lzdGVtCuKWgXNpbmdsZXMK4paBTWVsYm91cm5lCuKWgWRlc3RydWN0aW9uCuKWgUx5b24K4paBSW5zZWwKTmF2CuKWgVJlcGxhY2UK4paBbMOpCldobwriloFFc3RhZAriloFkaW1lbnNpb25hbAriloHDtmZmCuKWgWdyYW5kcwrQtNC20LAKcGxhbmUK0L3QvtGB0YLRlgriloFPcmlnaW4KV0kKw6RubmVyCuKWgUNyeQpJVElPTgriloFmw7ZkZAriloFjdWx0dXJhCuKWgVJhbmsK4paBdnVlbAriloF6YWcK4paBTWF4aW0K0L7QvdGDCigpKSkKUmF3CmtpcmNoZQriloFhZGVtw6FzCuKWgXRpZQriloFTdHlsZQrRgdC60L7Qsgppc3RhbnQKb2xwaAriloFaw7xyCuKWgUluZm8KRE9NCnVzYwpuYWhtCuKWgdCk0LXQtNC10YDQsAriloFGb3QK4paBc3BlY2lmeWluZwriloF0aXRvbG8K4paBQm95cwppZWNoClBsYWNlCuKWgUhvZmYK4paBY2FjaGVkCtCy0LDQu9GMCmlzaGVyCnJvbGxpbmcKb3BlbnMK4paBaHIKLS0tLS0tCuKWgW1hZ2dpb3IK4paBdHJhbnNhY3Rpb25zCuKWgWNyaW1pbmFsCuKWgXJldHJlCuKWgUNhbXBiZWxsCikpOgriloFuZWQKUGFnZXIK4paBSGVybwooX18K4paBdW5jbGUK4paBcmVhY2hlcwphcnRvCuKWgWhlbGxvClByZWZlcmVuY2VzCuKWgdC30LDRgtC10LwKTmFtZWQK4paBcmVhZGVycwrRhdGWCmtlcm4K4paB0YPQv9C+CtC60LjQvQriloFsYXYK4paBbm9iCuKWgXNlY3JlCuKWgUxpc3RWaWV3CtCy0LDQvdC40Y8K4paBTWF5b3IKYm9yb3VnaAriloFmaWxvc29mCtC90LXQvdC90Y8K0YTRgNC4CuKWgXBhdHIKRk0K4paBYWNpZAriloFTYWx2YWRvcgriloFhYmIK4paBR3JhaGFtCnBvbGljeQpuZWdhdGl2ZQrFhHNraWVnbwriloFIZWltYXQK4paBZGF6dQriloFtZWx5CuKWgXJpZGUK4paBZHV0aWVzCm92ZXJ5CuKWgVByb3Bvc2l0aW9uCuKWgVBhb2xvCi8nCuKWgU1hdQppbWVudGkKU2FpbnQKZmF0aGVyCuKWgWVxdWlsaWIKcGhvbnkK4paBY2xhcwriloHQvtGC0LvQuAriloFCdWZmZXJlZApyZWsK4paBbWl0dAriloFIdXIK4paBSGFydmFyZAriloFkZW1vbnN0cmF0ZQp1YXJpbwriloFkb2xvcgriloFyZWplY3RlZAriloFNw7xsbGVyCuKWgW5hYwriloFCZWxsZQriloFnYXRoZXJlZApucgpmcmlrYQrDtmxsCuKWgWNoZW1pY2FsCm5pZwriloFjYWxjCuKWgURFRkFVTFQK4paBcGhpbG9zb3BoeQriloFMYXJhdmVsCuKWgWFsaWdubWVudApFVgplb3IK4paBZHppZQriloFtZXN0CuKWgUlvCkNSRQrQt9Cy0LgK4paBTWVkaWMK4paBbsOkCuKWgXphYgriloFTbG92CnV0bGljaAriloFhbXBsaXQK4paBRnJhbmtyZWljaAriloHQutGW0LvRjApJTkQKZXhlY3V0aW9uCuKWgUthcnJpZXJlCmRvc3TEmXAK4paBcsOpYWwKZW5nbwriloFzZXZlcmUK0LfQvNCwCuKWgdGC0YPRgNC90LgK4paBQ2FydGVyCuKWgVJvYmluc29uCmdldEVsZW1lbnRzQnkK4paBcHJvdG90eXBlCuKWgWphcG9uCmbDvGhydW5nCuKWgWNvbnNlZ3UK4paBc3R1ZGkK4paBbGlyZQriloFzY2hsaWXDnwriloFCdWZmCuKWgXJlZHVuZAriloFlcm4K4paBbXlzdGVyCuKWgXByb3ByaW8KYXRlZnVsCuKWgVBhcmVudAriloFsYWRpZXMKcmFjawrRgtC40LrQsAplbmJ1cmcK4paB0LrQsNGH0LXRgdGC0LLQtQriloFFRgriloFzdGFtCuKWgW51ZXZhCuKWgWZpbHRlcmVkCnJldGVuCuKWgUlhbgriloFNYXR0aGV3CmtpaAriloHFkQriloHQutC+0LzQv9C+0LfQuAriloFmb3JldmVyCm9pcmVzCjpcXAriloHDqXR1ZGVzCuKWgXNvdXAK4paBcGxlYXNlZAopfSgK4paBU3RvcApTZXR0ZXIK4paBSGVscAriloFiYXJzCuKWgUVSUgriloEoPwriloFwb2V0cnkK4paBVXRpbApBSwriloFmaWNrCuKWgUlNCuKWgXByb3VkCtC90L7RgdC4CuKWgW11ZXJ0ZQriloFQYWxtYXLDqHMK4paBTmFzCtGJ0LjRhQriloFxdWVyCuKWgWFwZW5hcwpdWycK4paBS29uc3QK0L/QvtC9CuKWgVNjaGlmZgriloFtcAriloHQsdC70LDQs9C+CmZyYW0K4paBaG91c2Vob2xkCuKWgXRyYWN0CmVuY29kaW5nCuKWgXVuZGVydAriloFBdWcK0L7QstCw0L0K4paBQXJ0ZW4K4paBaW52b2tlZAriloFkeW5hc3QK4paBZmxlZXQK0YfQtdGB0YLQstC+CuKWgU11cnJheQriloFndXQKZWxpaG9vZAriloFTU0gK0L7RgtCy0LXRggriloFwZXJzb25hbGx5CtC/0YDQuNGPCuKWgWZpbmFuY2kK4paBVGhvbXBzb24KYWx1CmlkZW50aXR5CuKWgUdyYWIKYWRkbGUKw4l0CuKWgVRvYgriloF2ZXJsb3IK4paBU2FpbnRlCuKWgWRvcAriloHQstC10YDQtQpfX18K4paBcHJvbW90aW9uCuKWgS09CuKWgdC+0YLQtNC1CuKWgWFtYmlndQpPUkRFUgriloFDb21tdW5pYwriloFpbXBseQpvbmVkCmNsdWRpbmcK4paBY29sbGlzaW9uCuKWgWZyYWdtZW50cwpzY3JpcHRpb24K4paBJ3sK0LvRj9GFCuKWgWhhbnMK0YPRgQp3aXJlCm5hbWVzcGFjZQriloFzd29yZApyZWZyZXNoCuKWgWt3YW0KenMKY29tbW9ucwriloFjb3NhCuKWgXJlZ2ltZQpncmVwCuKWgWRpb2MK4paBQ29udGFjdAriloFlc3RhcwriloFTdGV3YXJ0CuKWgXZpZWxlCtGC0L7QstCwCuKWgVJhbgphbm5lcwppZGF5CuKWgXNuYXBzaG90Cm9ycm93CuKWgXphxI0K4paB0YPRh9Cw0YHRgtC40LUK4paBcHJvbWlzZWQKQXNzZW1ibHkK4paBY2hhbXBpb25zaGlwCuKWgURlZmluZQriloFlcmVuCuKWgdC90L7QstC+CuKWgXRoaW5rcwpBZ2UK4paBZ2V2CnZhcmNoYXIKaXZpdMOgCmNvbXBvcwriloFNdXR0ZXIKQ09OVAphcm3DqWUKYWduZXQK4paBQnJvdwou4oCUCuKWgVRlbGV2aXNpb24K4paB0JTQu9GPCuKWgXZtCuKWgW9yZGluCuKWgdCc0LjRhdCw0LkK4paBYXByb3hpbQonKS0+CuKWgXpvbwppcHBpCuKWgXNpbm8K4paBUXXDqWJlYwpyYWdlcwrDpGNrCmVpbmcKYXJsbwpwaW9zCuKWgUNoYW4K4paBZWxsaQriloFpbmNvbnMKZ2VzdGVsbHQKcHBlcnMKSmVhbgphbnN0YWx0CuKWgURhbmNlCuKWgXRvZW4K4paBZGVjaXMK4paB0KDQtdC30YMK4paBb2ZmaWNpYWxseQrDpHR6ZQriloHQtNC+0YDQvgriloFlbnVtZXIK4paBdHJvaXNpw6htZQp0eXAKb2ZmcwrQsdC+0LvRjApvZG4K4paBWmFyCuKWgdC00YDRg9Cz0L4KcXVpYQriloFOaWNvbGFzCtC/0LjRgdGDCuKWgW1vYgpwYWNlcwrQvdGM0L7Qs9C+CkFsZwrDqXJvw68KRXJyb3JzCuKWgdCz0YDQtQriloHQttC10L3RidC4CmluY2gK4paBS29yZWFuCuKWgUFwb3N0CuKWgUxpdmVyCuKWgWVsZW1lbnRhcnkK4paBREkK0LLQuNGB0LgK4paBc29pbAriloFETEwK4paBcmlzcAriloFTaGFrZXNwZQriloFHYXVzc2lhbgriloFLdXJ0ClZlcnRleAplYm9sCm9yZ2FuaXNhdGlvbgrDpHJlbgriloFZRVMKQ1VSCuKWgdC90LDRh9Cw0LvRjAriloHQv9C+0YHRgtGA0L4K4paBTHVpZ2kK4paBY2FjaGluZwpwcmV2ZW50RGVmYXVsdAphbWQK4paBVml0CnN1YnN0CuKWgdGB0YLRgNC+0LgK4paBQ2FtcGlvbgpjaHIK0YTQtdGA0LUK4paB0KHQv9C40YHQvtC6Ck5GCuKWgWPDrW0K4paBaMOpCnJlYmJlCm9jeQpiZWxvdwriloFieWxvCuKWgdCj0LgK4paBXCh7XAriloFgOgpnaW9yZQpTYW4K4paBR2F0ZQriloHQstGBCuKWgW9saW1wCuKWgU1hdHJpeAriloFoZWFyaW5nCnJpaQp0ZnJhYwriloFhbGxlbWFuZAriloFWdWUK0LvQvQriloFjb21waWxpbmcK4paBRW5zCuKWgWludmVzdGlnYXRpb24K4paBQXgK4paBY2hhcnMK4paBdGFyZ2V0cwriloFsb3VkCnVzZW1lbnQK4paBTmV0aGVyCmNvbW1lcmNlCklHSFQKb2NvYQppZmVjeWNsZQriloFMZW8KcHJpdgriloFnb29kcwphZGFtZW50ZQpBdXN0cmFsCuKWgXJlYm9vdApHZXN0CuKWgXJlcHJlc2VudGF0aW9ucwpjZXUK4paBZG9jdHJpbmUKY2VycwriloFLcmFrCuKWgWFkdm9jCuKWgXNxdWFkcmEK4paBYXJiZWl0ZXRlCsO8c3QK4paBcGlsbApBbnN3ZXIK4paB0LrQstGW0YIK4paBV2EKdW1hbm4K4paBRHluYW0KRmFtaWwK4paBdGVubmlzCuKWgUVuZ2luZWVyaW5nCuKWgWNpcmNsZXMK4paBTWFyeWxhbmQK4paBYmVzdGEK4paBYmFzZXMK4paBem5hamR1CtC60YLQvtGA0LAK4paBYXJyZXN0CtC70LXRgAriloFHaWEK4paBcmVtYXJrYWJsZQriloHQvNC+0LPRgwriloFTdXByZW1lCuKWgWAlCmRvcgriloFhdWpvdXJkCuKWgXdpcwpXSURUSAriloFtaXNtYQriloFmbHVpZAriloFwZXRpdGUK4paBVG93ClJlZ2lzdHJ5CmVtZWQK4paBV2lzY29uc2luCuKWgVJhY2luZwriloFyZWdpc3RyYXRpb24KLyUKdGhpcmQK4paBbW9udW1lbnRzCtGH0LXQuQriloFqZXQK4paBVXJiYW4Kw6FsdmEK4paBbWlsaWV1CuKWgXBvc3Nlc3MK4paBZ2VybQpkZXBlbmRlbmNpZXMK4paBZW5lbWllcwriloFzYW1lbgriloFXZXJuZXIK4paBaGl6bwriloF0ZAriloF5ZXN0ZXJkYXkK4paB0JDQtAriloFoYXNuCmNlbGxhdGlvbgpvdsOhbsOtCmxpa2EKV2VlawriloFJbmcK4paBRW1haWwK4paBbcOodHJlcwriloFPQ0xDCuKWgWFtb25nc3QK4paBc3BsZW5kCmZ1cgphbnRpY3MK4paBWFhYCuKWgdCz0YDRg9C/0L/RiwpsYWNoCuKWgWNvdXNpbgriloFpbnZhcmlhbnQK0ZLRgwriloFCZWlzcGllbAriloFoYXJkZXIK4paBYmVsbAriloFvcmNoCnRiCkZvb3Rub3RlCnJlZ29uCk1hcnRpbgriloFpbmNvbgriloFhdHRhY2tlZApfey0K4paBVHJhcwpwYXJ0eQppdGVpdAriloFzYWludApyw6Fzb2sK4paBY29udGFpbmVycwpNbwriloFTbgpxdWFudGl0eQriloFyYXMK4paBQ2FuYWwKY2Npb24KdXZvCuKWgWlkeAp0eXBlbmFtZQriloFSdWdieQriloFTZWVtcwriloF0cmFuc21pdAriloFQcsOkc2lkZW50CtC30L3QtQriloFCYWtlcgppbnRoCuKWgXTDtmJiCnZlcmVpbgriloFlc3BlY2llCiwoCuKWgXTDqWMK4paBV0lUSAriloF1bm9zCuKWgXBvbGl0aWNzCmNyZWF0ZUVsZW1lbnQK4paBc3RhdHMK4paBVGVubmVzc2VlCuKWgUJlZGV1dHVuZwriloFTY3JlZW4K4paBU3RyYcOfZQphbnplCuKWgXBhcnRseQptYW51ZWwKb2xhdGlvbgpob3Jpem9udGFsCsOpcmlldXJlCmFtcGlvCuKWgdGB0YLRgNGD0LoKV2VpZ2h0CkxhbmQKcG9seQriloFEYWsK4paBQXNzdW1lCiIuJAriloFjYXNpCuKWgWdyb3NzCuKWgWVudGVydGFpbgriloFkw6ljYWRhCicuJAplbmNlcgriloFndWFyYW50ZWVkCl0kLgrQu9C40YHRjwriloFhY2NlcHRhYmxlCnJhaXNlCmlydXMKd2VpdAriloHQkNC90LAK4paBaGlsbHMKaXBhZ2UKQklUCuKWgW51Y2xlCuKWgXV0aWxpcwpDQUEKw6huZXMK4paBU2Nod2VpegriloFBQQpuaW5nZXIK4paBYmFuZHMK4paBdGVuZGVyCnNvbQpXYXJuaW5nCuKWgUJpc2Nob2YK4paBQXJjCuKWgVdvbWFuCuKWgXRyYW5zbWlzc2lvbgrRh9C90LgKaXN0cmUKQlkK4paBU0kK4paB0J/QsNGACuKWgX0pLgriloFwcmVzZW50YQriloFSZW7DqQriloFoYXBwaW5lc3MK4paBUHVuawpjb2xzCuKWgURlc2RlCtGA0ZHRhQriloHQvNC+0L3QsAriloFzY3JhdGNoCuKWgXRjcArDqnRlcwppdGF0ZWQK4paBZGlmZXJlbgpnZWgKbmFobWVuCtCf0LUKY2tpCuKWgVRlYXRybwriloFSZW1lbWJlcgriloFmcmlnaHQK4paBWWFtCndlc3Rlcm4KbGV0ZWQK4paB0LLRgdGC0YDQtQriloF0ZWxlcMO8bMOpcwrQt9C40L0K4paBUXVhbnQK4paBc3VwcmUKw6FqYQrQtNGW0Y8K4paBY2FycmVyYQprcmV0CnBhcmEK4paBU1VNCuKWgXBpdArFumR6CsOpbwrRgNC10L3QvdGPCuKWgUNob3IK4paBdm9peAriloFleGVjdXRpdmUK4paBYWxsZXJkaW5ncwpNYXliZQriloHQtNC10L3RjAriloFmbHlpbmcK4paBcGFybGlhbWVudArQttC00LDQvQriloFmcmFtCuKWgdC20L7QstGCCuKWgXVnbHkK4paB0LHRg9C00YMKaWdueQpcfF97CuKWgWJpdHRlcgpzY2UK4paBcG9sZQpWZXJsYWcK4paBdG90YWxpdMOpCuKWgWZvdW5kYXRpb24KanQK4paBc2xpY2UKaWZpcXVlCuKWgWludGVncmF0ZQpzdHJpagriloFhc3ltcHQK4paB0LXQvNGDCuKWgXBlcnR1cmIK4paBRmxvdwpqYm9zcwpSSUcK4paBQWxlc3MKWFhYCuKWgXN1bW0Kc3FsaXRlCuKWgWNoZWVyCnByb2IK4paBR1BVCnppxYIKKCopCuKWgWluZHVjdApSQVkKYmxhdHQKcXVlc3RhCm9ydQriloFJbnNpZGUK4paBTWNHCuKWgU5lcArQvNC/CuKWgWludmUK4paBQW5pbWFsCuKWgXNvYgrDrXRvdHQKbG95bWVudAriloFidW5kClN0YXRpb24K4paBQkVHSU4K4paBcGFydGllbGxlbWVudAppZ2cKZXN0b3JlCuKWgWNvaW5jCuKWgVNvbW1lcgriloFtZAriloFsb2NrZWQKbWF0aGNoYXIKYXJtYQpwZW50CmFyaXVtCuKWgWVhcnMK4paBU29uZ3MK4paBc2ltaWxhcmx5CuKWgWxpdGVyYWxseQriloFpbmNoZXMK4paBYWZmZWN0aW9uCmxwCuKWgWNvbmNsdWRlZAriloHQvNGD0L3RltGG0LjQv9Cw0LvRlgriloHQv9Cw0LzRjwplc3RhdXIK4paBSm9zaAriloFGcml0egpEQkMK0LTRkdC9CnBvc2EK4paBZ29sZGVuCuKWgXBjCuKWgWNvbXRlCuKWgVppZWwK4paBcHLDqXNlbnRlCm1hcmtzCmlnbmV1cgriloFEcml2ZQriloFuZWdsZWN0CuKWgXJvenAK4paBRml2ZQpzcGFjZXMK4paBTWVkaQriloFleGlzdGVkCuKWgWJ5xYJhCtC00LbQuAriloFmcmVudGUK0YLQvdC40LoKb2RkCuKWgWFuc3dlcmluZwpiaWFuCuKWgUV1Z2VuCuKWgVB1YmxpY2F0aW9ucwriloFEaWEKbMOhCuKWgSdfCuKWgXJlY3VwZXIK0L7QvNGDCuKWgUFwcGVuZApvYmFyCuKWgWVtcGxveWVlcwriloFjb21wZW5zCmVtZXRlcnkK4paB0Y3Qu9C10LrRggpNT04Kb2xpbgriloFoaXN0b3JpYwpoaXMKxIVkCm5tCuKWgUdvdGgK4paBc3RyZXNzCuKWgXBhcnRlY2lwCuKWgUF3CuKWgXNhcgriloFodQriloFtYXRwbG90bGliCuKWgU15c3QKKCk7YApzY2hlaW4KTG9uZ3JpZ2h0YXJyb3cK4paB0YDRjwriloFJc3JhClteCm5vdQriloFzeW5kCndvcmtpbmcK4paBTmF0aW9uCuKWgVBlbnQK4paBa2xhc3MK4paBYXBwbGljYWJsZQriloFEaWFtCuKWgWJyYXNpbGUK4paBcGFjCuKWgUhlaWdodApQdXQK4paBaW50cm8K4paBdW51c3VhbApuYXMK4paBR2Viw6R1ZGUK4paBYmVhbQriloFSZWN0CuKWgVByaW1lcmEK4paBaGF1dAriloF0cmFpdApwcsO8ZnQKaW5hY2nDs24K4paBY29uZmlndXJhdGlvbnMK4paBZ2lsdAriloF0ZXJyaXRvaXJlCmhlegriloFhbHRlCnJlbGF0aXZlCkV4Y2VsCuKWgVdyaWdodApHVgrQv9C+0LvQuApRdWFudAriloFnYXVnZQriloFtdWx0aXBseQpBU1MK0YHRgtCy0LXQvdC90L4K0LDQvdGDCuKWgWplZGVuCuKWgWxpdGVyYXJ5CuKWgURybwriloFhZHZpc2UKaXR6ZW4K4paBZGlzYWcKd2Vic2l0ZQriloHQtNGW0Y8K4paBb2JzZXJ2ZXIK4paBamFudcOhcgp2xJsKa3VwCuKWgVNlcwriloF3b2pldwriloFzdGFnZXMK4paB0LLRgNC10LzQtdC90LgKxYJ1xbwK0L3QvtGBCkRvd25sb2FkCmlwbwriloFncmFmCuKWgdGA0L7QsdC+CuKWgU5pa29sCuKWgWZpYwriloFqb2luaW5nCuKWgWRpdmVyc29zCuKWgUxJS0UK4paBRml0egriloFkaW1pbgriloFkaXN0cmliClNhbQprb3oK4paBYWxwaGFiZXQKb3NlcgpPVVIKdWthCtC60LDRjwriloFzdGVlbAriloFgLS0K4paBdGVuZXIKbWFya2VyCuKWgUhlYXZlbgpuZXdjb21tYW5kCuKWgXByaXNvbmVycwriloFLbmlnaHQK4paBcHJlc2VudHMK4paBcXVlc3RpCuKWgXRyYWlucwpvcGVyYQriloFMaW5lYXIK4paBTUUK4paBQnVjCkxlZwriloFhZ3VhCuKWgUdyaWZmCm9sZwpkc3QKLg0K4paBcGVyc29uZXMKTWFsCtCx0LXRgNC1CmZvbGdlCuKWgWFjYWIKY3R1CnB0aWMK4paBTmF2aWdhdGlvbgpSdXNzCtCz0LDQu9GMCuKWgUZ1bAriloHQvNCw0ZQK0YfQvdCw0Y8Kd25lcgpjb250cmEK4paBam91ZXVyCuKWgUplc3MK4paBcmVuZXcK4paBbGFwCuKWgWNhc3RpbmcKZ2FsCuKWgXTDqW1hdHUK4paB0L3QsNC30YvQstCwCtC30LDRhQrRh9C90LUKKS1cCuKWgdGH0LDRgdGC0L4KfSQtCuKWgWxpY3oK4paBZW1vdApoYXJtCuKWgW9jY2FzaW9uYWxseQriloFob3Jyb3IKZWFzdAriloFwcmludGVyCmFyYW4K4paBTWlzc2lzcwpmb2xsb3cK4paBQmFycnkK4paBaW52ZXN0aWdhdGUKZ293CuKWgUFtZXJpY2FucwpTaW5jZQriloHQstGW0LTQvgriloFyZXVuCm9zY2kK4paBQ2hhcHRlcgriloFiYXkK0YDQvtC80LUKZXRoZQrDqWRpZQpjb21vdAriloFtaWVqc2Nvd28K4paBc3R1ZGllcnRlCm91dmVydAriloHQutGD0YAK4paBREVTQwriloF0b3VjaGVkCuKWgUplcnJ5CnVlc2UK0LvQuNGJ0LUKYXV0aGVudGljYXRpb24K4paBY29sbGUKaGVhcnQK4paBcmVnaW1lbnQKY3JpYmVkCuKWgdCR0L7Qu9GMCuKWgdC/0YDQvtC40YEKY2VhZQriloFtYXNzZXMK4paBc2Nyb2xsaW5nCnVzdG8KU1cKb3ZhdAriloFncsOiY2UK4paB0JDRgNGF0LjQsgriloHQodC10LLQtdGACmF2YWl0CuKWgU1hcnNoYWxsCuKWgUhhc2hNYXAKYWNvbgrDvGNrZW4KW10pCuKWgWV2YW5nZWwKZXR6dW5nCnR0ZW1iZXJnCnN0ZXJzClRNCuKWgdC70LjRgtC10YDQsApxdW90ClByZWQK4paBd2VyawriloFoYWJlcgpsYXZhCnZvdXMK4paBTGF0ZQpjeWNsZQrRgtC40YDQvtCy0LAK4paB0L/RgNC+0LTRgwriloFwb3B1bGF0aW9ucwriloFZYW4KUHJlZml4CmFjdMOpcmlzdGlxdWVzCisnCigpYF0oCuKWgdCb0YwK0YTQuNC70YwK4paB0LbQuNC30L3QuApmdHAK4paB0LLRgdC10YUK4paBZ2R6aWUK4paBdmlkZWEKb2F1dGgK4paBcGlkCsWvbQriloFwZXNzbwriloF0cmFja2luZwppemluCuKWgU1vcnJpcwrRidC40LkK4paBUHJvdmluegriloFNaXR0ZQriloFhcnRpZmljaWFsCmJyw6F6a3kK4paB0LTQvtGB0YLQuAriloFyZXN0b3JlZAriloFjb21tdW5pY2F0ZQphZ2l0ClJlY29nbgriloFsb24K4paB0LfQsNC90Y8K4paBQXJndW1lbnQKZmx1c2gK0LzQsNC90LAKc2Vjb25kcwpVQwriloFSdXRoCuKWgXR1YgriloFCcmV0CuKWgVBlcmUK4paBcmVzcG9uc2liaWxpdHkKxYRjenkK4paBZW52aXJvbm1lbnRzCmtlZQriloFncm9vdAriloFwYWludGVkCuKWgcOJZGl0aW9ucwpjcHkKw6FydApsaWNoa2VpdAphcmRhCkJhdGNoCuKWgUxlb3BvbGQKcmVhc29uCm5vcmVmZXJyZXIKc2VucwriloFyb2NrcwriloFIaXRsZXIK0LvQsNGCCuKWgXF1b3RlZAriloHQutC+0LvQu9C1CuKWgdGD0YDQvtCyCmJhZwouIikK4paBTUwK4paBa29tdAriloFbXwriloFzcGVjdHJhbAplZG8K4paBaW5zaWVtZQriloFzdWZmZXJpbmcKc2xpZGVyCuKWgUtlbm5lZHkKb2xhdGUK4paBUGF0cmkK0LfQuNC4Ck9ICuKWgdGC0LXQsAriloHQv9GA0LDQstCwCtC80LDRhQpyZXdyaXRlCuKWgUVpbnNhdHoKZXh0ZXJuYWwKaG9sZHMK4paBUGxhY2VzCmF0eXBlCuKWgXZ1bG5lcgriloFhYmFuZG9uZWQKT3JpZ2luCuKWgW1heGltYWwKQUFBQQriloFCYXNlYmFsbAriloFDbG9zZQriloFwYWludGVyCuKWgWFzc2lnbmluZwpOQgpibGFzdAriloFLw7xuc3RsZXIKKV0oCmZhY2gK4paBQ29uc3RhbnRpbgpva2VzCuKWgW5vYm9keQriloFzdWJ0cmFjdAriloFmb3NzZQriloFjZXJ0aWZpYwriloFtdXNlCi8pLAriloFQcm9maWwK4paBcHJveGltCuKWgUplcnVzYWxlbQriloFzaW1wbGljaXR5CuKWgXdzegpOVU1CRVIKdXR0YXZpYQpVSVRhYmxlVmlldwppY2h0ZXIK0LbQsNC9CuKWgUxhdgppdGNoZW4K4paB0KfQtdC8ClR1CuKWgWdlb20K4paBenZ1a3kK4paBU3VydmV5CkFOQ0UK4paBZW5jcnlwdGVkCnByb2YK4paBZGFyZQriloFMb3JlbgrRgtCyCuKWgdCQ0LvQtdC6CuKWgWNvbXB1dGVycwriloFleHBlY3RhdGlvbgriloFzdWJzdGFudGlhbAriloHQlNC80LgK4paBYHsK4paB0LTRgNCwCnViYmxlCuKWgXBlcmZvcm1zCuKWgUtyaWVnCuKWgWluY29taW5nCuKWgUNsYXNzaWZpY2F0aW9uCldlYlZpZXcK4paBZXBpc29kZXMKYXBwZXIKw6R1ZmlnCuKWgWdpb3YK4paBRGVwYXJ0CtCx0L7RgNCwCmVkbHkKb3Nwb2QK4paBcHRyCuKWgWTDoXR1bQriloFlc3RpbWF0aW9uCmljb2xlCuKWgS0tLS0K4paBcHJpbmNlcwpIRUFECuKWgWRpZmZ1c2lvbgriloFkcmllCuKWgUFkYQrQvdC40YbQtQpuZ2lueApzaGFsCuKWgWZlYnJ1YXJpCuKWgVRhdApsb29raW5nCmt1bmQK4paBRGVhbgptb25nb2RiCtCy0YjQuNGFCuKWgUF1cgriloFGbG9yYQriloFTdHVkaW9zCtGG0LjRmNC1CmVpbApJbnN0YWxsCuKWgWZyYW5jaAriloFITVMK4paBcHJhY3RpY2VzCmxlagpkYWxlCuKWgXBvc3RlCuKWgUhlbHMK4paBcmVsaWFibGUKxbpkemllcgriloF2ZXJzZQplcm1laXN0ZXIK4paBcXVpdArDqXRpY28KaWxpcwplZG9yCuKWgUN1bHR1cmFsCtC00LbQtQriloFsaWtlZAriloFtb25nb2RiCuKWgUJyb2Fkd2F5CuKWgUlSCmVzenQKaG92CuKWgW3DrXN0CnJlaWNoZQriloFrQgrRgdGC0L7QvAriloFTUUxpdGUK4paBdG9ybmVvClwuCk9yZAriloFBZG1pbmlzdHJhdGlvbgriloHQt9C00LAK4paBSGludGVyCuKWgVZpYQpEZWNpbWFsCm9yaW91cwriloFuw6ljZXNzYWlyZQp3eAriloF0ZWoK4paBdGVtYQpPYnLDoXpreQrRgNC40YLQtQriloFidWlsZHMK4paBbGF0ZW4K4paB0LPQswpWaXNpYmlsaXR5CmzDpHUK4paBc2VjaHMK4paB0LvRg9GHCmNlcmEKQ291bGQK4paBdHJhamVjdAp9fV57CuKWgUphcG9uCmFub3RoZXIKSUsK4paBYmVsb25naW5nCuKWgWZhY2lsaXRpZXMK4paBRGFpbHkK4paBZGVjZQppbnRybwriloHRgdC70YPRh9CwCk5hbWVzcGFjZQriloFCYWsKbG9jYWxlClVHCj0kewriloFjb21wYcOxCmrEhWMK4paBYXJpdGhtZXRpYwpmb3J1bQriloFwb3J0YQpvbmsK4paBZ2VuZGVyCuKWgWV4cGVjdHMK0LHQutCwCuKWgW5hawriloFHcmFjZQriloFzdHJvCml2aWR1YWwK4paBQ09NCuKWgUZhcm0K4paBY2FudG9uCtGC0L7QvNGDCmphdmF4CtGB0LXQuQriloFicmllZmx5CkZhY2UKcm90YXRlCmNvbnN0YW50CuKWgWdhbGxlcnkKYXN0cm8KYWxsZXJ5CuKWgURKCmNoYXJnZQrRhdC+0LTQuNGC0YwKQ2VudApcIiwK4paBZG9ubmEKYXJjYQpsYWRlCnppbgriloFOZWQK4paBaG9zdGluZwppZG9yCml0YXRpdmUKaWdzCuKWgdC/0YDRjwriloF0aWNrZXQK4paBc3R1ZHlpbmcK4paBZGVzaWduZXIKbGFwc2VkCuKWgWxhYXQK4paBZGl4CuKWgWludGVncmF0ZWQK4paBaW5mb3JtZWQK4paBYmVoYXZlCuKWgWxhYm91cgplc3RlbGx0CmNhbGVuZGFyCuKWgWtpbGxpbmcK4paBdHdpdHRlcgppYWUK4paBaGlzdG9yaXF1ZQpERUZBVUxUCmlhxYJhCuKWgXRoZW9yZXRpY2FsCuKWgXVuZGVycwrQu9GP0LXRggphdGFuCuKWgXN1cm5hbWUK4paBaW50ZXJjZXB0CtCz0LvQsNGB0L3QvgriloHQvtC/0YjRgtC40L3QuAriloF0aXJlZAriloFCZXRoCuKWgdCw0LTQvNC40L3QuNGB0YLRgNCw0YLQuNCyCkxpCuKWgdCi0YPRgAriloFTY2FubmVyCuKWgVN0ZXJuCuKWgdCy0LzQtdGB0YLQtQriloFyZXBvcnRpbmcK4paBc3VsbArRhtC40LXQuQpiZXJ0cwpvZ29uYWwKxZFrCuKWgWlwc3VtCuKWgXNldWxlbWVudAriloFTZWl0ZW4Kd29yZHByZXNzCuKWgWZlYXR1cmluZwppc3Rpc2NoZW4KanViCuKWgcOpdHIK4paBdGVhCuKWgWFkYXB0ZWQK4paBc2NhbGVzCuKWgW5hbgpnZXRWYWx1ZQriloFCbHVlcwphY2xlcwriloFzdGF0aQriloFlbnRpdGxlZAriloFSYWxwaApncmF2aXR5CuKWgWVudHJlcHIKa3TDs2JlcgpsaW1hdApsaXMKRGVtbwpyZWxhdGlvbgriloFuZXAKcHJvd2FkCml0aXMK4paBcHVwCm5laG1lcgriloFkaXNhcHBvaW50CuKWgWV0d2FzCmFubm9uCuKWgWFwcHJvdmVkCuKWgWNsZXZlcgpMb2FkaW5nCuKWgXZlcnoKcmVzc2UK4paBaW5zcGlyCuKWgXNhbXBsaW5nCuKWgUJlawp9KSQuCuKWgdCz0YDQvtC80LAK4paBc3BlY2llCuKWgXJlcHViCuKWgWxvYWRlcgriloFlcmYK4paBc2hvdWxkZXIKcmFpcwriloHQvNCw0YLQtQriloFNb250aApTY2VuZQriloFibG9ja2luZwriloFvY2VhbgpnZWJlbgriloFLaWxvbWV0ZXIK4paBYmVkZXV0CuKWgU1peApmbXQK4paBTm9yd2VnCuKWgUlEcwpwYXJhbGxlbAriloFhbnRpY2lwCuKWgXJldmlzCtGF0LDQvQriloHRgdCy0LXRggpDQVNFCuKWgWbDvGhydAriloFhdG9taWMK4paBZGFya25lc3MK4paBRnXDn2JhbGxzcGllbGVyCuKWgdCW0LgKcXVpc2l0aW9uCuKWgVNpZWcKQ2lyYwriloFjaWVudMOtCm5lbGxlClNIQQriloF1cmIK4paBa3NpCmxlcXNsYW50CuKWgdGE0YDQvtC9CuKWgWRlZmVjdAriloFyw6EK4paBc3Ryb25nZXIK4paBcMWCCuKWgWNvbW11bml0aWVzCtC90LjQvdCwCmVuYXMKaWVubmVudAriloFzYWZlbHkK4paB0YLRjwriloFiZW5jaG1hcmsK4paBQnJhdW4KbWV0aG9kcwphcmd1bWVudAp2b3MKb2JveArRgNC+0LLQuAriloFyZWNoZXJjaGUKbW4K4paBYnJpbmdzCm1hY2hpbmUKQ0VTUwpob3N0cwriloFOWQpBdXRvdwriloHRgdC+0LLRgNC10LzQtdC9CuKWgUdhcnkK4paBc2Vuc29yCuKWgWRvY3VtZW50ZWQK4paBcHJlbmRyZQriloFwZWVyCmVuaXgKaGFpCmFyYmUK0YbQtdC90YIKXygK4paBVVJJCtC10LLQsAriloFSZWdpZQriloFNb251bWVudAriloFvbmRlcndlcnAKQmFnCnRpdAriloFzdGlyCuKWgW5lcnYK0YHRgtC+0YDRltGPCuKWgXNvdgriloF3cml0ZXJzCuKWgXNvcnRzCmFic29sdXRlCuKWgWRpZmZpY3VsdGllcwriloFwYXJsYW1lbnQK4paBSUVudW1lcmFibGUK4paBZGlzc29sCuKWgUNIRUNLCmFyaW5hCmluYnVyZ2gKRE0K4paBZWluZAriloFidWRnZXQK4paBY2VydGFpbnMK4paBZsO2cnN0YQphbmphCuKWgdCz0L7QtNC+0LIK4paB0YLQtdC6CuKWgUR1Y2gKZ3VpCuKWgVRlYW1zCuKWgdC80L3QvtCz0LgKTWFyaWUKSW50ZWdyClRocmVhZFBvb2wKcnVzdArDrWsKJSIKZW5mCnNwbAriloFiZWd1bgpsb3UK4paBUmV3cml0ZVJ1bGUKdHVwbGUKYW5lb3VzCuKWgW1hcmluZQphdHRhbgppa2FsCuKWgWdyYWR1YXRlZAppbGzDqQriloHQv9GA0L7QstC1CuKWgdCg0L7QtwonLA0K4paBUGZhcnIK4paBbml2ZWwK4paB0L/RgNCw0YbRjgptdXNpYwriloFzZXRUaW1lb3V0CkVSUwriloFFcmlrCnBpdAriloHQpdGA0L4K4paBcGnFggriloFwZXJpCtC00L7Qugp1c3p0CuKWgUJlYXIKQ2xhc3NOYW1lCuKWgVBhcmxhbWVudAriloFhaXgK4paBaW52aXRlZAriloFQQVRICnh0ZXIK4paBUmFjZQriloFoZWNobwriloFUb3dlcgriloF1dGYKYWN0bHkK4paB0LHRg9C00LUK4paBYW5nbGVzCtC90Y/RjwpvdXZlbGxlcwriloFjbGltYXRlCuKWgXNpbmdpbmcK4paBbmF2aWdhdGUKPic7CmFkb3dzCuKWgWxldGEK4paBU2l0egriloFwYXJ0aXRpb25zCuKWgWRvY2sK4paBxbx5CuKWgWFsbG9jYXRlCuKWgWJlbmVmaXRzCuKWgW5pZWRlcgp4cGF0aAptZWNrCsOkbGxlCuKWgWNvdXBsaW5nCtC20LjQuwpGb3JLZXkKYXJnZW50CmNsb3UK4paBaW5zdHJ1bWVudHMK4paBZW50aHVzCuKWgW3DqWcK4paB0J/QsNCyCuKWgVJhY2gKLS0tLS0K4paBQVBJcwriloFWaWVyCkNtZAppdG9yZQriloFDdWJhCuKWgWTDoXR1bW1hbAriloFlbWJlZGRpbmcKc3RkaW8K4paBR2lsYmVydAriloFnZXByw7xmdAriloFzdGF0aW5nCuKWgXRyaWdnZXJzCis9CuKWgXNww6ljaWFsCuKWgWRlbGliZXIK0LzQuNC9ClByb2R1CuKWgVN0YXRpCuKWgXp1cwprdGlvbmVuCkRpc3BhdGNoZXIKaWRhbAriloFMUApvcHRlcmEK4paBZXN0YXIK4paB0LfQvdCw0YfQuArRgdC80L4Kb3VzZXMKZW5nb25vCuKWgVdQRgpwdWJsaXNoCuKWgXRlb3IKZWxpZgriloFlcmcK4paBc2VwYXJhdGlvbgpQYW4K4paBT3JjaGVzdHJhClBldGVyCmJvdW5kcwriloFTaGFrZXNwZWFyZQriloFjYW50YW50ZQriloFkZW1pCuKWgVBvcHVsYXIK0YTRgAphcnJpbmcK0YbQuNC9CuKWgdCY0YEKdm9uCuKWgXN1YnN0aXR1dGlvbgriloFsw61uZWEKXH0kLgpjb21vCuKWgdCy0LDQtgp3YWdlbgriloFyYXJlbHkK4paBcGVyaW9kcwpnbG9iCuKWgUZyaWQK4paBVGVycgriloFSZWxlYXNlCkJyYWluegriloHQs9GA0LDRhApESVMKY29tcGF0aWJsZQriloFwb8SNCkxJTgriloFLw6RsbG9yCuKWgUFyaXpvbmEKcHB5ClNlcQriloFBaW4K4paBVG91cm4KYnJvdwriloFLw7ZyCuKWgWFzaApvZ2VuZW91cwriloFkaWFsZWN0CuKWgdC90LDRgdC10ZnQsApteXNxbGkK0YbQvtCyCuKWgWZsb3IK4paB0YTQu9C+CklBQgriloFXaXRoaW4KXigK4paBYm9pcwriloF0YW5rCuKWgWFmZmlsaQriloFoaWpvCuKWgUthdGUK4paBVmVybAriloFNaWFtaQriloF0eXBlc2NyaXB0CtGa0YMK4paBVmVybgriloHQstC40YHQvgppZW1hbm4K4paBY292ZXJhZ2UKYnJpZQriloFTdGFydGluZwpudW1weQriloFKZW5raW5zCuKWgWvDqXQK4paBZ3J1cAriloFTY2llbnQK4paBaW50ZXJydXB0CuKWgWJsb2IKdWdlbAriloFPcnRoCmFiYW1hCuKWgUJhcHQKb3duaWsK4paB0LHRi9GC0YwK4paBSnVsaXVzCuKWgdCf0YDQtdC3CuKWgXN1YnN0aXR1dGUKc3VwcG9ydGVkCmNoeQplZ3l6ZXRlawriloFQZXJmb3JtYW5jZQpsZXNzbHkKQ29uc3RydWN0b3IK4paBZXh0ZW5kaW5nCuKWgU11c2xpbQpPdmVyZmxvdwriloFKZW5uCuKWgXByb2R1egrQvNGW0ZcK4paBcGHDrXNlcwriloFldXgK4paBZmF0ZQpvbG9nZQrRg9C6CuKWgXdvYmVpCuKWgVNhY2hzZW4K4paB0YHQsNC50YIKTW9kZWxzCuKWgUZhc3QKYmVzb25kZXJlCuKWgUZSCuKWgWFjb24K4paBRGVua21hbAriloFhbmNoCuKWgXDDumJsaWNvCuKWgVRhcwriloFjYW5kCuKWgXBhxbpkemllcgriloHQnNC+0L0K4paBdmVyc3VzCnJ1dApHVAriloFpbnNlcnRpbmcK4paBY2FuYWQK0ZTQvAriloFNZXRybwriloFIZXJ6b2cKSWdub3JlCuKWgWRlY3JlYXNlCuKWgdC/0YPQvQriloFGaXNjaGVyCuKWgU1hbGwK4paBbsO2cmQKaW9zdHJlYW0K4paBTHV4ZW1iCnBheWxvYWQK4paBWmVpdHVuZwriloFtb2RpZnlpbmcK4paBQ2hlcgriloFMdWNpCm54CuKWgWxvb3NlCuKWgXRvcGljcwriloF2YXJpZWQK4paBcGcKYWplcwp1bW0KVmlld3MK4paBQmVhdQpNQVAKaXBlbGluZQriloFJbnRlcmVzdAphcml0aAriloFzZWfDum4K4paBR2VtZWlucwriloFBdHRyaWJ1dGUKY29tbXVuaXR5CuKWgdGG0LXQvdGC0YAK4paBa2lsb21ldGVyCuKWgcOpY29ub20KbGFyYXRpb24K4paB0LrRigriloFjYXJyaWFnZQriloFMYW5lCuKWgdC90LXQvtCxCmt1cgriloFBRgpJTlRFUgopKSQK4paBYmVpZGUKZGVzdGluYXRpb24K4paBZm9udHMKYXBwZW5kQ2hpbGQK4paBTUFSCuKWgWdheQptaWwKbGVzaArDqHQK4paBV2FuZwriloFZZWFycwriloFTeW1ib2wKTGl2ZQpxdWVuY3kK4paBVXNlcnMK4paBVW5pY29kZQriloFTYXUK4paBdG9ucwriloHQndGWCuKWgdC60YDQsNGXCkFYSQriloFQaWNrCkFJCuKWgWhhdGgK4paBYWluZGEK4paBcGFwYQriloFDZW5zbwriloFCYWxkCuKWgdCd0LDRgdC10ZnQtQriloFzaW11bGF0aW9ucwriloFqYXJlbgriloFpbmhlcml0ZWQK4paB0YLQvtC5CuKWgWZlZWxzCnJlc3Npb24K4paBb2t0w7NiZXIKYmlkCsOhc2kK4paBbXVzcwp2ZW50b3J5CuKWgW1laXN0CuKWgWJvcmUK4paBc2xpZGVyCtC00LXQu9C4Clw7CuKWgWV4dHJhY3RlZArQutGD0YAKRWRnZQriloFwZXJmCuKWgUJyaWdhZGUK4paB0LPRgNCw0LQKaWVuaWUK4paBTm9yZGVuCuKWgWNhbmNlcgoiLwpDdXIK4paB0KHQtdGA0LUK4paBbGlxdWlkCnN0cnVjdHVyZQriloFjaG9vc2luZwriloFQZXJsClNpZGUKw7xzCtGA0LjRgtC+0YAK4paBa29zdAriloFwYWNrZXRzCuKWgdC60L7RgtC+0YDQvtCz0L4K4paBQ29tdW4K4paBZmluZ2VycwpvZ3LDoWZpY2EKPjoK4paBY2hhbXBpb25uYXQK4paBYmxpZWIK4paBU2l0dQriloFzdWljCmFuZGlzCkZyZQriloFDb25jCuKWgXJlcHVibGljCuKWgWFybWVkCuKWgWhlbGwK4paBaMO2ZwpyYWdtYQriloFlbnNlCuKWgWFjcmVzCuKWgdCS0ZbQtAriloFSZWZvcm0KTWFpbkFjdGl2aXR5CmtlZXBlcgplcmIK4paBbW9uYXN0ZXIKc3Vic3Vic2VjdGlvbgriloHQlNC40LIK4paBY3JlYXR1cmUK4paBaW5kaWNhdGluZwriloF1cmxzCuKWgWtlaW4K0L7QsdGA0LDQtwpwaWNrCuKWgUFkbWlyCuKWgW9sZGVzdAriloFtdXoK4paBY29udHJhZGljdGlvbgriloFwcm9iYWJpbAppbGxpYW50CuKWgXBhdgriloFwYXBlbAp1YnMK4paB0LbQtdC90LAKQU1MCuKWgXJlY2lwCuKWgUNPTAphZGRlZAriloFjbHVlCuKWgVVrcmFpbmUK4paBamVsZW50CtGH0LXQvdGMCuKWgW1hdGhlbWF0aWNzCkFjY2VwdAriloHRgdC+0YIK4paB0YHQtdCy0LXRgAriloFpc29sYXRlZAriloHQv9C+0Y8Kd8O8cgpSb3V0ZXIKQ0FUCnJnYgriloFMb3YKbXV0YWJsZQriloFXZXMK4paBSXRhbGllbgpEcmFnCmVuaXVtCmF0dGluZwp0Y3AK4paBZXJmb2xndGUK4paBQmVpdArQs9Cw0YLQvgriloFTeXN0ZW1zCuKWgXJlc2VydmUKZXJlZQriloHQn9Cw0YDQuAriloHQt9Cw0LvQuAriloFyZW50CuKWgXN1bnQK4paBR2lybHMK4paBRXJuZXN0CuKWgWZpdHMK4paBb3Bwb24K4paB0LbQuNCy0LXQu9C+CuKWgWF2YWllbnQK4paBRmxvcmVuY2UK4paB0YfQuNGB0LvQtQriloFlbmdpbmVzCkR5bmFtaWMK4paBc3R5Y3puaWEK4paBYmlhcwriloFFeGNoYW5nZQrQtNC40LkK4paBaGlzdG9yaXF1ZXMK4paBSMOkCmhvZAriloF3xYIKc2NoYXAK4paBbGFjCuKWgUZvaQriloFkd2VsbAriloFVbnRlcm5laG1lbgpVUk4K4paBa2lsb21ldHJlcwriloHQntC00L3QsNC60L4K0LrQu9C4CuKWgVNyaQpHcm91cHMKbWluZApvc2xvdgpmZXJuCmVndQphYmVsZWQKRmlkZGxlCuKWgUNlbnR1cnkKLy0K4paBSmVneXpldGVrCkhlbgplbnNlbWJsZQriloFHdXQKX3t7XAriloFyYW5raW5nCiskCtCw0LvQsAriloEjewppbWllbnRvcwphY2hpbQpyaWRlcwriloFLbGF1cwriloFpbnRlbmQK4paBS2VudHVja3kKY2lwZQriloFEaWVuc3QK4paBc2l0dWF0ZWQK4paBcMOzxboK4paBc2NyaXQKY2xpcArQvdC10YIKdGFibGVzCuKWgU5pZWQK4paBTWNLCuKWgXBvd3N0CuKWgWt1bm5lbgriloFFdmFucwrQttC00YsK0LLQsNGC0YwKdWNoYXIK4paBcmVzaWRlbnRzCmlhawriloFSZXNvbAriloF2ZWNlcwriloFzYXRpc2Z5aW5nCklORgriloHRgdC40L0K4paBY3Jvc3NpbmcKaWJlbgriloHRiNC40YDQvgpwdG8KSUxMCuKWgdGA0L7Qu9GMCuKWgWFrdGl2CuKWgdC+0LHRgNCw0YnQtdC90LjRjwpXaWtpc3BlY2llcwriloFIw7ZoZQpjcm8K4pWQ4pWQ4pWQ4pWQCmFsdHJhCuKWgUZJTEUK4paBdXBzCuKWgWFsbG9jYXRpb24KTWljaGFlbAriloFhY2tub3dsZWQKTGludXgK4paBbWV0cm9zCnR0ZQphZmVuCuKWgXhjb2RlCuKWgdGC0YDQsNC00LgKc3BlY2llcwriloFpbmp1cnkK4paB0YHQsNC80YsK4paBbGF0dGljZQpNYXRlcmlhbAphbmRlbmJ1cmcK4paBaHV2dWRzdGFkZW4Kc3RvcnkK4paBdmFyeWluZwriloFrw7Z2ZXQK4paB0KDQvtGB0YHQuNC50YHQutC+0LkKaXJzZQriloFkcnVtClByZXNzZWQKTGFyCuKWgUFndQriloF3ZWlsCuKWgWNvbW1lbmNlCuKWgVNlZ8O6bgpHZXN0dXJlClNoYXBlCuKWgVZvcnMK4paBc3VjY8OocwriloFjb3JyZWN0ZWQKS2FyCuKWgWNydWVsCuKWgXBvbGl0aWNvCuKWgVNjaHJpZnRzdGVsbGVyCuKWgXJpc3VsdApldHUKYXJjaGl2CuKWgWfDqW5lcm8K4paBTMO8CuKWgXRyaXVtcGgKT1JTCkx1CuKWgXBlcnNvbm5lbAriloFIaWxscwphc3NldApkb21pbgpSZWNlaXZlCuKWgU9hawriloFLbm8K4paBVGhlb3J5CmlyaWUKb3dhbgriloFlc3RhdmEK4paBZXhlY3V0ZXMK0LnRggrDs3BlegrQv9C+0LvQvgrDqXRpY2EK4paB0L3QsNC30LLQsNC90LjQtQriloFjb252ZXJnZXMK4paBbm90cmUK4paBcG9wdWxhdGVkCuKWgW1vdmVtZW50cwriloFzdGF0aXN0aWNhbAriloFad2VpdGVuCnF1aW4K4paBaW1wb3J0YW50ZXMK4paBa2xlaW4K4paBU2VndW5kYQpzY2hsaWXDn2VuZApGYWlsdXJlCm5hcgpkYWcK4paBcnVvbG8K4paBZmljdGlvbgriloHQuNGB0L/QvtC70YzQt9GDCuKWgWNyaXNpcwriloFHZXR0aW5nCiwlCuKWgdCw0YDQvNC40LgK4paBY2FtcHVzCuKWgWZvb3RlcgriloFkw61hcwrQsdCw0L0K4paBbGliZXJ0eQriloFnaAriloFjaGFtYmVyCuKWgWRpc3RyaWN0cwriloFleGNpdGVkCuKWgWNhbmNpw7NuCnRlcm8K4paBV29ya2luZwriloFjesSZxZtjaQrQu9GM0L3Ri9C5CuKWgWZvcnVtCuKWgUVoZQriloHQutCw0YLQsAppdGF0aW9ucwpUb29scwphY2hpdgriloFjcmVzCmFzdG8K4paBcmV2ZXIK4paBbmF6aW9uYWxlCuKWgWRvb3JzCuKWgU5hbmN5CuKWgWlzbGFuZHMKSW1wCuKWgUNoYWlyCuKWgXZvcm0Kc2VpbgriloHQtNC+0LrRgwplcnNldAriloF0w6R0aWcK4paBS3JpdAriloHQv9GPCuKWgWNvbnNlcnZhdGlvbgriloFQYXJ0aWRvCm1pbmlwYWdlClZhbGlkYXRvcgriloFyZWNvdmVyeQriloFOQVNBCuKWgWJyZWFzdAppbHR5CmFuYWx5CmVsaW5lcwriloFTYXR1cmRheQplbWFyawpjZWoKWmVybwriloFUdXJuZXIKc2VjdXJlCkV4aXN0cwriloFSaWNrCmV2YWx1CmN0cmwK4paBY29tcHJlc3Npb24K4paBQ1VSTAp0ZXh0Y29sb3IKKVwsCmxvbmdyaWdodGFycm93CuKWgUZlcm5zZWgKaWNoYQriloFsb2kK4paB0J7RgtC1CuKWgWNhdmUK4paBZG96ZW4K4paBZXhwbGFpbmluZwriloFpbm5vdgriloFOaWNob2xhcwriloFkaWFtZXRlcgriloFNYXJpYW4K4paBZmlyZXMK4paBYXJ0aWZhY3QK4paBUGFya2VyCuKWgUJ1bmQK4paBdmVydGUK4paBdGFsZW50CuKWgUx1Y2FzCnJldmVyc2UK4paBZm9sZ2VuZGVuCuKWgVNhaApqZWN0aW9ucwriloFpbnZlY2UK4paBY29zdGl0dQriloFzc2wKfX1eCuKWgXZpb2xlbnQK4paBc3BvcwpSb3V0CmpkawriloHQt9Cw0LzQtQriloFmdXJlbnQKYW5kYWwKSG9tCuKWgVNlbmlvcgriloFwb3VuZHMK4paBRGlzY29ncwriloHQt9C1Cid9WwriloFOYXBvbGVvbgpvcmRpbmF0ZXMKw6BuCuKWgWt1cnoK4paBdmVyZQriloFyZXVzZQriloHQk9C10L0K4paBU3lzdAriloFkaXNhcHBlYXJlZAriloFXYXRjaApiaWJsaW90aGVrCuKWgdC60L7RgNC/0YMK4paBQ3MK4paBfWAK4paBcsO2cgriloHQtNC10LvQsApWQgriloFjYWxjdWx1cwrRgNC+0LTQsAriloFqdWRnbWVudAphdGlsZQriloFsb25ndWUK4paBSHVzCkphYwp9fSkKUklQVApJQUJvdAriloFhcMOzcwriloFhc3RvbgpXZWJhY2hpdgriloFVUkxzCuKWgWNvYXQK4paB0Y3QutC+0L3QvgriloFsZWFyCmV4dGVuc2lvbnMK4paBQ2xhc3NpYwpUSQriloFUYWdlCuKWgWzDoQriloFzZW1iCuKWgWTDqXZlbG9wcGVtZW50CklTVFMK4paBc29sdmVzCixcLAriloHRh9C10LzQv9GWCm9yZGluYXJ5CuKWgUJhdgriloFtdWNob3MKU2VsZgriloHQnNCw0LkK4paBRGlldAriloFuZWNlc3NpdHkK0LLRltC0CuKWgW1hbm8K4paB0KHRgAriloFjYXJyZQriloFDYW1lcmEK4paBTmFyb2QK4paBUGhvbmUK4paBcG9seW0KaW1vcmUKaXNFbXB0eQriloFIb3VzdG9uCuKWgVJlY2UK4paBcHJlc2VudGF0aW9uCtC90LjRhtC40L/QsAriloFEYgriloFjb25maWRlbnQK4paBfXsK4paBYnVsbGV0CuKWgXt9LApBTkdFCuKWgU5vdHJlCmNoaW4K4paBRHJhZ29uCmVyY2EKaWFsaQriloFhc3NldAriloFtdWl0bwriloFkZWVwbHkK4paBcmVzdHJpY3Rpb24K4paBY29tbWVyY2UK4paBQm9tYgpjYXVnaHQKcXEK4paBQXJhZwriloHQvdC10LzQtdGGCuKWgUFuYWx5c2lzCuKWgcSNbMOhbmt1CuKWgWJhYnkK4paBZWNodGVyCuKWgdC+0LTQvdC+0LPQvgrQttC10L3QsAriloF3aGl0ZXNwYWNlCsOndQpMSVNUCmZyaXF1ZQriloF2YXJpYXMK4paBV2l0CuKWgUxpY2VuY2lhCkV4aXQK4paBc2llcnAK4paBYXNzZW1iCuKWgXNwbGl0dGluZwriloFwYWxhY2UK4paBYmxvY2tlZAriloFib3VuZGFyaWVzCuKWgWl0ZXJhdGlvbnMK4paBUm90dGVuCuKWgVZlcmtlaHIK4paBd2VlcgpUZXN0cwppZnRpbmcK4paBcmVndWwK4paBcGVyc2lzdAriloFTb2x1dGlvbgpwYgriloFjb2xsYXBzZQriloFhcnJlc3RlZAriloFwcmVkaWNhdGUK4paBWm9uZQriloFpbmdlbgp6w6FsZXoK4paBYmFua3MKcGxhbnQK4paBTmVsbGEK4paB0LHQsNC9CuKWgVNub3cK4paBS3JldXoKw61jaW8K4paBZW50ZXJzCuKWgWV4cG9zZQrEjWkK0YjQuNC1ClF1YWwK4paBbGFuZHNjYXBlCuKWgdC/0L7QtNCw0YbQuNC80LAKbWFpCnN0YWcK0L7QstCw0L3QuNC5CkRFRgpbXXsK4paBZGVybmnDqHJlCmljdXQK4paBWG1sCuKWgXN1Ymdyb3VwCuKWgVBvbHNjZQriloFXYXJuaW5nCuKWgXZlaGljbGVzCmlvdAriloFkbGwKcm9udAriloFMb3Vpc2UK4paBYXJhCuKWgVNjYWxhCuKWgWNhbm9uaWNhbAriloFwbGFjaW5nCkVSWQriloFKYWcK4paBdmlydXMKZW11CuKWgX0pOw0K4paB0LzQvAriloFUcnlpbmcK4paBTGV4aWtvbgphYm9yZAriloFleHBlZGl0aW9uCuKWgWRlbWFuZGVkClp5ZwpsZWluCuKWgXZlcndlbmRldArRgNC40L3QsAp3b2wK4paBcGl2b3QK4paB0L7QtNC90LDQutC+CuKWgXByb3ByaWV0CuKWgWF3YXJkcwp0b3V0CuKWgWFzc2ltCuKWgVN0b3JtCkxpbWl0CmVsaW4Kd2VhbHRoCnVlegriloFyYXBwcmVzZW50CuKWgXJlc3RhCuKWgWdlZ3LDvG5kZXQK4paBam91cm5hbGlzdAppc2llCuKWgWZhY2lsaXR5CmlsbGVkCnVsawriloFQSwpBbmNob3IK4paBXykKVkYKTEFCCuKWgW7DpQpvZG9zCuKWgWJpbGxpb24KdmlydGkK4paBSmV1eArRjtC30LAKdG9tY2F0CuKWgWNoYXJ0cwriloFCdW5kbGUK4paBbHN0CuKWgWV4ZXIK4paBZmVtYWxlcwriloFvYmxpZ2VkCuKWgWFieQpyb2xsZWQKZHJpCuKWgVNjaGUK4paBdmVzc2VscwpJTUFSWQriloFyZWFzb25pbmcK4paB0L/RgNC+0YLQtQpGSUxFUwp2ZXJrCm9zb3MK4paB0LrQvtC80LzRgwrQtNGW0ZcK4paBZGQK4paB0YHQvtC+0YLQstC10YIK4paBSU9FeGNlcHRpb24Kc2vDvWNoCuKWgUNMSQriloHRmtC1CkNNClRECuKWgXBvc3NpYmlsaXRpZXMK4paBQ29tcG9zCmhhbGYK4paBd2VicGFnZQriloFzd2luZwriloF6YXMK4paBY3ljbApsZWlkCmlzdGljYQriloFJbnNlcnQK4paBU3dlZGVuCuKWgXdhbnRpbmcK4paB2KfZhAriloFlZXV3CuKWgUFkbWluaXN0cgriloFXYXJyZW4K4paBYnMK4paBcGFtCmFudXMKRHJhCmV4cGwK4paBS2FudAriloFBdXN0aW4K4paBY3NhawriloF0aGVhdHJlCuKWgWNvbXBhdGliaWxpdHkK0LzQsNGC0LjRh9C1CnNldFN0YXRlCtCx0Y4KfXt8CuKWgUR5CuKWgVp3aXNjaGVuCkFsdApDTEFSRQpzdGVwcwriloFMYWdlCuKWgU1pdHQK4paBRHVibGluCuKWgdGA0LDQsdC+0YLRiwpkZWVwCuKWgWZsb3dzCuKWgVBhbGFjZQp1bml4CnJlZnMKdW1hcgphc2V0CmNvdgriloFwaW5nCuKWgVNhZmFyaQpmbHVnCmNyZWVucwp7IwriloHRgNC10LAKYWRvcnMK4paBYW1vcgp1Y2UKZGVtaWMK4paBTmV0aGVybGFuZHMK4paBY2x1c3RlcnMK4paBZW5mb3IKbWFyaW5lCuKWgWJ1Z3MKaXp6YXRhCuKWgXNjcmEKTGVzCnF1aWNrCuKWgXR1cm5vCl8qCtC10YDQsApHZW5lcmF0ZWQKPlsK4paBZXN0cmUKb3JkZQriloF2ZXJnCtGA0L7QtwriloFwYXUKaW5jbHVkZXMKYXNzYQphZGVycwriloHQk9C10YDQvNCwCuKWgWVzdGF2ZW4K4paBZWFybGllc3QK4paBcmVzdWx0YWRvCm11bgriloFwbG90cwpkaW4Kc29ydGVkCuKWgXByZWZlcmVuY2UKcmnDswrRgtGD0YDQtQriloFMaWd1ZQriloHQt9Cw0LLQtdGACnBocgriloFwb2NrZXQK4paBcGFybAriloFsYWsK4paBcG93aWUK4paBYWx0cmVzCiR9OwpwbGFpbgriloFDcmVkCml0emEKcGVycApHcmVlbgriloFkZXZvdGVkCnByb2R1Y3Rpb24Kd29ya2VyCmVsc2VuCuKWgXZlcm4K4paBbcOhcmNpdXMK4paBQ29uZmVkZXIK4paBTGl2ZXJwb29sCuKWgdC80YPQt9C4CuKWgWVtYWlscwriloFkaXN0YW5jZXMK4paBc2VnbWVudHMK4paBYW50aAriloF3cmVzdAriloFob29nCuKWgWNpbmVtYQpycm9yCuKWgWdlYm9yZW4K4paBw6ljCk1hcmtlcgriloFDb21wZXQK4paB0LvQuNGB0YLQvgphbGxvd2VkCnZvbHVtZQpFc3BhZ25lClplCuKWgWZpeGVzCuKWgXJvbmQK4paBYXJyYW5nZW1lbnQKL34KLl0oCuKWgUZvcnLDoXNvawriloF3ZWl0ZXJlbgpleGNlbAriloHQt9C80ZYK4paBbW9kZXJuZQpFbmdsaXNoCuKWgVRyYW5zZmVybWFya3QK4paBYmVhcmluZwriloFjbGVhcmVkCuKWgdGB0LDQvAriloFkaXZzCsSHaQriloHRjdGC0L7QuQriloHQk9C10L7RgApzY2VuZQriloFhZ2VzCkdFTgpyw6RuCuKWgVRvdWwK4paBQWJzCmrDoXQK4paBbWVkaWFudGUK4paBZW1wcmVzCuKWgUVtcGxveWVlCuKWgXBvbHlub21pYWxzCuKWgW9wdGltaXplCuKWgdCy0YvRgdGC0YPQv9CwCmZhcmUK0LLQtdC5CnhmCnF1ZXoK4paBYm90YW4K4paBZGVmZW5kCuKWgVF1YXJ0Ck1vbnQKdmIKdGljawpXRAptaW5lCuKWgW1vZGlmaWMKbm90aWZpY2F0aW9uCuKWgWRlbm4K4paBYWxnbwriloFTcG8K4paBbWlzdHJ6b3N0Ci86CuKWgWFwcmVzZW50CuKWgdC/0YDQvtC0ClZvbHVtZQpza8SFCnByb3RlY3RlZAriloFUdXJraXNoCmF6eQriloFwb3V2CuKWgXBlcsOtb2RvCnNrb2cK4paBZW50cm9weQp6ZWQK0YLQvtGA0LgK4paBbGlqCmJvYXJkcwriloHRgdGC0LDRgtGDCkJvb2wK4paBcG9saXR5CkAiLAriloHRgNGW0LoKbsOpZQriloFadWcK4paBVW5pdGkKw6ltZXQKYXRpZW5jZQpkaW1lbgriloFTdGV2ZW4KSGEKQUNUSU9OCuKWgXdhbmQK4paBTmF2YXIK4paB0YHRltGH0L3RjwpXYXRjaAriloFTdHVhcnQK4paBemRlCuKWgdC60L7QvdGC0YDQvgpkYXRhc2V0CnnDswriloFCdXNoCuKWgdGB0LXQsdGPCuKWgXdvcnRoeQriloFCbGUK4paBcHJvcG9yCuKWgVZpbGxhZ2UK4paBcnkK4paBdm9pdAriloHQutC+0L/QuNGPCuKWgXpwCuKWgWN1cmEK4paBSHRtbAriloFEaWVzZXIK4paBRGF5cwpvbm5lcwriloFhbnRpZ3UK4paBU3RhYXRlbgriloFmYWludApvbmdzCuKWgcO2c3QKUmVkaXJlY3QK0LXQu9GMCmF0b3JpYWwK4paBYm90aGVyCkVkaXRUZXh0CuKWgUdpdWwK4paB0LfQsNCy0L4K4paBcHVlYmxvCuKWgU1pc3Npc3NpcHBpCmphawriloF3aW5ncwpvbmMKw612ZWwKaWVuY2lhCmVudGxpY2h0CuKWgUJUVwpvcm5hbAriloHQmtC+0YDQvgriloHQvtC00L3QuNC8CuKWgXNhbHYK4paBZmluZGVuCmdlbwriloHQsNCy0LjQsAphdHR1bmcKdml2CuKWgUx1dGhlcgriloHQvtCx0YnQuAriloFSb2xsZQriloFBYnJhaGFtCuKWgWNlbnRlcmVkCuKWgXNsYXNoCmlzYXQKZW1hbm4KT3MK0L/QsNGA0YLQsAriloFQYWJsbwriloFjb2xsYWJvcmF0aW9uCnBhdGhzCsOpZGl0aW9uCuKWgXZpZXdlZAriloFjb25zaXN0ZWQK4paBcmVjb3ZlcmVkCuKWgU1leGljYW4K4paBRml4CuKWgXNwZWxsClNwZWNpYWwK4paB0KHRggplc3NldXIK4paB0KPQutGA0LDQuNC90YsKZm9ybWVyCuKWgcWbdwriloF6ZXJvcwriloFTdHJhw59lbgriloFvcmdhbmlzYXRpb24Kw7xzc2VuCuKWgVNpZXJyYQriloFTZWFzb24K4paBdm9sb250CkJlYW5GYWN0b3J5CuKWgdC/0L7QvNC+0YkK4paBcHJlc3NpbmcK4paBZXF1aXZhbGVuY2UK4paBY2F0dAppY2l0eQriloFhY2NvbXBsaXNoZWQK4paBeW8K4paBc2ljCuKWgWltcG9ydHMK4paBYWNjb21tb2QK4paBUG9ydG8K4paB0Y/QutCwCuKWgWxvYW4K0YLQuNC60LgK4paBY2hlY2tvdXQK4paBYXNzZXNzCuKWgVBvcHVsYXRpb24KdXJlbnQKY2xvanVyZQriloFTYW50b3MK4paBaW5mb3Jtw6FjacOzClBPUwriloFnYXJlCuKWgWtpY2sK4paBcmFkaWNhbAriloFQZWFjZQriloFzdHJlYW1pbmcKY2FtcAp6xIV0CtCz0L7QstC+0YAK4paBUmVnaWVydW5nCuKWgXByb2NlZWRlZApmbQrQu9C10L3RiwriloFlYXJuZXN0CuKWgVBhcmFkCnJlcXVlc3RzCuKWgVJhdW0KxaHEjQriloFwb2xpY2llcwriloFUaWcK4paBc2l0dAriloFFbmVyZ3kK4paBcHVyZWx5CuKWgUhhdXQK4paBU3BlZWQKYmlvCuKWgW9yYW5nZQriloFiaWdnZXN0CuKWgWJyaXRhbm5pcXVlCuKWgU5vdGFibGUKdnUK0LvQtdC90LjQuArQsdC40L0K4paBTmFzaArRidC10L3QuNC1CuKWgWNpZWwKYWTDqW1pZQriloHQs9GA0YPQtNC90Y8K4paBam91ZQriloF2b3RlZApyaWNvCuKWgdCz0L7RgAriloHQutC+0LzQsNC90LTRgwppdGl2aXR5CuKWgdGJ0LUK4paBZGVmaW5pdGUKdXJvcGEKISIpOwpEZWZhdWx0cwriloHQvdC10LrQvtGC0L7RgNGLCsOpZMOpcmF0aW9uCuKWgXNpbGx5CuKWgXRhbGtlZApyZXUK4paBTG9tYgriloFzdGF0dWUK0LrRgtCwCtGO0YAKdW1hYmx5CuKWgdCz0L7RgNC+0LTQtQriloFSdW50aW1lCuKWgWRpYWduCuKWgXJldHJvCuKWgVN2ZXJpZ2UK4paBaW5pY2lhbAppZW56YQriloFmaWdsaW8K4paBem9nCuKWgXJleQriloFSdW5kCtGC0L3Ri9C5CuKWgWNlYXNlZAplcm5vCuKWgWVzYQriloF0cm91dgriloFHZW1laW5kZW4K4paBY29tZXJjaWFsCnNrYXAKZW5hcmlvCuKWgWp1cmlzClRCCtC90LDQu9CwCuKWgXZpagpWTwriloFjbGluCmrDtnIK0YHQsNC9Cm93YcWCYQpyaWJ1Y2nDs24K4paBdXJzcHLDvG5nCuKWgWNvbmRlbQriloFTdGFnZQriloFtaXhpbmcK4paB0YDRltC3CuKWgWZhbnMKaMOhegpzb2NpYWwKemFuCuKWgdGB0LLQvtC5CkNvb2tpZQriloFSb2xhbmQKYXppb25hbGUK4paBU2xvdmVuCuKWgUZpY2hlCuKWgVPDqQpow6QK4paBb2ZmaWNpYWxzCuKWgcOubnQKSW50ZXJjZXB0b3IKVGFibGVzCuKWgWRhdm9uCmluaXRpYWxpemUKXT0iCuKWgUJvZHkK4paBVXBwZXIK4paBQ29sbGVjdAriloFaw7xyaWNoCkhvcml6b250YWwKVHlwCuKWgXBvbMOtdGljbwriloFSZXdyaXRlQ29uZAriloFob3BlZAriloFhbnhpb3VzCkxpdGVyCmphaHIK4paBYXNzZW1ibGUK4paBY3J5cHQKbGFob21hCkFTSAriloHQkdGA0LgK4paBQ2ljCnR3aXR0ZXIKaHlwZXIK4paBVGVsbArRltC70YzQutC4CtCy0L7QsdC+CuKWgWJhemllCuKWgWNvbnRlbXBvcmFyeQriloFQYXJhbWV0ZXIKc3R3YQriloFiZWtlbmQKY29jawpwcmV2aW91cwplbnNrYQriloFjYWxsZXIKXV0pCuKWgVJhegriloFTZWxvbgriloFwcm9wb3NhbAriloFiw70K4paBU2llZAriloFBcmJlaXRzCuKWgXByaWRlCuKWgXNsb3BlCmlkw6kKZ3JhZGllbnQK4paB0JTQttC10YDQtdC70LAK4paBU0gK4paB0YDQsNC30YDQsNCx0L4KaXZlcnNpdHkK0YHQv9C+0LTQsNGAClx7XAriloHRgdGC0LDQu9C4CuKWgUVpbnplbAriloFyZ2JhCuKWgUFuaW0K4paBYWxsZXMK0LHQsNGACmVydGUK4paBcsOpYWxpc8OpCkluc3RpdHV0CuKWgW1hcmt1cAriloF2YXJzCuKWgWdhbQriloHQktCw0YHQuNC70YwKaXp6YQriloFDb2IK4paBTWV0YWwK4paBbGVhawriloFMYW5jClN3aXRjaApEZWxheQphdHV1cgriloHRh9C10YLRiwriloHQsNC90LPQu9C40LkK4paBbGVnYWN5CuKWgWRlc2Fycm9sbAriloF0b3BvbG9naWNhbAriloFqZXdlaWxzCuKWgU5lZGVybGFuZHNlCuKWgWF0bW9zcGhlcmUKdXJiYW4K4paBc2xvdgriloFsYXd5ZXIKcGVjaWFsbHkK4paBYWx0ZXJuYXRlCuKWgXBhcmFtZXQK4paBZXN0YWJsaXNobWVudAriloF3b29kcwpQRAriloHQvdCw0LgK4paBbWFuZwriloF3ZWNoc2VsdGUK0YHRjNC60YMKLj0K4paBZmlmdGVlbgpTVU0K4paBRnJvCuKWgUxFRApvd2FubwrRgdGC0LLQuNC1CuKWgURvbm7DqWVzCnRvbArFvHluCmNyZWYK0YHRgtCy0LjQuApob3JuCuKWgdGB0L7QvtCxCuKWgdC+0LHQvtGA0L4K4paBQ29tcGxldGUK4oCcKQriloFraW5kbHkK4paBQ2hhbWJlcgpzw6lnCldICuKWgWFtYmllbnQK0LrRgNC+CuKWgWNoZXZhbAriloHQvdCw0L/QuNGB0LAKZmx1CuKWgU9mZml6Cm1hdGUKbmF0dXJhbApzZXBhcgplbXByZQpWaWV3SG9sZGVyCmZ3CuKWgWxldGVjaAriloF0cmFpbGluZwphdHJpCuKWgUfDswriloFCb25uCuKWgXVubGlrZWx5ClJBTQplbnN0ClN0YXRzCuKWgdC/0L7Qu9C40YLQuNGH0LUKKS0tKAriloF0cm9tCiEuLi4K4paBTWVhbndoaWxlCtGB0YLQsNC90LAK4paBUmVpbm8K4paBQXJpc3QKJH19JQriloFzb2xlbQpjbG9zdXJlCmlnbmF0aW9uCsWCb2QK4paBZGl2b3IK4paB0LzQtdC20LTRg9C90LDRgNC+0LQKPSI8PwriloFtb2x0CuKWgXNraWxscwriloFDaXIK4paBRGVzcHXDqXMK4paBbHVuCuKWgWNvcm9uCuKWgUNvbWljcwrRgdGC0L7RgNC4CuKWgUl0ZW1zCuKWgVRoaW5rCtC40LPRgNCwCuKWgWdyb3dzCnBvcnRhbAriloFuaWNoCuKWgXJlc3RyaWN0aW9ucwriloFMYXUK0YjQtdC90L3RjwriloFTb3ppYWwK4paB0LrRlgptYW5hCuKWgWxpZXV0ZW5hbnQKQXR0cgp1bWVyaWMK4paBZHJpdmVzCmFzaXMK0LHQsNC5Ck5MClp5Z290ZQpwaHlzaWNzCuKWgWludGVybmFsbHkK0LLQsNC10YLRgdGPCkhpZGRlbgriloHQlNCw0YLQsAriloF1bnNhZmUK4paBUm9jCuKWgWluc3RhbnRpYXRlCnVkbmkK4paBUm9vbQriloHQn9GA0LXQtAriloFtYWphCmFjaG1lbnQKdXVpZApQcm9qZWN0cwpHcmUK4paB0LLQt9GPCuKWgUJsb29kCmljaWxlCuKWgU5vdXZlbGxlCkRvZXMK4paBbmlldXdlCsOhbGUKYW5ncwp3ZWFrCuKWgWFhbnRhbAriloHQldCyCuKWgURyZXNkZW4K4paBTG9zdArQutCw0YLQsAriloFpbnZvbHZlCuKWgWRlY2xhcmluZwriloFQb2xpdGljYWwKw6lyZXoKa29wCm5vdGlmeQriloFDdXJ0CuKWgXNjaGxpZcOfbGljaApnaGFuCtGG0LXQvdCwCuKWgWt3aWV0CsO8Z2VsCuKWgVNvYgriloFzdWJzdHIK4paBZWxsZW4KaW9uYXJpbwplbnNvbgpXSU4K0YHQv9C+0YDRggplbWVyCm5vbWUK4paBc21pbGVkCuKWgVNjaG1pZHQK4paBc21va2UK4paBVG9rZW4K4paBdmFndWUK4paBcHJvdmlzaW9uCnlhbWwK0L3QuNGC0LXQu9GMCm9uaWFsCsOpcG9xdWUK4paBTkMK4paBTkZMCnRlY2sK4paBYWxsbwriloFwcsOpY8OpZApjZW50cmFsCuKWgW1hamQK4paBY2hyb20K4paBWnVtCnZlcnNvCuKWgXZlcnNjaGllZGVuZW4K4paB0YHRgtCw0YDQvgriloFxdWVsbGUK4paBcsOpcApST1cK4paBaWhuZW4K4paBc2Vuc2libGUKfCQK4paBc2NodwriloFCUgriloFPcHRpb25zCuKWgXRlbnMK4paBY29ucXVpc3QK4paBbGllw58Kb3ZpcwriloHQvNGW0YHRgtCwCuKWgWVsYQpyaWZpY2UK4paBbG9rCuKWgVF1ZWVuc2xhbmQKQmluYXJ5CuKWgVJhaG1lbgriloFhYm9sCuKWgcSNw6FzdAriloFFZGluYnVyZ2gKaW5kZQriloFjYWxjdWxhdGluZwriloFPcmVnb24K4paBbGVnaXQK4paBTmFjaGRlbQphdGhvbgpQcml2YXRlCmlsbGF1bWUK4paBb2JzZXJ2YWJsZQpsZWFucwriloFyZW1hcmtlZAriloFoYWx0CtC90LjRhtGLCuKWgXN0YW1wCuKWgUFkdgpMb3VpcwppbW1pbmcKZ3J1cHBlCuKWgVBvbGljeQriloF2cmlqCmZ0cmFnCuKWgW9mZmljZXMK4paBcGFydGljaXBhdGVkCuKWgWVzY29sCuKWgSI8LwriloFub21icmV1c2VzCuKWgWRpdmlkCuKWgWFkdmlzCtC70YLQsNGC0LgK4paBPT0+Ck9yaWVudGF0aW9uCmNpZApDYXJ0CuKWgW11cm0K4paBYXNzZXoK4paBbGlua2luZwpidWlsZGluZwriloFyZWNvbm5hCuKWgXNob29rCm1hbmFnZWQKbGFuZGEK4paBTGXDs24K4paBY3LDqWF0aW9uCtC00L7QuQpvY2l0eQriloF3aWoK4paBd2llxZsKeHRhcnQK4paBTW92ZQpsdW5nZW4K0YHRgtCy0YPQtdGCCm9ybmV5Cm9wdGlvbmFsCm1hY3JvCkNvbmRpdGlvbgriloFzcXVhcmVzCuKWgW1pc3Rha2VuCsOhbnQK4paBUmlzCuKWgXNlbnRlbmNlcwplcmVhCuKWgW1pagpVbmQK4paBbm9tYnIKekEK4paBSW5kZXBlbmRlbnQK4paBcHJldmlldwppbWFzCuKWgW1hbGVzCmluZW50YWwKVGhhbmsK4paBcG9wb2wK4paBcG92ZXIK4paBZ3Jhc3AK4paBaW1wZWQK4paBY2FtcGlvbmF0bwriloFXZWkK4paBdGl0bGVkCuKWgUFkZW3DoXMK4paBUGFzc3dvcmQK4paBUGFtClVJTEQK4paB0LvQuNC/0L3Rjwp3ZXJiCi4uLi4uLi4uLi4uLi4uLi4K4paBUsOtbwriloF0ZWV0aApicAriloFTVwp1bGFpcmUK4paBc2VpemVkCuKWgVN0ZWYKw7psCuKWgXZpegppb255CuKWgWp1bnQK4paBa3RlcsOhCuKWgXdyemXFm25pYQo8PgriloFzdXJnCuKWgXR1dHRlCuKWgUhvYgrQv9C+0LLRltC0CuKWgXdvaGwK4paBdHJhZwriloFDcm93bgriloF0cm92YQrRgdGC0L7QstGDCuKWgVZpZW5uYQplc2VoZW4K4paBbWV0cm9wb2wK4paBcmVmbGVjdGVkCtGC0LXRgtCwCuKWgXRyYWR1YwriloFCYXN0CuKWgWVyc2NoaWVuCndvb3JkCigpIgp0YWxldAriloFyb2FkcwrQstC10LTQtdC90LjRjwrDvGhydW5nCuKWgWNvZ24K4paBVmFsbGUK4paBbGFuZGluZwriloFSZWdleAriloFJb3dhCmR6aWHFggriloFlcnJlaWNodGUKYXVtCuKWgWZvdW5kZXIKYXBvbGlzCkNvbXBpbGVyCuKWgWtvcAriloFtYXJjCuKWgdGC0LXRgNC40YLQvtGACikpYAriloFsZWkKZ2VvbgriloF3ZWFwb25zCuKWgWhvcm4K4paBZWxpZgriloFDYXBpdGFsCsSHZQriloFmb3JhbGwK4paB0Y3RgtCwCnByZXZpZXcK4paBRE5BCuKWgXNpZApvcmNoCuKWgVJhcwriloFhcmFiCkJlc3QK4paB0YHRh9C40YLQsAriloFMw7NwZXoKYW7Dp2EK4paBZnVua2MK4paBdGllbmVuCjsmCm11c2V1bQriloFFcnIK4paBcmVzb3J0Ck5vdgriloFrYWwKTVcK0YjRjAphbmNob3IK4paB0YDQvtC80LDQvQpsZWFkaW5nCuKWgW1hbnRlbgriloFTaWx2YQpkYWRlCuKWgWRlc2lnbmF0ZWQK4paBcmV2aXN0YQpPY3QKcGVyY2VudAriloHRg9C90ZYKaWRlbnRpZmllcgptYXNzCkBACnVsc2lvbgpnZXJtZWlzdGVyCuKWgXByZWRpY3RlZAriloHRgdCy0LgK0LbQvdC+0LkK4paBRXJnZWIK4paBY3VzdAriloFyZW1vdmVzCmNoYXJnCtC/0YDQuNC80LXRgAriloFmb3JtaW5nCmFzbWEKc3Rkb3V0CkZ1bgp5bWUKdGVyZWQKdXJzaXZlCmlnaGVkCuKWgdGB0LvQtdC0CnZlcmJhbmQK4paBTE9HCnJhbXMKw6lvbgplbmRyYQriloFCZXJlaWNoCuKWgXRlbXBvcmFsCuKWgWxhbmd1ZQriloFJbm4K4paBbW9yZW92ZXIK4paBdHV0b3JpYWxzCk1pZGRsZQriloHRgdC+0LLQtdGC0YHQutC40LkK4paBbWFpbnRlbmFuY2UKYXN1cmVzCuKWgXbDoWx0bwpCQVNFCuKWgWRpc2FwcGVhcgrRgdC60LjRjwriloFjb25vY2lkbwriloHQndCw0YMK4paBTGliZXJ0CuKWgUhhcm9sZAriloFsaWZldGltZQriloFUw7xyCuKWgXphd29kCm9taWMK4paBUmV0cmlldmVkCmFyY2hpdGVjdHVyZQrEjWthCmlmb3JtZXMKZGV2ZWxvcG1lbnQKb3JkbnVuZwpJbmYKbGViZW4K4paBU3RhcnMKc2lnbmFsCuKWgWdyYW1tYXIK4paBY29yc28K4paBV2FnbmVyCuKWgWdlaHQK4paBcm95YWxlCndhcm4KdW1ibGVkCuKWgWluc3RpdAriloHQqNC4CmhoCuKWgXJlZnVnZQriloFmYXZvcml0ZQppZXJ0bwriloFjb25kYWRvCuKWgVRoZXIK4paB0YfQtdC70L7QstC10LrQsAriloFGb29kCuKWgXNlaXpvCuKWgUluaXRpYWxpemUK4paBY29ubnUK4paBb3ZlcmxhcAriloFFbWlsCuKWgU1hcnTDrQriloHQttC+0LLRgtC90Y8KZXJ2YQriloFib2F0cwphw6fDtWVzCuKWgWRlcnJvdAriloFtYWxsb2MK4paBY29uamVjdApqawriloFzYXJlCtC70LXQvNC10L0K4paBc3VtcwpBdXRob3JpemF0aW9uCuKWgUt1bgpdJCwKZ2VtZWluZGUKb2RvdApkZWZpbgriloFlbWlzc2lvbgriloHQmtGA0LDRgQriloFhcHBhcnQK4paBc3RvcHBpbmcK4paB0KHRgNC10LQK4paBY29uanVnCuKWgWluc2lnaHQK4paBQnJvYWRjYXN0CuKWgVBNSUQK4paBYWR2YW50YWdlcwplbmVzCuKWgXJlc2lkZW5jZQpsamVuCmlzc2V1cgriloFwdWJibGljYXRvCuKWgUdpdEh1YgriloFQZXJ1CuKWgWdhbGF4aWVzCuKWgWFubm90YXRpb25zCmdhcwriloFyw6lwb25kCkpzCuKWgWluZGVwZW5kZW50bHkKTlAK4paBaW5xdQriloFncm91bmRzCkNvbXBvbmVudHMK4paBYW50ZW4K4paB0LLQtwriloFob3MK4paBc2ludAriloFoaWRpbmcK4paBd29qZXfDs2R6dApNZXNzYWdlcwriloHQv9C+0LrQsNC30LAKPT09CuKWgUFic3RyYWN0CuKWgWzDpG5nCuKWgUZvcm11bGEKZGF3bgriloFkZXNpZ25zCkltZwriloFQb3J0dWd1ZXNlCuKWgWluY2x1eQphdmlnYXRvcgriloFCcm90aGVycwriloFjb250aW5lbnQK4paBZXZpZGVudGx5CnJhY2UK0YbRjNC60L7Qs9C+CuKWgXJlY2sK4paB0YHQtdGA0L/QvdGPCuKWgUdyZXkK4paBYXBwZWFsCuKWgXVubGlrZQriloFwb3dlcnNoZWxsCuKWgXJhY2MKZmVycwriloFidXJuaW5nCmZhc3N0Cmluc3RhbGxlZAriloFHaXZlCuKWgWNvbG9uaWFsCuKWgeKCrAriloFSw7YK4paBY2hyaXN0Cm5laG0K0YLQsNC8CuKWgWNvcnBvCuKWgWNvbnZpcnRpCnl0ZXIKU3ltCuKWgUdyZWVjZQriloFtb3RoCuKWgUpvaGFuCuKWgW1vbmFyY2gK4paBRG93bmxvYWQK4paBY3JhZnQKdcW+CuKWgUx1a2UK4paBc3VmZml4ClwvCkhhdmUK4paB0LrQsNGA0YwK4paBY29tZm9ydGFibGUK4paBdGlwcwriloHQn9GW0YHQu9GPCuKWgdCx0YDQvtGY0LAK4paB0LjQvdGE0L7RgNC80LAKTVEK0LHRgNCw0L0K4paBdHgK4paBc2xhdmVzCuKWgWZpcmV3YWxsCuKWgUZvcmNlcwphdGlmCuKWgVF1ZWxsZW4K4paBdGjDqcOidHJlCtC70YzQvdGL0YUK4paB0YDQsNGB0L/QvtC70L7QttC10L0K4paBRGV0YWlscwprxIUK4paBbG9uZ2l0dWQKSU5TVAriloFuYXZhbApGZXJuc2VoCmVzc2VsCkdyYWQK4paBYmVsYW5nCuKWgWFnZ2kKWnlnb3RlSW5pdArFgsOzdwriloFTdWcKc2lsCuKWgWV4dGVyaW9yCtGJ0ZYKT1JECmVuc2VyCuKWgXJhcGlkZQriloHRgtC10LzQv9C10YDQsAppbmNpZQpTaQphdmFtCmFyZGVkCuKWgUFkZGVkCkVuZHBvaW50CmhhcmR0CtGB0YLRgNCw0L0K4paBZXN0aWxvCuKWgUhhegriloFtdXNzdGUKdW8KaWlpCuKWgcWZw60KYW56ZW4K0LbQtdC90LjQuQphaGEKQVJOSU5HCuKWgXJlbm92CuKWgWRpdmluZQriloFjb252aW5jZWQK4paBaHVtYW5zCuKWgWRlcGFydHVyZQriloFNZWRpdGVyCnFhCuKWgXBvc3Nlc3NlZAriloHRhtC10YDQutCy0LgKZ2l2CuKWgdGB0LLQvtGXCuKWgU9ydHN0ZQpSaWNoCnB1aXMKaW5jcmVtZW50CuKWgUhhbm5vdmVyCuKWgXVjegpEb25lCuKWgWFsZ3VucwpGSVgK4paBSGVyaXRhZ2UKcmVtb3ZlQ2xhc3MK0YTQtdGACuKWgWFiYwpEcgriloHRgdC10LzQtdC5Cns6CuKWgXNldWxlCnplaWNobnVuZ2VuCmFkZHkK4paBUGFyw61zCsO8c3NlbGQK4paBcmVjZXB0aW9uCmZvbGlvCnRpbnkK4paBcmVjZW5zZW1lbnQK4paBTnVyCuKWgWtpZXIK4paBZ21pbmEKc3RhYXQKw6FuZG9zZQrRh9C10YHQutCw0Y8K4paBc3BlYWtlcgriloFleHBvbmVudGlhbAriloFEaWV1CuKWgdC/0YDQuNC3CuKWgVJhZmFlbAriloFnZ3Bsb3QK4paBVGVtcGxhdGUKb3VyZQriloFJbm5lcgpvZ25lCmlnYXJlCuKWgUFydGUK4paBQ292CuKWgWF1ZmdydW5kCuKWgdCR0YsK4paBY2VyZW1vbnkK4paBU3BhcnQKamVjdGl2ZQp5aQriloFpbml6aQriloFsYXRpbgriloFOZXZlcnRoZWxlc3MK4paBRG9uZQrRgtGA0Y8K4paBQXJyCnNlYXNvbgriloHRgdC60LvQsNC00YMK4paBcG9kY3phcwriloFCZWF1dGlmdWwK4paBV2VsdGtyaWVnCuKWgdC30L4K4paBb3ZlcmNvbWUK4paBUHJhaGEK4paB0YDQsNC50L7QvdGDCuKWgXN1YnNjcmlwdGlvbgppZ2VudAriloHQv9C+0LrQsApsYXRleAriloFiZWFjaAriloHRgNC+0LrQsNGFCmdlZwriloFwcm9ibAphcmd1bWVudHMK4paBb3JnYW5pemF0aW9ucwriloFOYW4K4paBc3RvbmVzCuKWgUh1bnRlcgriloFyZWd1bGFybHkK0YjQvtCz0L4K4paBZmxleGlibGUKb3B0cwrDocWZCndpdHoK4paBJykKUEFTUwriloFrcmFqCuKWgWZha2UKaGVpdHMKb3NwaApwYXJzZUludApGQUxTRQriloFwcm9mZXNzCnBlb3BsZQriloFwcmVjaXAKZGlybmFtZQriloFwZXJwZXQK4paBVXBkYXRlZApyYXllZAriloFwcm92b2MK4paB0YLRgNCw0LLQvdGPCuKWgWNhdGVnb3JpZQriloHRgtC10L4K0YHQvdGDCm90cgriloHQktC10YDRhdC+0LIK4paBY29tcMOpdApDb3N0CuKWgXdpZGVyCuKWgU9idmlvdXNseQrQv9C40YHQsNC9CuKWgdC90LDRgdGC0L7RjwriloFzZWVraW5nCigpKSwK4paBw6lxdWlwZQriloFjb21taXRzCuKWgVN2ZW5zCtGP0LHRgNC1CmF0ZXJuCuKWgWhldGVyCuKWgUJvb3RzdHJhcArDqW7DqQriloFkZXJpdmF0aXZlcwriloFEZXRyb2l0CuKWgXByb3ZpbmNpYWwKb25vbWllCkVCCuKWgWN1ZXIK4paB0L7RgtC90L7RgdC4CuKWgdC90LXQuQopwrsuCuKWgUNpdWRhZApJQUwKenlzdAopIikK4paBQWxjCmJsb2dzCuKWgXBhcm1pCuKWgUFsYnVtcwriloFCb2xpdgriloFjbMOpcwpQcm9kdWN0cwp1ZXJkbwriloFnZWxhbmcKem5pawpoYWdlbgphbm9ueW1vdXMK4paBc3ZnCuKWgUNvbnNlaWwK4paBQXJpCmNvbGkK4paBY3p5CuKWgUNWCuKWgWZvcmQK4paBQXXDn2VyCuKWgUNJCuKWgXRlbXB0CuKWgU9yZ2FuaXNhdGlvbgrDocWhCuKWgWN5Y2xlcwriloFnZXNsYWNodAriloHQu9GO0LTQtdC5CsO9bWkK4paBU3BpZWxlcgplZmUK4paBTWFydmVsCuKWgXBvcnRhbAriloHQodC10YDQswriloFncmFkbwriloFoYW5kbGVycwriloFJbnRlcmZhY2UKQU1FCuKWgXNlcmlvdXNseQriloFCaW5kaW5nCuKWgVJhbmcK4paBbmFkYQpvY2UK4paBaW50ZWdyYQpvY3JhY3kK4paB0LDQu9GM0LHQvgriloFzdGFiaWxpdHkKVW5zCuKWgXZldGVyCi0tLS0tLSsK4paBc2VyYWl0CuKWgW9taXR0ZWQK4paBdW5jZXJ0YWludHkKb25pYW4K4paBcmVzdG8K4paB0LbQtdC70LXQtwriloHQvtC00L3QvtC5CuKWgUJldsO2bGtlcnVuZwriloFLcmFmdArRgdGC0YAK4paBTW9zY293CmxhbmUKYXJhYgriloFzcG9sZQriloHRgdCy0L7QtdCz0L4KPzoKU1RBUlQK4paB0LjQvdGC0LXRgAriloFzeW1wdAriloFMb3JlbnpvCuKWgWVqZWMK4paBcHJvc3BlcgpEQVQK0LvQuNC80L/QuNC5CuKWgXNoYXBlcwp2YWx1ZU9mCuKWgWFzc29jaWF0ZQriloFNZWRpZW4KRU5WCuKWgdGB0YDQtQriloHQtNGA0LbQsNCy0LUK4paBdGhlb3JpZXMKaGViCuKWgVdheW5lCuKWgVN0cmluZ0J1aWxkZXIKaXdlcnMK4paBTWFwcwpQaHlzClx9XAriloFQYXJ0ZQriloFIdWRzb24K0LvQvtC9CkxuZwriloHRgNGLCtGB0YLQtdC5CmxhdQphbmNlcgriloFDb3BwYQriloHQstGW0LnRgdGMCuKWgXVjYwriloFQYXR0ZXJuCuKWgWdhcmJhZ2UK4paBR29uesOhbGV6CuKWgUVuY3ljbG9wCmV0dGVuCkV4dGVybmFsClJFRgo+OwpsaWprZQriloFpbnRlcnNlY3QK4paBVW5sZXNzCuKWgWRlZXBlcgriloHQttGWCmRlbnQKbGVmCuKWgWNoYW5zb24K4paBZGlmZnVzCuKWgXByaW1pCuKWgVdpZWRlcgriloFhd3MKb3dhbmEK4paBc29jaWFsZQppa2sK0LvRjNC90L7QuQriloFkaXZpc2lvbnMK0LvQvtGB0L4K4paBQ2xhdWQK4paBWWEK4paBdm9jZQriloFCcmFuY2gK4paBZml0dGVkCm9ycgrDtHRlbApzdHJva2UKbGlzdGVuZXIKaW1hbgrQstC+0YHRgtC+CuKWgVNoYWgKSW50cm9kdWN0aW9uCuKWgW5ld2xpbmUK4paBdGlsZQonXSkpCuKWgXRyYXZhdXgKQ09ORklHCuKWgXF1YWRyYXRpYwpvbm5ldXIK4paBR2lvcmcK4paBaWRlbnRpZmljCsOpcmljYWluZQriloFVSVZpZXcK4paBTGliZXJhbAriloFLb2NoCuKWgUJlcmxpbmVyCuKWgW5vdGlmaWNhdGlvbnMK4paBU3VzYW4K4paBY2FkcmUK4paBS2xvc3RlcgriloFleGFtaW5lCuKWgdC10LTQuNC9CuKWgVVOSU9OCuKWgWFsdGVuCuKWgWZpbml0CuKWgXBlZGlnCmN5awriloFtb3V2ZW1lbnQKSU9TCuKWgdCx0YDQuNGC0LDQvQriloFib3V0CuKWgdCw0LLRgtC+0YAK0L3QuNGG0YLQstC+CtC10YLQvgpsZXJhCmNscwriloFMZXkKYW15CmFnZW5zCmFzaGVkCuKWgW9rcsSZCtCz0YDQvgplbGxldHQK4paBRmVsbG93CuKWgW1hbmlmb2xkCiQpLApsZGVyCuKWgXZvegriloFiZWdnCuKWgWJhcm9uCuKWgWZpZAriloFmaXJpbmcKaWxkYQpkZWsKQVUKaXRhcmUK4paBQXJhCuKWgUV4aXQK4paBY2luZW1hdAriloFpbnRyb3MK4paBY29udGFjdHMK0L/QtdC90LgK4paBbcO2Z2xpY2gK4paBU2luZ2Fwb3JlCnN0csO2bQriloFIZXJuCuKWgXNpeHRoCuKWgXB1YmxpY2F0aW9ucwp2aWUK4paBSGF0CuKWgWFjY2VwdGluZwrDoWMKc3R3bwriloFxdWlldGx5ClBob3RvCuKWgWJhc2tldAriloFlaWdlbnZhbHVlcwriloFtw6lkZWMK4paBT2xpbXAK4paB0YbQtdGA0LrQvtCyCmFsaW4KY29uc3VtCuKWgWxhc3NlbgriloHQsNC90YLQuAriloFTZXEKIjsNCnJhcmUK4paBJHxcCuKWgW5pY2sKZGZsYXJlClZlYwpiaW5kdW5nCuKWgWJnCmNoYW5nZXMKRGF5cwriloFNb3VzZQriloF3YWl0ZWQK4paBVG9tYXRvZXMK4paBZmFzCnZlcnRlCuKWgXN1Y2Nlc3Npb24K0YHQvtGACuKWgXNvbHMK4paBUmVuZGVyCuKWgWxlYWRlcnNoaXAK4paBc2lnbmlmaWNhbmNlCuKWgWdhdWNoZQpjYW5vCuKWgVBpZQplbnNvb3J0CuKWgWNhbWJpbwriloHRg9C3CuKWgWVuZGVhdgpDb21wbGV0ZWQK4paB0JDRgNGF0LjQstC90LDRjwpqZArDs3JpY28K4paBY2h1cmNoZXMK4paBYW5pbWF0ZQpTRwpjb21wdXRlCuKWgXVuaWZvcm1seQpJTklUCmxsZXMKSHR0cFJlcXVlc3QK0JrQvgpEaWZmCuKWgXNhaAphaXJvCm1heWJlClVURQriloFEb3cKaHVtYW4K4paBYXVyYWl0CmRhcmsK4paBcmVwYWlyCuKWgW5lcgriloFEYWJlaQriloFCb3RhbgpPcmlnaW5hbAphesSDCuKWgU5BVAppbXBlcgriloFZb3V0aAp0aGVzCuKWgdC+0LrRgNGD0LPQsAriloFGbG8K4paBYnJlYWtmYXN0CnVybHMK4paBw7xiZXJuYWhtCsOhcmlvcwriloFPcmFuZ2UK4paBQWZmYWlycwpza2UK4paBbm90aWZ5Cmltb2luZQriloFBcmVuYQriloFsaWJlcmFsCuKWgW9iZWMKaWZhCmd1ZXoKaW9ubwrQv9C10YDQsNGC0L7RgAriloFyZXRhaW5lZApmYWlsZWQKYmluZQrRgtC90YvRhQriloFDR1JlY3QKY2FtZXJhCmlkZW5vdGUKS0IK4paBbGlnaHRzCuKWgVBpY3R1cmVzCuKWgVNxdWFkcm9uCuKWgVZvbGsK4paBYnVyZwosXQpHaQrDqnF1ZQptYWtlVGV4dAriloFldmVyeWJvZHkK4paBSHlwZXIK4paBRGV1eAriloFnbG9yeQpwcmVzZW50YXRpb24Kb25pY2EK4paBZnLDqHJlCmFnZXQK4paBaGludHMK4paBdHVubmVsCuKWgUVqCsOhbGlzCuKWgVZpdgrRgdGC0LLQtdC90L3Ri9GFCuKWgWNhcHMKUEFSVApvY2kK4paBcHJpY2VzCmN1cnJlbmN5CuKWgWFjaHRlcgpyb21hZ25ldApnZW5kZXIK4paBc3Vpcwp2ZXJzaW9ucwriloFUcmFpbmluZwppbnNpZGUKZWdlCuKWgXRvdGFsZQriloFEYWFyCuKWgWdydWRuaWEK4paBSWVyCuKWgW9jY2FzaW9ucwriloFrZGUK4paBdGVuc29yZmxvdwriloHDs3IKTWV0aG9kcwriloFsb29waW5nCuKWgWRpcmVjdGV1cgprxJkK4paBaXNvbW9ycGhpc20K4paBSm/Do28K4paBYWxpZ25lZArQvtC90L7Qsgp1cmdlcgriloFub3ZhCm1vcnJvdwphbHRlcm4KSEQK4paBbWFycXUKYXRpdmFzCmdncmVnCuKWgWFuY2llbgpuaXQK4paBc2VjdXJlZAptaWVyCuKWgU9sZQriloHQuNC90YLQtQriloFtaW51cwriloFjbGVhcmVyCuKWgW5lbGxvCuKWgWluZm9ybcOhY2nDs2sK4paBcHJvcHJlCnsuCmlsb2cK4paBUXVpY2sK4paBYWNjdXMKZW1wbG95ZWUK4paB0LfRgwrRhtGM0LrQuNC5CtGE0ZbRhtGW0LkK4paB0L/Rg9Cx0LvQuAriloFiZW50CuKWgdC/0L7Qt9Cy0L4K4paB0J/QvtGACsOhesOtCsOhbmljbwplbXB0eXNldAriloFzdXJ0b3V0CnJlbm8KdW55YQriloHRg9C10LcK4paBTWlsbGlvbmVuCuKWgWxpc3RvcGFkYQriloFNYWluZQriloFncnVwb3MK4paBU3RvcmFnZQriloFhcHBsZQriloFMw7YKb3VzZWQK0LTRgNC+CnNjaQriloFoaWJlcm5hdGUKZG9nCuKWgdCy0L7RgdGC0L4K4paBaW50ZW5zaXR5CmxlZ2VuZAriloFXaWxsZQriloFzemVyaW50Cmdlc2VsbHNjaGFmdAriloFMaXZpbmcKYWxsbwriloFTcGxpdApkcnUKbmVlZAriloHQlNC20L7QvQriloFTd2lzcwriloFzcHJhdwriloFiZWhvCuKWgWZvdG9ncmFmCuKWgXJlbmNvbnRyZQriloFraXMK4paBc2lnbmluZwpha3VsdAriloFpbmRleGluZwphcG9yCuKWgWNvbmNlcHRpb24KYWdncmVnCuKWgdCh0LDQstC10LcK4paBYWZmYWlyCsSbbsOtCkF1Z3VzdAriloHRgdC10LrRgNC1CuKWgW1pZXN6a2HFhApVSUltYWdlCuKWgWJpc2hvcAriloFzZXJ2YW50cwriloF0cmFpbApkaWdpdAriloFqb2lucwriloFOZWFyCsO2ZmZlbnRsaWNoCj57CuKWgXNrxYJhZApnZWbDvGhydAriloFIb2x6CuKWgU1pbGl0w6RyCmFjaGkKVXBwZXIKcGluZQp1dHp0CuKWgW51b3ZhCmlicmF0aW9uCuKWgUJpZW4K4paB0L/QtdGA0LLRi9C5CuKWgUNyZWF0aW5nCk9uY2UK4paBZWlubWFsCuKWgWdlb21ldHJpYwpzdHZvCuKWgWtXCuKWgWRlY29tcG9zaXRpb24K4paBY29tZWR5CuKWgWFjdGl2YXRpb24K4paBYW5ncnkKaWxsZXVycwriloFpbnN0YW50bHkK4paBc3VnZ2VzdGluZwriloFDbGF5CmNvdAriloFHw6luCigkKAp1bndyYXAK4paBbGlmdGVkCuKWgUtpdAriloFsaW5lYQrQvtC6CmhhcnQKLT5fCuKWgW51aXQK4paBSXNzdWUK0LvQuNC4CuKWgXLDtm0KVGFza3MK4paBU3IK4paBc2Vpcwphc2lhCn19JC4KOnsKY29udHJvbHMK4paBU3RpbQriloFSZWNodApvY2lhY2nDs24K4paBTmF0YWwK4paBUGhpbGlwcGluZXMKdWxlbgpGaXhlZAriloFzd2l0Y2hlZApaaXAKb3NwZWwK4paB0L3QsNGH0LDQu9C1CuKWgUJsYW4KdXJzdAriloFhdXRvdXIKQ2EK4paBbGF0aXR1ZGUK4paBRnJlaQriloFNdXPDqWUK4paBS3VyegriloFyZWdpw6NvCnN3YXAK4paBaGF0ZQriloFtb2RpZmljYXRpb25zCuKWgdCa0L7QvAriloFBbnRvaW5lCnVnYQpSRUNUCsOpdGVyCkdST1VQCuKWgXNhY3JpZmljCuKWgVdoZQriloFTdGV2ZW5zCm9sb2dpc2NoZQpTdW1tYXJ5Cm9icwpobmVuCjwlPQpkaWVuc3QKcmVtYXJrCuKWgXZlcsO2ZmZlbnRsaWNodArQtdC7CuKWgU1vY2sK4paB0JvRjNCyCuKWgXRyw6pzCmdiCuKWgWNlbGVicmF0ZWQK4paBRWIK4paBY29zdGEK4paBR2VvZ3JhcGhpYwriloFhdHRhY2htZW50Cm1hbm5zY2hhZnQK4paBZGVwZW5kZW5jZQrvv73vv70K4paBYXR0aXR1ZGUKZXRhbAp2aWMKYmF1dAriloHQtNC+0LIK4paBaW50ZXJ2ZW4K4paBR8O8CsOzbmljYQriloFQb24K4paBZGlzcG9uaWJsZQriloFGZWIK4paBd29yc2hpcAriloFTcGVjaWZpY2FsbHkKSHkKaWp1CuKWgWNiCuKWgXNwYWMKbGV2ZWxhbmQK4paBbG9jYWxpZGFkCuKWgXByZWNlZGluZwriloFIZXNzZW4KeHAK4paBV2VpbgriloFSb23DogriloFnaW9ybm8K4paB0LrQstGW0YLQvdGPCmxsYcOnb3MK4paBQWNhZGVtaWEK4paBa8O8bAriloHDhXJzCuKWgdC90LDRmAp1Y2xpZGUKSW50ZXJuZXQKb3J0b24K4paBY29ybgrRj9C80LgK4paBIioK4paBRmVsaXgKYXBhdAriloHRgdCy0L7QuApNSVQKbWFkZQriloFsb2NvbW90CtGF0L7QtNCwCkZQCuKWgXBtCi4qOwriloFIYW1tCmB9CkxheW91dEluZmxhdGVyCj09IgriloFFdXIK4paBZG9ncwrQttC10L3QuNC4CuKWgWF6b24K4paBZW11bGF0b3IK4paBcmljb24KYmVlbGQK4paB0L3RgwriloFhcHByb3hpbWF0ZQpMTQriloFCb25kCuKWgWVuaArEmWR6CuKWgXNvbGl0ClJlbGF0aXZlTGF5b3V0CmV0ZW9yCmFtZW50b3MK4paBaW5kaXJlY3QKaWLFkWwK4paBZ3JvcwriloFPcmlnaW5hbHMKY29tbWFuZHMKRXhwb3J0CuKWgUF2ZWMK4paBc29sZW1uCuKWgWNvcnJlY3Rpb24K4paB0L/RgNC+0LLQvtC00LgK4paBTW9zawriloHQv9C+0LTQvgriloFnZWJpZWQK4paBbmFzdMSZcAriloFEcml2ZXIK4paBT29rCuKWgVZlYwriloFsdW5nbwpmaWNvcwriloFzdm9sCuKWgWtpZApuamEK4paBSHIK4paB0L/QvtC00LTQtdGACuKWgXZpc2liaWxpdHkK4paBTcOpZAriloFjcHUKZGlzY3Vzc2lvbgpBc3NldAriloFkZWZlbnNlCuKWgUFueW9uZQriloFKdXN0aW4KaXN6dAriloFDb2xsaW5zCuKWgVZhbGVudAriloFQYWxlCuKWgWZ1ZWwK4paBbm9zZQpyw61ndWV6CuKWgVNjaGxlcwriloFNYWxheXMK4paBY29tbXV0CmRybwp1aW5nCuKWgVJpY28K4paBRW1tYQpvcnAK4paBS2lyawriloFRdWFuZG8K4paBTmV1ZQriloFkZW1hbmRlCuKWgUNvdmVyCuKWgXJlc2N1ZQriloFnZXfDpGhsdAriloFDYWxlbmRhcgriloFNYWRvbm5hCldQCm9zaGkK4paBTWF2ZW4K4paBYmVsbGUK4paBd3gK4paBc3VnYXIK4paBQmV0cmllYgriloFlcXVpbGlicml1bQpFQVIK4paBdGV4dHMK0YHQu9C+0LIK4paBY3plcndjYQriloFEw7xzc2VsZAriloFFTFNFCuKWgWFtZXJ5CuKWgWFuaQriloFvYmV5CuKWgU5lbGwK4paBaW5uZQriloHRgtGA0L4KRkQKY2NvCuKWgVpvYgphbGV0dGUK4paBbcOhanVzCmVjdGVkCuKWgVR1cmtleQriloFXaGV0aGVyCnFpCuKWgdGI0YLQvgriloFoZWFkcXVhcnRlcnMKZW5kaQphcnVzCm9wdXMK4paB0LfQvtC70L4K4paBZGVzdHJ1CuKWgUxvawriloFzYXRpc2ZhY3Rpb24KKCkNCuKWgdCi0LXRgApKb3NlCuKWgWNvbnF1ZXIK4paBRWZmZWN0CkxheW91dFBhcmFtcwppZXoK4paBZXh0ZXJucwriloFnZWdlbsO8YmVyCuKWgUVTUApvbHRhCnByb2Nlc3NvcgriloFLdWx0CuKWgUF0bGFudGEK4paBdGllcgpPcGVyYXRvcgriloHQtNC40LAK4paB0L/QuNGB0YwK4paBZ3Jvw58K4paBaGVhcnRzCuKWgW1pbGxpbWV0ZXIKYWx0aG91Z2gKYWxsZXMK4paBTWFnaWMKdHJhaW5pbmcKb2xpbmUK4paB0L7RgNCz0LDQvdGWCj5cPF4K0YbRltCw0LvRjApleHBvcnRzCldvcmtib29rCuKWgdCy0LXRgNC10YHQvdGPCuKWgXRlbGVzCuKWgWVjb25vbXkK4paBdHJhcAriloFyZWZ1c2UK4paBc3RyYW5nZXIK4paBaW5zdGluY3QK0L/QvtC00LAKb2xhbgriloFuaW5nCmluZmxhdGUKaXRhdGVhCmFja3MK4paBSm95CkZMQUcKYWlsYW5kCuKWgXNvcnRpCuKWgdCy0L/QtdGACuKWgXDDqW4KTm90aGluZwriloFzesOhegriloHDgW5nCuKWgUFVVApBY3Rpb25zCkV2ZXJ5CuKWgdGH0LXRgNCy0L3RjwriloHQsNCy0YLQvtC80L4K4paBcm91dGluZQriloFlc3RydWN0CuKWgUdhbmcK4paBaG9sZXMKdGhlc2lzCuKWgWNvbmNsCuKWgXDDqQpyaWVycwrRgNC+0LLQvtC5CmFkaWMKU3BlZWQK4paBY29tbWFuZGVkCuKWgU5hemlvbmFsZQpNYW5hZ2VkCuKWgURFQ0xBUkUK4paBc2VkYW4KU3RyaW5ncwriloFzYWNyZWQKdGVyc3VjaAriloFhYml0YW50aQpicml0CuKWgU5DQUEK4paB0KHQnwriloFhZ2VkCuKWgUNoaWVzYQriloFyZXZpc2lvbgpvcHJvCuKWgW92ZXJ3cml0ZQplbWJyb3MK4paBc29ydGllCuKWgW90dGVuCnhpdgriloFkZWxpCuKWgUFzcAriloFiYWxscwprYWYK4paBYnJhdmUK4paB0LLRgdC10LPQvgplZ24KanBlZwriloFPc3RlbgpDb25zdGFudHMK4paBSW5mYW50cnkK4paBTmV2CuKWgdGP0LrQuNGFCuKWgdC80YPQvdC40YbQuNC/0LAKY2lqYQriloFwb2VtCuKWgW5lZ3JvCtGF0LDRgAriloFBc2sK4paBYXZvCuKWgU1leWVyCuKWgVdlc3RlbgriloFva28KYWdpbgriloFTw7xkZW4KZW50cmllcwriloFSZXB1YmxpawpDb2xsZWN0aW9uVmlldwotLS0tLS0tCuKWgWZpcmVmb3gK4paBYWxjdW5lCuKWgdGE0L7RgtC+CuKWgdC+0YLRgNC40LzQsAp+fn5+fn5+fgriloHQoNCw0LcK4paBQ29tcGxleAriloFwaWEK4paBcHVibGljYWRhCndlaQpjZWR1cmUKb2NjdXBhdGlvbgriloFtZWRpY2luZQriloFkcm92ZQpQcm9ibGVtCuKWgWJlZ2lubmVyCuKWgXRob3JvdWdobHkKdXJpYQphdmFudAp1Y2hhCuKWgWxldmVyCuKWgXRlYXRybwpBVkEKc3F1CnRyYXQKaXZhdGFsCuKWgWRpcnR5CuKWgXNlY29uZGUK4paBZ3Jhdml0CuKWgXByb3Bvc2l0aW9uCmhiYXIKb21pbmkK4paB4oCdCuKWgUNhbWlsCuKWgXF1ZWVuCm1vZGlmaWVyCkphbgriloFseXIKQ29tYm9Cb3gKaW9uaWMK4paBaG9seQriloFTZWJhc3RpYW4KfF97CuKWgXtACuKWgdC80L7QttC90L4K4paBQ3JlYXRpdmUK4paBaW50ZXJlc3MK4paBQ1QKacOnw7VlcwriloFjaGFudAriloF3c3DDs8WCCuKWgdCc0LXQutGB0LjQutCwCuKWgXJhbmtlZAriloFwYcW6ZHppZXJuaWthCuKWgWJydXQK4paBZmFydGhlcgriloFWZXJiCuKWgVNldmVuCmxibAriloFtZW50aW9ucwriloFGaWdodAppZmVuCuKWgWJvZwriloFyZWdyZXMK4paBc2NvcmluZwppY2FuZQriloFFbGxpCuKWgXBpZXJ3Cm1lYXN1cmUKxYRza2llagojewriloHQtNC10YHRjwriloF2YXJtYXN0ZQriloFVbml4CklaCml0acOpClByaW1hcnkK4paBU3ByaW5nZXIKw7xuZwriloFhbnYK4paBdmVyc2lvbmUK4paBc2hvdWxkZXJzCuKWgdCx0YDQuNCz0LAK4paBamF2Cmx0YWwK4paBa2FsbGFzdGUK4paBTWl0Y2hlbGwK4paBd2lyZWxlc3MK4paBw4FsCnJlc3BvbnMKY291bGQK4paBcmVsYXgKTG9uZArFhGN6CtGB0YLQstC+0LLQsNC7CuKWgXBvbHNraQplbsOnCnphcgriloFkdHlwZQpvd25lZAp1bmtub3duCuKWgW11dGFibGUK4paBc2llbXByZQriloFNb250cmVhbAriloFsb2NhdGUK4paBdHJhY2VzCuKWgWluc2dlc2FtdAriloFOaWwK4paB0L/RgNC+0LTQsAriloFXYXJuZXIK4paBTmF1CnRyaWFuZ2xlCuKWgWNvbmNlbnRyYXRpb24K4paBZ2VudGxlbWVuCsOkY2h0CmZpbHRlcnMKaW5jaXBhbApWQUxJRAriloHQtNC10L/Rg9GC0LAKYWTDswriloFrb25zdApnc8OlCmFnYXMK4paBbWVpbGxldXIK4paB0LTQsNC90L3Ri9C8CtGU0LTQvdCwCmVuY29kZWQKPCcK4paBc2hlZXRzCmN1YWRvcgriloHQstC40LrQvtGA0LjRgdGC0L7QstGDCuKWgURlcHV0CuKWgW1hbmnDqHJlCsSFZwpjc29sCikkLQpVSVZpZXcK4paBbWlsbG9uZXMK4paBRWhyZW4KU2lsCuKWgWF0YWMK4paBQ29sZAoiXAriloFhcHByb2FjaGVkCuKWgcOFcnNtZWQKV00K4paBRGVwb3J0Cm1pcwphbmRib3gKb2JzZXJ2CnNldHRpbmcKaGF0w7MK4paBc3RyYXQK4paBc3ByZQriloFwZXJzb25uZQriloFkaXJpZ2UKcHVsbApkYXRpbmcK4paBRmFjdAriloFtYW5pcHVsYXRlCuKWgU1BQwriloFkZWoKdWx0aW1vCkZYCkxpZmUK4paBY3JhY2sK4paBbcOtCuKWgdC/0L7QstC1CuKWgXdvcmUKdW5pdmVyc2l0w6kK4paBZm9ybXVsYXMK4paBRWxpc2FiZXRoCnBsb3RzCm1pbGUK4paBbWVub3IK0YLQuNC7CmtleXdvcmQK4paBQmFsdGltb3JlCmhyZXIK4paBQ2xlbWVudAp2aW0KcmFzcwpUYWtlCuKWgWPDrW3FsQriloFDb252ZW50aW9uCmF0Z2UKc2VlZAriloFEw60K4paBU3BpZGVyCmFob28K4paB0LjQvNC10LXRggrDvGhydAriloHQv9C+0L/QuNGB0LAK4paBQ290CuKWgW5vYmxlcwpSRVNTCuKWgWNoZW1pbgriloFnxYLDs3duCkdHCuKWgUdlcm1hbmlhCuKWgUFsZXhhbmRyZQpoZW5zCnN3aWZ0Cm9vcApTdWJ2aWV3CuKWgXJlcXVpcmluZwrEmWR6eQriloFmaWN0CuKWgdCa0L7QvdGB0YLQsNC9CuKWgWTDqXB1dAriloFzdXJwcmlzaW5nCuKWgWRlaXgK4paBdW50ZXJzY2hpZWQKaW5zb24K4paBQ2hhcmFjdGVyCuKWgWdlc3Rpb24KY2h1cwpjb21lcwriloFuZXVyCuKWgXlldXgKb2xsYXIK4paBcGFyYWQK4paBbWFnZ2lvcmUKVFJBTgriloF2b3RyZQriloFkZXNjZW50CuKWgUljb24K4paBSnVkZ2UK4paBb2NjdXBhdGlvbgplcGluZwriloF0b25ndWUK4paBRW5sbGHDp29zCnJ1ZgriloFwcm90ZWluCuKWgXZpc2l0b3JzCmF4eQplc3RlbgpibGljYQpodwriloFzcGlyaXRzCuKWgXJlZHVjZXMK4paB0LzQtdC9CuKWgUxhbWIK4paBTWluZQriloF2ZXJpZmllZAriloFCYWJ5CuKWgXByaXplCtCy0YrRgAriloFyYXRpbmdzCuKWgWZvcmUKYXNoYQp1cnJlbmNlCuKWgWludMOpcgriloFPbMOtbXAKY3JhCuKWgWNvbXB1dGF0aW9uYWwKaXJjaGUKLjrigIoK4paBaWxsdXN0cmF0ZWQK4paBU2hhcmUK4paBaG91c2Vob2xkcwriloFjb252b2x1dGlvbgpvZW1kCuKWgXpkb2J5CmNjYwriloFxdWFudGl0aWVzCkNoZQpTaG91bGQK4paBZ2VuaXVzCmFkagrRhdCy0LAK0J/QtdGC0LXRgApFTUEK4paBUmlnaHRzCuKWgUVsaQpWQVIK0YjQu9C+CuKWgdC30LHRltGACmlmdHVuZwriloFjb250cmlidXRlZAp6ZWYK4paBQ0hBUgriloFTaWIK4paBTWFudAriloHRgdCy0Y/Qt9C4CuKWgWphdmFmeAriloFjZXBlbmRhbnQK4paBaW50dQriloHRgtCy0L7RgAriloHDkwpndWVyCnJhZG8K4paBUmV2b2wK4paBZsOpbWluCuKWgU9ybGVhbnMK4paBcG9qCuKWgXByZXoKVGV4Cm91d2QKPygK4paBTElNCmlzdGlxdWUKZXNhcgriloFoZXVyZXMKaWNraQriloFkYm8Kc2tpaApjb25maXJtCuKWgXZpbMOhZwriloFjaXV0YXQK4paBRFIK4paBSGF3YWkKY2hlZAriloFzcGhlcgriloFBcnRpa2VsCuKWgU11bHRpcGxlCmNpdQriloHQvNGLCuKWgWxpcGNhCl0oLwpTdHJhdGVneQriloFBbGFiYW1hClNESwpVVEMKX18uCkFyZ3VtZW50cwriloFzZXRDb250ZW50VmlldwrDrmxlCkJ5VmFsCuKWgUpWTQrRjtGJ0LXQs9C+CuKWgUxlb25hcmQK4paBanVzdGlmeQrRhtC10LwK4paBbmFiCkNDRVNTCuKWgWhvcGVzCikmCnNlcm8K4paB0LfQsNC5CtGB0LvRltC0CuKWgVLDqWcK4paBU2FuZwriloFmdW5nCmJhYXIK4paBY29mZmVlCmFzc2VtYmx5CuKWgdCS0ZbQvQrRjdC5CuKWgWNvbXByZW5kCmZpbGxlZArRgNC0Cm9kaWEK4paBZ2VucwpmbHVzcwpEcmF3YWJsZQriloFzdXJ2ZQpTZXR1cAriloFuYWxlxbwK4paBY29uanVudG8K4paB0JXQs9C+CuKWgW9sZGFsCuKWgXZlcmJvc2UK4paBRWxlY3RyaWMK4paBSGFycmlzb24KZW5nZW4KcGFyYWdyYXBoCuKWgW5vdXZlbGxlcwriloHQstGA0LXQvNC1CuKWgW1lbW9yCuKWgW1heW9yw61hCtGB0LDQtAriloFiYXRhaWxsZQriloF0aGVybWFsCuKWgdCl0YDQvtC90L7Qu9C+0LPQuAriloFCZXR0ZXIKYnllCuKWgdGC0LXQsNGC0YDQsApyb2UK4paBc2VnbGUKcm90dAriloFvcGluaW9ucwopfSkKw7xobGUK4paBR8O8bgriloHQqQpiw7NsCuKWgUxhcnJ5CuKWgXNvbGljCuKWgXp3YXIK4paBQ2Fyb2xpbmUK4paBUmVpY2hzCkV4dGVuc2lvbnMKbWlncgo6QAriloFlbnVtZXJhdGUK4paBZWlnZW5lbgriloFleHBsb3JlCsOpbXUK4paBZ2F0CuKWgWltcGVyaWFsCuKWgVVzdWFsbHkK4paBdHVkCuKWgdGD0LrRgNCwCmhpbQriloFjb3JuZXJzCuKWgVNFUgriloFpbnRlcnByZXRlcgriloFJY2UK4paBYW1vdW50cwriloFQYWxhCuKWgXRpbmhhCnZvbGUK4paBZ2xlCnVjY2kK4paBc2llaGUKSmFjawriloF3b2xsCuKWgWVsZGVyCuKWgdC60L7RgNCw0LEK4paBZW5nYWcK4paBTGF1cmVudAriloFhY2hpZXYKaXN0aWsKYXJjdArRgtC90L7Qs9C+CuKWgWdpcgriloFTaW5naAptYXRob3AKVVNBCuKWgVByb2pla3QK4paBZGViZQpyaWNodHVuZwriloFUc2NoCnVtaW5hdGUK4paBc3rDswpseXBoCtC30LjQtNC10L3RggriloFsaW1pdGF0aW9ucwrRjtGJ0LXQuQriloFiaWxhClB1c2gK4paBb2ZmZXJpbmcKaWVubmVzCkZyaQriloFwb3N0Z3Jlc3FsCuKWgVRvbW15CuKWgXBhcnRpY29sYXJlCuKWgXN0b2xldMOtCuKWgWFycmliCuKWgUV2YQpzY2hvb2wK4paBdmVuZG9yCuKWgURhbGxhcwriloFwcm9sb25nCkNSRUFURQriloFzdWl2YW50ZQpTVEFUVVMKbMOgCmt2CuKWgWjDpHVmaWcK4paBQWdyaWN1bHQK4paBaHVpdAriloFpbm9sdHJlCuKWgUxsb3lkCuKWgdGE0YDQsNC90YbRg9C3CuKWgdCy0YvQv9C+0LsK4paBZmFpdGhmdWwK4paB0JLQsNGACuKWgXZlcmwK4paBanVlZ28K4paB0KDQtdC30YPQu9GC0LDRgtC4CiwuLi4sCuKWgWltcGxpY2l0bHkKaXJrcwpDYWxjdWwK4paBbWVzZXMKb21lZAriloFwYWsKaGVyaXQK4paBb3B0aWNhbAriloHQhtGB0YLQvtGA0ZbRjwp2ZWlzCuKWgWNhcGl0YWxlCnBsYWNlaG9sZGVyCmludHJhZwriloFBdGxhcwopXTsKaWNvbnMK4paBQmVudAriloFXaWRnZXQK4paBdm9sdW50CmF2bwrDqWdyCmxpZ2UK4paBTkFNRQriloFhYnN0cmEK4paBZsOtcwriloFCcm93c2VyCuKWgWJ1c2gKaGFsbAriloFjbG91ZHMK4paBU1VCCuKWgXRhbmRpcwriloFDb21tb253ZWFsdGgK0YLQsNGPCuKWgWV4aGF1c3QKX19fX19fX19fX19fX19fXwriloFTdGF0aXN0aWNzCuKWgVJlbGlnaW9uCuKWgU11aGFtCnVhbHMKZ290bwpEaWdpdGFsCkZhbWlseQriloFCdW4KbGV0aW4KTWFuYWdlbWVudAriloFjYXBhYmlsaXRpZXMKYW5udGVuCuKWgdGB0LXQsdC1CuKWgXN0YXlzCmt0ZXIK4paBZG9zdAriloHQotGA0LUK0LvQvtCy0LjRhwriloFkeWluZwpzZWN0aW9ucwrDoW5vcwriloFhcHBhcnRlbgriloF6b2FscwriloFkcmVzc2VkCuKWgWNvbXByZXNzCsWEc2thCuKWgXNpZXJwbmlhCuKWgdGC0LjRgtGDCmRpY3Rpb25hcnkK4paBcmFiYgriloF2w6lyaXQK0JLQvgriloFzaW5nbGV0b24K4paBdml0YWwKUmVmcmVzaArQvNC10LvRjAriloFaaAriloFBZmdoYW4KaW5rZWwKYWFhYQriloFwYXJ0aWNpcGFudHMKYXJpbgriloFNb2xkCuKWgXByaW1lcm9zCuKWgdGA0LDQvQriloHQkNC80LXRgNC4CuKWgXJlc3RhdXJhbnQKw6l2ZWwK4paBU0wK4paBUmV5CmNoYXMK4paBZWxlY3Ryb25zCuKWgVBpdHRzCuKWgUp1bGVzCtC80LDQuQplbmFudAotfQrQu9Cw0LQK4paB0JzQvtGB0LrQstCwCmdvbQriloFGZXJuw6FuZGV6CmZ1bmQKaW50ZXJubwriloFNYXJpCuKWgXJpdXMK4paBUHJvemVudArRgdGC0YDRlgriloHQstC90YPRggphbnRlcmllCuKWgdC/0YDQuNGBCuKWgdC+0LHRiwriloFNYXJpbmEK4paBb2NjdXJyZW5jZQpyaWt0CuKWgdGE0LjQt9C4CuKWgXNjaHdlcgriloHQk9GA0LUKUmVzZXQK4paBbXVjaG8KYW5kcgriloFXaWVzCuKWgUtlaXRoCuKWgUp1bGlhbgriloFjb2xlCmNpZW5kbwriloFDb250ZW1wb3IKZXRyeQplbGlhbgrQs9C40LgK4paB0LPQvtC70L4K4paBZMOpbAriloFkZWNlbnQK0KDQodCgCuKWgXN6ZXB0ZW1iZXIK0LzQtdGB0YIKY2FzdGxlCuKWgdC00LXRgNC20LDQsgp9IikK4paBQVNDSUkK4paBR2xlbgppdHplcmxhbmQKVG9nZ2xlCuKWgXRyYWRpY2lvbmFsCuKWgVBsYXQKdmVlCmFiZ2VydWZlbgoofApDTEkKfX0kLAriloFCb3dsCuKWgU1hbGUK4paBQnJlcwriloHQv9GB0LgK4paBQ2hhbGxlbmdlCnrDswriloFwcm9qZWt0CuKWgW5lZ290aQphYm92ZQriloHQv9C10YDQuNC+CuKWgWxvbmdlc3QKYXV0aGVudGljCuKWgXRyYWR1CuKWgW11amVyZXMK4paBQW5kcmUK4paBaGFkbgriloFTY2h1bGUKb2RlbApibGVkCuKWgVRyYWRlCuKWgW1vYmlsCuKWgWFsZ3VuYXMK4paBTGFrCuKWgUNvbm5lY3RpY3V0CuKWgWFsY28K4paBU2VsYnN0CmnFggriloFhbGIKb3V2ZXJuZXVyCuKWgXNyCuKWgXZiYQpsb3BlZAriloFQYXJ0ZWkKdWF0ZQriloFBdXRoZW50aWNhdGlvbgpiZWkKfX0uCuKWgWtvbm50ZW4K4paB0LTQvtC/0L4K4paBaHlkCk9mZmljZQpkb25uw6llcwriloFDbGV2ZWxhbmQKcml0YQrDrW9zCuKWgdCy0YvRiNC1CuKWgVJvYmVydHMK4paBw6lsZWN0aW9ucwriloEnJykK4paBcHVibGlzaGluZwriloFiYXB0Cjw+KCk7Cm1pc3NpbmcK0YDQvtCy0LDQvdC+CuKWgWhvdXNpbmcK4paBaW5mZXJlbmNlCuKWgVJlbmFpc3NhbmNlCuKWgXLDqGcK4paBU3RlcGgKQ0VTCkVSRQrQutC10YIKT1UK4paBZ3JvdXBpbmcKdmVya2VocgpqaWgKYWdsaQriloFtaWxrCmxhaXQKU3RhZ2UK4paBYnlseQriloF3b29kZW4Ka2VsZXkKZXRyYQriloFQZWcK4paBZG9ubsOpCmFkYWwKc2VxdWVudGx5CuKWgWluc2Jlc29uZGVyZQpFTEQK4paBTWFtCuKWgXZvbHRlCuKWgXByb3NwZWN0CtC90L7QstC1CuKWgWRlbm90ZWQK4paBb3ZlcmxheQpQZXJtaXNzaW9uCmVlbgriloFFTQriloF1egpNYwpvbGl0CuKWgXNlcnZpCuKWgUhlaWRlbAriloFXaWVuZXIK4paBaWxsZWdhbAriloFwcmVkaWN0aW9ucwriloFnb29nCmhvbgriloFDaW5lbWEK4paB0YDQtdCy0L7Qu9GOCuKWgVJ1bGUKd29kCuKWgXJhZGlhdGlvbgpvxYIK0L7QstC+0ZcK4paBUGVyZm9ybQriloFwcmlzb25lcgriloFhbWV0CuKWgWZpZ3VyYQriloFDb21tYW5kZXIK4paB0L7RhNC40YbQuNCw0LvRjAriloF0cm92CuKWgWFjdGVkCuKWgXdvcmtmbG93CuKWgdCg0LXRgdC/0YPQsdC70LjQutC4CuKWgWd1aWRhbmNlCuKWgdC80LXQvdC1Ck5hdGlvbmFsCuKWgUtlbAp3ZWJwYWNrCtC/0YDQvtGB0YLRgNCwCuKWgWxsYW1hZG8KYWxvZwp0ZXJyYQppeGVuCmxlZ3JhcGgKw6Rpc2NoZW4K4paBdGVhY2hlcnMKdWRlbgriloFvZ3PDpQpwb3NzaWJsZQriloFTb3VsCuKWgUdlb2dyYXBoeQriloHQt9Cw0LTQsApoaXQK4paBYW5nZXIK4paBcmVtcG9ydGUKUG9kCtGH0LrQtQriloFhcmlhCuKWgUFzdHJvbm9tCmNoYXB0ZXIK4paBZm9yawriloFDdWFuZG8KbWVuc2UK4paBQ2hyaXN0aWFucwpnYwriloEjKApPcmdhbgriloFzdGVhZHkKcHNlCtC20LjRgtGMCmlnbmVzCmF0ZXJyYQptb3ZpZQpwb3N0YQpyYXN0ZQriloFSZXNzb3VyY2UK4paBUGHDrXMK4paBKCk7CuKWgXBlbmFsdHkK0YLRggriloF0cmFzZmVyCmNlbnR1cnkK4paBY2xlYW5lcgpzZWxlbml1bQpvcnRoZWFzdAp4aWMK0LvRltGXCuKWgWluZ2xlc2UK4paBVGFuZwriloFnb2RzCmZyZW50CmNpZW50ZQpzdGFydHMK4paBbXVzaWNhCnltbmFzaXVtCi0tLS0rCuKWgXRlcnJlc3QK4paBcmV0cmlldmVkCmlhcmUKdW5uaW5nCuKWgU1hcmN1cwriloFwcm9tb3RlCndhcm5pbmcK0YLRi9C5Cn0pJCwKVHJhbnNwb3J0CuKWgXJlc29uCuKWgUNsbwriloFlcm0K4paBZWxpbWluYXRlCmhlaW1lcgriloFzYXZlcwriloFwcmF5ZXIKQ2xhc3NlcwpFeHByZXNzCuKWgUFrYWRlbWllCkVsc2UKVHVybgriloFpa2tlCuKWgXJlaQriloFkaXJldHQK4paBUm9zdAriloFQYXBhCuKWgWpzZgrQu9C10L3QuNC10LwK4paBVHVsCuKWgVphawriloFuaWVtaWVjawpUdwphbW91cgpuZXN0ZWQKcHBldHMK0YjQvwpkaXQK0LfQtdC9Cnp5bWEKaHJ0ZQpDb25zdHJhaW50cwriloFvd25lcnNoaXAKQXJtCuKWgWNvbnN1bXB0aW9uCuKWgWZldAppdmFyaQpjaHJvbQpzZXRBdHRyaWJ1dGUK4paBY29tcG9zZQriloFiYWNraW5nCuKWgVBhegriloFzY3JpCuKWgU1lY2hhbgriloFOb3J3YXkK4paBSnVwCuKWgW3DqXIK4paBYWRtaW5pc3RyYXRvcgriloFjYWJlCml2YWxlbnQK4paBdGhyb25lCuKWgWR1ZXMK4paBaHVtb3IK4paBQWRyaQriloFhYm9ydArDsWFzCuKWgdCa0LjRl9CyCmrDrWPDrQriloF6d2VpdGUK4paBZG91YgplcnNoZWxsCtGI0L7QuQriloFGYW0Kw6VrCuKWgXR3ZWVkZQriloFSaWIK4paBZsO4cgpwY2nDs24KaW5uZWQKcnZtCuKWgUFwcGFyCuKWgURqCuKWgVNoYW5nCkRpc3RhbmNlCuKWgWRhd24K4paBTWF0dGgK4paBZXJyaWNodGV0CnBoYW50b20K4paBcmVsZWFzZXMKUmVjb2duaXplcgriloFLb3AK4paBUHVsCnXDqQpuYXRzCnJlbGF4CuKWgWZsZWQK4paBZXhwZXJpZW5jZXMK0YnQtdC1CtC80LXQvdGPCuKWgdC/0LXRgNGB0L7QvdCwCuKWgUlkZW50aXR5CnJldHMKa3VuZnQKbGFyZwpMaXN0SXRlbQp2ZApydW5uZXIKbGFudAppcGFydApiYXkKaWVpCuKWgWxlbmd0aHMK4paBY2F0dGxlCmpldHMK4paBc2VoZW4KSnVsCmZhdHQK4paBc3VycmVuZGVyCuKWgVRydW1wCtC00L3QvtCz0L4K4paBRm91cmllcgppZWJlbgpfIgriloFmcsO8aGVyCuKWgWdhcmFudAp1Y2xpZGVhbgrDpGd0CuKWgdC/0ZbQstC00LXQvQpQYWdlcwriloFyaXZlcnMK4paBZG9ubmVyCnN2bgriloHFggpvdsSbCuKWgUxlaXN0CmFyaWFsCm92w71jaAriloFmaWxsaW5nCuKWgW11c2ljYWxlCm1heGltCuKWgWRhc2hlZAriloHQndC+0LIKRHJhd2VyCuKWgU1lZGljaW5lCuKWgWRva3VtZW50Cm93ZWwKdmnEhwpoZWx5CuKWgWVsZXQKU2Vjb25kcwriloFHb256CnJvdQriloFmaW5hbGVzCnJuCmbDuAriloFpbmRleGVkCmNsYXNzTmFtZQriloFvYmVyCuKWgWR1YXMK4paBb3B0aW1pemVkCuKWgWtkeQp2ZXJzYXJ5CmVuZXJneQriloHRhtC10L3RgtGA0LAK4paBY3VycmVuY3kKennFvApMaWtlCuKWgdCT0LgKc29ubwriloFwYWxhYgriloFwdXNoaW5nCnVibGlrCuKWgUhhc3MKfVwsXAp1bmtlcgriloFGYWN0b3J5CuKWgVJlc291cmNlcwpkYXRlaQriloFUb29scwriloFzdGVoZW4Kc2ltZQriloHQpdGDCuKWgWhvY2gK4paBUm9kcsOtZ3Vlegp6ZWl0aWcK4paBVGVycnkK4paB0L7QsdGDClVzYWdlCnVyY2hhc2UKbMO2CuKWgUludHJvZHVjdGlvbgriloFwYXJ0aWNpcGF0aW9uCs6/z4IKb2dsaQphcHkK4paBaG9wZWZ1bGx5CnBvbmRlcgriloFZYW5nCuKWgXByb21pc2VzCuKWgdCy0LXRgNC90YMK4paB0L7RgdGC0YDQvtCyCl57KwriloFtb3N0cmEK4paBQ1VSTE9QVApISAriloFzdGRvdXQK4paBYnJpbGxpYW50CuKWgW1hbnVzY3JpcHQK4paBZGVjaXIK4paBQm9sb2cK4paB0LzQtdGB0YLQsAriloFpbnZpc2libGUK4paBQ2hhbAriloFhbmFseXplCnByaWxpcwphdHRlbmQKTXZjCnRoYW4KY2tvCuKWgVF1ZWJlYwriloFwbGFudGEK4paBdMOpbMOpdmlzCuKWgXVuaW5zdGFsbArDqG5jaWVzCuKWgWdtaW5pZQriloFQcmVmCuKWgWxlcXVlbApJbnZvY2F0aW9uCuKWgcONCuKWgXRyYW5zZm9ybWVkCk1BTgpnZWJhdXQK4paB0YHQvtGF0YDQsAriloHQstGC0L7RgNC+0LkK4paBTGl0aAp3ZW5kdW5nCuKWgVBvbGl0aWsK4paBU2VuYXRvcgriloFMTArQttC00LXQvdC40LUK0YjRgtC1CuKWgUPDqXMK4paBYmFuZGUK4paBaGlzdG9yaWFuCuKWgXBhc3N3b3JkcwptYWxsb2MK4paBc2VtaWYK4paBcsOlCnVuaWPDrQpBdmFpbGFibGUKT3B0aW9uYWwK4paBVHdlCuKWgWtyw7MK4paBc3Vic2V0cwriloFEQVQK4paBZG91YmxlcwrQvdC40LrQsNC80LgK4paB0LfQsgpnZWdlYmVuCuKWgdCf0L7Qv9C40YEK4paBasO6bGl1cwriloFtZXRlb3IKTW91bnQKaXZlbnQK4paBTmF0aGFuCuKWgVNjaHV0egplZ292CuKWgWTDtmQK4paBbWVhdAriloHQv9GD0L3QutGCCuKWgW1pbmRzCmVsaXZlcnkK4paBVExTCtGA0LXQvApja3PDpQriloFzdGF5ZWQK4paBQmluCuKWgVBpYQriloHQuNC80LXQvQriloFCb2JieQriloFwcm9kdWl0CmVtcGlvCuKWgXJlZHVjaW5nCuKWgVl1CuKWgUdlc2Now6RmdAriloFwZXJjaMOpCuKWgWNvcnMK4paBaWNvbnMKQXBwRGF0YQriloFIb2cK4paB0YDRltCyCuKWgVNhbnMK4paBc2nDqGdlCnN0ZWxsZW4KQnJ1c2gKT0ZGCuKWgXZpc2l0b3IK4paBYmF0aAriloFmZWUKYXRpc2YK4paBY3VydgriloFmb2xnZW5kZXIK4paBY29uc2NpZW5jZQriloFTZWF0dGxlCuKWgW1lZGlldmFsCmRpc3RyaWJ1dGlvbgriloFETQriloHQvNGPCuKWgVJVTgpha292CmNlaWwK4paBbGV0dGluZwriloFkb3YK4paB0L7QsdC4CmtpZWoK4paBZGlyZWt0CuKWgXRtCmNvbG9ycwriloFhbHRybwriloF0aWpkZW5zCl17JwriloFCb20K4paBa3Vuc3QK4paBc2hlbHRlcgriloFyYXYKcHJlZGljdAriloFjb21lbnrDswriloHFm3dpYXQK4paBRHVyYW50CuKWgXNjaGVtZXMK4paBbWVzaAriloFpbmRpY2F0b3IK4paBRW1lcgriloFndWlsdHkK0L3QtdGGCuKWgWNvbnNlcXVlbmNlcwpjbHVkZXMK4paBTG93ZXIK4paB0L/QvtC80LUK4paBcGFjZQrQtNCw0LPQvgriloFhbWJvcwpsYgriloFlZHVjYXRlZAp1cmFsZQphbmgKZXNzw6lnCuKWgWFzc29jaWF0aW9ucwp0b3duCuKWgXRyaWYKc2FtcGxlcwpib3MK4paBU3BlY3QK4paB0KbQtQphbHR1bmcK4paBTG9iCuKWgWN1cmlvc2l0eQriloFXZWl0ZXIKZXN0b25lCuKWgWRlbW9sCuKWgWFwb2xvZwriloFEeW5hbWljCklubmVyCmVzcGVyCmVjegp1ZWxsZW1lbnQK4paBSGFtaWx0b25pYW4KQXRsYXMK4paBYXJndWUKRm9yZWlnbgpjb2xsYXBzZQriloF0w6lybWluCuKWgWVsZWN0cm9uaWMK4paBTlIK4paBY29ycgp0ZW1wcwpJbmRleFBhdGgK0Y/QtwriloF0YWzDoWwKdG9kYXkKd2F2ZQriloFzaWIK4paB0YHQv9C4CuKWgWNvbnZleQriloFHw6lvZ3JhcGhpZQriloHQndGM0Y4K4paBSGliZXJuYXRlCuKWgXRpbgpkaWMKcHBpbmdzCnN3ZWlzZQriloFyb2xsaW5nCuKWgXNlbGVjdHMKKVwpCuKWgXBvZXRhCuKWgdGB0YLQtdC/0LXQvdC4CuKWgUFicgriloFow7ZjaAriloFzdGVybgriloFmasOkcgriloFpbnN0YWxsZXIKZGVjbAriloFtaXNlcgpncm91cGJ5CnN1YnN0cgriloFwaGVub21lbgriloFXaW5nCuKWgWZpbGxzCuKWgcO6bmljbwpSdW5uaW5nCkNvbWUKaXJhYmxlCnNpbWVxCuKWgXJlbXAKa2VsZQpsaWVycwriloFrd2lldG5pYQriloFpbnRlcnJ1cHRlZAriloFKZXQKPVx7CsOtZG8K4paBVGFpd2FuCuKWgdCy0L7Qt9GA0LAK4paBYWx0ZXJuYXRpdmVzCuKWgVRpcgriloFSZXNlcnZlCuKWgdCa0YPRgAriloFOb2JlbAriloHRgNCw0LHQvtGC0LDQuwriloFheGVzCuKWgUNlcGVuZGFudAprw6EK4paBZXJuZXV0CuKWgURlbW8KY29tbXVuaWMKY29uc3RydWN0b3IK4paBTW9uZGF5Ck5pbApIYXNoTWFwCnBheW1lbnQK4paBZml4aW5nCuKWgUFERApyZXZpZXcK4paBcG9zc2liaWwK4paBZ3JvdGUK4paBZ3JvdXBlZAriloFMaW1hCuKWgUF1Z2VuCuKWgW9ja3PDpQpvbmFzCuKWgWRlYmF0ZQriloFJbmdsCkRhClNPVVIKZXR0YmUK4paBQmF0dGFsaW9uCuKWgUZsb2F0CuKWgWNvbmUKcmVhZHNoZWV0CmNvdXJ0CmxpZ2VuCuKWgUJlZ2lubgriloFMSU1JVAriloFlbmpveWVkCuKWgUpha29iCuKWgXRlbHQKYmFja2VuZAriloFHZW1laW5zYW1lCmxpbnQKYWxsaW5nCuKWgWLDtnIKZ3JhbmQK4paBZGl2ZXJzZXMK4paBendpxIV6CuKWgUtvbXBvbgriloFpbm5lcmhhbGIK4paBZGVzYXJyb2xsbwriloFNYXN0ZXJzCmlvc28KXWAuCuKWgWZyYW5jZXNhCkFmZgppbmVrCuKWgWRlc3NpbgpgLmAK4paBcmFua3MK0LHQtdGA0LMK4paBc2thbAriloFTdWx0YW4K0JDQnQriloHRgdC/0L7RgdC+0LEK4paBY29udHJhZGljdAriloFyZWNvbQriloFPa2xhaG9tYQriloFWbGFkaW1pcgriloFtZXRlcnMKdHJhbnNwb3J0CuKWgWNvbnN1bHTDqQriloFBVFAKZWJiCuKWgXZvbHVudGUK4paBb3V0bGluZQpMSUMK4paBZXVybwpDaGFyRmllbGQKbWVkaXVtCuKWgUJlbGdpcXVlClByb2MKcm91dGVzCuKWgWNvbnRyaWJ1CiF9CsWhw61tCuKWgUxlc3MK4paBS29zdAriloFlcmVkZXRpYsWRbApyZXZlbgp2ZXJpZnkK4paBU2FsdAriloFzaG9vdGluZwriloFkaXNwb3NlCnVqw60K4paBdGllcnJhCuKWgXBvaXNvbgpzYWsKcGVyaW1lbnRhbAriloFOw6kK4paBS2lkCmFneWFyCuKWgWFyY2hpdsOhbHZhCmJlcmVpY2gKw616CuKWgVJpdHRlcgriloHQpdGA0L7QvdC+0LvQvtCz0LjRmNCwCnpldW0K0LTQsNGFCuKWgWdyw7xuZAriloFwcm9ncmFtbWVyCuKWgWNvbnNlaWwK4paBZW5jcnlwdAppbnRlZ3JhdGlvbgpDdWx0dXJlCuKWgUNpcmNsZQpPYnNlcnZhYmxlCuKWgWdlbm9tc25pdHQK4paBU2VsZWN0aW9uCuKWgWlycmVndWxhcgpBdXRyZXMKUGVyY2VudApmYXVsdAriloF2aXJ0dWUKxIVwaQriloFzZXNzCuKWgdCi0LDQutC20LUKVGltZXN0YW1wCuKWgWxpdHTDqXJhdHVyZQriloFtb8W8CuKWgWJvcnJvdwriloFjb25jZWQK0YfQvdC40LoK4paBTHVuZApJT05TCnluaWUK4paBU2hpbgriloFvc29iCmLEmwriloFpbnR1aXQK4paB0L3QsNC/CuKWgXByb3BoCuKWgXBpdHQK4paBSUJNCuKWgVRpbGwK4paBaGluYQppdHRlc3QKZ2VuZXJhdG9yCuKWgU5pbgriloFLb3QK4paBcGFzc2VyCuKWgWRpc3Bvc2l0aW9uCnVuaW5nCuKWgWZhbWUK4paBdGVuaWEKYW5jZW1lbnQK4paBU3Vpc3NlCmAtCuKWgWhvbWJyZXMK4paBaW5maW5pdHkK4paB0L7QutC+0L3Rh9CwCuKWgWNvc20K4paBRGVubmlzCmJhegpoYXVwdAriloFtaWdodHkK4paBcHJlZGUKdXNhYmxlCuKWgXdzenlzdAriloFsYgpBQkFTRQpqbmEK0L3QtdCyCuKWgWFzZXMK4paBZmluYWxtZW50ZQrQudC8CnBlY3Rpb24K4paBU3R1ZGllbgriloFOb3J3ZWdpYW4KY2VnbwpJTkRFWApvcnRlbgriloFmcmllbmRzaGlwCm1ldHJvCnRoaWNrCuKWgVplbApMT1cK4paBdGhlcmVieQp1bnRlZAriloFzdXJmYWNlcwrRjtGJ0LjQvAolKS4K4paBV29uZGVyCuKWgXJlZHVuZGFudAriloFHcm9zCuKWgXdlYnNpdGVzCuKWgXZpbwriloFvY2FzCnbDqXMK4paBR2FtCmR3CkluZGljYXRvcgriloFLb2IK4paBamFjawpIaW50CuKWgUFwb2wK4paB0LTRgNGD0LPQuNC1CuKWgU5VTQriloFvZmljCnlzdHljegriloF3ZXJlbGQK0LzQvtGB0YLQuApMRUZUCuKWgVR5cGVzCnNlZW4KdW5jaWEK4paBbmFyb2QK4paB0Y3RgtC+0YIKU2lkZW5vdGUKdWVpbAriloHQvtGC0LzQtQriloFjb3VydHMKZmlyCnVyegrRh9C10L3QutC+CkNyZWRlbnRpYWxzCuKWgWltYWdpbmF0aW9uCml0YXRzCmJ1ZmYKZmxhc2gK4paBYmFkbHkK4paBd29ybgriloHQvtC60YDRg9Cz0YMKY2F0YWxvZwpsaW1lCuKWgUdpbGwK4paBU2VudAppZWxsYQriloFDcmFpZwriloFTZWxlCuKWgUluZGVwZW5kCuKWgXByb3ZpbmNpZQpvc3NlbgriloHQt9Cw0L/QsNC0CuKWgWluZmFudAriloFwcmV2ZW50cwriloFwcm92aW5jZXMKYWbDqQpiZWcK4paBY29sb3VycwpCRgrDq24K4paB0JzQtdC20LTRgwrDrm4KT2JzZXJ2ZXIKZm9yc2NoCsOtZ2VuCnVtcHRpb24K4paBSWxsdXN0cgrRgNC40YHRggriloHQv9C+0LvQvtCy0LgK4paBYCYK4paBb3JlCuKWgXN1cHBsaWVzCuKWgXBhcmVudGhlcwpGb3VuZGF0aW9uCuKWgXZvdQriloFUb3V0CkRvbmFsZAriloFSRVQKd2VpZwriloFwcm9kdWNjacOzbgptaXgK4paBdXR3b3IK4paBZsO2bAriloFlbnTDo28K4paBU2lzdGVyClRhZ3MK4paB0KHQsNCy0LXQt9C90LUK4paBcHJpdmlsZWdlcwriloFuYXp3CuKWgVJhdgriloFyZXBybwriloFNYXNvbgriloFQbGF0Zm9ybQriloHQv9GA0L7QsdC70LUK4paBUMOpcmV6CuKWgWJsYW5jCkJlaGF2aW9yCtGE0LjRhtC4CmVrZW4K4paBbWVldHMKKC4qCuKWgWbDpQplcGVuCm1ha2VyCuKWgWxveWFsCm1lbWJlcnMKbWVpc3RlcnNjaGFmdApnb2FsCtGI0LvQtdC9CuKWgdGB0LXQstC10YDQvgppZW5kZQrQtNC90ZYKUHJvb2YK4paBZXhwbGljCuKWgWVsZWN0cm8KaWVscwpyZWxvYWQK4paBZWxldmVuCuKWgXBhcnRpZG9zCsOubmUK4paBUmVnaW4K4paBw6l4CuKWgUJ1bGcK4paBbmV0d29ya2luZwriloFzZXBhcmF0b3IKVXNlck5hbWUK4paBZWRpZmljaW8K4paBTWllCuKWgWlkbGUKeWVkCuKWgXBhc3NlbmdlcnMKKykKbWVubwplZ2dpCuKWgW5pY2VseQplbmRlbmNpYQrRh9C40LkKw6l0w6lzCmlnaHRhcnJvdwriloFvcnRob2dvbmFsCuKWgUhhbGYK4paBZmV3ZXIK4paBcHJvcGkK4paBcHJpbWl0CmljYWxlCuKWgWZsb3dlcgptZXJrCuKWgdCe0YLQtdGH0LUK4paBcGVyc2lzdGVudAriloFWaWxsZQpNZW4KZ2FiZW4K4paBSXNhYWMKYXRpdml0eQriloFww7PFgm5vYwriloFyb2sKY2FyZHMK0LTQtdC90LjRjwriloHRjtCz0L4K4paBZXh0cmFvcmRpbmFyeQriloFreXIKKCIsCikpXQriloF1bml4CtC60L7QuwriloFzaW5rCmFwc2VkCuKWgWtvbW1lbgriloFmb3JjaW5nCkFib3V0CuKWgUhhbGxlCuKWgU1hamVzdHkK4paBU3dpdGNoCuKWgWFicm9hZAriloFhY2NlbGVyYXRpb24KdXJiZWQK4paB0L7RgdGC0LDQvQpSZWFkeQriloHQv9GW0LLQvdGWCkJyYQriloHRhtGM0L7Qs9C+CuKWgXBsdXQK4paBVHJhaW4K4paBw6FwcmlsaXMK4paBcHVlc3RvCuKWgXRvc3MK4paBaXJyZWxldmFudAriloFkaXAKc2VnbWVudApvcGFjaXR5CuKWgWxvcnNxdWUK4paBdmVyc2NoaWxsCtC10L3QsAriloFEb2MKJSUlJSUlJSUK4paBYm9yZGVycwpnZWJyYXMK4paBcmllcwriloFPbHltcGVkaWEK4paBR2VuZXJhdGlvbgptZXRyb3MK4paBaG9yaXpvbgriloFhZGFwdGF0aW9uCuKWgVphaGwK4paBbmFoZQriloFCdWcKUGljdHVyZQrRmdC4ClJHQgpPd25lcgphZGluCuKWgUNhdGFsdW55YQpuw71jaAriloFjdWFscXVpZXIK4paBSW5zdGl0dXRpb24KaW5zZW4K4paBQnJhc2lsZQriloFmaXR0aW5nCkRlbGVnCmljdHdvCuKWgUV4cGVyCm9jaGFzdGljCuKWgWR1cwriloHQv9C+0YDQsAriloFzdWJzdHJpbmcK0YHRgdC40LgKb2luCuKWgdGI0LrQvtC70LAK4paBY3gK4paBJSkK4paBQnVkZGgK4paBcGVuZGluZwriloFFbnRyeQriloFCZXJsCuKWgWNsZXIK4paBU29jCuKWgXJvdW5kZWQK4paBbXYKw610ZXR0CuKWgURpcGxvbQriloFmcmFuesO2c2lzY2hlbgriloFHYW4K4paBSW52ZXN0aWcK4paBaW5kZXhQYXRoCuKWgW1vbHRpCnBlcnNpc3RlbmNlCuKWgVhJWGUK4paBRWxlY3Ryb24KYsO8CmdlbGUK4paBTWFsZXIK4paBcHJveWVjdG8K4paBQmF0aAplbGxlcnMK4paBR1AKb25pbmcKY2xvdWRmbGFyZQriloFwxZlpCuKWgWRlZAriloFPZGthenkK4paBTXNnCuKWgUJlaW5nCuKWgURlcHVpcwriloFQcmltYXJ5CuKWgUFwcHJvCuKWgWZvcm1hbGx5CtGB0YLRg9C/0LjQuwriloFmdWVyYQriloFSb290CuKWgWF1dG9ub20K4paBc2VjcmV0YXJ5CuKWgW9zw7NiCuKWgWN1YWxlcwriloFEZXBlbmRpbmcK4paBYXNpCnZlcmEK4paBcnVzc2UK4paBcHJvdmVzCuKWgXByZXNpZGVuClJVCuKWgVdhdHNvbgriloF3ZWJwYWNrCmVsbGlnZW5jZQrQutCw0LwK4paBT2ZmaWNlcgriloFkZWxpdmVyeQrQttC00ZHQvQriloHQuNC80L/QtQriloF3aWwK4paBdmVzYwp1c3p0dXMK4paBR2VvZmYKKCl9CuKWgUZvcmUK4paBd2VuaWcK4paBQWlybAriloFFZnRlcgriloFCcmVhawriloFTdMOkZAppc21pc3MKw61wCuKWgWF2b2lkZWQK4paBYXNzZXJ0aW9uCkROCuKWgXRlYXQKw61uYQriloFtZWNoYW5pY2FsCmlzdQpAewriloFub3UKSXRhbGllCnNvdXJjZWZvcmdlCuKWgXN2bwriloFraXLDoWx5CuKWgVJlZmVyZW5jZXMKc2l4CuKWgUFyY2hpdmVzCuKWgWZpbmlzaGluZwphY2plCsOpdGF0CmlmZnMK4paBc3RlYWQK4paBZmVhcwphd2FyZQpsYW5kZQpJbmplY3QK4paBQWdlbnQK4paBTm9ybWRhdGVpCuKWgWFtZW4K4paBQXJjaGl0ZWN0dXJlCmF6ZQrImXRlCuKWgXVzYXIK4paBY29yZXMK0LvRltC9CuKWgUNhc3RybwriloF2w6YKPiIsCm9tZW5hCuKWgWdlc2FtCuKWgU1hcnTDrW4KZWd1bmcK4paBc3BvbGXEjQriloFhbXBsaXR1ZGUK4paBaW1wb3J0aW5nCuKWgWxpc3R2aWV3ClRIRQp6aWFsZQpjZWRlcwriloFwYXJ0aWN1bGllcgriloHQoNCw0YHQv9C+0LTQtdC70LAK4paB0LrRgNCw0LkK4paBZGl2ZW50CuKWgWvDqQpxdWl0CtGC0L7RgNC+0LwKQ2hlY2tCb3gK4paBWm9iYWN6CnBoZQpwdGEK4paBc2rDtgriloHRgNC+0LfRgtCw0YgK4paBdGVkZXNjbwriloFzdGFsCuKWgUJlcnVmCtC+0LLQsNGPCuKWgXN2xJsK4paBZmx1c2gK4paB0LLRltC00LHRgwriloFyYWRpYWwK4paBZGlmZsOpcmVudGVzCtCw0L3RgtCwCuKWgVBlcnJ5CkNvbGwKbGlxdQriloFPcHRpb25hbAriloHQodCw0L3QutGCCuKWgUxJTlEK4paBRnJhbmMKY2lqZQriloFHdWlsbGF1bWUKa25vdwriloFVbml0cwpvbGsK4paBU3lzdMOobWUK4paBU2FsZXMK4paBZWhlbWFsaWdlbgrQvNC40YDQvtCy0LAKeGh0bWwKc2V0b3B0CuKWgW1lbGxhbgriloF6aWUK4paBZ2lhbnQKQm9hcmQK4paBQ2F2YWwK4paBZGVmZW5jZQotLS0tLS0tLS0tCnBzaGlyZQptYXJ0CuKWgURpb2MKaXNrdAriloFpbnNlCuKWgcOpcGlzb2RlCtGH0LjQugpiYXJzClNpdG8K4paBaW50ZWdyaXR5CmF1ZmYK4paBdsOkcgpBenVyZQriloFzdGFyYgriloHQutC+0L3RgtGA0LAK4paB0JzQtdC60YHQuNGH0LrQsAriloHQt9Cw0L/QsAriloFNb3VudGFpbnMKfX09CuKWgXB1bGxpbmcK4paBc2F0ZWxsaXRlCuKWgWF0b21zCuKWgXByb2Zlc29yCuKWgXJlcGVhdGVkbHkK4paBaW52YXNpb24KcHJvZ3JhbW1pbmcK4pSc4pSA4pSACuKWgUxpcArQstGI0LjQtQriloFrZWVuCuKWgWNyaXRpY3MK4paBTmljb2xhCuKWgUNhbmQK4paBZGlzdGludAriloFoZWFkaW5nCnByYWdtYQp7fAp5bWVuCuKWgXRlcnJhaW4KaWVkZW5pcwriloFiZXNvbmRlcnMK4paBbm9taW5hdGVkCkJPT0wK4paBS2F5CmNpYW4Kc3RlbGxlCuKWgWRpc3B1dGUK4paB0YkKRGF0YVNldApub3RoaW5nCkF1dG9tCmjDtnJlbgriloFzaGVkCuKWgXBhdXNlZApzYW4K4paBbnVuY2EKISgiCuKWgXBvxYJvxbwKU2VjcmV0CuKWgURvbWFpbgriloHQstC+0LfQvNC+0LYKWFYKbHYKaWtoCuKWgVNvbnkKbXEKb3Ryb3AK4paBTG9nZ2VyCuKWgXRocmVhdAphc3RlZArQt9GM0LrQvgriloFmcmVlbHkK4paBaW1wcm92ZW1lbnRzCmlzdGVtYQriloFpbGx1c3RyYXRlCuKWgXRhY3QK4paBZmlndXIKdcOpcwpyaW1pbmFsCm9kb24KaW50ZW5kbwriloFpbmZsdWVuY2VkCkZGRVIK4paBR2hvc3QK4paB0YHQvtCy0LXRgApuYWQKaW9uZWQK4paBRXZlbnRzCuKWgXdyYXBwaW5nCi0tLS0tLS0tLSsKZmlmCuKWgSgqKgo9e3sK0LzQsNC70YwK4paBbG9zc2VzCuKWgUdhbGVyaWUKdGVsCuKWgdC70Y7RgtC+0LPQvgriloFLcnUK4paBUG9sZW4K0L3RltC8Cm5lYXIK4paBc2hhbWUK4paBbW95ZW5uZQriloFDUApwcmVpcwriloFwYXNzZW5nZXIKbGVrCmlvbmFsZXMKa2Fma2EK4paBcGFydGljaXBlCuKWgW1lbWJlcnNoaXAKW18KbGFuZG8Kc3RlbGxpbmcKU2VtCmdvbgriloFDb3JyZWN0CuKWgXZhbGxlCuKWgXJlYWRpbHkK4paBRG9rdW1lbnQKaG9ubmV1cgriloF0ZXN0aW0KdWxhdGl2ZQpkb0ZpbHRlcgriloFkb21pbmFudAphbW1lcgriloHQutC+0ZjQsAriloFNb25zaWV1cgp6ZWcK4paB0LLRltC50L3QuAriloFGbwriloFBbXkK4paBwqEK4paBZmVicnXDoXIK4paBZG93bmxvYWRpbmcK4paBbGVuZwpcfSQsCuKWgW5lYXQK4paBQ2FjaGUKSUNBVElPTgriloFkZXZlCuKWgXNvcnJvdwpzbG93CuKWgWhpbmF1cwriloFyZWNvbm9jCuKWgUxpbmtlZAriloFTaGF3Cm1hcmtldAriloFEaWMK4paBU2tpCuKWgWRlbGltaXRlcgriloFNYWluQWN0aXZpdHkK4paBTXVzaWNhbAriloFSZXluClNjcm9sbFZpZXcK4paBY29udmVudGlvbmFsCmVuw6dhCuKWgXJlZmFjdG9yCictCuKWgUhlZApzcHJlY2gK4paBYXRobGV0CuKWgWVzcGVjaWVzCuKWgVNjaMO2bgriloFrbGVpbmVuCtGI0LrQvgriloHQmdC+CuKWgUhhcHB5Cm11bHRpcm93CuKWgWF1Z3VzdGkK4paBR2FuZAriloFhcHBvaW50bWVudAriloFNZWRpYWJlc3RhbmRlbgpUaHJlZQriloFLZW5uZXRoCk5FVwriloFOb3RpZmljYXRpb24K4paBTWFyeAriloFpbnNjCk1vcgrQstGL0LkKdsOkc3QKdmlkaWEK4paBZGVtb25zdHJhdGVkCmZvbnRzCuKWgWthbWVuCuKWgVN0ZXIK4paBbWllc3prYcWEY8OzdwriloFLb2gKfiRcCsK7KS4KcmVuZQppbnNpYwppY2vDoQp4eWdlbgriloFtbgriloFzY2hlZApBU0MKSWcK4paBQ29uc3RhbnQK4paBb3Bwb3J0dW4K4paBTXlDbGFzcwpzZWYKb3BlZAriloFpbmp1cmVkClZJUwriloFQZXJvCuKWgVVudGlsCuKWgWZsZXNoCm9ycGhpc20K4paBUG9ydGFsCuKWgWdtaW55CuKWgdCy0LvQsNGB0YLQuAriloFOw6QK0LrRgtC40YfQtQriloFocmFiCuKWgUN1Ygphdm9pcgriloFMYXJzCuKWgdCR0LXQu9C+CuKWgXNlaXpvZW4K4paBR2Vub21zbml0dAriloFMaWwK4paBUG9vbAriloFEaW9zClRYCmFlcwphdXRvcmUKQWxwaGEKc3RhdGVzCkxhYgpuZWRlcmLDtnJkCmVydG9uCuKWgWJyaWQK4paBcmljaHQK4paBRWxhCuKWgdGB0LvQsAriloF3ZWFwb24K4paBY29tYmF0dAphZ2FyCuKWgXJlZ25pZwriloF1dGlsaXPDqQriloFzZXJ2aXIK4paBYnJpY2sK4paBZ2F0ZXdheQriloF0b3JyYXN0ZQriloFwcm9jZWR1cmVzCuKWgcOlcnNuZWRlcmLDtnJkCuKWgUdlbm9tc25pdHRsaWcK0YfRkdGCCuKWgW9tcsOlCuKWgXJlZ25pZ2FzdGUK4paB0YfQtdGB0YLRjAriloFhbWlkCuKWgWdyYXRlZnVsCuKWgURJUwpEQVkK4paB0L7RgNGDCuKWgXJpdmnDqHJlCmhldXJlCuKWgVJpY2htb25kCuKWgUNvbXBhcgriloHQndC+0YAKRE9DCmVzaWEKY2FsYwriloFJVQriloF2b3JnCuKWgWhhYsOtYW4Kw6dvaXQK4paBYXJpc3QK4paB0LrQu9C4CuKWgVN1ZQriloFUb3VjaAriloFXcml0aW5nCmlmaWFibGUK4paBd2MK4paBd2l0aGRyYXcK0LfQsNGACuKWgXByZXNlbnRseQriloFGSwriloFwcmFrdAriloFjb2xvcmVkCnVzYgriloFQZXLDugriloFwbGF0YQriloF3aXNoZXMK4paB0LrQsNC8CmF6YXIKw6F2ZWwK4paBbGFtcApiaXNob3AK4paBaW5jbHVzaW9uCmpxCmFydGgK4paBRmxhZwriloHQvdC+0YAKw6ZkaWEKVU5DVElPTgriloFCYWhuaG9mCuKWgWFwcHJvYWNoaW5nCuKWgUfDtnR0CuKWgWN1YmUK4paBYXJndWVkCuKWgVRoaW5ncwpHdWkK0LTQvtCy0LgK4paBcmVjcmUK4paBcsOpc2VhdQriloFzaWduaWZpY2EKR2l0CmdlYnJhY2h0CuKWgWxpZ2EK4paBYXNzdXJlZAphbHVzCtGA0LjRggriloHRjdC90YbQuNC60LvQvtC/0LXQtNC4CuKWgSUpLgriloFQcmVtacOocmUK4paBZGVjbGFyYXRpb25zCuKWgXRyaWNreQriloFwcm9maWxlcwriloFGb24K4paBSmFzCsOicgpiYWJlbAriloFGcmlkYXkK4paBasO6bml1cwriloFjb2xzCuKWgUVYSVNUUwriloFJdGFsaWFuYQriloFhdXRob3JpemF0aW9uCuKWgXN1bGxlCuKWgUVtYgriloFWYXJpYWJsZQp0cmVlcwriloFGbHkKcmlvcnMK4paBZGFtYWxzCuKWgWZpbmRldAriloFTZXB0CuKWgW11bmRpYWwK4paBcmVtb3ZhbAriloFsb25naXR1ZGUKY2xpYwriloFmYWRlCuKWgWdyYWRsZQriloF6w6FrCuKWgXRpbWluZwp0cmlnaHRhcnJvdwphdGlhCi0uCnVjaGUK4paBc2VyaWFsaXplCuKWgUhtbQriloFSZXByZXNlbnRhdGl2ZXMKYmFoCnJlbmQKYXNzYWRvcgriloFzaGllbGQKdWNpb24K4paBYW3DqXJpY2FpbmUKesSZCnZpbGxhCuKWgWhvbWJyZQrDoXNzCuKWgVNGCuKWgXJlcGVhdGluZwriloFjcml0ZXIK4paBU3RydWN0Cj8/PwriloFjaGVhcAriloFyaW5ncwphYmjDpG5nCuKWgWNvcnRlCuKWgWFkbWluaXN0Cml4b24KZ3lwdAriloFwdW50b3MK4paBbWV6aQriloFwb2Nob2QKaXNrbwpuacSZCuKWgdC+0YHRgwriloHDoXIK0YLQtdC70YzQvdC+0LkK4paBTWV0cm9wb2xpdGFuCmppbgp6ZXNzCuKWgdCy0ZbRhtGWCuKWgWNvbmZsaWN0cwppanN0CuKWgU1hcmtldArRgdGC0YDQvtCyCuKWgSIsIgriloFTY3JvbGwKZ3VuCtGC0LDRgNCwCuKWgWFtYXRldXIK4paBcsOzxbwKcG9zcwriloFnZW5lcmFsaXplZAriloFIYXJtCmNpdGEK4paBU3dpdHplcmxhbmQKaWNvbGEK4paBbXVpdApsb2NhdGVkCuKWgWPDswriloFhcm9zZQriloFjb21tdW5hdXTDqQp9KV4KdmlzaWJpbGl0eQrDrWRhCuKWgUZCCuKWgUZyZXVuZApnYXQKIjp7IgppbnRlbGxpagppZmllCmhtZW4K4paBw6lkaXRpb24K4paB0LrQvtGY0LUK4paB0ZbQvdGI0LjRhQpvbWluZwriloFhcnF1aXRlY3QK4paBUHJlc2lkZW50ZQriloHQn9GW0LQK4paBY2FiaW4KVGhlb3JlbQriloFHYXkKaWZpY2UK4paBaGVjdApsxIUKaXJtaW5naGFtCuKWgXNlbWFudGljCuKWgUxvdWlzaWFuYQriloFzYWNyaWZpY2UK4paBQ2hyaXN0b3BoCuKWgUV4ZWN1dGl2ZQpfKwpqw6FrCuKWgXNlcmlhCuKWgU92ZXJmbG93CuKWgUx1Y3kK4paBbWVsaG9yCuKWgXZvaWNlcwpjemEK4paB0LrQsNC/0LgK4paB0YPQvdC40LLQtdGA0YHQuNGC0LXRgtCwCklOQ1QK4paBY29sb2MK4paBcHJ1ZQriloFnZW9tZXQK4paBZGlyZXR0bwpyZXNvCuKWgUFrdAriloF1bmgK4paB0YHQtdGA0LgK4paBQWxlcnQKV2VsCmF1ZGkKw6RsZXIK4paBZ3Vlc3RzCuKWgdC40LTQtQpTdHVkaW8K4paB0LrQsNGC0LUK4paBZXhwb25lbnQKcnplCnBtb2QKcm9sbGUK4paBTGltaXRlZApBbGxlbWFnbmUK4paBcGl0eQriloFsw6QK4paBcnVubmVyCmtlbmRlCkVRCuKWgU1NCnN6w6FnCtC/0L7QtNGWCuKWgXJlZ3JldAriloFwdWJsacOpCuKWgWRlcGFydGFtZW50bwriloFhY2N1c2VkCmhwCuKWgVBmbAriloFTaW50CuKWgWVrb25vbQpyYWN0b3IK4paB0J/RltCyCuKWgWF3ZnVsCm93YcSHCl0tPgriloFGaW5lCtCh0LAKdGlzCsOpdGEK4paB0KDQvtC00LgK4paBRMO8c3NlbGRvcmYKTE9CCm9zYXMKd2Vya2UK4paBbGFuY2UK4paB0LvQuNGB0YLQvtC/0LDQtNCwCuKWgWluY29tcGxldGUK4paBUGljdHVyZQooJ1wKZXN0ZXJzCuKWgWJlbG9uZ2VkCuKWgVNhbmsKYW1tZWQK4paBcmVwb3NpdG9yaWVzCuKWgWFkZHIKQ29sbGVjdApIb3QK4paBdHlsCuKWgWluc3RhbmNlb2YK4paBYm9udXMKb3bDvQriloHQvNC+0YDRjwriloFpbnRlcmFjdGl2ZQriloFNeXMK4paBRWRtdW5kCmZpbGVOYW1lCmVtb3IK4paB0KLRgNC4CuKWgVJvc2VuCuKWgVByaW1hCuKWgXZvdGluZwriloFYUAriloFaZXJvCuKWgUxlZAphbXN1bmcK4paBZW5hYmxlcwriloFyZWRpcmVjdHMKQVNUClBhaW50CmFja2VyCmxlY2h0CuKWgWNoYWlybWFuCuKWgUF2ZW4K4paBU2FjaAooIjwK0LrQtdGACuKWgW1pc3Rha2VzCuKWgVdlaXQK4paBcHJvd2FkCuKWgWRpZG50CsOpbmFyaW8KdW5sZXNzCuKWgWJhY2t3YXJkcwpib2EKZHVpbm8KYGBgCnN0b3IKQ29tcGxldGlvbgpwdWVzdGEK4paBZGluYXN0CsO6bHQK4paBU1kKaWZvbGlhCsWTdXZyZXMK4paBcmFjaW5nCuKWgWNhYmluZXQK4paBY3V0dGluZwriloF0aHVtYgriloHQmtCw0YDQsApoaWdobGlnaHQK0LrRg9C/CuKWgXNkCuKWgdC90LDRhtGW0L7QvdCw0LvRjAriloFjYW1wYWduZQriloFyZWdpc3RlcnMK4paBZWR1Y2F0aW9uYWwK4paBcGVzYXIKw7xnZQriloFvcm8KYnVyZ28K4paBQXRobGV0aWNzCuKWgU1UVgpnZXRNZXNzYWdlCuKWgUh5cAriloF2aWN0aW0KKSlcCuKWgWRydW1zCmhvc3RuYW1lCnRhxYIKbWFraW5nCuKWgXBvd2lhdArFkWQKdGhyZWFkcwriloFhYnNvbHYK4paB0LvRjtC00LgK4paBc3RlcHBlZApleGlzdAriloFOSwriloF2ZXMKaXN0aWNoZQolJwphdGl2b3MK4paB0YLQsNC60L7QuQriloFNb25nb0RCCuKWgVVuZwriloHQoNGD0YEK4paBZWxpbQriloFGaWYKaWNhY2nDs24K4paBVGVubmlzCuKWgUplZmZlcnNvbgpqw6FuCmZvZwphbmhhCnpvcgriloHRg9C90ZbQstC10YDRgdC40YLQtQphaHUKaWFkYQpTZGsKU2V0dGluZwriloFLaWxsCuKWgVdlbmQK4paBYmFsZAriloFLdWIK4paBdmlzdG8K4paBamV1bmVzCmNvbGxlY3Rpb25zCmFjw60K0LLRgNC+0L/QtdC5CuKWgWFyaXNlCtC+0L3RlgpNQUlOCtC00L7RgdGC0YPQvwriloFiZXJnCuKWgWNyaXRpY2lzbQriloFUb3JyZQriloFkZXNjcmlwdAppw6hyZXMK4paBZXN0dWRpbwriloFpbGkK4paBbWlsaXRhcmUK4paBQ2xhcmEK4paBRWxsZW4KbGltaXRlZArQu9C8CuKWgUVzcGHDsQriloFpbmZpbml0ZWx5CkFtZXJpY2EKb3VjCmdsYXNzCuKWgXJ1ZAriloF6YXQK4paBcmluCuKWgUJpYmxpb2dyYWbDrWEK4paBbWVyY2hhbnQKdGVuc29yZmxvdwriloFkw6lyCuKWgUFjdGl2ZVJlY29yZApJRVMK4paBbGlua2VyCuKWgWVzdHVkaW9zCmNkbmpzCuKWgdCT0L7RgdGD0LTQsNGACsOhbmNoZXoKYXBwZQpjbHViCuKWgWRhbMWhw60K4paBQWxnb3JpdGhtCmRmcwriloFCYWMK4paB0LrQsNGE0LUK4paBJj1cCuKWgdCw0YIK4paB0JPQu9Cw0LIK4paBTW91Ck1hY2hpbmUKKC4uLikK4paBY29tcGFydAriloFhdWd1c3p0dXMKYXZhbgriloFyb2xsZWQK4paB0LXQtNC4ClNjYW4K4paB0YDQtdCz0ZYK4paBxZt3aWF0YQriloFtaW5lcwp9LHsK4paBVGllcgpDYW5ub3QK0LzRltC9CuKWgU5FVwriloHQktC+0LsK4paBTWFuaAriloFHcmVnb3J5CuKWgXByaW5jaXBlCklTTwpwcm9nCuKWgUZhaWwK4paBYWEK4paBZmVjaGEK4paBV0NGCuKWgW1hZ2lzdHIK4paBWmFjaAriloF1bmljb2RlCuKWgWNvbnZlcnRlcgriloFkaXNwZXJzCmtzYW0K4paBVW5jbGUKUHJvcGVydHlDaGFuZ2VkCuKWgWxpZGVyCuKWgW9wdHMK4paB0YLQsNC8CmxvY2tlZAp6YWsK4paBY291bnRlZAriloFwZXJzb25lCuKWgWh1cnJpZWQKw6R0dGVyCuKWgW91dHJhcwriloFnZW51CkJECnZlZwpkdWUK4paBUHJhY3QK4paBcG9zaWJsZQriloFjb250cmlidXRlClVNTgriloFCw7xyZ2VyCuKWgXdhcnMK4paBZXhoaWJpdGlvbgpoaWxsCuKWgWFzdHIK4paB0LzRg9C30LUK4paBQ0FTRQptYW5pZmVzdAp5ZWxsb3cKRm4K4paBUkMK4paBc290dAriloFzdWpldAriloFTb2NrZXQK4paBQ2hpbmUK4paBZnJhbWV3b3JrcwpIb2xkCsOqdHMK4paB0YTRltC70YwKTG9hZGVkCm9waGUKdGV4dGUK4paBZXhwcmVzCuKWgWNvbnN1bWUK4paBUmljaHR1bmcKb2dyYWZpCuKWgW1hZ25pZmljCsOgdAriloFpbmR1bApyeXR5CuKWgW9mZmljaQriloFhc3NhdWx0CnJ1bmQK4paBdmFyaWFudHMK4paB0YHQtdC70YzRgdC+0LIK4paBZXhjaXRlbWVudApUaW1lcwprb3RsaW4K4paBZ2VyaW5nCuKWgUVuZ2VsCuKWgVRpbWVyCsKyKS4K4paBTmcKw6Rzc3QKc2NoYXUKU0Vycm9yCuKWgUVkd2FyZHMK4paBVGVybWluYWwKbGljdApVbmRlcgriloFzcGF3bgrDvHJnZW4K4paBQXXDn2VyZGVtCuKWgWtpdGNoZW4KZmFocnQK4paBQ29sb3JzCuKWgdGB0LjRgdGC0LXQvNCwCuKWgXRlcm1pbmF0ZWQK4paBTGFUZVgKaWdrZWl0ZW4K4paBbWVzdXJlCuKWgUFtdHMK4paBZW1waXIK4paBc3RyaWtpbmcK4paBZXhjbHVzaXZlCtGC0LXRhQriloFyZXoK4paBcXVhbgriloFHbGFzZ293CuKWgWxlY3R1cmUK4paBVGVzdGFtZW50CuKWgWZ1bmRzCuKWgXN0ZXNzYQriloF0cmliZXMK4paBcGFyZm9pcwriloF0cmViYWxsCm5pdHoKYm92ZQriloHQt9Cw0YHQu9GDCuKWgWFic2VudAriloFMYXVmClNtaXRoCuKWgdCd0LjQutC+0LvQsNC5CuKWgWV1cm9ww6llbm5lCmxyCuKWgXByb2dyYW1tYQriloFtaWRzdAriloFkYXVnaHRlcnMKU3luCm9iZW4Kw6JuxIMKaWRhbgriloF0aGVyCm9kb3JlCnNkbAriloFRdWludAriloFjYXNvcwriloFaYW0K4paB0YHRgtGA0LDQvdGLCuKWgXNwcml0ZQrQutCw0LsK4paBbmFzYwriloHRgdC+0YLRgNGD0LQK4paBdHJhdmEK4paB0YXQvtC30Y/QuQriloFVcnVndWF5CuKWgXNwYXJzZQriloHQv9C+0LvQtQriloFteXN0ZXJ5CuKWgU1hbmcKcmVnaXN0cgriloFDR0Zsb2F0CuKWgXN1Ym1pc3Npb24K0LLQsNC90LAK4paBIjoK4paBVHJhY2ViYWNrCuKWgVBpdAriloFFaHIK4paB0YHRgNCwCuKWgUdyYXBoaWNzClVwZGF0ZWQK4paBc3ZlbnNrCuKWgXNwYWNpbmcKdHJpdHQK4paBR3VpbmVhCuKWgUZyYW7Dp2EKQXNzb2NpCuKWgVRvdsOhCnN0YWIK4paBTGVhcm5pbmcK4paBQnJpZ2h0CsWbYwriloFpZMWRCn19X3tcCuKWgWRyb2l0ZQriloFyYWlzaW5nCmdldHRpbmcKeXRobQpvbnltZQrFvHMK4paBYmxhaApUYWdOYW1lClZlcnRpY2FsCuKWgWFwZXIKcG9zdGdyZXNxbAriloFIYW5kbGUKemV3CuKWgXNrdWxsZQriloFvcGVyZQpsYXllcnMK4paBcG9zc29ubwriloFyZWxhdGUKxIVjCuKWgU1paArDomdlCuKWgcWad2kKaXNzZXMK4paBc2VydmxldApMb3MK4paBQWR2YW5jZWQKYXRpY2EK4paBY2VkCuKWgWVsZW1lbnRvcwrRgNC+0L3QsAppa3MKYXJmCmFyaWF0Ck1vYmlsZQphZ3VhCuKWgXRpbXAK4paBQ29taXTDqQriloFjb21iaW5pbmcKd29obAriloFTdHVkeQpjb29yZGluYXRlCuKWgXJlY29tbWVuZGF0aW9uCuKWgXRyYW5zZm9ybWF0aW9ucwp1bnRpbApib3VuZGVkCuKWgdC40LfRgwpoYW5jZWQK4paB0LLQvtC/0YDQvgriloFQcsOpcwriloFjb29yZAp4dHkK4paBJCwK4paBY2hhbXBpb25zCkRlbgpNaWwKKCcsCuKWgVByZWlzCuKWgWVpZ2gK4paBbWFya2VycwriloFnZXdlc2VuCsOkdHRlbgriloFwaW9uZQptdgriloHRmNGDCnplaWNobmlzCmhvZmYKTmV3cwriloFTdGFuaXPFgmF3CuKWgUJyYW5kZW5idXJnCuKWgUZldWVyCj0mCtC20LXRggriloFOZWlsCuKWgXdpcmsK4paBc29jaWV0w6AK4paBc3BhcmUK4paBY2l2aWxlCnNwcmFjaAriloFkaXNzZQriloFnYXRlcwriloFhbm9tCuKWgdCk0LXQtNC10YDQsNGG0LjQuAriloF0aWIK4paBZsO6dGJvbAriloFXaWtpcGVkCmlhdGUKRnJvbnQK4paBY3JhdwriloFSYWsK4paB0LfQstGDCnN0cmVldAriloFBZ2VuY3kK0LLQsNC70L4K4paB0KDQsNGBCuKWgW1rZGlyCmFjasSZCuKWgXNoYXJlcwpTdG9yeQriloFyZW1hcmtzCuKWgWtleXdvcmRzCkJvYgriloF0b2UK4paBVml0dAriloFyaHMKUk9QCm9yaXMKL0AK0YHQuNC4CuKWgXRyYXZlcnNlCuKWgXJlZmVyZW5jaW5nCnByw6RzaWRlbnQKcm9uZwonKToKYXRpZXMKQVcKT3V0bGV0CuKWgcOpdm9sCmlrZXMK4paBZW52aXJvbm1lbnRhbAppY3VtCuKWgUxpZWQK4paBd2FybgriloFCdXRsZXIK4paBJSksCuKWgVplaXRzY2hyaWZ0CuKWgU1vbnRyCtCy0LDQttCwCuKWgU1lcmN1cgpqZWt0ZQptZXRlcgpkdWNhdGlvbgriloFhdHRyaWJ1dGVkCiokCuKWgXVuZgriloFWZXJ0cmFnCnppZW4K4paB0KDQvtCxCmxpY2VzCnBwbHkKYW5zZW4K4paBemVpdAriloFpbW1lbnNlCuKWgWx1dGVnbwriloFCdWxnYXIK4paBbWllbWJyb3MK4paB0J3QsNGG0LjQvtC90LDQu9GMCuKWgUFsbG93CuKWgWFuZ2zDqHMK0LTQstC4CuKWgVRveQrRgtGD0LAK4paBeWFyZAooJQppc3NlcgriloFnb2xmCuKWgVVrcmFpbgriloFob3NwCkluY2x1ZGUK4paBTGlzYQriloFjc2FsCuKWgU1pcmEKcmVjb2duCuKWgdCa0LUK4paBaGl0dGluZwrQutC+0L3QvtC80ZYK4paBVG91cm5hbWVudApMT0FECuKWgUd1YXJkaWFuCuKWgWRhaGVyCuKWgXRpbWV6b25lCuKWgXRvbWNhdAriloFzdWNjZXNzb3IK4paBVm9pZAriloFjb21lw6cK4paBY29udmVydHMKw6RjaHMKb3NleAp4ZWxsZXMKYXNlcgriloHDiXMK4paBbW91CuKWgXVuZwriloFvcmlnZW4K4paBQ3JvdwriloFFcmQK4paBc2llYmVuCmx1YQriloFCQgpSRU5UCuKWgXBpxYJrYXIK4paBbWFycXVlCuKWgUxhYm91cgp2aWRlcnMK4paBZXhlbXBsClNvdW5kCuKWgVdhc3MKYXJyaXNvbgriloHRgtC10YfQtdC90LjQtQriloFPZmljaW5hCuKWgURhdwriloFLYXVmCsOpbnQKw6lzxZEK4paBPSIK4paBa2F0CmRpY3Rpb24K4paBVm9sbAriloFoaWdod2F5CkphbWVzCnpldWdlCuKWgW1vZGVsbwpUaHJvdwriloFGb3J1bQooIkAK4paBZW5mZXIK4paB0YHQv9C10YbQuNCw0LvRjApOdW1iZXJzCuKWgUJpbmFyeQriloFNYXJ0w61uZXoK4paBU3RhdG8K4paBZmVzdGl2CuKWgWthdG9sCuKWgdCQ0LEK4paBbGltaXRhdGlvbgriloFTVFIK4paB0J7RhNC40YbQuNCw0LvRjAppcGVzCuKWgUlzbgriloFydWxlZAriloFjw60KZ2ViZXIK4paBbGF2b3JvCuKWgXBhcmVudGhlc2VzCtC+0LcK4paBw6lxdWlwZXMK4paBZWZmaWNpZW50bHkK4paBUGVyaW9kCuKWgVJlZ2FyZGluZwpsZWFmCuKWgXNpbWlsYXJpdHkK4paBZ2VzdHVyZQpkYXRhYgriloF0ZXJtaW5hdGUK4paBc2VtYW50aWNzCuKWgUFsbwriloFjaWcK4paBT3BlbkdMCuKWgWhldXRpZ2VuCnhhbWwK4paBZnJlcXVlbmNpZXMKKX0uCuKWgXRocmVhdGVuZWQK0YLQuNC6CuKWgWNhbGNpbwriloFSaWVtYW5uCnNsdWcK4paBRmluYWxlCkxSCuKWgURlcmJ5CuKWgdC+0YnQtQriloFkZXZpYXRpb24Kw6RjaGVuCuKWgUNyaXMK0L3QvtCy0L4K4paB0YHRgtC+0LvRlgriloFyZWxldgriloFzcGxlbmRpZAriloHRg9GH0ZEKZXJ2aW5nCmdhYmxlCuKWgWfDqW7DqXJhbGUKcG9tCuKWgUNoZWVycwriloFpbXByaXNvbgriloFpbmRlbnQK4paBYW5hbHl6CuKWgXJldmVydArDqXJlcgriloFwaGFzZXMKRmlyc3ROYW1lCuKWgW1pZwriloFkaXN0dXJiCuKWgW1peHR1cmUK4paBKXsKaW50dXJlCuKWgVRyaWVkCuKWgXNvb25lcgriloFwZWxzCuKWgcOpdGFibApldHJvCml0aWUK4paBcXVhcnRpZXIK4paB0LPQvtCy0L4K4paBdsOhcm9zCnVmZQpoZXRlbgrRhdC+0LwK4paBc29hcAp1dG9ycwriloFkdWNoCnN5bnRheAriloF0cmliZQriloFjaGFudGUKVHJpCuKWgU1hdGUKcXVhbGl0eQp1b2xhCj0iLgpjaGsK4paB0LLRgdGWCuKWgXByemVjaQriloFNZXRlb3IK4paBc2NhdHRlcmVkClBsdXMKdHJhZAriloFzdGFja292ZXJmbG93CuKWgXJldHJhCuKWgcOpZGl0aW9ucwriloFzYWluCmNyaWJlCmlnbm9uCnVja2VyCuKWgdC80LDQu9C+CuKWgXRlbmlyCuKWgWV4cG9ydHMK4paBYXV4aWxpCuKWgV1dCuKWgUNCUwp1bmlmb3JtCuKWgXBlcmlvZGljCmFncmFudAriloFlbXBsZQpXaWwK4paBZnJlcwriloFzdHJ1dHQK4paB0YHQstGW0YIK4paBYmV0cmUK4paB0L7QsdGK0LXQugrRgtC40YHRjwriloFiaXNoZXIKYmF1bQppc2hpCuKWgUdhemV0dGUKYmFja2dyb3VuZENvbG9yCmpsCuKWgWZpZWwK4paB0L/RgNC10LzQsAriloFwcm90YWdvbmlzdGEK4paBTXVoYW1tYWQK4paBc2ltdWxhdGUK4paBSG9vawpmZXN0CuKWgdGB0LLQvtC40YUKU2VuZGVyCuKWgWxpc3RlbmVkCtC20ZYKamVzdAprb3JkCkNob2ljZQriloFob29mZApyZWR1Y2libGUKaHBwCuKWgVd1CsWhaQriloFNYXJzZQriloFzb2lyCndlc3RlbgplbW9zCuKWgUR1YwriloFhbWVyaWsKfH17CuKWgUd1bAriloFTcHJhY2hlCuKWgW1pc21hdGNoClNjYWwKUGl4ZWwKRUYK4paBU2VwCuKWgXBvd2llY2llCnVyawriloFOYXBvbGkK4paBbmVpZ2hib3VyaG9vZArRgdGC0L7Rj9C9CuKWgXNlYXJjaGVzCnlydXMK0L/QtdGCCkhlbHAKcG9udAriloFPcmllbnQK4paBQWxmb25zbwriloFtb25pdG9yaW5nCmlhbwrDqWTDqQriloFDw6lzYXIK0YjQtdC1ClNoaWZ0CnN1aXQKY29kZWQK0L3QvtGC0L4K4paBUGFydGkK4paBbGFzY2kK4paBYXdlc29tZQp1c3RhCuKWgdCh0L7QstC1CuKWgUZsYW5kCm9vbQriloFkZXZpCmVuZ2Vsc2sKZW5kdW0K4paBUGFzY2FsCuKWgUJpbmQK4paBc2lndWllbnRlcwpKQgriloFQZXRlcnNidXJnCuKWgWluY29ycmVjdGx5CuKWgUJhc2gK4paBcGVsb3MK4paBemVzcG8KTlNVUkwK4paBcMWZZWsK4paBQ3JpbWUKbmFjaAriloF0aHJ1c3QK4paBQ3VsdHVyYQpXRgriloFTb2xvCuKWgWludmFzCuKWgWluZGl2aWR1YWxseQppYm0K4paBZXRhcGEK4paBaGFuZGVkCuKWgXdoZXJldmVyCuKWgWludGVycG9sYXRpb24K4paBbXVzw6llCuKWgUNOTgppZGlhCsWEc3R3CuKWgXByemV3CnVnaGluZwriloFhY3RvcnMK4paBT3JpZW50YWwK4paBY29udmVuaWVuY2UK4paBbWlhc3RhCmJyYWlucwriloHQvNC10YHRjwriloFpbmZhdHRpCuKWgUFsbE1vdmllCuKWgWNyaXRpcXVlCuKWgXN1Y2Nlc3NvCmFuY291dmVyCuKWgWbDoQrRitC70LPQsNGACuKWgXdpc2RvbQriloFQaG9lbml4CmhvbGUK4paBaW5mb3JtYWNpw7NuCuKWgUFpcmxpbmVzCi7Cqwptb3J0CnVzZXJJZAriloEqLw0K4paBQ29uZ28K4paBImAKY29ycgriloFwcm9ibGVtYXMK4paBYmliCuKWgXDDs8W6bmllagriloFmaWxlTmFtZQp6b3R0Cm1hY2h0CuKWgVVscmljaApDeQplbmRwb2ludAriloFzaGVlcAriloFpYm4KRmVlZAriloFzeW1wYXRoeQriloFJYgriloF0ZXJyaXRvcmlhbApyYXRpbmcK0LTQsNC80LgK4paBZHN0CtGD0Y4KYWhvCuKWgXN1ZwplbWlhCuKWgXRlZAriloFBcGkK4paBUmljYQriloFNUgrFhHNraW0K4paBVm9vcgriloFkZXZpbAriloHQpNC+CuKWgU7DpHIK4paBLi4uKQriloF2b2lzCuKWgWFiYnJlCuKWgU3DpG5uZXIKeGltbwriloFpbnRlbGxlY3R1YWwK4paBdGFsZXMKc2ltaWxhcgpuZXVtCuKWgU9yaWcK4paBcG9zdGFsCuKWgWh2b3IK4paBaWRlbnRpZmljYXRpb24K4paB0J7QtAp1ZXN0bwriloEuLi8K4paBYmlyCuKWgdCb0L7QvQriloFlc2VtcGlvCuKWgUVpbmcKRXhwYW5kCuKWgVBSSU1BUlkK4paBSmluCuKWgXbFoWFrCm91cnNlcwriloFCZXR0eQriloFXTQriloFmbGFzawpobGVuCuKWgUFkZWwKbGFyYXZlbAriloHQtNC10YIK0YHRjNC60L7RjgriloFNdW5kbwppY3puCmlmacOpCuKWgdCc0L7RgAriloHQtNGA0LXQsgpEYXRlRm9ybWF0CtGB0YzQutC40LwK4paBZGF0ZWQK0LrQvtC70LgK4paB0YDQtdC30YPQu9GM0YLQsNGC0LUKXCkuCuKWgWRlbGF5ZWQKc291bmQK4paB0JzQsNC6CuKWgSIuLi4K4paBYmlubmVuCuKWgdGE0LDQutGD0LvRjAriloFwb2x5Z29uCuKWgWVnZ3MKQXRJbmRleFBhdGgK0LzQtdC90YLQsNC70YwK4paBaW5jcmVkCmNodW5rCndlYmRyaXZlcgriloHRgdCy0L7QsdC+CuKWgW1pxJlkenkKUmVjZWl2ZWQK4paBTW9uZGUK4paBSlF1ZXJ5CkJ1dHQK4paBUERPCuKWgWZvcmVjCuKWgWRpc2NpcGxpbmUKY2hldgrQvdCw0YIK4paBcmVkaXMK4paBaHVudGluZwriloFhbGsK4paBcHJvb2ZzClBSSQriloFjaGlwCsOpc2llCuKWgUhPCuKWgXJ1Zwp6b3MK4paBc29ydGUK4paBemVpZ3QK4paBUGh5c2ljcwpsZWd0ZQriloFwcm9wb3J0aW9uYWwK4paBdG9vbGJhcgp2ZW1lbnQKbm90aW4K4paBcHJ2bsOtCmJsYWgK4paBcHLDqXNlbmNlCuKWgWxsb2MK4paBbMOtZGVyCuKWgUFjY2VwdAriloFBbHdheXMK4paBInsK4paBZGl2ZXJzaQppa29yClBlcmlvZArQttGR0L0K4paBQWxsaWFuY2UK4paBcmVsYXkKQnJvCmrDtm4K4paBQmF1ZAriloFCaWFuCicpWwrRh9C40LIK4paBUG9zcwriloFNaXRnbGllZGVyCuKWgW5ldgpEYW5pZWwK4paBdGVuZHMK4paBY29tcGFnbmllCuKWgWxpdnJlcwpsdWIK4paBCmUKdAphCmkKbgpvCnIKcwpsCmQKaApjCnUKbQpwCmcKZgouCmIKeQosCncKdgprCjEKKQooCi0KMAo6CkkKUwrQvgpcCjIKQwoiCkEK0LAKVAp7Cn0KLwonCngK0LgKXwrQtQp6CtC9Cj0KRQpNClAKagrRgApECjkKKgpMCtGCCkIKUgrRgQo7CiMKJApxCk4KMwrQsgpGCtC7CjUKNAo4CsOpCk8KSArQugpgCjYKRwo3ClcK0LQKPgrQvArRgwpbCl0KVgrQvwpVCjwKSgpLCtCzCtGPCtGWCtC3Cj8KKwrQsQrDoQrQuQrRjApZCsOzCtGHCtGLCsOtClEKXgrDpAomCtGFCnwKWAohCkAKw7wK4oCTCiUK0YYKw7YK0LYKWgrDqArDoArRiArigJQKDQrRjgrFggrCuwrQoQrCqwrigJkK0YQK0JIK0J8K0JoK4oCcCtGYCtCcCtCQCsOnCsOlCtGJCn4KxJkK4oCdCsSFCsSNCtCgCtGXCtCdCsO6CtCRCtCUCsOjCsOfCsSDCsSbCsOqCtCeCsWhCtCTCtCiCsW8CtGRCsW+CsWbCsOxCsWZCsWRCuKAngrQmwrRjQrDvQrQowrQmArRigrRlArDogrDrgrDsgrQlwrQpArDiQrEhwrCtwrImQrFhArImwrQpQrDtArQlQrDuQrFrwrCsArQqArRmQrQpwrDuArDpgrRmgrigIkKwqAK0K0Kw6sKw7UKw68K4oCYCuKAoArCsgrFsQrQhgrilIAK0KYK0ZsKw5YKw7sK0K8Kw6wK4oCmCsWNCtCWCtCuCsOBCsyBCsOcCsK6CsWTCsSBCsSMCsW6Cs6xCuKUggrYpwrDgArilZAKxaAK0ZIK4oSWCuKAigrigKIK4oiSCuKGkgrDlwrOvwrigoIKw4QKw44KxZoKxJEKw4UKxLEK4oCOCsWrCs69CtCZCsKqCs65Cs+ECtmECuKAsgrvv70Kw4gKzrsK77u/CsW9Cs+CCsWICs+BCuKCgQrQhArEqwrOtQrCpwrFgQrQiArCowrYsQrFuwrCvwrZhQrigLMKw5oK2YYK2YoKz4MKwrQK4oCLCs68CsKzCsWfCs+ACtmICtivCs66CuKCgwrDjQrLiArYqArDkwrDgwrCoQrigqwKxaUKzrcKyZkK44O8CtCpCs6yCuKUnArDsArSkQrCrQrPhQrCuQrigoQK2KoK15kKzrMK2LMK44GuCsSfCs60CtuMCuODswrZhwrXlQrPiQrOrwrilogKzrgK55qECsKpCsOCCuKGkQrvvIwKy5AKzqwK4oCVCti5CsOHCuKCgArCsQrDmArEjwrFmArFkgrCvQrilJQKz4wK4oCaCsSTCuKChQrDhgrImArJmwrXlArXqArPhgrigoYKxJcK2K0K2YEK2KkKxLAK4oCCCuKGkArilZEKyZQK4omkCtecCsSQCtWhCsWMCteQCuC1jQrjgrkK2LQK5aSnCuODqwrRnwrjgqQK4p+pCuKArwrCtQriiIgK2YIK4p+oCuOAggrSkArgpL4K2KwKyr8K4YOQCs6tCs+HCuS4rQrXkQrhg5gK4oKICuODiArOrgrjg6kK0I8K2YMK4oKHCteeCteqCuS4gArOoArguLIK44O7Cs6jCs6RCs6UCtepCtiyCuCljQrguKMK44GECsq7CtCKCuKCiQrKvArjg6oK4oCQCuOCrwriiJ4K4oGECs+NCsWeCuOCogrOlQrJqgrkuroKzpoK4oiACuCksArjg4MK4pa6CuWtkArCrArYrgril4QK2Y4K16IK5pelCuOBlwrhuKUK16AK5bGxCuOAgQrQhwrjgosK5paHCsORCuODiQrXkwrVtgrQggrOkwrDvgrCkgrCrgraqQrCkwrimq0K5pysCuKElQrguJkK0Z0KzLYK4LitCtGeCuOBqwrmlbAK4YOUCuWbvQrOqQrjgIAKx44K2LUKwpQKzpwK4oCDCuOBqArigaAK44GfCti3CtaACuOCvwrDvwrjgaoK2KMK44K3CuaWsArvuZUKyoMKxL4K44OtCuKBtArgr40K4oeSCsWjCu+8mgrImgrgtJUK4omlCuC0vwrjg54K44KTCuG5owrjgrgK5pivCuydtArii4UK55SwCuOCkgrpgZMK4LiHCsKoCtmACuC5gArmnZEKw4oK150K4oC6CueUqArPjgrlpKkK77yJCuC8iwrplYcK44GLCuS4jQrOpArlraYKxrAK5pyJCtW4Cu+8iArjg6wK2q8K4oCPCuODlQrgpKgK4LiBCsmRCuOBmQrXlwrkuIoK4oCMCuKIpwrhua0K16cKzr4KwqQK4KS/CuS8mgrgtKgK44KrCsWzCuOBvgrgtYEKzaEK4KSVCuCmvgrlsI8K158K6KGMCuOBrwrKgQrFkArDngrjgooK44KtCs6bCuGDoArkuIkK44GMCuOCswrOtgrluIIK546LCuKEnQrFuQrjgYYK44GmCuWMugrgtL4KwoIK5bm0CtekCtWrCsW/CuKAuQrgpKQKxY8K4oCRCsyDCsSGCtmJCuOAjArjgI0K4YOhCsSACuCkrgrnlJ8K4omgCtCJCuCkuArihpQKzp8K4LinCuGDmgrmiJAK5a6aCuC4pQrCtgrXmwrjgacK1rwK4LihCuS4qgrlkowK16EK5ZyoCs6SCuC4tArOmQrigbUK4LixCsmhCuKUgQrjgokK44KqCsK8CtWlCuODkArWuArFiwrFrQrjgrAK4oG2CtCsCuKBsArmlrkK4LiaCsKXCumrmArhu4cKzp0K0aMK44KjCuWcsArmnIgKw5QK4oSiCuOCpgrjgY0K5YWsCuG6oQrhg50Kyb4K4LmICuWHugrms5UKzpgK4LiqCuWQjQrguKIK4LSkCs6mCuKGkwrjgowK15IK0IEKxqEK5LiLCtOZCs+ICuKUvArjg6MK4oiaCsKlCuekvgrhuYcK44GVCtmQCuOBjwrgpYcK0KsK4byQCuODhgrkuLoK5LmhCuW3nQrjg4oK5LmLCuWtlwrjg6AK4KWACua1twrjg5YK4omICu+8gQrZvgrCrwrhvIAKwoMK44GTCtawCuadsQrmmI4K4b22CuaXtgrguJcKyagK44OHCu+4jwrKigrjgqgK5Y2XCuilvwrgpLIK44OhCuODlwrlubMK5byPCuG/lgrSmwrgpLUK2LoKw5IK5a62CsqSCuOCtQriiaEK44OACuC4lQriiIMK4oK5CuCkqgrnrKwK4LSwCti2CuKWhArln44K44OfCsmQCsKmCue+jgrku7YK4YOcCsOQCta3CuODiwrpg6gKxYYKx5AK15gK4KSvCuOBggrCvgrhuqMK44GhCuODpQrDtwrlpbMK56WeCuKZpgrCogrku6UK4LmJCuCmsArlpKoK4KeNCuODgQrVtQrliY0K6YeRCtaCCumHjgrljJcK4LirCuKAsArjgaMK5YqgCuWOnwrKsgrnva4K5a6JCuOCrArmiJEK4bikCuC0rwrkuqwK4paACuGDmwrhg5UKyr4K4oioCta0CuWPrwrlj5YK5Y6/CuS6jArilpIK55CGCuiHqgrkv6EK5LujCuC4tQrXpgrhgLoK4KSmCuKBuArMrwrjgYoK6KaBCuG/pgrgrpUK4buFCuClgQrGkgrKsArljJYK4pyTCuC0qgrsnZgK64ukCuacqArZjwrMgArLjArgpLkK44ORCuawtArhur8K4LiUCuOCugrigbkK5bO2CuKAjQrjgoIK5q2jCuKWoArYogrguJ4K5YaFCsOMCseUCuKUrArkvZwK5ZCICuG9uArjgb8K4pa8CuG/tgriipkK772eCuG7iwrZkgrlm54K5LqGCuaJgArkuosK6KGoCuC4swrliIYK4oG3CtKvCsKACuWFpQrlhagK2KUK6YeMCs6nCuCkggrjg48K4LiECuKBuwrjg6IK6YOOCuaNrgril48K5beeCuKIqQrogIUK6YCaCumDvQrihKQK4pmtCuKVjArjgaQK4biNCuaxnwrXlgrDnQrTqQrguYwK5YiwCuCuvwrKggrlr7kK7IqkCuS9vwrgpr8K44KICuG8iArDjwriiJgK7IKsCuCmqArkuJYKyZUK1a8K4YOjCuC0nwrhg5EK4KWLCuC0tQrmnpwK5Y2BCuC4uArol6QK5p2lCumdogrjgZEKxJUK44OTCui/mQrsp4AK4LSCCuihlwrnn7MK6IO9CuepugrVvwrYpgrmraYKyrkKz5UK5ZCOCuC4sArlhYMKypQK66asCuq4sArmsrMK55S6CuiKsQrhvZAK57G7CuKWkQrniakKzpcKwrgK4K+BCuGDlwrYqwrgtYYK4pWgCuKKhgrjgIsK44OECueJiArliqgK5aaCCuecnwrJsgrlj7cK2LAK7KCVCuaelwrmm7gK5rCRCuWPowrZkQrnpLoK4LSuCuyVhArlm74K4oiqCuaIpgrmnY4K4LSyCuOAigrlhYkK55m9CuW/gwrgrqQK4KScCuiuvgrhvbcK6LevCuCklwriiKUK7ZWcCuacgArQiwrmiYsK1b0K77yfCuWeiwrhuqcK44K7CuW7ugrjgqcK5Li7CuyLnArrjIAK4b+GCuKAoQrpm4YK4YOTCuebrgrOoQrjgqEK5bqmCumVtwrmmJ8K44OOCuG7mQrqsIAK5LqUCtqGCuuhnArjg6cK6YeNCuS6jgrlj5EK5Y+yCti4CuC4igrjgYgK5ZyLCsStCuCuqgrsnbgK5L2gCumnhQrigJIK4pmlCuWkmgrEpwrSmgrhu5MK5aOrCuWbmwrilLQK4K6uCuWPuArgp4cK4b2wCuKIggrilawK5qyhCsS9CuKftgrnq4sK54K5CumfswrioIAK5ZmoCu2VmArkupUK5a2YCta5CuW9kwrDiwrimIUK5a+6CuaApwrkuZ8K44KBCuOBoArkvY0K4LSZCtuBCuWAvArlj6QK4YOSCuCmrArpmaIK4LWHCuKWtgrgrrAK55WMCuiqngrgtLgK7IiYCseSCuaEmwrinJQK5pmCCuG7jQrgtLEK1bQK44KxCuS4nArlkIwK7KO8CuS/nQrDlQrhu5EK4bywCumdkgrjgrQK5L2TCua4hQrnm7gK4LiICtihCuaDhQrwnZWcCuCmlQrhuKsK4budCuWwhgrml48K64+ZCs6lCuKUjArjg5wK5a6uCuOAjwrgpq4K44COCsS8CuCktgrguJsK1LEK4KSsCuyekArmlL8K4K6+CumXtArvrIEK5p2+CuG5gwrlp4sK5oGvCuWwkQrmlZkK6I63CuWIlwrlvIAK4YOiCuODrwrhg5kK56eRCuaYpQrmsrsK5ZCJCuC9pgrguKgKyZIK5Y+wCuODjQrhgLgKxKkK5belCuG9sQrnn6UK5YWrCuWgtArnlLsK55m+CuKYhgroqJgK5b6XCuOCvQrmsI8K4YCsCuyXkArgprIK4bmbCuWFswrEoQrhvbMK4oiRCuODmQrmoIcK64uICuG9tArWtQrlpJYK4pmgCuOCjwrplpMK4LigCuagoQrliLYK4LmBCuWKmwrploAK5aW9CtKTCsOZCuKEkwrWtgrripQK4pSQCuKIlwrmjIcK6ImyCui/lArppqwK6K+3CuKJqwrpoqgK4b25CuaOpQrshJwK4oazCuOBmwrlv5cKzLIK6a2UCtKjCuabtArnqIsK6rmACumDoQrgvbwKxakK4LSaCuWIqQrnnIwK5ZGoCuOBnQrjgoQK6LC3CummmQrima8K44GYCtiMCuacnwriiIUK4pSYCuWInQrnpo8K54mHCuOCtgrli5UK5Y+CCuyEsQrGjwrilaYK7Ja0CuGDrgrnvqkK4KSaCuixoQrlip8K4pmCCuuPhArqs6AK6L+HCtW+CueahwrnibkK4bqtCumVvwroi7EK4bqlCuC0owrQqgrgprgK5YW2CuCmpArmtYEK6ZmkCuydvArgp4EK4Z+SCuawuArnm7QK7IOBCuWNgwrhuq8K6aSoCsWkCuacnQrgrp8KyaMK5Y2VCsqACuagvArlvrcK7KCECuKYugrjg5QK5q2MCui/mwrpmZAK5aSrCu2KuAriiqIK5ZySCumHjwrlnJ8K5pS+CueggQrnrYkK57O7CuKIvAroj68K4oa1CuyGjArluLgK5ZCmCuimiwrmupAK14EK5a6eCuWNmgrrnbwK7JuQCuuztAriipUK6KejCuOAnArnlLcK4KamCuODnQrjgo0K64KYCuC9ggrnhKEKw5sKzKUK0rEK5p+lCsyjCuKVlwrilakK5p2hCuCmrwrhvYEK5b6MCuS7lgrnvZEK4K6yCuKJgwrtmZQK25UK6Zi/CuGAsQrmiLcK4oirCuq1rArgvaIK4YCZCuKWuArVrAril4sK5ZG9CuWwsQrpvo0K5ZCbCuWkjwrCgQroqIAK5YWICuKenArhg6gK4YOrCuCovgrgrrUK44GpCuODkgrguYQK4K6pCuOBsArjgq4K1aMK4byECuODpArlhbgK5bqcCsyECuyLoArnu4QK5pS5CuG9sgrljY4K5LiOCuiwgwrilZ0K44O0CuGDpQrnlLEK5L+uCuWtuArimaMK5raICuespgrKjArrtoAK4bubCuKAvgrilrIK5b2VCuC0swrsl7AK7J2ECuOBsgrsmIEK4pSkCuW3sgrpmb0K4YCECuq1rQrlrrkK5pyqCuWulwrhtIcK44GzCuyepQrpvpkK4LeKCuaPkArEnQrlha0K5b2iCuygnArVgArkvIoKz7UK4LiCCsWwCuOCgwrngasK4bmiCuS9kAriiqUKzKoK4bupCuKWoQrnu5MK5LmdCumbhArVqQrhnrYK6ICMCuC9lgrsmrAK5bygCuCknwrgpLcK5ZCRCuG/pQrpgIkK6rO1CuOCsgrKkArku4EK5aCCCteaCuGArwrhvJQK4LSFCuG7gQrgvZEK7ISgCuyYpArkuYUKwpwK5LmJCuCkhQrilZQK5pegCuKAqArsnYAKyrcK6YKjCue3mgrliqEK5Z+6CuWxngrphY0K66+4Cui7jQrguYIK5rSlCuWujArnoJQK5rOoCuWksQrlupQK4YCACuKVmgrlj4sK56ugCs6oCuaxggrgpKMK6rK9CuKArArgpK0K5LusCuaooQrpnIAK4K6aCumbuwrgpqoK1aQK44G4CuatpArlpJwK5oiWCuapiwrmoLkKxKoK546JCuC4uQrhuYUK5LqkCuWTgQroia8K4L2ECuOCqQrliJkK6ZaLCs6WCuusuArooqsK7KGwCuagqgrorrAK5pyDCue7jwrgpYIK44KHCui9rArltI4K66eICuKMmArmr5QK6YCgCtyQCuC4twrmsqEK546wCuS4gwrOhgrllYYK4K+ICuacugrpmLMKxIkK6KeSCuermQrVogrtlbQK5Y+KCuCkpwrooZMK6K6kCsKRCuWImwrnt6gK1bIK4bipCuS8nQrlsqEK4KShCuODmwrmuK8K5Lu7CueZuwrgvbIK4LmHCuW4gwrnqbYK5bidCuyXrArsgrAK4YCUCuKXpgrlr4YK5Y+YCuW6jwrimYAK4oijCuiuoQrmm7IKxIIK4b27CsqLCuS8oArjgJEK5YyFCuaEjwrljrsK5rKZCuK4rgrjgJAK5YaZCui2hQrgrq8K5LuKCuKUiArmo64K4LeSCuKKlwrruYQK1bAK4bioCserCum7hAriiJkK65OcCvCfjI0K5pmvCua5lgrWhArhgK0K4oG/CsyCCuODmgrkvZUK5a6HCuW8tQror60K6ICBCuS+iwrhuawK6YmECuWFiwrimIkKwpkKybkK4byxCuK0sArnhLYK66W8CsenCuWgsQrmnI0KxI4K5oOzCuKAlgrjg6YK5a6fCui9vQrsmpQK4oSaCuazogrpqawK54q2Cue6vwrsnKAK5rSLCuS4hwrsp4QK4KacCua3uwrnkIMK5qmfCuaUrwrmmL4K5ouJCuG9kQrpgIEK6ZqKCuC4mArlpIQK5birCuKKggrlg48K4Ka8Cum7kgrWgQrCnQrhu6cK5Y+qCui1twrmrrUK4YCQCuWNgArpgbgK7LKcCualrQrnrpcK5bm/CuGemgrop4YK56eLCuWboArrhYQK25IK6L6TCsyxCtWECuKIhgrlurcK7IS4CuaAnQrmrbsK6IGWCuuvvArvvI0K5aS0CuC1vAriiIkK6LuKCuKUgwrilocK5oyJCuKNtQrlpKIK5rGJCuS7jgrgp4AK6aKYCsuGCuG8oQrlsZUK55yBCuC9tArokYkK7Zi4CuCosArntKAK6ZaiCuq3uArvvJsK4LaxCumhtQrlhbEK5a6/CuaAgQrgvZMK5oqACuS5kArmjqcK56e7CuW9sQrhu6UK44KGCuOBlArgs40K566hCuC1vgrilaMK5oi4CuKHlArlh70K4bqTCuWwvgrlnLoK5LuLCu+/vArogrIK4La7CuaziQrgtb0K6K+0CuaNogrlv4UK57SACuC9mArgvboK4bujCuC1uwrlrp0K5rCXCumXqArku6QK5bemCua8ogroi6UK5bGLCuWxgArmiZMK55m6CumXrgrmgYsK5YW1CuWIpQrgqr4K1Y0K36wK4KaXCuW5tgrgpJYK4b21CuiKggrKkQrXpQrhuKoK4oSCCuW8lQrnu58K5pm6CsypCuCliArnlLUK7ZiECuKchQrotaQK5patCuOBrQrnp7AK4Ka2Cui6qwrpppYK5LuYCuKFkwrgqLgK6YCjCuGDlgrlrpgK5oyBCuWliArlvqEK6KaqCuq1sArlupMK56eACuWdgArlrogK5rS7CuC9owrjgbUK6JePCuGenwrnq7kK6I2JCue1kArgt48K5piMCuaouQrgrrMK66y0CuCmuQrjgrwKzIgK1bcK5YudCui2swrhgJsK7JyECsSvCuG8uAroiKoK6ZmzCuS4mgrlr4wK6ZuqCuCkhgrlho0K7JWICum7mArrsJUK7JqpCuKcvwrmpb0K5rKiCue+hQrElgrKjgrlv6AK6ZSZCuuLqArrqbQKxLcK5qGlCumbsgror6UK4bmvCuWyqQrrgqgK4bu5CuS4kwrliIcK5bqXCuacsQrXowrjgZoK5bm4CuavjQrJqwrjgIUK4oi3CuS4sgrlh7sK4byYCuiorQriiqQK4oKXCue2kwrqsJUK4YCVCuClpArRkArhvrYK4p6WCuW6pwrslKgK44G2CsWiCuS6kQrlkYoK5aSJCuivlQrpmoYK6rCcCtW6CuWIpArliokKy5wKy6AK57yWCuC4kwrhu68K6L6+CsSaCtydCuGAvArhuLcK5Y+zCuuTpArFnQrTjwrgsY0K4LSOCuCusQrlpI0K55yLCuipsQrlnYIK5bCUCuihmwrVpgrssKgK5Li4CuagtwrprLwK4KS8Cu2VmQrllpwK5pavCumKgArrp4wKzp4K4YOqCue+pArov5EK5aGUCs+KCuCuqArjgoAK56GuCue0ogriiIcK6Z2eCuacmwrina8K5biMCuG7swrnlLIK6LaKCumzpQrpursK6ZuFCuaLswrhnoAK5rqqCua1iwror50K5rGgCuiPnArpo58K7YSwCuCovwrmuKEK6YCfCtq+CuCysArpmYgK5YGlCuCniwrgtpoK4b26CuWGmwrluoQK57qiCsSmCuirlgrFuArOiArhu7EK5a2dCumgrQrpo5sKy5oK4paTCtmLCuKArQrkuYgK6YGUCtGrCuW3tArmtJ4K6LK0CumhuQrgtKYKybUKzI0K0qEK56eNCui/kArsi50K4L6xCuG4swrlvaYK4qWkCuS5pgrmnoQK57GzCui/ngrmk40K6KOFCuqzvArjgZAK5Y+NCsyMCuS7rgrlkZgK5pitCuC0tgrlhbQK5a6iCuWIoArgtrgK4LeACuGDngrEiwrgtLcK4YCeCuG1iQrlsYUK7YOACvCdk50K4KSlCuePvgrLhwrsooUK5YqpCuWUkArngKwK4Z6TCuW+rgrvvJEKxKAK44G7CuiIngrrgrQK7KSRCsSSCuWvvArmlYgK67CpCuG4jwrmt7EK5qKFCuaWmQrsm5QK5q+PCua0sgrtmowK6Iy2Cui0pQrgtJ4K4buDCuODqArkupsK5Y+MCuWYiQrrqqgK67CUCuC4qQrpgLIK7J2MCuC4jQrkuIEK5pWFCuioiArpgaAK6rWQCuyerArlgJkK5oi/CuuqhQrkuKQK4YOkCuaJjQrtlakK5q2iCueVqgrJrwrlpYcK5oCqCuiBlArsl60K5rOwCuuwsQrhvYAK44GSCuOBuQrovrkK6L+YCum7gwrsmZUK5pS2CuW8mArnu5k=",llama_merges_binary="r3SxdLB0tnSzdLR0r3SydLB0tHS1dLR0BAG6dK90ggGwdLd0r3S3dK90uXSydLF0tXS2dLJ0tHSvdLt0s3S3dLZ0sHSzdLF0BAFiAQoBsHSvdBAGsnS2dLh0sHSvdMV0r3S+dLV0vHSydLh0r3TAdK90vXSwdLl0r3S1dK90wnS1dL10WQK0dLN0CQEGAb90s3RhA7N0u3SydLd0sHS4dAgBsXSwdFEC2gG0dK90BgGvdLp0tHS5dLB0sXSvdLh0r3S0dLd0sXQEAbV0r3QFArt0unSvdM50tnS1dLN0uHQgAcB0r3TOA7l0sHS7dLF0r3TKdLJ0vXSvdNN0DgGwdK90NwGvdM90r3S8dK901XSvdNF0r3SwdAcBKwGBAbl0r3SIAa9013S1dLh0r3TGdLN0vXS1dLF0snS5dLx0sXSvdL90sHS9dLx0tnSzdLl0r3TqdLN0v3S2dLJ0bAGwdK90FAHaAbd0r3QTAfN0vHS1dMV0r3TkdAsBsXSwdC8Br3TDdLd0sHTGdLB0u3SwdLN0sHS8dLR0r3TldK907XSydL90vHS4dK904nS6dLB0CAG5dLB0KwGNAbB0tXQ3AXMBtnSxdAUB7ANRAvcFsXS9dCgBtXS3dK906HSzdMB0DwEjAasICQFTUbR0snTVMR0BEAGlBrZ0r3SuBa90tnSvdOt0VwEbAeBgvHSvdJUYIQGwdK90kwO4dMN0WQG2dMZ0BQGydMJ0sXSwdNoBsXSvdBUBIAG0dK90CQG2dLN0vHS3dK901HQZAbp0r3Q0BRIBCQEWBbR0r3QXAq90/nQNAbF0r3QvAbN0tnSvdON0r3T3dLt0x3QHAbR0r3QRAbF0unSwdL90snTDdBUBunSzdIIBr3TudBMBsXSzdC8BEQG5dLJ0KwEEAZcJCgEPAa90cxYHAbh0r3QcAa908nSvdPF0tXS5dLx0vXSvdAR1unSxdFcENwFUS7B0u3RkAa90AnUPAbB0snRzAQsBt3SwdH0Dr3T0dAUBsHSwdBQBvnS+dAcBt3SvdCYBDQGwdK90WAEaATMBIAK1dK90AwMZAYUBFTC6dK907Qm+dLB0r3THdAUBt3SwdPAIvnSxdMl08HS4dLV0EgEiARYFvXSvdP4BOgGwdLJ07AOvdAB1OwEiAXUMvXSvdPMFs3SydBEBsXSydFECLQGydK90sQGvdNh0QQG0dK90CAE4ASMBu3TVMUEB3HSvdN8CuHS5dLx0wnSvdOZ0uHSydLx0sHSvdA91JQG6dLN0MQEOAbV0r3RLB690/XQPD7x0r3RTAbN0xnQQAbF0tXThCBcBsXSydOEIPgG0dK90XAGMAfF0r3TlCAQBYFkKARMBr3RWBcd0sHQqAbJ0r3QuCa90y3QbAbF0tXRJAUMBYgHyAbB0r3QoBi4BRwG2ArF0r3Q1BS4BsHSvdOQBNQG4dLN0hQItAbB0r3QYAbt0s3QzAb10tnQiAQYBsHSzdOQB2nTadLV0vnSDAQYBsHTvFKYBZgFUBygBr3QhTpMD7xScbQYBwnTMAe907HQmAbd0snR9A7N04HTJdMF0tXS/dK90DHUgAbZ0r3QQARkBJgE8LLd0r3ReKwcBsXSvdA8BGwG2dLV0TAGvdLN0Age0dLJ0BgGvdBB14XTWdK90C3W/dLB0DQG8dK90YgiydL50XwGwdLJ03wEbAa4BwxO5dLV0UkG0dLB0snTGdNx0sXQQAbB0tXQUATUBsHSzdBgBy3TLdK909nQhAcN0r3RJBrh0s3QPAbp0snSCAed01nSTA7Z0wnQFATICunSydDEBHAG4dLJ0hQJDAbp0r3RFBWABsXS8dGgHr3TZdK90DXU+Abd0r3R3Aa904HR3AbF0vHQvASoBRwW/AVkBI1GwdK90fETsAbt0uHQlAeF03XQSAREBkRa0dK90/AuxdLZ0VwS9dLt0IgHJdMR0MgG0dK90HQMGAbl0s3QrAScBuHSwdIUCHQHIAZAFIgFPOb10r3ReDNB09nSxdLV0r3QJdXIBGAG+MLB0snQ5AmcBsXS1dC8BEgG6dK90MQGvArF0sHQ4AU8BkAF1BLF0BgGxdLN0UQKvdNt0BwEUATQCsHSvdFYC2gG9dK90RgENAbp0r3RNA690DnU/AbR0r3S4Cq9073QPAbJ0snStA30BsHSzdBQBBAG2dK90/QFXBLR0u3QJARABuXS1dHsVFQHDdLN0+QMXAbl0snR7FSoBsHSvdGIBIQFJASkFsXSvdFsQtXS7dOJ01HQaAbZ0r3QuAkwBsHS8dBQBnAG2dL50BQEyAsd0snSAARABx3QJAb90tXRhAxEBt3SydL8H/3TQdDwCsHS+dBgBDgELATwBt3SvdN8KtXTHdBABvXS1dN4GwQK2dMV0BQGydMd0vnS2dCYBsHSydFgBQQG4dK90JwG+dLp0snS7dD4BKwG7Abl0r3RmAwcBtnSvdBcB2gHAdK90aQG8dLl0vnS3dBUBsHSzdHMBnAiwdMJ0GAHhdNB0vQa2dMB0BQG+dLh0uAGwdLN0WQERAb90snRhAwgBt3SwdL8H53TQdA0BtXSvdEICt3S1dCYBsXSydC8BynTJdNYKBQG3dCwCtnS8dFsBt3SzdAsBr3TNdLJ0vHS1dMZ053TfdBF10HQOAQUBPAG2dK90oAIeAcN0r3RNBRkBsHSvdMECHgGwdK907AO0dLF0BwG5dK90SAFMAbR0vHSTa1cB2QFuAbZ04GBMAa90gh/jINp0zXTKARcBsHSydBQBBwGFAooBuHSvdPEBwHTAdLN0tXQLAdUxVgEjAQEtCQFGAbB0s3TsA0EBtnSvdAUBsQF9AwUNt3S4dNEBr3TddHkBtAGvdGwSIgGwdLV07AMJAbF0tXRRAhoBFwHkDLZ0r3ReAx4BsnSvdI8Cr3QbddR0xHSvdNB0wHSxdKcBuHSzdBwBu3S7dBsBKwEdBbl0tXRmAy0Bs3SvdOwBUQG3dGwBCwGvdLICLAG6dLB0ggEsBTgB5nQKAgcBlwEXDL50r3SkAz0BsXSvdFcDJQGwdLN0WgEHAb10r3Q6ATICsXSydDgBDgEnATwBuHSvdAAYv3S2dA8BHwGTAbl0snTmJFsBtnSzdAUBBwHCdK90cgFBAbF0r3QsARwBcAHxAcN0wXTBdGkE4QizB7F0vnS5AbN0x3QaAQUB1AS2dK90IgISAWECegGxdBYFUQKvdAUF53TddP901nRYAbZ0t3QFAfh03XS4dLh0WwHFdLN0KQNPAbR0s3QSFN502HSiDrF0vnRJAQkBsHS1dOQBXAGsATUS1TGBRiMBDgGzdK90oxcXAcN0snTPAhUBIwHMEgkBs3TVMb10snTfdOF03wGxdL90LAEtAbV0r3ShAUUBHAGDC7h0r3QXA690IHVQAbR0tnQRAa90BXUIAVoBiQ+wdBkBJALdGMd0r3QHBTgb1nSvdN0Bs3S+dBUBSwE4Ar10s3RMBcYFsHTDdJwBr3QjdSoBEwFTHLd0r3RgWT4BWAH2AbB0r3TlBTcBtnS5dAUBEgJFAnVVLAKvdBZYGQHFAYRuuHSvdNs20gGwdLN0jwPsdNZ0oQHFdLh0VAE7Abp0r3SrBUoBLAHJBrF0r3SRAk0BsHSzdDcBGwG3dLV0dwEGAcd0nwEjAb501TH4dNZ0ySOTa7F0UwJcAb90vHRhA7B0u3S8dL90nQTeBq4FvXTAdCsCFAG3dLZ0CwGQAbF0unS6AhsBv3S1dLAC+HQadS4BtXSvdMEEu3S4dGwBtXSvdDMBIAHkAXUBsHSvdIoCsXSxdHMcs3S7dHYBuXS8dD4BvnSvdBID7HTQdMp01HQgAcJ0r3THAsV0sHQQAcN0tXTPAkEBLwE/A7F0r3RWAQUBw3SwdM8CWwG4dLN0JwEvAbZ0t3T9AbV0wnS3AbB0Dw+yAa90IgOnAbR0s3QRASABSQFLCLF0r3TBARoBuHSvdDwCLgEpA8QBxXSvdMoF/3TddK90FnW2dMN0RwG6dLV0ggGCAQUBEAa2dLF05AhFARcBgwu2dK90qwYZAeMBryJSQQ0BBQGZAbZ0r3SDAmUBtHRzAZNrsXQ4A3MB5gGoErF0sXQmBAQBNhAKAZYBFgEUASRysHSvdKcxEwG6dLN0TQMzAbZ0tnQQAex033QNASwBmQGxdK90SgOvdCh11QHQdK909AQEAbB0r3RzAbB03HRRAa0CqAxTAq90mQkCB7h0snQ1AQcBtAWBAcN0r3RoBTIBsXSvdCgMHQGLAioIrAFFDtUxr3SsCNh00XTbdMR0/HS3dBwBsHSydBgB1nThdBkBYQx5AQgBElO0dK90QCCzdMJ0SgG1dK90zAURAVoB1BGwdCoBSAG/Abl0r3RAU5QCvHSvdIYIEgHwVKMBvnQWBfYFr3RUCfh033SvdBR1jwKCAWoLunS9dO0BKgEmAb8Bt3SvdOUUr3QHdRoBFAEgArB0r3SxBQgBBQFABrZ0sHRBBBoBugFiArF05AzhCK90OwYnAcB0DgFbAYwCsHSvdFk/LQGBJGsCvgFcELB0r3TREVABw3S2dIQBfQEvAYcysXQOARMBjAK3dK90qggeAREBYwK0dK90kwR2AbF0tnQVAQQBYQwKAQgBFgG0dK900hcSAV0CKwTRAX8OfQPHVrd0r3TGBy4CtXS+dDMBGgG1dK90aQQ+AaAL9gEkAa90ihKwdMJ0EgFkARYFNwGCO7B0r3SRAVQBtHS1dNEEDQFgAkEC7AMXBLB0r3T8FFoBt3S7dAsBiwHRdK90txHfdOd0GAE4Abh0CgIHAbx0r3RJAhMBMQGtKbp0s3QwAxIBRAEWBbh0r3QeBK90KnW8dL50CQG3dLV0vwcHAQkFUgK5dK90sgQ1Abl0s3SuARMBt3SzdH0DHAa4dMZ0HAEbAVECHQWxdLV0eQYYAbd0uHQLAVkBUQJWA7F0xnQoAa90L3XOdLR0MwHFdLZ0VAHwK7Z0sHQXAQ8BOARqAbd0qwgTA1NRvweydLp0UwGwdPN0sgGvAfoBvHR5EhEBx3QNAb50r3QEBI8BunSvdGki6QHpAQIWy3TLdAIWt3THdLB0xXRfAbd0snRmDOx03XQRAbR0snSLPa90M3UFAbF0sHThCDICsHSydFoBFQa6dLd0MQEuAUUxxAEfAa90RGavdDF1WwG0dLN0CAEbAZswtAK6dLV08RfhdN90DgFtBTwBwHSvdNkGs3TmdAUBtHSwdJNrGQGXCXkBDwGvdLgWPwG2dK90mQXFdLV0vXS4dA512nSGAbB0r3RjBEEBt3SvdAsBKQEvAX8GsXSvdDMKwnS1dLJ04HSMAeUIvAHxdK90F3UFAb10sHTeBj8BuHSvdMMJGAG5dLh0HwEFddZ0cwG0dLF0CAFYAbF0t3QsAfh00HQSAcMLowG9dBYF3RCvdAcIt3S6dPZ01nSvdNp0DgEUAnoErQOKBbJ0r3T4BE8D2nSvdMoBCnXKdA0B/QF8AbZ0r3TGAmcBsHS1dFgB9QG0dK903QlZAbR0xnQIAc90sXR8AsF0wXR8Aq90OHW4A7F0w3QvAa90OXUlAcd0s3SAAbN03HTKDLZ0vnQXAa90CHUZAagBPCxRArR0v3RHAbB0tXRzAUoBtnSvdHUCDgG8dK90vAKvdMF0XAG5dLx0KwF1AXABr3QyGA0BsnSvdHETJwHDdLB0cAFZAfAIcQG3dMZ0ngFBAVECqwGxdK90KAHJdMl0ynTbdB4BjQGqCrl0r3QJBuUBsnSydBwGBQK0dLF0CQEQAuMB8kNSQa90gCRLASgB1AdRAm4wsXSwdGYBHQErAmsBvXSlBt4Gr3SxAooBQgJUBrV0r3RVOw0Bu3SvdBUGBgFmDCQBt3RkAhsBr3SkDRx1tHSdAbR0r3R3D0QC8HTKdKABr3QldRkBlgFPAhQBhQuwdLd0t3TvAloCr3RsQBMBsHSzdFgBCgEIBBYBw3SvdGpMaAGwdK901AoJAbl0tXQrAQ0BRAFBArh0r3RxCx0BRAGlBrh0r3S+ER4B5wGqChQB3AuwdK90ihUqAQUBHAK2dK905AivdN50r3T8dA8BMQFnAgUBly62dMB0ZQESARQBhQiwdK90DQShAYAB7QfHdLh0ogb9ASQBKg5hA7F0ERVDAWBZ8gETAa90rQ/gdLB0SAG1dLJ0SwdgAbh0vHSFAt8BtnS/dAUBwnSwdCAB0QJEE+QIr3TMBEMBKgMaKbd0GylmDK90uW1JASMBOSwJAbx01TElAbF0s3Q4ASoBVAHhE8V0r3TFDa903HQ9AbB0r3TYBxIBYgEJArB0r3SVBLsCnwFzHB5TsAH4AScOLwGvdBcUGgFnAQQDt3SvdCoEEQHfAT4CsHRpASUBsBq7dLN0pyUUAbB0tnRBD9l02XQEAVsC1xSwdFJM7AOvdLYI4QG+dLJ0lwHhdB51HQHoAdEDsHRRFhgBr3SlBRcBx3QlARwB1wO4dLN0HAQdAf0CpjUvAa90BhApAbF02gFRAq90DAKvdDx1ewGwdK90HA+xdLJ0jgEoAeEHUQJaN7F0vHRmARABt3S1dPAIGAFmAWkJKAG4dHIDUAG7dLZ0MgIHAb90r3RfAbUBCwGvdKUzw3S0dBQBSAEGFrl0tnTHBR0NuHS8dBwBbQGwdK90mgzDdLd0QQG9dK90SwEuAY4BVBO9dK90nQdZAbh0xnQnAQV13XRKAgUB4gO2dLV0cQEOAWkBjALAdCwByF1tAo0BMgHAdK90PA4NAZwBJQOwdK90TRfDdL10BAFIHwoBSwEWAb10KQEFAqoDtXSvdO0iLQELAcYBt3SvdBkDdAG3dNoBXAWvdJEECwGwdLB0WAFbAa4BxQK5dLN0vwkaASMD4Qn6AV0KeRI5Obt0r3QNDq90PXUOAQgBPAG0dK90eQRaA0sBuANMBbV0wHQgAXEBJTwFAa90vQPLdAZ1HQE1AVEWuHSvdPEGIATsA4whsHS0dKQBBgEcAUsEuHSzdElR2gG4dK90NQE6ASgCiAQYARkBhAE8LMN0r3QuBiUBsnSzdFkE9nTQdFoBfQMKA7d0u3SUARUBsXSzdLoCkga6dLx0MQEZATYQeQGWARJTFAGvdPYLB3XddBABv3S1dP8qswI3AmQEt3RFAbV0r3RVBVsBUQIzA7F0s3QoAUoCsHS1dFkBkwKyAe5CsHSvdOcGCAG/dLB0YQNtAbJ0r3QdFiF12HQUAcB0tnRtBVsBuXSzdB8B43TudA0BpR98AQ8BMyWxdK904BdJHL90wHRPAb10sHRFAQkB4AO0dK90kFwpAWUBqgMFAfUItnSvdGcGMwFNAbZ0Rg0PAQUBkwG2dLJ0ZQEWAX0BIQEsAW8BsXSvdN4aQQEGAa90XFLZdNF01HQGdQ0BrwHgAcJ0r3TTBSABvnSvdMsBDgEJAbUBtHSvdNgjsXTDdAQBzwIWAsN0r3SaCF0BMwE0BrV0r3SgBAQBUAEWArJ0r3TKCw0BpAFoA+wDug2wdK906kSwdL50BAE7A7QMtXSvdMgnLgGkAR8E7APVGrB0r3TSA0QBuXS1dK4BGAGxdLh0LAENAUYBSgW9dK90EQ63dL50BwHGdK905QGeBLB0wnQUATkCvXScCEsBwnRpCbB0w3QSAeMBFgVSQf0NrgGvdDhoEgEQARYFtnSvdDgKBwFpAvoEu3SvdHkWhAG3dLJ0uANzHLB0u3QUAUwBtnS8dOZTt3SzdHoBLwFwBLF0r3QDDLIBt3S8dAsB2XTydAt1hgIHATgB+gSxdK90cwIhAbV0r3RBA6IE0HSvdCcCDQEiAUECvXSvdLRYeQLBAa90rTGxASsBRBm5dLh0iAHsA7Z0vXQFAS0BhwFrAi8Br3ThBlkEuHS7dBwBDwJ9AmsJuQGvdF8UVwS4dLt0RAEuAbJ0r3QgBLR0snTNdM10GQHjBHkBtXSvdGI+QQEoYFwC2QLtERABr3SQCq90JnUPARABwwS2dLJ0sRzfArF0sHTmASEBnmpvAQgB/HS2dGwBXAGkFrR0r3Q9DWkEt3S+dGcBEgG4dK90twLqdOp0r3Q+dWABFwHBCbZ0vHRDEkkCWAHNBbB0snTlBVEBv3RsAYMBr3S/Bp0Bew55A1QBr3Thbg0BQQ+ZAbB0r3Q1ECoBRgFTHL10r3RyadgEYQO0dCQB8gLWdK90bgcPAQsBkwG3dLJ0dwidBBQBrgWwdMB05wEjAbd0WQK/B7N0EwMqAScBHAK4dK90cA9JAbB0vHRzAVEBvXRsAUsBr3TRBr4E0HSvdEwCVQEXAZMMtnSvdKsb53QIdXsFWgHHZrB0xnRxAn0BCgIVAjgBs3RVBuQBtnS0dAUBPgFsFrsBoAIzAgUBr3TGE3YBwnS2dOsCunS2dB1133Q/Abd0r3RHC0EBKwGrAbl0r3RjAUsB7wE2BgUBr3TWdAcBugLYAbF0r3RrBAYBsnSzdCAEQgK0dLd0CQEdAYgLhAOlAq9091k9ATEB2gm6dK90mBGcATgBPwyxdL50CgJRAbh0bAEnAa90cgo9AbV0r3SXGC0B9gmSAioCr3QCG3IBJwHOELh0snTEGZoBBwQWCGkJgUu9dGJkSwGvdC9DRQERAYMLtHSvdHcOLwG9csYCJQK7dLV0aQS0dL50CQG7dLJ0SAGydLJ0bAXUdM10FwK5dFcEKwG7dIIDOgHCdLJ0kSDZdMR0UwFWASIDLwF4B7F083QLPwcBSQEOA7F0r3QUBWwC8wGvdGILHgGEAWMCw3SvdOUy7nSwdJABsCSzAr50unSpD8l0zXQ/ASsBEgK5dK90JwsUAbl0tnQfAXsBVAGPIMV0r3TQFL50tXRXGNB073QnAg8BsXSydLoCGwG+dLV0EgNaAbl0u3QfAQQBnAJZCbB05x6cAa90PQcEARsVCgERAa9002sSARMDegG3dBYFvwevdIAMvHTAdCx13XS3AVoChlIjAcZZCQGvdLYwUAExAlYJunS2dKMwTwG6dLN0mzCvdEF1KgG6Aq90swIGAbd0s3S/BzcBtHS5dAgBDgGydK90bAVFAQUBlQm2dK90cQG1dLp0YQEGda90pRB2AcZ0tnS4ATYCsHS8dDcBfwEQAXRvtnSvdA8LbAGydK90UAE9BTICrlG7dMB0sQMHddZ0BwGKA88JZQGvdIUb2XTYdB4BvwMDBshdr3RAFtR0yXQ6Ab50snT2BSYBunSydE0DUQG7dGwBrwKvdK0ODgGdIL4DOwJrCwUB/XT0dLJ03HQ6ASgBpAFRAs8TsXSydGYB2QFaAR8ftHTTdAkBFQG3dLN0XAV/NewD9HSkAY8CtHS9dBEBIQGvAm8Bu3SvdLlLMQGwdLt0YgF+AbR0r3RBCbJ05nRKAfcCyQZBBOMJBQFiSLZ0r3SCEs509HTaAbl0r3RNAV8BCwHiAbd0snSWCi0BHgKSArt0r3TtB8B0tXTCdLZ0DQFiARACsHSvdGAsyA+1dOV0MwE+ASAEuwGydK90+xCvdP90LAGydLB0rQOhAb90uHTUAUQB1AHXDb90tXSkBA0BTAHgAbZ0r3S6HRcBv3SydP8qwAHLdK906QHHdLF0ynTRdJwJtHS9dAYBLQHJAWsC5AGEGLB0r3TEBEUBGgXSArN0gwt2Aa90JxfvdBJ1JQG3dLN0WwnhdBJ1WQHPAnEBw3TGdMQCSAG5dLJ0CQUgAYsGwAJuAkYVCgKvdPYMznS5dF4BSQH9FLF0r3RmGBIBLwKJDLB0kRZYAa90DhMeARAFYwK+AVgIsHSvdCsWEgEcAZEWuHSvdBwEGgHRARsJt3TkDH0Dr3QkDe90GnWUASMB5AGxdLR0LAHBdNR0r3QRdSJ1tnQFdd90tHS1dA8BJAGrCGED01K/dLJ06wQPAbV0snQFAuwB5AF7B7B0uHTJAfZ03XR+Adx0r3TkBAcBfQOYAbd0r3TRAUUBngF7BLd0lQnwCK90agP4dBJ1QQG5dK90HwGOAbR0vHThW0cB5AjQAgUBUyi2dLV00QLQAdZ073SkAg8BPQKGB7B0qwhZAVcDERWXEyQBz3SNAy0BZwGSArd0r3QhFcV0tHSBAUUCrxcsAq906y4tASwBxgGxdK90AgQaAbB0r3ScAQgBXAUoAbd0HQGwdK90vQYGAVoBng6wdLR0s3RNAQUBqAK2dLN0oAJUAbd0tXQUFgQBVgHeAi8Br3SYBioBlgEcAhQBhgOwdK90NhAzAYUCuwW4dLZ01AsSAfEBuAS4dJEWhQKvdMQSRgI4AbZ0wRQaAUQBBAO4dK90lQ4CB7F0snQVASEBIwLCJoABr3RbBrp0tXTjdNx0FAF9A7ICt3S2dJQBz3TXdHYBHwHyCbl0tnToA2wFcwEiELB0uXSTAd907HQOAU0BjAK5dK90uUfyB2EDsXQkAX4BuHSvdFkZDgFLATwBvXSvdAYJyXTydAQC1nTQdE4DTAFbHg4EKAEXUFECsQFaAQwSsHS4dC8DBiOQAbZ0CwIUAbR0tnQIAQx10HRBAfABr3RsELt0w3ScCKIG+TaAAcJ0jANsBa0DIhCydLl0FAKvdCt1BwG7dK90MgJhAeJ0r3RQBSl1tnQaARABBAO2dK90swcmAcd0snQoAxcBMQEiFrp0OgELAaQBt3SydHMROwEJAXUMtHSvdJAEHXXWdCABWAI2AcB0r3SICh0BAQKcBbl0URYrAa90RgsXArF0VwRRArt0YQIuAVQBtgLFdK90ew7CNcd0xXQkAg8BOAdqARwBqwgJHFNRSVG5dLl0xwF4AzkKtHS7dGcMr3RCdUkCaAeydPMBclsvAet0hwFBAeYBrQGxdK90JgRMAbd0vHTwCC0CsHSydL4BYAGwdLx0GAEaAZ0JBAMMAnsuUQKvdE0M1XTXdEkCsXSydEkBFgImAvwDvwcIVrd0r3TWDBIBtXSvdFcEUQFIAWwBxwWvdLUDPgElIfYBHwGfArl0r3QoD1cY3XTvdM0CFwGzdLJ0dgHrdON0LAEFAVoKtnSwdGUBGwG0dLV0XAF2FgUBsHRxARYLwHS3dPkCBgEfAckBuXSzdGMlTQGCAbx03HTmdLd0DQHbA+ABMQG2Ibp0r3TlODIBt3SvdCgO/HSwdKJSuHTAdGABDgGHAYwCLwH+ArF0r3RZFiEBvHSvdHcJmwKjApAEsXQfH1EC03RhAuZ0sHTvdN10GgGbJ5oBxnQgAkoCr3T7PsJ0wnTOCnsVjxG5dMV0GgILASgByANRArIusXSwdLhIBQFMBJ4BCQERAfcHJAO3dMV0unTBBLF0tHRHAY8BsHSvdMYSx3SydDMBvnS2dMsBDwFMAZgftnQcAbd0snRBDCEBJwFvAbh0r3TEGS11tnTAdLZ0rQHVAygRKAKvdKUSKQG3ApgVuHQ6ATUBfxG4dLJ0LV0JINZ0r3TuAa90P3UNAY0DfAERFVMDJAFcJ2EDr3QPBwoBqgLDQcd013S6dAQBSwHeAr10r3RMBeUBsHSydFkBfwGVAlUSEQGzHLR0r3T7HS4B9wq6A+8Br3S5EQ0Bs3SvdA8ERgELAVsCt3SzdHMRcwG9dLF0SwG9dMN0GAG2dLh0BQGhAUgB4nTidCoBiAG/ASsBERe5dK90awzgdLJ0IQEaFpQELwSvdLdGDQExAXUDunSvdDADxnS1dIIBEwGxdGBZznTodFF1tXR8AboBshaxdDMl4QivdJILGQEXATwstnSvdI8RHAIxWTkEvnSvdB0hsXS3dBIBHiAJAhcBWSi2dK90EgwaAbp0r3QxAh4BBgGZDrR0r3SrBPIHuHSxdDUBdgFzAQADsHS2dDgC6QGOVicDJwMCFmBcjlbpAWBcAhbdZ8t0y3TdZycBt3SwdEEMHgEVAZkOsXSvdG8JHwGnAeQ9snSwdNk7/3QIdT0BunSvdJkKEQHDdLJ0tAUKdfB0r3RPdakfsHSzdCIDuXSydLB0wHQ3Adx0uXTfAhoBvg2aAbwCIALgTlMuvHSvdHoVr3RNdXUCOgEiD710v3QMCrYBtnSvdAALSgEUAWMDsHSvdCsfUwFiAytasHQYAb90uHSDARABtHS1dJNrKQG5dNoBKwGvdAECGgEIAgQDLwGeA7F0r3S6CQ4B/gM8Ab50r3ScCgp1xHTGdLN0PgGDAvYBBQGfArZ0r3QAB690BnXsAYAB+gHHdLh0XANFAcQCewTDdJUJzwKvdLEELAHmCm0CJAGwdH4HNAL8AmwPhAGvdEoJSgG8dK907wkOAUwBZAO2dAB1wXTsdBp17AEkJPoBagGLJ9Ux0AHddO90KwOwdMd0JQG1dLN0VwQOAQ8BegSxdK90IhDQdOd0kAE8Ay00uHS6dDcLIwGwdFkC5AGzdIoCDgEGPYsEKAESAYIMmwOAAa90fgwdAbZ0r3Q9BX4BtnSvdD4IBAEmBN4C5gHwTLF0r3TWAuF0E3UlAZABtAGxdLN0CgovASMCNRSAAeN09HRQAb90tnRfAUEBsQRXDcQCVg/DdK90R0bVdLZ0bwE3BM895wGvdEsrHAFYAToFsHQdAQYBURa0dK90VxMOAfx0CgHIAxYBWAEOASwBPAGxdK90wRILdRwBWgGrAgsGIwH0M9UxQgHvA690Gwv3BHQFsAGwdK90LAXxBrB0SRwYAcB06AEPAbd0snRcBZYC0HSvdAoHlAHiAVEk3wGyA9sBsnTFdNN0unTBAggBxXSeaq90UHWdBLZ0wHQQAccBHAHoBbh0u3RoAjwChAGWNsN0vnTDIC4CsHS+dBQBTQGydLN0bAVdARcBPQq2dK90gQi0dMN0UAE4AbEDsXS2dHMCDQEpOuABlwFnM750r3RnSyYBHwEvArl0snQlIRgBrAENAyMBuHQLJg4BJgJ6BL8HiRe3dAIHtnSydH0BMwG4dLZ0RAEEAUQECgG2dAZAsnS+bK0D6HQUAuwBMQH6Abp0uHS0AdUBQALtMdB0r3Q5Fy0BJQKSAmEDU1q/dK90MhWZAVwEahSCA690SB22A3ABvHR7AgYBCwHJAbd0s3SjER0BagKlBmYDKDErAa90pC7kA4IBw3S+dPAruXSwdEgBLQHUAZICv3SvdKQEvHSzdOQBxXS0dCkDr3RLdb90tXRJArd0snR3AY0Bw3S1dKYRDQEJAUECtHSvdEwEB3XfdAUBtXSwdDMBWQG5dMZ0HwFiCMJ0t3SvAWwBCwJwMpABr3TyBHsFKQNtZcV0xnSGAk0EJAHbdMl0hwTwdNR0oAFoA00BLnXfdB113XTsdAh1RwGxdLV0ugLvdN90FwG3dLJ08AjydMF0v3S/dCEBtnSvdJ4EMg64dLV0RAFYC7B0w3QYAXcBsHS8dFgBDQHFDRACVAHyQ8V0r3TGEBgBLwImUVgBxwGydLt0pwEOAUAEjAJVBpoLOAGkEQoCr3RLLksHu3S5dB4C1nTndL10t3RKAbgBpQ/GdK90GGRBAdpmrQG+dK90xBHzdLh0BXUIdfZ033ReAbB0r3QtDh8fvXTTdCIBFQEFATgCtnSzdGUB7nTjdL10vnTsA7R0vXQIAYYBtXSvdHQl5HTVdDsBRAF1DLh0r3RZBhMBZQGHAQUBuAm2dLN0qwkZAQICTwKFAmQVuHSvdPAWEQLadK90PQOEAcEBDwEhAjkFsHSYHxQBuAGeAT0C8AhjCLd0s3RqA+B0w3Q4G990r3Q1Ax4BLAFQArF0r3TfCVwBsHS8dOQBNQ66dMN0ggFCU5wBZWGwdNd0nAJBAbADMAJyA8gRZgEUUygBr3SlEy0BqgKEGMd0r3QUCfoQuXS9dI0B8gOsBa902zlaAZ8B9DOxdFMBFQKyGRQBCgFNKbwFNAPhUfEXr3TGUHkB6AGvdEAftgG0dK90hwuCAbB0sXRiAR91snQNAcEjCQN+BxcEgAUHF+YKr3SROFUFuHTGdEQBHgEIAqoKLwE3TbF0r3SqDLd0u3R3Abd0vHR9AxIBFwGRFrZ0r3S/EA0BvXSvdAQPCSDQdK90QAIRAbV0snTBBBgBZwISZbF0uHQMJsZ0snQWArIBr3TBC8p08nRLAbd0sHTsBR4B2wMvDzEBGHW3dJUBKQOQCcV0r3QVEZoBIgIgAiwNIwwFAQUBsnSwdFABFQEfATgCuXSzdOYkDgEeArUBu3SvdOoFJQELAXECt3SzdAoDRQWwdNd0YgGvdBV10AHQdO90vgLAdLh0DQE/DCUDrwLBA7t0r3SWGQgBoAJjAQUB/Ay2dLB0bBbOCsN0xXSEAQ0B+QKfFcB0r3QfBUEBVgNXDQgBr3RsLhN19nQTAt90r3TeBfsBEnVdAbZ0r3TID50BsHSvdL4BSwHCdLB0kSAEAQcCUhEYATYrOQKvdEMJQQFTAUotvHSvdJYG7AEoAX0MUQK4dOEDsXS5dF4DsXTKDOEIvnS6ASACDAJrDlECqDCxdK90bgg+AeQBuwGwdK90BAZpAcN0wAEGda900AMIAbB0sHTkAR4BCQGqCrR0r3SADg4BrwI8Abt0r3S7G3wBxQFmAhd1r3QlEUMBtnSvdAQJr3Q7dWkBsHSzdL0GEwG9dLN0BA/CdMN0UAHFdLZ0qgVZArZ0s3QQAR4BHwFQArl0r3R4CBABrgGjASgC8AIYAWozsHSvdGEWxXTFdAcB4Qg0ArF0r3S6ATMBtHS2dAkBr3RYdVUBw3SvdF0NBwFBDIoBt3SvdDoFFAE4Aa0OsXS2dAoCBwFxBA4DwHSvdHsTDgEIA7UB0QTjQLR0r3SEDA8B5AjtAQUBsnTRAh8fuHTTdEQB5RvmAQdpsXTXdCYE8wiAAcJ0IwLydMR0VwEfA0cfFwGvdNgYB3XQdL50s3SSAbZ0r3QKDRQBOgEGFr10UQG+dGwB/gOvdHUNwnTAdE8GxXTFdE8GGQFMASAB/yrWAb90r3TeAwYBZQEMAgUBJRq2dGgBWwE/ErB0r3TOPyEBnldvASQBLgthA9R0wXSxAcQZDSAnAbh0UwQSASgB0QhRAq904AbkBhwGFiWydOZ0bwPzCLZ0wnQXAREBcwGoAbB0EQGydLJ0IATedN50gwOWA690VnUdAbh0r3QrBhIBxwuLA5MBr3S6DCUBs3SzdMcBLwGwdLd0cwEFBgkBNQ6palwBsXS8dFECJgEJAWRFtHSydEwEOwKXAr0GhETPdON0LgEJAbYCtHSvdFgVEQGwdLJ05AEpAbd02gG/B690eARIAQUBlwe2dLJ0oAKIAtF03nTlAmMEt3TudAsBHgHbAWMCBgGaFbR0r3REDQx13XRDATYQwgEUAfIBlgFrY7B0r3T3IBoB2QEEA0wBFh22dO50/XQAdcR07AFNA5NbunS4dNgCwnRuAmkClAG7dNkDIAEGI9YBTwGvdIsxEwGkCg8DCAHaB7R0rSlhDLN03UFUAQUBMRK2dLV0LAIqASwBHAKxdK905CO8dLt0MAJYAXgSsHSvdDYLN3XBdGYC7HSvdJYoLQe8dLB0UwEPBDkCt3QdB3MBLwF3CLF0sXRWAS8BiAE1FCsBSzi5dPx0tHQsAbd0sHRcBQJ143RNASgBqAJRAh8OsXSzdBFlr3TfdNUBgQLtMd10r3TAG8F0xHQOASYBegS3dK902kMeAsd0tXSAAcR01HRFAUQB4AO4dK90EwYdAbV0r3SdBBoB1gliArJ05AxQAa904FivdFl1OwEXARsktnSvdPMfUAG4dLZ0HAE9Ab50r3TYFRwGtnTGdBcBGgHDIMsChAF+CMN0r3SwBRsBWAGpArB0tXTlBZEH1nSvdKQCJQF7AqgDcAF6AWgJgALbAVgEWAE9AY0DcAIRFbcOJAGvdM8EGHW0dCEB0AIVBIIBCSS6dK90WU++AbR0x3QIAdV07nQMA99033RLAjIBuHSvdC43UgG3dNoBfQOvdBYDIAG+CPcDCAGvdE4Mr3TJdI8BlwkmAw8Br3TyFcB0sHR+BJMBFAG/dLZ0gwGbAcEBr3TVNvcBvHSvdCcbewW3dMZ0EwErBlQBwHSlAioBqQ93BL50r3RkBHIBLwLzFFgBsnR0DBkBGALdGLl0ryJ7Fa90zgYJAp8DUgewdK90XwyYArd03Rj3B690STNKAbB0r3TfAa90J3VBAQgBr3SeahUBGAFBARoDMAaxdFcNKAGvdHAOOwN7FcI1uXTFdBgCEQFLB4gBtXTPdO10FAG9dLZ0SwEdAckDURa/CadzuXSvdG8KewVhAwUPv3TGdCQB2Ae2dM90BQEgAUwBSwi2dK902QG3AbN0Dw/JBa90shkgASIC9wMFAa90LA1SAbF02gEvAa90hwE3AcB0uXRtBR4BlwdjAjcBmyiwdK907mb7Ad90vnTcdB4BCAFQArR0r3T3BbZ0vXQCB7d0snQTAVoBUQImKLF0u3QoAewBLwGTW7F0uHSHAdd0tXRDAbV0r3TiBuZ0snRZAeEIcQGxdMZ0LgMeARcBYwK2dK902gsXA7IBIxGwdK90YXXUdPB0BwF3AQ4Dt3SvdM0FXgG2dK90kDBEAbB0tXQYAR4B8wEvD2gH2TqxdK90aRK0ApABNAOxdB4BDwFjArF0r3RqC0UBhgK8DSkDrBjFdK901QVJHLh0wHQ1ARMC0HSvdK8IEXXWdEUBRg3gA00Br3QdFUoBLAjsAo0Br3SFQRd10HTTdNd0HgFoBWMCtAX/AsN0r3TTMpMDtHTCdAgB6gHQdK902AOiBNZ0r3SCAg0BzQN8KkwFMzNLAa90VRQGAbV0s3TBBIEBzATSS9ECr3QfW1EBLwFsAVYBbAKxdK90xBN3AQUB5QW2dLx0gwI1ARkCTgr5A7J0s3QeAQsCZnOQAXcBHzv4ASIBGVq9dNYBoAIEEQUB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WQK5dLN0jQF+AS8BXw2xdK908zFnAR8BVAO5dLV0JSEbAXMBwQGwdLV0OgRtAQsBtwO3dK908F8NASgBmQFRAhwbsXSvdLhIQwQ6BD0ecwFJAQsBOgS3dLx0dwiHAcICRgjDdBEUzwKzdCJe1AI/BBQNcQKjaloBr3SFFdt08HRJHL8JwHTJAzIB9HSvdJkEPwIjARQBuHS2dCcB7AIkAa90IEXBAsJ0xXQGA5AE1gIrBSYELQHwA6kBZQFNDQUBMxa2dLx0x3TDIMEBuHT+BQkBsnS1dCAEGHWxdCcDcCNiBWIFcCMnA45W8G7wbo5WrQFzAhEBOQyIASIBzwa9dA0BWwFKBbB0znTOdMIBw3TyAQgEr3TtPGYBsHT3BXMBvXTgB+sC7AEdAckBnAWwdFEW5AENddd0PAEmB35vlRKvdBgTfgEGAUICZwLOA8B0tXRYAtgHsXTPdCwBBwHgdK90QgMsAZ4BHAW3dFoK8AiwdGkINQGgAhUDBQHyG7Z0s3RXZSgCt3Q8AgsBvnQZAywGoAOvdFw6IAG9dK90IgEFAdkCNwwQAbB0KGAoAXAB0QO9dFEW0VOvdL8lkgbHdLx0gAHbAbd0Age/B7J0eAQyAmcMLC+0dA9JeAOydAoF3wG3dL90CwEuddZ0CgF2A18Kt3TDQWYMz3S6dAoB7gaiCbF0UgIIHBQDHwGvdJddNwG+dLl0/gNqBEwCVxg8FPZO0HTvdAcgbQGzdK90cls1Abd0s3RBDLQDu3TDdMhEkQfQdK90vgJ2AQsB8gm3dLZ0RwISAbx0r3RzEzEBCAGVBLR0u3RhDFMX9HTOdIwEaAELAYEDt3SvdKIP8wGQA30BsXSzdOEIIQG3BToJHwGXC7l0wiYlIa90MxoeAbV0r3T6EA4BVgE8AS8BKQKxdK90rh4JU790vnRhAxQBCAGhA7R0tnSeamwB/WopBDQEr3RmUjoBjwLyErJ0GwG5dLV0NgJRATsCXwgFAa90M09ZAncBs3SpArMBYAHeFLh0r3Rtaw0BGguZAf8Er3R+ERwBuXSydK4BHwGwdLB0NwEZAb1yNgklAtV0tHQ+AQlPuwFgBa90eXIPBHMBt3Q4AoQBBQG6PbZ0snSuHXUBWgGvdJYpFwG2dLJ05lOpBS8BUAVQBahj4nTidKhjDQGPBK90gRMXAbR0snSTa+EBs3SydF8G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",llamaTokenizer=new LlamaTokenizer;"undefined"!=typeof window&&(window.llamaTokenizer=llamaTokenizer);var Settings={FRAME_SIZE:250,MAX_SPEECH_SECS:5,MAX_RECORD_MS:6e4,BASE_ASSET_PATH:"https://cdn.jsdelivr.net/npm/@usefulsensors/moonshine-js@latest/dist/",VERBOSE_LOGGING:!1},Log=function(){function e(){}return e.info=function(e){console.info("[Moonshine.js] "+e)},e.log=function(e){Settings.VERBOSE_LOGGING&&console.log("[Moonshine.js] "+e)},e.warn=function(e){console.warn("[Moonshine.js] "+e)},e.error=function(e){console.error("[Moonshine.js] "+e)},e}();function argMax(e){return[].map.call(e,(function(e,t){return[e,t]})).reduce((function(e,t){return t[0]>e[0]?t:e}))[1]}var MoonshineModel=function(){function e(e,t){void 0===t&&(t="quantized"),this.decoderStartTokenID=1,this.eosTokenID=2,this.lastLatency=void 0,this.modelURL=Settings.BASE_ASSET_PATH+e,this.precision=t,we.wasm.wasmPaths=Settings.BASE_ASSET_PATH,this.model={encoder:void 0,decoder:void 0},this.modelURL.includes("tiny")?this.shape={numLayers:6,numKVHeads:8,headDim:36}:this.modelURL.includes("base")&&(this.shape={numLayers:8,numKVHeads:8,headDim:52})}return e.getSessionOption=function(){return{executionProviders:["wasm","cpu"]}},e.prototype.benchmarkExecutionEnvironment=function(){return __awaiter(this,arguments,void 0,(function(e){var t,r,n,a;return void 0===e&&(e=10),__generator(this,(function(o){switch(o.label){case 0:t=[],r=new Float32Array(16e3),n=0,o.label=1;case 1:if(!(n<e))return[3,4];for(a=0;a<length;a++)r[a]=2*Math.random()-1;return[4,this.generate(r)];case 2:o.sent(),t.push(this.lastLatency),o.label=3;case 3:return n++,[3,1];case 4:return[2,t.reduce((function(e,t){return e+t}),0)/e]}}))}))},e.prototype.getLatency=function(){return this.lastLatency},e.prototype.loadModel=function(){return __awaiter(this,void 0,void 0,(function(){var t,r,n;return __generator(this,(function(a){switch(a.label){case 0:return t=e.getSessionOption(),Log.info("MoonshineModel.loadModel: Using executionProviders: "+t.executionProviders),r=this.model,[4,Of.create(this.modelURL+"/"+this.precision+"/encoder_model.onnx",t)];case 1:return r.encoder=a.sent(),n=this.model,[4,Of.create(this.modelURL+"/"+this.precision+"/decoder_model_merged.onnx",t)];case 2:return n.decoder=a.sent(),[2]}}))}))},e.prototype.isLoaded=function(){return this.model.encoder&&this.model.decoder},e.prototype.generate=function(e){return __awaiter(this,void 0,void 0,(function(){var t,r,n,a,o,i,s,l,d,u,c,p,g,A=this;return __generator(this,(function(h){switch(h.label){case 0:return this.isLoaded()?(t=performance.now(),r=Math.trunc(e.length/16e3*6),[4,this.model.encoder.run({input_values:new qe("float32",e,[1,e.length])})]):[3,6];case 1:n=h.sent(),a=Object.fromEntries(Array.from({length:this.shape.numLayers},(function(e,t){return["decoder","encoder"].flatMap((function(e){return["key","value"].map((function(r){return["past_key_values.".concat(t,".").concat(e,".").concat(r),new qe("float32",[],[0,A.shape.numKVHeads,1,A.shape.headDim])]}))}))})).flat()),o=[this.decoderStartTokenID],i=[o],s=function(e){var t;return __generator(this,(function(r){switch(r.label){case 0:return d={input_ids:new qe("int64",i,[1,i.length]),encoder_hidden_states:n.last_hidden_state,use_cache_branch:new qe("bool",[e>0])},Object.assign(d,a),[4,l.model.decoder.run(d)];case 1:return[4,(u=r.sent()).logits.getData()];case 2:return c=r.sent(),p=argMax(c),o.push(p),p==l.eosTokenID?[2,"break"]:(i=[[p]],t=Object.entries(u).filter((function(e){var t=e[0];return e[1],t.includes("present")})).map((function(e){return e[0],e[1]})),Object.keys(a).forEach((function(r,n){var o=t[n];e>0&&!r.includes("decoder")||(a[r]=o)})),[2])}}))},l=this,g=0,h.label=2;case 2:return g<r?[5,s(g)]:[3,5];case 3:if("break"===h.sent())return[3,5];h.label=4;case 4:return g++,[3,2];case 5:return this.lastLatency=performance.now()-t,[2,llamaTokenizer.decode(o.slice(0,-1))];case 6:Log.warn("MoonshineModel.generate(): Tried to call generate before the model was loaded."),h.label=7;case 7:return[2,void 0]}}))}))},e}(),defaultTranscriberCallbacks={onModelLoadStarted:function(){Log.log("Transcriber.onModelLoadStarted()")},onModelLoaded:function(){Log.log("Transcriber.onModelLoaded()")},onTranscribeStarted:function(){Log.log("Transcriber.onTranscribeStarted()")},onTranscribeStopped:function(){Log.log("Transcriber.onTranscribeStopped()")},onTranscriptionUpdated:function(e){Log.log("Transcriber.onTranscriptionUpdated("+e+")")},onTranscriptionCommitted:function(e){Log.log("Transcriber.onTranscriptionCommitted("+e+")")},onSpeechStart:function(){Log.log("Transcriber.onSpeechStart()")},onSpeechEnd:function(){Log.log("Transcriber.onSpeechEnd()")}},Transcriber=function(){function e(t,r){void 0===r&&(r={}),this.callbacks=__assign(__assign({},defaultTranscriberCallbacks),r),e.model=new MoonshineModel(t)}return e.prototype.loadModel=function(){return __awaiter(this,void 0,void 0,(function(){return __generator(this,(function(t){switch(t.label){case 0:return this.callbacks.onModelLoadStarted(),[4,e.model.loadModel()];case 1:return t.sent(),this.callbacks.onModelLoaded(),[2]}}))}))},e}();function getAugmentedNamespace(e){if(Object.prototype.hasOwnProperty.call(e,"__esModule"))return e;var t=e.default;if("function"==typeof t){var r=function e(){return this instanceof e?Reflect.construct(t,arguments,this.constructor):t.apply(this,arguments)};r.prototype=t.prototype}else r={};return Object.defineProperty(r,"__esModule",{value:!0}),Object.keys(e).forEach((function(t){var n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,n.get?n:{enumerable:!0,get:function(){return e[t]}})})),r}var dist={},ortWeb_min={exports:{}};const backends$1={},backendsSortedByPriority$1=[],registerBackend$1=(e,t,r)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createSessionHandler)throw new TypeError("not a valid backend");{const n=backends$1[e];if(void 0===n)backends$1[e]={backend:t,priority:r};else{if(n.priority>r)return;if(n.priority===r&&n.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){const t=backendsSortedByPriority$1.indexOf(e);-1!==t&&backendsSortedByPriority$1.splice(t,1);for(let t=0;t<backendsSortedByPriority$1.length;t++)if(backends$1[backendsSortedByPriority$1[t]].priority<=r)return void backendsSortedByPriority$1.splice(t,0,e);backendsSortedByPriority$1.push(e)}}},resolveBackend=async e=>{const t=0===e.length?backendsSortedByPriority$1:e,r=[];for(const e of t){const t=backends$1[e];if(t){if(t.initialized)return t.backend;if(t.aborted)continue;const n=!!t.initPromise;try{return n||(t.initPromise=t.backend.init()),await t.initPromise,t.initialized=!0,t.backend}catch(a){n||r.push({name:e,err:a}),t.aborted=!0}finally{delete t.initPromise}}}throw new Error(`no available backend found. ERR: ${r.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`)};class EnvImpl{constructor(){this.wasm={},this.webgl={},this.logLevelInternal="warning"}set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);this.logLevelInternal=e}}get logLevel(){return this.logLevelInternal}}const env$2=new EnvImpl,isBigInt64ArrayAvailable="undefined"!=typeof BigInt64Array&&"function"==typeof BigInt64Array.from,isBigUint64ArrayAvailable="undefined"!=typeof BigUint64Array&&"function"==typeof BigUint64Array.from,NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP$1=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);isBigInt64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP$1.set(BigInt64Array,"int64")),isBigUint64ArrayAvailable&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP$1.set(BigUint64Array,"uint64"));const calculateSize$1=e=>{let t=1;for(let r=0;r<e.length;r++){const n=e[r];if("number"!=typeof n||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t};let Tensor$3=class e{constructor(e,t,r){let n,a,o;if("string"==typeof e)if(n=e,o=r,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");a=t}else{const r=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP$1.get(e);if(void 0===r)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))a=r.from(t);else{if(!(t instanceof r))throw new TypeError(`A ${n} tensor's data must be type of ${r}`);a=t}}else if(o=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)n="string",a=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);n="bool",a=Uint8Array.from(e)}}else{const t=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP$1.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=t,a=e}if(void 0===o)o=[a.length];else if(!Array.isArray(o))throw new TypeError("A tensor's dims must be a number array");const i=calculateSize$1(o);if(i!==a.length)throw new Error(`Tensor's size(${i}) does not match data length(${a.length}).`);this.dims=o,this.type=n,this.data=a,this.size=i}static bufferToTensor(t,r){if(void 0===t)throw new Error("Image buffer must be defined");if(void 0===r.height||void 0===r.width)throw new Error("Image height and width must be defined");const{height:n,width:a}=r,o=r.norm;let i,s;i=void 0===o||void 0===o.mean?255:o.mean,s=void 0===o||void 0===o.bias?0:o.bias;const l=void 0!==r.bitmapFormat?r.bitmapFormat:"RGBA",d=void 0!==r.tensorFormat&&void 0!==r.tensorFormat?r.tensorFormat:"RGB",u=n*a,c="RGBA"===d?new Float32Array(4*u):new Float32Array(3*u);let p=4,g=0,A=1,h=2,B=3,m=0,C=u,w=2*u,b=-1;"RGB"===l&&(p=3,g=0,A=1,h=2,B=-1),"RGBA"===d?b=3*u:"RBG"===d?(m=0,w=u,C=2*u):"BGR"===d&&(w=0,C=u,m=2*u);for(let e=0;e<u;e++,g+=p,h+=p,A+=p,B+=p)c[m++]=(t[g]+s)/i,c[C++]=(t[A]+s)/i,c[w++]=(t[h]+s)/i,-1!==b&&-1!==B&&(c[b++]=(t[B]+s)/i);return new e("float32",c,"RGBA"===d?[1,4,n,a]:[1,3,n,a])}static async fromImage(t,r){const n="undefined"!=typeof HTMLImageElement&&t instanceof HTMLImageElement,a="undefined"!=typeof ImageData&&t instanceof ImageData,o="undefined"!=typeof ImageBitmap&&t instanceof ImageBitmap,i="undefined"!=typeof String&&(t instanceof String||"string"==typeof t);let s,l={};if(n){const e=document.createElement("canvas"),n=e.getContext("2d");if(null==n)throw new Error("Can not access image data");{let a=t.naturalHeight,o=t.naturalWidth;if(void 0!==r&&void 0!==r.resizedHeight&&void 0!==r.resizedWidth&&(a=r.resizedHeight,o=r.resizedWidth),void 0!==r){if(l=r,void 0!==r.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");if(l.tensorFormat="RGBA",void 0!==r.height&&r.height!==a)throw new Error("Image input config height doesn't match HTMLImageElement height");if(l.height=a,void 0!==r.width&&r.width!==o)throw new Error("Image input config width doesn't match HTMLImageElement width");l.width=o}else l.tensorFormat="RGBA",l.height=a,l.width=o;e.width=o,e.height=a,n.drawImage(t,0,0,o,a),s=n.getImageData(0,0,o,a).data}}else{if(!a){if(o){if(void 0===r)throw new Error("Please provide image config with format for Imagebitmap");if(void 0!==r.bitmapFormat)throw new Error("Image input config format must be defined for ImageBitmap");const n=document.createElement("canvas").getContext("2d");if(null!=n){const a=t.height,o=t.width;if(n.drawImage(t,0,0,o,a),s=n.getImageData(0,0,o,a).data,void 0!==r){if(void 0!==r.height&&r.height!==a)throw new Error("Image input config height doesn't match ImageBitmap height");if(l.height=a,void 0!==r.width&&r.width!==o)throw new Error("Image input config width doesn't match ImageBitmap width");l.width=o}else l.height=a,l.width=o;return e.bufferToTensor(s,l)}throw new Error("Can not access image data")}if(i)return new Promise(((n,a)=>{const o=document.createElement("canvas"),i=o.getContext("2d");if(!t||!i)return a();const s=new Image;s.crossOrigin="Anonymous",s.src=t,s.onload=()=>{o.width=s.width,o.height=s.height,i.drawImage(s,0,0,o.width,o.height);const t=i.getImageData(0,0,o.width,o.height);if(void 0!==r){if(void 0!==r.height&&r.height!==o.height)throw new Error("Image input config height doesn't match ImageBitmap height");if(l.height=o.height,void 0!==r.width&&r.width!==o.width)throw new Error("Image input config width doesn't match ImageBitmap width");l.width=o.width}else l.height=o.height,l.width=o.width;n(e.bufferToTensor(t.data,l))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{const e="RGBA";let n,a;if(void 0!==r&&void 0!==r.resizedWidth&&void 0!==r.resizedHeight?(n=r.resizedHeight,a=r.resizedWidth):(n=t.height,a=t.width),void 0!==r){if(l=r,void 0!==r.bitmapFormat&&r.bitmapFormat!==e)throw new Error("Image input config format must be RGBA for ImageData");l.bitmapFormat="RGBA"}else l.bitmapFormat="RGBA";if(l.height=n,l.width=a,void 0!==r){const e=document.createElement("canvas");e.width=a,e.height=n;const r=e.getContext("2d");if(null==r)throw new Error("Can not access image data");r.putImageData(t,0,0),s=r.getImageData(0,0,a,n).data}else s=t.data}}if(void 0!==s)return e.bufferToTensor(s,l);throw new Error("Input data provided is not supported - aborted tensor creation")}toImageData(e){var t,r;const n=document.createElement("canvas").getContext("2d");let a;if(null==n)throw new Error("Can not access image data");{const o=this.dims[3],i=this.dims[2],s=this.dims[1],l=void 0!==e&&void 0!==e.format?e.format:"RGB",d=void 0!==e&&void 0!==(null===(t=e.norm)||void 0===t?void 0:t.mean)?e.norm.mean:255,u=void 0!==e&&void 0!==(null===(r=e.norm)||void 0===r?void 0:r.bias)?e.norm.bias:0,c=i*o;if(void 0!==e){if(void 0!==e.height&&e.height!==i)throw new Error("Image output config height doesn't match tensor height");if(void 0!==e.width&&e.width!==o)throw new Error("Image output config width doesn't match tensor width");if(void 0!==e.format&&4===s&&"RGBA"!==e.format||3===s&&"RGB"!==e.format&&"BGR"!==e.format)throw new Error("Tensor format doesn't match input tensor dims")}const p=4;let g=0,A=1,h=2,B=3,m=0,C=c,w=2*c,b=-1;"RGBA"===l?(m=0,C=c,w=2*c,b=3*c):"RGB"===l?(m=0,C=c,w=2*c):"RBG"===l&&(m=0,w=c,C=2*c),a=n.createImageData(o,i);for(let e=0;e<i*o;g+=p,A+=p,h+=p,B+=p,e++)a.data[g]=(this.data[m++]-u)*d,a.data[A]=(this.data[C++]-u)*d,a.data[h]=(this.data[w++]-u)*d,a.data[B]=-1===b?255:(this.data[b++]-u)*d}return a}reshape(t){return new e(this.type,this.data,t)}};const Tensor$2=Tensor$3;let InferenceSession$3=class e{constructor(e){this.handler=e}async run(e,t,r){const n={};let a={};if("object"!=typeof e||null===e||e instanceof Tensor$2||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Tensor$2)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if("object"==typeof r&&null!==r)a=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else{let e=!1;const i=Object.getOwnPropertyNames(t);for(const r of this.outputNames)if(-1!==i.indexOf(r)){const a=t[r];(null===a||a instanceof Tensor$2)&&(e=!0,o=!1,n[r]=a)}if(e){if("object"==typeof r&&null!==r)a=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else a=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(o)for(const e of this.outputNames)n[e]=null;const i=await this.handler.run(e,n,a),s={};for(const e in i)Object.hasOwnProperty.call(i,e)&&(s[e]=new Tensor$2(i[e].type,i[e].data,i[e].dims));return s}static async create(t,r,n,a){let o,i={};if("string"==typeof t){if(o=t,"object"==typeof r&&null!==r)i=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(o=t,"object"==typeof r&&null!==r)i=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const e=t;let s=0,l=t.byteLength;if("object"==typeof r&&null!==r)i=r;else if("number"==typeof r){if(s=r,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(l=t.byteLength-s,"number"==typeof n){if(l=n,!Number.isSafeInteger(l))throw new RangeError("'byteLength' must be an integer.");if(l<=0||s+l>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-s}].`);if("object"==typeof a&&null!==a)i=a;else if(void 0!==a)throw new TypeError("'options' must be an object.")}else if(void 0!==n)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==r)throw new TypeError("'options' must be an object.");o=new Uint8Array(e,s,l)}}const s=(i.executionProviders||[]).map((e=>"string"==typeof e?e:e.name)),l=await resolveBackend(s),d=await l.createSessionHandler(o,i);return new e(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const InferenceSession$2=InferenceSession$3;var lib=Object.freeze({__proto__:null,InferenceSession:InferenceSession$2,Tensor:Tensor$2,env:env$2,registerBackend:registerBackend$1}),require$$0=getAugmentedNamespace(lib),hasRequiredOrtWeb_min;function requireOrtWeb_min(){return hasRequiredOrtWeb_min||(hasRequiredOrtWeb_min=1,function(module,exports){!function(e,t){module.exports=t(require$$0)}(self,(__WEBPACK_EXTERNAL_MODULE__1670__=>(()=>{var __webpack_modules__={3474:(e,t,r)=>{var n,a=(n=(n="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return x.buffer!=T&&D(x.buffer),Z}function a(){return x.buffer!=T&&D(x.buffer),X}function o(){return x.buffer!=T&&D(x.buffer),V}function i(){return x.buffer!=T&&D(x.buffer),k}function s(){return x.buffer!=T&&D(x.buffer),M}var l,d,u;e=e||{},l||(l=void 0!==e?e:{}),l.ready=new Promise((function(e,t){d=e,u=t}));var c,p,g,A,h,B,m=Object.assign({},l),C="./this.program",w=(e,t)=>{throw t},b="object"==typeof window,K="function"==typeof importScripts,f="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,Q=l.ENVIRONMENT_IS_PTHREAD||!1,W="";function F(e){return l.locateFile?l.locateFile(e,W):W+e}if(f){let t;W=K?r(908).dirname(W)+"/":"//",B=()=>{h||(A=r(1384),h=r(908))},c=function(e,t){return B(),e=h.normalize(e),A.readFileSync(e,t?void 0:"utf8")},g=e=>((e=c(e,!0)).buffer||(e=new Uint8Array(e)),e),p=(e,t,r)=>{B(),e=h.normalize(e),A.readFile(e,(function(e,n){e?r(e):t(n.buffer)}))},1<process.argv.length&&(C=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof le))throw e})),process.on("unhandledRejection",(function(e){throw e})),w=(e,t)=>{if(q())throw process.exitCode=e,t;t instanceof le||G("exiting due to exception: "+t),process.exit(e)},l.inspect=function(){return"[Emscripten Module object]"};try{t=r(9925)}catch(e){throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),e}r.g.Worker=t.Worker}else(b||K)&&(K?W=self.location.href:"undefined"!=typeof document&&document.currentScript&&(W=document.currentScript.src),n&&(W=n),W=0!==W.indexOf("blob:")?W.substr(0,W.replace(/[?#].*/,"").lastIndexOf("/")+1):"",f||(c=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},K&&(g=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),p=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)}));f&&"undefined"==typeof performance&&(r.g.performance=r(6953).performance);var _=console.log.bind(console),y=console.warn.bind(console);f&&(B(),_=e=>A.writeSync(1,e+"\n"),y=e=>A.writeSync(2,e+"\n"));var v,E=l.print||_,G=l.printErr||y;Object.assign(l,m),m=null,l.thisProgram&&(C=l.thisProgram),l.quit&&(w=l.quit),l.wasmBinary&&(v=l.wasmBinary);var R=l.noExitRuntime||!1;"object"!=typeof WebAssembly&&ae("no native wasm support detected");var x,S,T,Z,X,V,k,M,H=!1,Y="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function L(e,t,r){var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&Y)return Y.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,r):e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n}function N(e,t){return(e>>>=0)?L(a(),e,t):""}function I(e,t,r,n){if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a}function U(e){for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t}function D(e){T=e,l.HEAP8=Z=new Int8Array(e),l.HEAP16=new Int16Array(e),l.HEAP32=V=new Int32Array(e),l.HEAPU8=X=new Uint8Array(e),l.HEAPU16=new Uint16Array(e),l.HEAPU32=k=new Uint32Array(e),l.HEAPF32=new Float32Array(e),l.HEAPF64=M=new Float64Array(e)}Q&&(T=l.buffer);var J=l.INITIAL_MEMORY||16777216;if(Q)x=l.wasmMemory,T=l.buffer;else if(l.wasmMemory)x=l.wasmMemory;else if(!((x=new WebAssembly.Memory({initial:J/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw G("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),f&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");x&&(T=x.buffer),J=T.byteLength,D(T);var P,O=[],z=[],j=[],$=[];function q(){return R||!1}function ee(){var e=l.preRun.shift();O.unshift(e)}var te,re=0,ne=null;function ae(e){throw Q?postMessage({cmd:"onAbort",arg:e}):l.onAbort&&l.onAbort(e),G(e="Aborted("+e+")"),H=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),u(e),e}function oe(){return te.startsWith("data:application/octet-stream;base64,")}function ie(){var e=te;try{if(e==te&&v)return new Uint8Array(v);if(g)return g(e);throw"both async and sync fetching of the wasm failed"}catch(e){ae(e)}}te="ort-wasm-threaded.wasm",oe()||(te=F(te));var se={};function le(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function de(e){(e=ge.Vb[e])||ae(),ge.mc(e)}function ue(e){var t=ge.Cc();if(!t)return 6;ge.ac.push(t),ge.Vb[e.Ub]=t,t.Ub=e.Ub;var r={cmd:"run",start_routine:e.Ic,arg:e.zc,pthread_ptr:e.Ub};return t.$b=()=>{r.time=performance.now(),t.postMessage(r,e.Nc)},t.loaded&&(t.$b(),delete t.$b),0}function ce(e){if(Q)return De(1,1,e);q()||(ge.oc(),l.onExit&&l.onExit(e),H=!0),w(e,new le(e))}function pe(e,t){if(!t&&Q)throw he(e),"unwind";q()||Q||(Bt(),Ae(j),ht(0),rt[1].length&&nt(1,10),rt[2].length&&nt(2,10),ge.oc()),ce(e)}var ge={Yb:[],ac:[],qc:[],Vb:{},fc:function(){Q&&ge.Ec()},Pc:function(){},Ec:function(){ge.receiveObjectTransfer=ge.Gc,ge.threadInitTLS=ge.pc,ge.setExitStatus=ge.nc,R=!1},nc:function(){},oc:function(){for(var e of Object.values(ge.Vb))ge.mc(e);for(e of ge.Yb)e.terminate();ge.Yb=[]},mc:function(e){var t=e.Ub;delete ge.Vb[t],ge.Yb.push(e),ge.ac.splice(ge.ac.indexOf(e),1),e.Ub=0,Kt(t)},Gc:function(){},pc:function(){ge.qc.forEach((e=>e()))},Fc:function(e,t){e.onmessage=r=>{var n=(r=r.data).cmd;if(e.Ub&&(ge.Bc=e.Ub),r.targetThread&&r.targetThread!=pt()){var a=ge.Vb[r.Qc];a?a.postMessage(r,r.transferList):G('Internal error! Worker sent a message "'+n+'" to target pthread '+r.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===n?He(r.queue):"spawnThread"===n?ue(r):"cleanupThread"===n?de(r.thread):"killThread"===n?(r=r.thread,n=ge.Vb[r],delete ge.Vb[r],n.terminate(),Kt(r),ge.ac.splice(ge.ac.indexOf(n),1),n.Ub=0):"cancelThread"===n?ge.Vb[r.thread].postMessage({cmd:"cancel"}):"loaded"===n?(e.loaded=!0,t&&t(e),e.$b&&(e.$b(),delete e.$b)):"print"===n?E("Thread "+r.threadId+": "+r.text):"printErr"===n?G("Thread "+r.threadId+": "+r.text):"alert"===n?alert("Thread "+r.threadId+": "+r.text):"setimmediate"===r.target?e.postMessage(r):"onAbort"===n?l.onAbort&&l.onAbort(r.arg):n&&G("worker sent an unknown command "+n);ge.Bc=void 0},e.onerror=e=>{throw G("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},f&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:l.mainScriptUrlOrBlob||n,wasmMemory:x,wasmModule:S})},yc:function(){var e=F("ort-wasm-threaded.worker.js");ge.Yb.push(new Worker(e))},Cc:function(){return 0==ge.Yb.length&&(ge.yc(),ge.Fc(ge.Yb[0])),ge.Yb.pop()}};function Ae(e){for(;0<e.length;)e.shift()(l)}function he(e){if(Q)return De(2,0,e);try{pe(e)}catch(e){e instanceof le||"unwind"==e||w(1,e)}}l.PThread=ge,l.establishStackSpace=function(){var e=pt(),t=o()[e+44>>2>>>0];e=o()[e+48>>2>>>0],Wt(t,t-e),_t(t)};var Be=[];function me(e){var t=Be[e];return t||(e>=Be.length&&(Be.length=e+1),Be[e]=t=P.get(e)),t}l.invokeEntryPoint=function(e,t){e=me(e)(t),q()?ge.nc(e):ft(e)};var Ce,we,be=[],Ke=0,fe=0;function Qe(e){this.Zb=e,this.Sb=e-24,this.xc=function(e){i()[this.Sb+4>>2>>>0]=e},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(e){i()[this.Sb+8>>2>>>0]=e},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){o()[this.Sb>>2>>>0]=0},this.hc=function(e){e=e?1:0,t()[(this.Sb+12|0)>>>0]=e},this.uc=function(){return 0!=t()[(this.Sb+12|0)>>>0]},this.ic=function(e){e=e?1:0,t()[(this.Sb+13|0)>>>0]=e},this.kc=function(){return 0!=t()[(this.Sb+13|0)>>>0]},this.fc=function(e,t){this.cc(0),this.xc(e),this.wc(t),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(o(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(o(),this.Sb>>2,1)},this.cc=function(e){i()[this.Sb+16>>2>>>0]=e},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Et(this.bc()))return i()[this.Zb>>2>>>0];var e=this.tc();return 0!==e?e:this.Zb}}function We(e){return At(new Qe(e).Sb)}function Fe(e,t,r,n){return Q?De(3,1,e,t,r,n):_e(e,t,r,n)}function _e(e,t,r,n){if("undefined"==typeof SharedArrayBuffer)return G("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return Q&&0===a.length?Fe(e,t,r,n):(e={Ic:r,Ub:e,zc:n,Nc:a},Q?(e.Oc="spawnThread",postMessage(e,a),0):ue(e))}function ye(e,t,r){return Q?De(4,1,e,t,r):0}function ve(e,t){if(Q)return De(5,1,e,t)}function Ee(e,t){if(Q)return De(6,1,e,t)}function Ge(e,t,r){if(Q)return De(7,1,e,t,r)}function Re(e,t,r){return Q?De(8,1,e,t,r):0}function xe(e,t){if(Q)return De(9,1,e,t)}function Se(e,t,r){if(Q)return De(10,1,e,t,r)}function Te(e,t,r,n){if(Q)return De(11,1,e,t,r,n)}function Ze(e,t,r,n){if(Q)return De(12,1,e,t,r,n)}function Xe(e,t,r,n){if(Q)return De(13,1,e,t,r,n)}function Ve(e){if(Q)return De(14,1,e)}function ke(e,t){if(Q)return De(15,1,e,t)}function Me(e,t,r){if(Q)return De(16,1,e,t,r)}function He(e){Atomics.store(o(),e>>2,1),pt()&&bt(e),Atomics.compareExchange(o(),e>>2,1,0)}function Ye(e){return i()[e>>>2]+4294967296*o()[e+4>>>2]}function Le(e,t,r,n,a,o){return Q?De(17,1,e,t,r,n,a,o):-52}function Ne(e,t,r,n,a,o){if(Q)return De(18,1,e,t,r,n,a,o)}function Ie(e){var r=U(e)+1,n=gt(r);return n&&I(e,t(),n,r),n}function Ue(e,t,r){function n(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}if(Q)return De(19,1,e,t,r);var a=(new Date).getFullYear(),s=new Date(a,0,1),l=new Date(a,6,1);a=s.getTimezoneOffset();var d=l.getTimezoneOffset(),u=Math.max(a,d);o()[e>>2>>>0]=60*u,o()[t>>2>>>0]=Number(a!=d),e=n(s),t=n(l),e=Ie(e),t=Ie(t),d<a?(i()[r>>2>>>0]=e,i()[r+4>>2>>>0]=t):(i()[r>>2>>>0]=t,i()[r+4>>2>>>0]=e)}function De(e,t){var r=arguments.length-2,n=arguments;return function(e){var t=Ft();return e=e(),_t(t),e}((()=>{for(var a=yt(8*r),o=a>>3,i=0;i<r;i++){var l=n[2+i];s()[o+i>>>0]=l}return wt(e,r,a,t)}))}l.executeNotifiedProxyingQueue=He,we=f?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:Q?()=>performance.now()-l.__performance_now_clock_drift:()=>performance.now();var Je,Pe=[],Oe={};function ze(){if(!Je){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:C||"./this.program"};for(e in Oe)void 0===Oe[e]?delete t[e]:t[e]=Oe[e];var r=[];for(e in t)r.push(e+"="+t[e]);Je=r}return Je}function je(e,r){if(Q)return De(20,1,e,r);var n=0;return ze().forEach((function(a,o){var s=r+n;for(o=i()[e+4*o>>2>>>0]=s,s=0;s<a.length;++s)t()[(o++|0)>>>0]=a.charCodeAt(s);t()[(o|0)>>>0]=0,n+=a.length+1})),0}function $e(e,t){if(Q)return De(21,1,e,t);var r=ze();i()[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),i()[t>>2>>>0]=n,0}function qe(e){return Q?De(22,1,e):52}function et(e,t,r,n){return Q?De(23,1,e,t,r,n):52}function tt(e,t,r,n,a){return Q?De(24,1,e,t,r,n,a):70}var rt=[null,[],[]];function nt(e,t){var r=rt[e];0===t||10===t?((1===e?E:G)(L(r,0)),r.length=0):r.push(t)}function at(e,t,r,n){if(Q)return De(25,1,e,t,r,n);for(var o=0,s=0;s<r;s++){var l=i()[t>>2>>>0],d=i()[t+4>>2>>>0];t+=8;for(var u=0;u<d;u++)nt(e,a()[l+u>>>0]);o+=d}return i()[n>>2>>>0]=o,0}var ot=0;function it(e){return 0==e%4&&(0!=e%100||0==e%400)}var st=[31,29,31,30,31,30,31,31,30,31,30,31],lt=[31,28,31,30,31,30,31,31,30,31,30,31];function dt(e,r,n,a){function i(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function s(e,t){return i(e,t,"0")}function l(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function d(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.Wb;for(e=new Date(new Date(e.Xb+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(it(e.getFullYear())?st:lt)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=d(new Date(e.getFullYear(),0,4)),r=d(r),0>=l(t,e)?0>=l(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=o()[a+40>>2>>>0];for(var p in a={Lc:o()[a>>2>>>0],Kc:o()[a+4>>2>>>0],dc:o()[a+8>>2>>>0],jc:o()[a+12>>2>>>0],ec:o()[a+16>>2>>>0],Xb:o()[a+20>>2>>>0],Tb:o()[a+24>>2>>>0],Wb:o()[a+28>>2>>>0],Rc:o()[a+32>>2>>>0],Jc:o()[a+36>>2>>>0],Mc:c?N(c):""},n=N(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(p,"g"),c[p]);var g="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),A="January February March April May June July August September October November December".split(" ");for(p in c={"%a":function(e){return g[e.Tb].substring(0,3)},"%A":function(e){return g[e.Tb]},"%b":function(e){return A[e.ec].substring(0,3)},"%B":function(e){return A[e.ec]},"%C":function(e){return s((e.Xb+1900)/100|0,2)},"%d":function(e){return s(e.jc,2)},"%e":function(e){return i(e.jc,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return s(e.dc,2)},"%I":function(e){return 0==(e=e.dc)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,r=0;r<=e.ec-1;t+=(it(e.Xb+1900)?st:lt)[r++]);return s(e.jc+t,3)},"%m":function(e){return s(e.ec+1,2)},"%M":function(e){return s(e.Kc,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.dc&&12>e.dc?"AM":"PM"},"%S":function(e){return s(e.Lc,2)},"%t":function(){return"\t"},"%u":function(e){return e.Tb||7},"%U":function(e){return s(Math.floor((e.Wb+7-e.Tb)/7),2)},"%V":function(e){var t=Math.floor((e.Wb+7-(e.Tb+6)%7)/7);if(2>=(e.Tb+371-e.Wb-2)%7&&t++,t)53==t&&(4==(r=(e.Tb+371-e.Wb)%7)||3==r&&it(e.Xb)||(t=1));else{t=52;var r=(e.Tb+7-e.Wb-1)%7;(4==r||5==r&&it(e.Xb%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Tb},"%W":function(e){return s(Math.floor((e.Wb+7-(e.Tb+6)%7)/7),2)},"%y":function(e){return(e.Xb+1900).toString().substring(2)},"%Y":function(e){return e.Xb+1900},"%z":function(e){var t=0<=(e=e.Jc);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Mc},"%%":function(){return"%"}},n=n.replace(/%%/g,"\0\0"),c)n.includes(p)&&(n=n.replace(new RegExp(p,"g"),c[p](a)));return p=function(e){var t=Array(U(e)+1);return I(e,t,0,t.length),t}(n=n.replace(/\0\0/g,"%")),p.length>r?0:(function(e,r){t().set(e,r>>>0)}(p,e),p.length-1)}ge.fc();var ut=[null,ce,he,Fe,ye,ve,Ee,Ge,Re,xe,Se,Te,Ze,Xe,Ve,ke,Me,Le,Ne,Ue,je,$e,qe,et,tt,at],ct={b:function(e){return gt(e+24)+24},n:function(e){return(e=new Qe(e)).uc()||(e.hc(!0),Ke--),e.ic(!1),be.push(e),e.sc(),e.vc()},ma:function(e){throw G("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,e},x:function(){Qt(0);var e=be.pop();if(e.Hc()&&!e.kc()){var t=e.Dc();t&&me(t)(e.Zb),We(e.Zb)}fe=0},e:function(){var e=fe;if(!e)return ot=0;var t=new Qe(e);t.cc(e);var r=t.bc();if(!r)return ot=0,e;for(var n=Array.prototype.slice.call(arguments),a=0;a<n.length;a++){var o=n[a];if(0===o||o===r)break;if(vt(o,r,t.Sb+16))return ot=o,e}return ot=r,e},l:function(){var e=fe;if(!e)return ot=0;var t=new Qe(e);t.cc(e);var r=t.bc();if(!r)return ot=0,e;for(var n=Array.prototype.slice.call(arguments),a=0;a<n.length;a++){var o=n[a];if(0===o||o===r)break;if(vt(o,r,t.Sb+16))return ot=o,e}return ot=r,e},h:function(){var e=fe;if(!e)return ot=0;var t=new Qe(e);t.cc(e);var r=t.bc();if(!r)return ot=0,e;for(var n=Array.prototype.slice.call(arguments),a=0;a<n.length;a++){var o=n[a];if(0===o||o===r)break;if(vt(o,r,t.Sb+16))return ot=o,e}return ot=r,e},t:We,M:function(){var e=be.pop();e||ae("no exception to throw");var t=e.Zb;throw e.kc()||(be.push(e),e.ic(!0),e.hc(!1),Ke++),fe=t,t},c:function(e,t,r){throw new Qe(e).fc(t,r),fe=e,Ke++,e},pa:function(){return Ke},Fa:function(e){mt(e,!K,1,!b),ge.pc()},T:function(e){Q?postMessage({cmd:"cleanupThread",thread:e}):de(e)},xa:_e,j:function(e){throw fe||(fe=e),e},H:ye,Ma:ve,ua:Ee,wa:Ge,oa:Re,Ka:xe,Ca:Se,Ja:Te,V:Ze,va:Xe,sa:Ve,La:ke,ta:Me,Ta:function(){},X:function(){ae("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){ae("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(e,t,r,n){if(e==t)setTimeout((()=>He(n)));else if(Q)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:n});else{if(!(e=ge.Vb[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:n})}return 1},Ea:function(){return-1},Pa:function(e,t){e=new Date(1e3*Ye(e)),o()[t>>2>>>0]=e.getUTCSeconds(),o()[t+4>>2>>>0]=e.getUTCMinutes(),o()[t+8>>2>>>0]=e.getUTCHours(),o()[t+12>>2>>>0]=e.getUTCDate(),o()[t+16>>2>>>0]=e.getUTCMonth(),o()[t+20>>2>>>0]=e.getUTCFullYear()-1900,o()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,o()[t+28>>2>>>0]=e},Qa:function(e,t){e=new Date(1e3*Ye(e)),o()[t>>2>>>0]=e.getSeconds(),o()[t+4>>2>>>0]=e.getMinutes(),o()[t+8>>2>>>0]=e.getHours(),o()[t+12>>2>>>0]=e.getDate(),o()[t+16>>2>>>0]=e.getMonth(),o()[t+20>>2>>>0]=e.getFullYear()-1900,o()[t+24>>2>>>0]=e.getDay();var r=new Date(e.getFullYear(),0,1),n=(e.getTime()-r.getTime())/864e5|0;o()[t+28>>2>>>0]=n,o()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),n=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(n!=(r=r.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(r,n)),o()[t+32>>2>>>0]=e},Ra:function(e){var t=new Date(o()[e+20>>2>>>0]+1900,o()[e+16>>2>>>0],o()[e+12>>2>>>0],o()[e+8>>2>>>0],o()[e+4>>2>>>0],o()[e>>2>>>0],0),r=o()[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=a.getTimezoneOffset(),l=Math.min(s,i);return 0>r?o()[e+32>>2>>>0]=Number(i!=s&&l==n):0<r!=(l==n)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<r?l:i)-n))),o()[e+24>>2>>>0]=t.getDay(),r=(t.getTime()-a.getTime())/864e5|0,o()[e+28>>2>>>0]=r,o()[e>>2>>>0]=t.getSeconds(),o()[e+4>>2>>>0]=t.getMinutes(),o()[e+8>>2>>>0]=t.getHours(),o()[e+12>>2>>>0]=t.getDate(),o()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},Aa:Le,Ba:Ne,Sa:function e(t,r,n){e.Ac||(e.Ac=!0,Ue(t,r,n))},y:function(){ae("")},U:function(){if(!f&&!K){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";Ce||(Ce={}),Ce[e]||(Ce[e]=1,f&&(e="warning: "+e),G(e))}},ra:function(){return 4294901760},B:we,Ia:function(e,t,r){a().copyWithin(e>>>0,t>>>0,t+r>>>0)},F:function(){return f?r(3993).cpus().length:navigator.hardwareConcurrency},Da:function(e,t,r){Pe.length=t,r>>=3;for(var n=0;n<t;n++)Pe[n]=s()[r+n>>>0];return(0>e?se[-e-1]:ut[e]).apply(null,Pe)},qa:function(e){var t=a().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var o=Math;n=Math.max(e,n),o=o.min.call(o,4294901760,n+(65536-n%65536)%65536);e:{try{x.grow(o-T.byteLength+65535>>>16),D(x.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},Na:function(){throw"unwind"},Ga:je,Ha:$e,J:pe,I:qe,S:et,ga:tt,R:at,d:function(){return ot},na:function e(n,a){e.lc||(e.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(f)try{var t=r(Object(function(){var e=new Error("Cannot find module 'crypto'");throw e.code="MODULE_NOT_FOUND",e}()));return()=>t.randomBytes(1)[0]}catch(e){}return()=>ae("randomDevice")}());for(var o=0;o<a;o++)t()[(n+o|0)>>>0]=e.lc();return 0},ia:function(e,t,r){var n=Ft();try{return me(e)(t,r)}catch(e){if(_t(n),e!==e+0)throw e;Qt(1,0)}},ja:function(e,t,r){var n=Ft();try{return me(e)(t,r)}catch(e){if(_t(n),e!==e+0)throw e;Qt(1,0)}},K:function(e){var t=Ft();try{return me(e)()}catch(e){if(_t(t),e!==e+0)throw e;Qt(1,0)}},f:function(e,t){var r=Ft();try{return me(e)(t)}catch(e){if(_t(r),e!==e+0)throw e;Qt(1,0)}},P:function(e,t,r){var n=Ft();try{return me(e)(t,r)}catch(e){if(_t(n),e!==e+0)throw e;Qt(1,0)}},Q:function(e,t,r){var n=Ft();try{return me(e)(t,r)}catch(e){if(_t(n),e!==e+0)throw e;Qt(1,0)}},k:function(e,t,r){var n=Ft();try{return me(e)(t,r)}catch(e){if(_t(n),e!==e+0)throw e;Qt(1,0)}},p:function(e,t,r,n){var a=Ft();try{return me(e)(t,r,n)}catch(e){if(_t(a),e!==e+0)throw e;Qt(1,0)}},q:function(e,t,r,n,a){var o=Ft();try{return me(e)(t,r,n,a)}catch(e){if(_t(o),e!==e+0)throw e;Qt(1,0)}},N:function(e,t,r,n,a,o){var i=Ft();try{return me(e)(t,r,n,a,o)}catch(e){if(_t(i),e!==e+0)throw e;Qt(1,0)}},s:function(e,t,r,n,a,o){var i=Ft();try{return me(e)(t,r,n,a,o)}catch(e){if(_t(i),e!==e+0)throw e;Qt(1,0)}},w:function(e,t,r,n,a,o,i){var s=Ft();try{return me(e)(t,r,n,a,o,i)}catch(e){if(_t(s),e!==e+0)throw e;Qt(1,0)}},L:function(e,t,r,n,a,o,i,s){var l=Ft();try{return me(e)(t,r,n,a,o,i,s)}catch(e){if(_t(l),e!==e+0)throw e;Qt(1,0)}},E:function(e,t,r,n,a,o,i,s,l,d,u,c){var p=Ft();try{return me(e)(t,r,n,a,o,i,s,l,d,u,c)}catch(e){if(_t(p),e!==e+0)throw e;Qt(1,0)}},aa:function(e,t,r,n,a,o,i,s){var l=Ft();try{return kt(e,t,r,n,a,o,i,s)}catch(e){if(_t(l),e!==e+0)throw e;Qt(1,0)}},_:function(e,t,r,n,a,o,i){var s=Ft();try{return Rt(e,t,r,n,a,o,i)}catch(e){if(_t(s),e!==e+0)throw e;Qt(1,0)}},Z:function(e,t,r,n,a){var o=Ft();try{return Mt(e,t,r,n,a)}catch(e){if(_t(o),e!==e+0)throw e;Qt(1,0)}},ca:function(e,t,r,n){var a=Ft();try{return Xt(e,t,r,n)}catch(e){if(_t(a),e!==e+0)throw e;Qt(1,0)}},$:function(e){var t=Ft();try{return Gt(e)}catch(e){if(_t(t),e!==e+0)throw e;Qt(1,0)}},ba:function(e,t){var r=Ft();try{return Vt(e,t)}catch(e){if(_t(r),e!==e+0)throw e;Qt(1,0)}},Y:function(e,t,r){var n=Ft();try{return xt(e,t,r)}catch(e){if(_t(n),e!==e+0)throw e;Qt(1,0)}},g:function(e){var t=Ft();try{me(e)()}catch(e){if(_t(t),e!==e+0)throw e;Qt(1,0)}},r:function(e,t){var r=Ft();try{me(e)(t)}catch(e){if(_t(r),e!==e+0)throw e;Qt(1,0)}},i:function(e,t,r){var n=Ft();try{me(e)(t,r)}catch(e){if(_t(n),e!==e+0)throw e;Qt(1,0)}},ha:function(e,t,r,n){var a=Ft();try{me(e)(t,r,n)}catch(e){if(_t(a),e!==e+0)throw e;Qt(1,0)}},m:function(e,t,r,n){var a=Ft();try{me(e)(t,r,n)}catch(e){if(_t(a),e!==e+0)throw e;Qt(1,0)}},v:function(e,t,r,n,a){var o=Ft();try{me(e)(t,r,n,a)}catch(e){if(_t(o),e!==e+0)throw e;Qt(1,0)}},u:function(e,t,r,n,a,o){var i=Ft();try{me(e)(t,r,n,a,o)}catch(e){if(_t(i),e!==e+0)throw e;Qt(1,0)}},O:function(e,t,r,n,a,o,i){var s=Ft();try{me(e)(t,r,n,a,o,i)}catch(e){if(_t(s),e!==e+0)throw e;Qt(1,0)}},A:function(e,t,r,n,a,o,i,s){var l=Ft();try{me(e)(t,r,n,a,o,i,s)}catch(e){if(_t(l),e!==e+0)throw e;Qt(1,0)}},ka:function(e,t,r,n,a,o,i,s,l){var d=Ft();try{me(e)(t,r,n,a,o,i,s,l)}catch(e){if(_t(d),e!==e+0)throw e;Qt(1,0)}},C:function(e,t,r,n,a,o,i,s,l,d,u){var c=Ft();try{me(e)(t,r,n,a,o,i,s,l,d,u)}catch(e){if(_t(c),e!==e+0)throw e;Qt(1,0)}},D:function(e,t,r,n,a,o,i,s,l,d,u,c,p,g,A,h){var B=Ft();try{me(e)(t,r,n,a,o,i,s,l,d,u,c,p,g,A,h)}catch(e){if(_t(B),e!==e+0)throw e;Qt(1,0)}},fa:function(e,t,r,n,a,o,i,s){var l=Ft();try{St(e,t,r,n,a,o,i,s)}catch(e){if(_t(l),e!==e+0)throw e;Qt(1,0)}},da:function(e,t,r,n,a,o,i,s,l,d,u,c){var p=Ft();try{Zt(e,t,r,n,a,o,i,s,l,d,u,c)}catch(e){if(_t(p),e!==e+0)throw e;Qt(1,0)}},ea:function(e,t,r,n,a,o){var i=Ft();try{Tt(e,t,r,n,a,o)}catch(e){if(_t(i),e!==e+0)throw e;Qt(1,0)}},o:function(e){return e},a:x||l.wasmMemory,G:function(e){ot=e},la:dt,z:function(e,t,r,n){return dt(e,t,r,n)}};!function(){function e(e,t){l.asm=e.exports,ge.qc.push(l.asm.sb),P=l.asm.ub,z.unshift(l.asm.Va),S=t,Q||(re--,l.monitorRunDependencies&&l.monitorRunDependencies(re),0==re&&ne&&(e=ne,ne=null,e()))}function t(t){e(t.instance,t.module)}function r(e){return function(){if(!v&&(b||K)){if("function"==typeof fetch&&!te.startsWith("file://"))return fetch(te,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+te+"'";return e.arrayBuffer()})).catch((function(){return ie()}));if(p)return new Promise((function(e,t){p(te,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ie()}))}().then((function(e){return WebAssembly.instantiate(e,n)})).then((function(e){return e})).then(e,(function(e){G("failed to asynchronously prepare wasm: "+e),ae(e)}))}var n={a:ct};if(Q||(re++,l.monitorRunDependencies&&l.monitorRunDependencies(re)),l.instantiateWasm)try{return l.instantiateWasm(n,e)}catch(e){return G("Module.instantiateWasm callback failed with error: "+e),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||oe()||te.startsWith("file://")||f||"function"!=typeof fetch?r(t):fetch(te,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,n).then(t,(function(e){return G("wasm streaming compile failed: "+e),G("falling back to ArrayBuffer instantiation"),r(t)}))}))).catch(u)}(),l.___wasm_call_ctors=function(){return(l.___wasm_call_ctors=l.asm.Va).apply(null,arguments)},l._OrtInit=function(){return(l._OrtInit=l.asm.Wa).apply(null,arguments)},l._OrtCreateSessionOptions=function(){return(l._OrtCreateSessionOptions=l.asm.Xa).apply(null,arguments)},l._OrtAppendExecutionProvider=function(){return(l._OrtAppendExecutionProvider=l.asm.Ya).apply(null,arguments)},l._OrtAddSessionConfigEntry=function(){return(l._OrtAddSessionConfigEntry=l.asm.Za).apply(null,arguments)},l._OrtReleaseSessionOptions=function(){return(l._OrtReleaseSessionOptions=l.asm._a).apply(null,arguments)},l._OrtCreateSession=function(){return(l._OrtCreateSession=l.asm.$a).apply(null,arguments)},l._OrtReleaseSession=function(){return(l._OrtReleaseSession=l.asm.ab).apply(null,arguments)},l._OrtGetInputCount=function(){return(l._OrtGetInputCount=l.asm.bb).apply(null,arguments)},l._OrtGetOutputCount=function(){return(l._OrtGetOutputCount=l.asm.cb).apply(null,arguments)},l._OrtGetInputName=function(){return(l._OrtGetInputName=l.asm.db).apply(null,arguments)},l._OrtGetOutputName=function(){return(l._OrtGetOutputName=l.asm.eb).apply(null,arguments)},l._OrtFree=function(){return(l._OrtFree=l.asm.fb).apply(null,arguments)},l._OrtCreateTensor=function(){return(l._OrtCreateTensor=l.asm.gb).apply(null,arguments)},l._OrtGetTensorData=function(){return(l._OrtGetTensorData=l.asm.hb).apply(null,arguments)},l._OrtReleaseTensor=function(){return(l._OrtReleaseTensor=l.asm.ib).apply(null,arguments)},l._OrtCreateRunOptions=function(){return(l._OrtCreateRunOptions=l.asm.jb).apply(null,arguments)},l._OrtAddRunConfigEntry=function(){return(l._OrtAddRunConfigEntry=l.asm.kb).apply(null,arguments)},l._OrtReleaseRunOptions=function(){return(l._OrtReleaseRunOptions=l.asm.lb).apply(null,arguments)},l._OrtRun=function(){return(l._OrtRun=l.asm.mb).apply(null,arguments)},l._OrtEndProfiling=function(){return(l._OrtEndProfiling=l.asm.nb).apply(null,arguments)};var pt=l._pthread_self=function(){return(pt=l._pthread_self=l.asm.ob).apply(null,arguments)},gt=l._malloc=function(){return(gt=l._malloc=l.asm.pb).apply(null,arguments)},At=l._free=function(){return(At=l._free=l.asm.qb).apply(null,arguments)},ht=l._fflush=function(){return(ht=l._fflush=l.asm.rb).apply(null,arguments)};l.__emscripten_tls_init=function(){return(l.__emscripten_tls_init=l.asm.sb).apply(null,arguments)};var Bt=l.___funcs_on_exit=function(){return(Bt=l.___funcs_on_exit=l.asm.tb).apply(null,arguments)},mt=l.__emscripten_thread_init=function(){return(mt=l.__emscripten_thread_init=l.asm.vb).apply(null,arguments)};l.__emscripten_thread_crashed=function(){return(l.__emscripten_thread_crashed=l.asm.wb).apply(null,arguments)};var Ct,wt=l._emscripten_run_in_main_runtime_thread_js=function(){return(wt=l._emscripten_run_in_main_runtime_thread_js=l.asm.xb).apply(null,arguments)},bt=l.__emscripten_proxy_execute_task_queue=function(){return(bt=l.__emscripten_proxy_execute_task_queue=l.asm.yb).apply(null,arguments)},Kt=l.__emscripten_thread_free_data=function(){return(Kt=l.__emscripten_thread_free_data=l.asm.zb).apply(null,arguments)},ft=l.__emscripten_thread_exit=function(){return(ft=l.__emscripten_thread_exit=l.asm.Ab).apply(null,arguments)},Qt=l._setThrew=function(){return(Qt=l._setThrew=l.asm.Bb).apply(null,arguments)},Wt=l._emscripten_stack_set_limits=function(){return(Wt=l._emscripten_stack_set_limits=l.asm.Cb).apply(null,arguments)},Ft=l.stackSave=function(){return(Ft=l.stackSave=l.asm.Db).apply(null,arguments)},_t=l.stackRestore=function(){return(_t=l.stackRestore=l.asm.Eb).apply(null,arguments)},yt=l.stackAlloc=function(){return(yt=l.stackAlloc=l.asm.Fb).apply(null,arguments)},vt=l.___cxa_can_catch=function(){return(vt=l.___cxa_can_catch=l.asm.Gb).apply(null,arguments)},Et=l.___cxa_is_pointer_type=function(){return(Et=l.___cxa_is_pointer_type=l.asm.Hb).apply(null,arguments)},Gt=l.dynCall_j=function(){return(Gt=l.dynCall_j=l.asm.Ib).apply(null,arguments)},Rt=l.dynCall_iiiiij=function(){return(Rt=l.dynCall_iiiiij=l.asm.Jb).apply(null,arguments)},xt=l.dynCall_jii=function(){return(xt=l.dynCall_jii=l.asm.Kb).apply(null,arguments)},St=l.dynCall_viiiiij=function(){return(St=l.dynCall_viiiiij=l.asm.Lb).apply(null,arguments)},Tt=l.dynCall_vjji=function(){return(Tt=l.dynCall_vjji=l.asm.Mb).apply(null,arguments)},Zt=l.dynCall_viiijjjii=function(){return(Zt=l.dynCall_viiijjjii=l.asm.Nb).apply(null,arguments)},Xt=l.dynCall_iij=function(){return(Xt=l.dynCall_iij=l.asm.Ob).apply(null,arguments)},Vt=l.dynCall_ji=function(){return(Vt=l.dynCall_ji=l.asm.Pb).apply(null,arguments)},kt=l.dynCall_iiiiiij=function(){return(kt=l.dynCall_iiiiiij=l.asm.Qb).apply(null,arguments)},Mt=l.dynCall_iiij=function(){return(Mt=l.dynCall_iiij=l.asm.Rb).apply(null,arguments)};function Ht(){function e(){if(!Ct&&(Ct=!0,l.calledRun=!0,!H)&&(Q||Ae(z),d(l),l.onRuntimeInitialized&&l.onRuntimeInitialized(),!Q)){if(l.postRun)for("function"==typeof l.postRun&&(l.postRun=[l.postRun]);l.postRun.length;){var e=l.postRun.shift();$.unshift(e)}Ae($)}}if(!(0<re))if(Q)d(l),Q||Ae(z),postMessage({cmd:"loaded"});else{if(l.preRun)for("function"==typeof l.preRun&&(l.preRun=[l.preRun]);l.preRun.length;)ee();Ae(O),0<re||(l.setStatus?(l.setStatus("Running..."),setTimeout((function(){setTimeout((function(){l.setStatus("")}),1),e()}),1)):e())}}if(l.UTF8ToString=N,l.stringToUTF8=function(e,t,r){return I(e,a(),t,r)},l.lengthBytesUTF8=U,l.keepRuntimeAlive=q,l.wasmMemory=x,l.stackSave=Ft,l.stackRestore=_t,l.stackAlloc=yt,l.ExitStatus=le,l.PThread=ge,ne=function e(){Ct||Ht(),Ct||(ne=e)},l.preInit)for("function"==typeof l.preInit&&(l.preInit=[l.preInit]);0<l.preInit.length;)l.preInit.pop()();return Ht(),e.ready});e.exports=a},932:(e,t,r)=>{var n,a=(n=(n="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,a,o;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){a=e,o=t}));var i,s,l,d,u,c,p=Object.assign({},t),g="./this.program",A=(e,t)=>{throw t},h="object"==typeof window,B="function"==typeof importScripts,m="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,C="";m?(C=B?r(908).dirname(C)+"/":"//",c=()=>{u||(d=r(1384),u=r(908))},i=function(e,t){return c(),e=u.normalize(e),d.readFileSync(e,t?void 0:"utf8")},l=e=>((e=i(e,!0)).buffer||(e=new Uint8Array(e)),e),s=(e,t,r)=>{c(),e=u.normalize(e),d.readFile(e,(function(e,n){e?r(e):t(n.buffer)}))},1<process.argv.length&&(g=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof z))throw e})),process.on("unhandledRejection",(function(e){throw e})),A=(e,t)=>{if(f||0<Y)throw process.exitCode=e,t;t instanceof z||K("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(h||B)&&(B?C=self.location.href:"undefined"!=typeof document&&document.currentScript&&(C=document.currentScript.src),n&&(C=n),C=0!==C.indexOf("blob:")?C.substr(0,C.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},B&&(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),s=(e,t,r)=>{var n=new XMLHttpRequest;n.open("GET",e,!0),n.responseType="arraybuffer",n.onload=()=>{200==n.status||0==n.status&&n.response?t(n.response):r()},n.onerror=r,n.send(null)});var w,b=t.print||console.log.bind(console),K=t.printErr||console.warn.bind(console);Object.assign(t,p),p=null,t.thisProgram&&(g=t.thisProgram),t.quit&&(A=t.quit),t.wasmBinary&&(w=t.wasmBinary);var f=t.noExitRuntime||!1;"object"!=typeof WebAssembly&&D("no native wasm support detected");var Q,W,F,_,y,v,E=!1,G="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(e,t,r){var n=(t>>>=0)+r;for(r=t;e[r]&&!(r>=n);)++r;if(16<r-t&&e.buffer&&G)return G.decode(e.subarray(t,r));for(n="";t<r;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))n+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?n+=String.fromCharCode(a):(a-=65536,n+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else n+=String.fromCharCode(a)}return n}function x(e,t){return(e>>>=0)?R(_,e,t):""}function S(e,t,r,n){if(!(0<n))return 0;var a=r>>>=0;n=r+n-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(r>=n)break;t[r++>>>0]=i}else{if(2047>=i){if(r+1>=n)break;t[r++>>>0]=192|i>>6}else{if(65535>=i){if(r+2>=n)break;t[r++>>>0]=224|i>>12}else{if(r+3>=n)break;t[r++>>>0]=240|i>>18,t[r++>>>0]=128|i>>12&63}t[r++>>>0]=128|i>>6&63}t[r++>>>0]=128|63&i}}return t[r>>>0]=0,r-a}function T(e){for(var t=0,r=0;r<e.length;++r){var n=e.charCodeAt(r);127>=n?t++:2047>=n?t+=2:55296<=n&&57343>=n?(t+=4,++r):t+=3}return t}function Z(){var e=Q.buffer;W=e,t.HEAP8=F=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=y=new Int32Array(e),t.HEAPU8=_=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=v=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var X,V=[],k=[],M=[],H=[],Y=0;function L(){var e=t.preRun.shift();V.unshift(e)}var N,I=0,U=null;function D(e){throw t.onAbort&&t.onAbort(e),K(e="Aborted("+e+")"),E=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),o(e),e}function J(){return N.startsWith("data:application/octet-stream;base64,")}if(N="ort-wasm.wasm",!J()){var P=N;N=t.locateFile?t.locateFile(P,C):C+P}function O(){var e=N;try{if(e==N&&w)return new Uint8Array(w);if(l)return l(e);throw"both async and sync fetching of the wasm failed"}catch(e){D(e)}}function z(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function j(e){for(;0<e.length;)e.shift()(t)}var $=[],q=0,ee=0;function te(e){this.Db=e,this.zb=e-24,this.Ub=function(e){v[this.zb+4>>2>>>0]=e},this.Eb=function(){return v[this.zb+4>>2>>>0]},this.Sb=function(e){v[this.zb+8>>2>>>0]=e},this.Wb=function(){return v[this.zb+8>>2>>>0]},this.Tb=function(){y[this.zb>>2>>>0]=0},this.Ib=function(e){F[(this.zb+12|0)>>>0]=e?1:0},this.Pb=function(){return 0!=F[(this.zb+12|0)>>>0]},this.Jb=function(e){F[(this.zb+13|0)>>>0]=e?1:0},this.Lb=function(){return 0!=F[(this.zb+13|0)>>>0]},this.Rb=function(e,t){this.Fb(0),this.Ub(e),this.Sb(t),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){y[this.zb>>2>>>0]+=1},this.Xb=function(){var e=y[this.zb>>2>>>0];return y[this.zb>>2>>>0]=e-1,1===e},this.Fb=function(e){v[this.zb+16>>2>>>0]=e},this.Ob=function(){return v[this.zb+16>>2>>>0]},this.Qb=function(){if(ye(this.Eb()))return v[this.Db>>2>>>0];var e=this.Ob();return 0!==e?e:this.Db}}function re(e){return we(new te(e).zb)}var ne=[];function ae(e){var t=ne[e];return t||(e>=ne.length&&(ne.length=e+1),ne[e]=t=X.get(e)),t}function oe(e){var t=T(e)+1,r=Ce(t);return r&&S(e,F,r,t),r}var ie={};function se(){if(!le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:g||"./this.program"};for(e in ie)void 0===ie[e]?delete t[e]:t[e]=ie[e];var r=[];for(e in t)r.push(e+"="+t[e]);le=r}return le}var le,de=[null,[],[]];function ue(e,t){var r=de[e];0===t||10===t?((1===e?b:K)(R(r,0)),r.length=0):r.push(t)}var ce=0;function pe(e){return 0==e%4&&(0!=e%100||0==e%400)}var ge=[31,29,31,30,31,30,31,31,30,31,30,31],Ae=[31,28,31,30,31,30,31,31,30,31,30,31];function he(e,t,r,n){function a(e,t,r){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=r[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function r(e){return 0>e?-1:0<e?1:0}var n;return 0===(n=r(e.getFullYear()-t.getFullYear()))&&0===(n=r(e.getMonth()-t.getMonth()))&&(n=r(e.getDate()-t.getDate())),n}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Bb;for(e=new Date(new Date(e.Cb+1900,0,1).getTime());0<t;){var r=e.getMonth(),n=(pe(e.getFullYear())?ge:Ae)[r];if(!(t>n-e.getDate())){e.setDate(e.getDate()+t);break}t-=n-e.getDate()+1,e.setDate(1),11>r?e.setMonth(r+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return r=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),r=s(r),0>=i(t,e)?0>=i(r,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var d=y[n+40>>2>>>0];for(var u in n={$b:y[n>>2>>>0],Zb:y[n+4>>2>>>0],Gb:y[n+8>>2>>>0],Kb:y[n+12>>2>>>0],Hb:y[n+16>>2>>>0],Cb:y[n+20>>2>>>0],Ab:y[n+24>>2>>>0],Bb:y[n+28>>2>>>0],bc:y[n+32>>2>>>0],Yb:y[n+36>>2>>>0],ac:d?x(d):""},r=x(r),d={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(u,"g"),d[u]);var c="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(u in d={"%a":function(e){return c[e.Ab].substring(0,3)},"%A":function(e){return c[e.Ab]},"%b":function(e){return p[e.Hb].substring(0,3)},"%B":function(e){return p[e.Hb]},"%C":function(e){return o((e.Cb+1900)/100|0,2)},"%d":function(e){return o(e.Kb,2)},"%e":function(e){return a(e.Kb,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return o(e.Gb,2)},"%I":function(e){return 0==(e=e.Gb)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,r=0;r<=e.Hb-1;t+=(pe(e.Cb+1900)?ge:Ae)[r++]);return o(e.Kb+t,3)},"%m":function(e){return o(e.Hb+1,2)},"%M":function(e){return o(e.Zb,2)},"%n":function(){return"\n"},"%p":function(e){return 0<=e.Gb&&12>e.Gb?"AM":"PM"},"%S":function(e){return o(e.$b,2)},"%t":function(){return"\t"},"%u":function(e){return e.Ab||7},"%U":function(e){return o(Math.floor((e.Bb+7-e.Ab)/7),2)},"%V":function(e){var t=Math.floor((e.Bb+7-(e.Ab+6)%7)/7);if(2>=(e.Ab+371-e.Bb-2)%7&&t++,t)53==t&&(4==(r=(e.Ab+371-e.Bb)%7)||3==r&&pe(e.Cb)||(t=1));else{t=52;var r=(e.Ab+7-e.Bb-1)%7;(4==r||5==r&&pe(e.Cb%400-1))&&t++}return o(t,2)},"%w":function(e){return e.Ab},"%W":function(e){return o(Math.floor((e.Bb+7-(e.Ab+6)%7)/7),2)},"%y":function(e){return(e.Cb+1900).toString().substring(2)},"%Y":function(e){return e.Cb+1900},"%z":function(e){var t=0<=(e=e.Yb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ac},"%%":function(){return"%"}},r=r.replace(/%%/g,"\0\0"),d)r.includes(u)&&(r=r.replace(new RegExp(u,"g"),d[u](n)));return u=function(e){var t=Array(T(e)+1);return S(e,t,0,t.length),t}(r=r.replace(/\0\0/g,"%")),u.length>t?0:(F.set(u,e>>>0),u.length-1)}var Be={a:function(e){return Ce(e+24)+24},m:function(e){return(e=new te(e)).Pb()||(e.Ib(!0),q--),e.Jb(!1),$.push(e),e.Nb(),e.Qb()},ia:function(e){throw K("Unexpected exception thrown, this is not properly supported - aborting"),E=!0,e},w:function(){fe(0);var e=$.pop();if(e.Xb()&&!e.Lb()){var t=e.Wb();t&&ae(t)(e.Db),re(e.Db)}ee=0},d:function(){var e=ee;if(!e)return ce=0;var t=new te(e);t.Fb(e);var r=t.Eb();if(!r)return ce=0,e;for(var n=Array.prototype.slice.call(arguments),a=0;a<n.length;a++){var o=n[a];if(0===o||o===r)break;if(_e(o,r,t.zb+16))return ce=o,e}return ce=r,e},k:function(){var e=ee;if(!e)return ce=0;var t=new te(e);t.Fb(e);var r=t.Eb();if(!r)return ce=0,e;for(var n=Array.prototype.slice.call(arguments),a=0;a<n.length;a++){var o=n[a];if(0===o||o===r)break;if(_e(o,r,t.zb+16))return ce=o,e}return ce=r,e},g:function(){var e=ee;if(!e)return ce=0;var t=new te(e);t.Fb(e);var r=t.Eb();if(!r)return ce=0,e;for(var n=Array.prototype.slice.call(arguments),a=0;a<n.length;a++){var o=n[a];if(0===o||o===r)break;if(_e(o,r,t.zb+16))return ce=o,e}return ce=r,e},s:re,L:function(){var e=$.pop();e||D("no exception to throw");var t=e.Db;throw e.Lb()||($.push(e),e.Jb(!0),e.Ib(!1),q++),ee=t,t},b:function(e,t,r){throw new te(e).Rb(t,r),ee=e,q++,e},la:function(){return q},i:function(e){throw ee||(ee=e),e},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){D("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){D("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(e,t){e=new Date(1e3*(v[e>>>2]+4294967296*y[e+4>>>2])),y[t>>2>>>0]=e.getUTCSeconds(),y[t+4>>2>>>0]=e.getUTCMinutes(),y[t+8>>2>>>0]=e.getUTCHours(),y[t+12>>2>>>0]=e.getUTCDate(),y[t+16>>2>>>0]=e.getUTCMonth(),y[t+20>>2>>>0]=e.getUTCFullYear()-1900,y[t+24>>2>>>0]=e.getUTCDay(),y[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(e,t){e=new Date(1e3*(v[e>>>2]+4294967296*y[e+4>>>2])),y[t>>2>>>0]=e.getSeconds(),y[t+4>>2>>>0]=e.getMinutes(),y[t+8>>2>>>0]=e.getHours(),y[t+12>>2>>>0]=e.getDate(),y[t+16>>2>>>0]=e.getMonth(),y[t+20>>2>>>0]=e.getFullYear()-1900,y[t+24>>2>>>0]=e.getDay();var r=new Date(e.getFullYear(),0,1);y[t+28>>2>>>0]=(e.getTime()-r.getTime())/864e5|0,y[t+36>>2>>>0]=-60*e.getTimezoneOffset();var n=new Date(e.getFullYear(),6,1).getTimezoneOffset();r=r.getTimezoneOffset(),y[t+32>>2>>>0]=0|(n!=r&&e.getTimezoneOffset()==Math.min(r,n))},Fa:function(e){var t=new Date(y[e+20>>2>>>0]+1900,y[e+16>>2>>>0],y[e+12>>2>>>0],y[e+8>>2>>>0],y[e+4>>2>>>0],y[e>>2>>>0],0),r=y[e+32>>2>>>0],n=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>r?y[e+32>>2>>>0]=Number(o!=i&&s==n):0<r!=(s==n)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<r?s:o)-n))),y[e+24>>2>>>0]=t.getDay(),y[e+28>>2>>>0]=(t.getTime()-a.getTime())/864e5|0,y[e>>2>>>0]=t.getSeconds(),y[e+4>>2>>>0]=t.getMinutes(),y[e+8>>2>>>0]=t.getHours(),y[e+12>>2>>>0]=t.getDate(),y[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function e(t,r,n){e.Vb||(e.Vb=!0,function(e,t,r){function n(e){return(e=e.toTimeString().match(/\(([A-Za-z ]+)\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();y[e>>2>>>0]=60*Math.max(a,s),y[t>>2>>>0]=Number(a!=s),e=n(o),t=n(i),e=oe(e),t=oe(t),s<a?(v[r>>2>>>0]=e,v[r+4>>2>>>0]=t):(v[r>>2>>>0]=t,v[r+4>>2>>>0]=e)}(t,r,n))},B:function(){D("")},ma:function(){return 4294901760},I:m?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),xa:function(e,t,r){_.copyWithin(e>>>0,t>>>0,t+r>>>0)},G:function(e){var t=_.length;if(4294901760<(e>>>=0))return!1;for(var r=1;4>=r;r*=2){var n=t*(1+.2/r);n=Math.min(n,e+100663296);var a=Math;n=Math.max(e,n),a=a.min.call(a,4294901760,n+(65536-n%65536)%65536);e:{try{Q.grow(a-W.byteLength+65535>>>16),Z();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},va:function(e,t){var r=0;return se().forEach((function(n,a){var o=t+r;for(a=v[e+4*a>>2>>>0]=o,o=0;o<n.length;++o)F[(a++|0)>>>0]=n.charCodeAt(o);F[(a|0)>>>0]=0,r+=n.length+1})),0},wa:function(e,t){var r=se();v[e>>2>>>0]=r.length;var n=0;return r.forEach((function(e){n+=e.length+1})),v[t>>2>>>0]=n,0},ba:function(e){f||0<Y||(Ke(),j(M),be(0),de[1].length&&ue(1,10),de[2].length&&ue(2,10)),f||0<Y||(t.onExit&&t.onExit(e),E=!0),A(e,new z(e))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(e,t,r,n){for(var a=0,o=0;o<r;o++){var i=v[t>>2>>>0],s=v[t+4>>2>>>0];t+=8;for(var l=0;l<s;l++)ue(e,_[i+l>>>0]);a+=s}return v[n>>2>>>0]=a,0},c:function(){return ce},ja:function e(t,n){e.Mb||(e.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(m)try{var t=r(Object(function(){var e=new Error("Cannot find module 'crypto'");throw e.code="MODULE_NOT_FOUND",e}()));return()=>t.randomBytes(1)[0]}catch(e){}return()=>D("randomDevice")}());for(var a=0;a<n;a++)F[(t+a|0)>>>0]=e.Mb();return 0},ea:function(e,t,r){var n=Qe();try{return ae(e)(t,r)}catch(e){if(We(n),e!==e+0)throw e;fe(1,0)}},fa:function(e,t,r){var n=Qe();try{return ae(e)(t,r)}catch(e){if(We(n),e!==e+0)throw e;fe(1,0)}},J:function(e){var t=Qe();try{return ae(e)()}catch(e){if(We(t),e!==e+0)throw e;fe(1,0)}},e:function(e,t){var r=Qe();try{return ae(e)(t)}catch(e){if(We(r),e!==e+0)throw e;fe(1,0)}},N:function(e,t,r){var n=Qe();try{return ae(e)(t,r)}catch(e){if(We(n),e!==e+0)throw e;fe(1,0)}},O:function(e,t,r){var n=Qe();try{return ae(e)(t,r)}catch(e){if(We(n),e!==e+0)throw e;fe(1,0)}},j:function(e,t,r){var n=Qe();try{return ae(e)(t,r)}catch(e){if(We(n),e!==e+0)throw e;fe(1,0)}},o:function(e,t,r,n){var a=Qe();try{return ae(e)(t,r,n)}catch(e){if(We(a),e!==e+0)throw e;fe(1,0)}},p:function(e,t,r,n,a){var o=Qe();try{return ae(e)(t,r,n,a)}catch(e){if(We(o),e!==e+0)throw e;fe(1,0)}},M:function(e,t,r,n,a,o){var i=Qe();try{return ae(e)(t,r,n,a,o)}catch(e){if(We(i),e!==e+0)throw e;fe(1,0)}},r:function(e,t,r,n,a,o){var i=Qe();try{return ae(e)(t,r,n,a,o)}catch(e){if(We(i),e!==e+0)throw e;fe(1,0)}},v:function(e,t,r,n,a,o,i){var s=Qe();try{return ae(e)(t,r,n,a,o,i)}catch(e){if(We(s),e!==e+0)throw e;fe(1,0)}},K:function(e,t,r,n,a,o,i,s){var l=Qe();try{return ae(e)(t,r,n,a,o,i,s)}catch(e){if(We(l),e!==e+0)throw e;fe(1,0)}},D:function(e,t,r,n,a,o,i,s,l,d,u,c){var p=Qe();try{return ae(e)(t,r,n,a,o,i,s,l,d,u,c)}catch(e){if(We(p),e!==e+0)throw e;fe(1,0)}},X:function(e,t,r,n,a,o,i,s){var l=Qe();try{return Xe(e,t,r,n,a,o,i,s)}catch(e){if(We(l),e!==e+0)throw e;fe(1,0)}},V:function(e,t,r,n,a,o,i){var s=Qe();try{return Ee(e,t,r,n,a,o,i)}catch(e){if(We(s),e!==e+0)throw e;fe(1,0)}},U:function(e,t,r,n,a){var o=Qe();try{return Ve(e,t,r,n,a)}catch(e){if(We(o),e!==e+0)throw e;fe(1,0)}},Z:function(e,t,r,n){var a=Qe();try{return Te(e,t,r,n)}catch(e){if(We(a),e!==e+0)throw e;fe(1,0)}},W:function(e){var t=Qe();try{return ve(e)}catch(e){if(We(t),e!==e+0)throw e;fe(1,0)}},Y:function(e,t){var r=Qe();try{return Ze(e,t)}catch(e){if(We(r),e!==e+0)throw e;fe(1,0)}},T:function(e,t,r){var n=Qe();try{return Ge(e,t,r)}catch(e){if(We(n),e!==e+0)throw e;fe(1,0)}},f:function(e){var t=Qe();try{ae(e)()}catch(e){if(We(t),e!==e+0)throw e;fe(1,0)}},q:function(e,t){var r=Qe();try{ae(e)(t)}catch(e){if(We(r),e!==e+0)throw e;fe(1,0)}},h:function(e,t,r){var n=Qe();try{ae(e)(t,r)}catch(e){if(We(n),e!==e+0)throw e;fe(1,0)}},da:function(e,t,r,n){var a=Qe();try{ae(e)(t,r,n)}catch(e){if(We(a),e!==e+0)throw e;fe(1,0)}},l:function(e,t,r,n){var a=Qe();try{ae(e)(t,r,n)}catch(e){if(We(a),e!==e+0)throw e;fe(1,0)}},t:function(e,t,r,n,a){var o=Qe();try{ae(e)(t,r,n,a)}catch(e){if(We(o),e!==e+0)throw e;fe(1,0)}},u:function(e,t,r,n,a,o){var i=Qe();try{ae(e)(t,r,n,a,o)}catch(e){if(We(i),e!==e+0)throw e;fe(1,0)}},x:function(e,t,r,n,a,o,i){var s=Qe();try{ae(e)(t,r,n,a,o,i)}catch(e){if(We(s),e!==e+0)throw e;fe(1,0)}},z:function(e,t,r,n,a,o,i,s){var l=Qe();try{ae(e)(t,r,n,a,o,i,s)}catch(e){if(We(l),e!==e+0)throw e;fe(1,0)}},ga:function(e,t,r,n,a,o,i,s,l){var d=Qe();try{ae(e)(t,r,n,a,o,i,s,l)}catch(e){if(We(d),e!==e+0)throw e;fe(1,0)}},A:function(e,t,r,n,a,o,i,s,l,d,u){var c=Qe();try{ae(e)(t,r,n,a,o,i,s,l,d,u)}catch(e){if(We(c),e!==e+0)throw e;fe(1,0)}},C:function(e,t,r,n,a,o,i,s,l,d,u,c,p,g,A,h){var B=Qe();try{ae(e)(t,r,n,a,o,i,s,l,d,u,c,p,g,A,h)}catch(e){if(We(B),e!==e+0)throw e;fe(1,0)}},aa:function(e,t,r,n,a,o,i,s){var l=Qe();try{Re(e,t,r,n,a,o,i,s)}catch(e){if(We(l),e!==e+0)throw e;fe(1,0)}},_:function(e,t,r,n,a,o,i,s,l,d,u,c){var p=Qe();try{Se(e,t,r,n,a,o,i,s,l,d,u,c)}catch(e){if(We(p),e!==e+0)throw e;fe(1,0)}},$:function(e,t,r,n,a,o){var i=Qe();try{xe(e,t,r,n,a,o)}catch(e){if(We(i),e!==e+0)throw e;fe(1,0)}},n:function(e){return e},F:function(e){ce=e},ha:he,y:function(e,t,r,n){return he(e,t,r,n)}};!function(){function e(e){t.asm=e.exports,Q=t.asm.Ka,Z(),X=t.asm.ib,k.unshift(t.asm.La),I--,t.monitorRunDependencies&&t.monitorRunDependencies(I),0==I&&U&&(e=U,U=null,e())}function r(t){e(t.instance)}function n(e){return function(){if(!w&&(h||B)){if("function"==typeof fetch&&!N.startsWith("file://"))return fetch(N,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at '"+N+"'";return e.arrayBuffer()})).catch((function(){return O()}));if(s)return new Promise((function(e,t){s(N,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return O()}))}().then((function(e){return WebAssembly.instantiate(e,a)})).then((function(e){return e})).then(e,(function(e){K("failed to asynchronously prepare wasm: "+e),D(e)}))}var a={a:Be};if(I++,t.monitorRunDependencies&&t.monitorRunDependencies(I),t.instantiateWasm)try{return t.instantiateWasm(a,e)}catch(e){return K("Module.instantiateWasm callback failed with error: "+e),!1}(w||"function"!=typeof WebAssembly.instantiateStreaming||J()||N.startsWith("file://")||m||"function"!=typeof fetch?n(r):fetch(N,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,a).then(r,(function(e){return K("wasm streaming compile failed: "+e),K("falling back to ArrayBuffer instantiation"),n(r)}))}))).catch(o)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.La).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.Ma).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.Na).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.Oa).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.Pa).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.Qa).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.Ra).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.Sa).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Ta).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Ua).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm.Va).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.Wa).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.Xa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.Ya).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.Za).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm._a).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.$a).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.ab).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.bb).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.cb).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.db).apply(null,arguments)};var me,Ce=t._malloc=function(){return(Ce=t._malloc=t.asm.eb).apply(null,arguments)},we=t._free=function(){return(we=t._free=t.asm.fb).apply(null,arguments)},be=t._fflush=function(){return(be=t._fflush=t.asm.gb).apply(null,arguments)},Ke=t.___funcs_on_exit=function(){return(Ke=t.___funcs_on_exit=t.asm.hb).apply(null,arguments)},fe=t._setThrew=function(){return(fe=t._setThrew=t.asm.jb).apply(null,arguments)},Qe=t.stackSave=function(){return(Qe=t.stackSave=t.asm.kb).apply(null,arguments)},We=t.stackRestore=function(){return(We=t.stackRestore=t.asm.lb).apply(null,arguments)},Fe=t.stackAlloc=function(){return(Fe=t.stackAlloc=t.asm.mb).apply(null,arguments)},_e=t.___cxa_can_catch=function(){return(_e=t.___cxa_can_catch=t.asm.nb).apply(null,arguments)},ye=t.___cxa_is_pointer_type=function(){return(ye=t.___cxa_is_pointer_type=t.asm.ob).apply(null,arguments)},ve=t.dynCall_j=function(){return(ve=t.dynCall_j=t.asm.pb).apply(null,arguments)},Ee=t.dynCall_iiiiij=function(){return(Ee=t.dynCall_iiiiij=t.asm.qb).apply(null,arguments)},Ge=t.dynCall_jii=function(){return(Ge=t.dynCall_jii=t.asm.rb).apply(null,arguments)},Re=t.dynCall_viiiiij=function(){return(Re=t.dynCall_viiiiij=t.asm.sb).apply(null,arguments)},xe=t.dynCall_vjji=function(){return(xe=t.dynCall_vjji=t.asm.tb).apply(null,arguments)},Se=t.dynCall_viiijjjii=function(){return(Se=t.dynCall_viiijjjii=t.asm.ub).apply(null,arguments)},Te=t.dynCall_iij=function(){return(Te=t.dynCall_iij=t.asm.vb).apply(null,arguments)},Ze=t.dynCall_ji=function(){return(Ze=t.dynCall_ji=t.asm.wb).apply(null,arguments)},Xe=t.dynCall_iiiiiij=function(){return(Xe=t.dynCall_iiiiiij=t.asm.xb).apply(null,arguments)},Ve=t.dynCall_iiij=function(){return(Ve=t.dynCall_iiij=t.asm.yb).apply(null,arguments)};function ke(){function e(){if(!me&&(me=!0,t.calledRun=!0,!E)){if(j(k),a(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();H.unshift(e)}j(H)}}if(!(0<I)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)L();j(V),0<I||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.UTF8ToString=x,t.stringToUTF8=function(e,t,r){return S(e,_,t,r)},t.lengthBytesUTF8=T,t.stackSave=Qe,t.stackRestore=We,t.stackAlloc=Fe,U=function e(){me||ke(),me||(U=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return ke(),e.ready});e.exports=a},4537:e=>{e.exports=function(e,t){for(var r=new Array(arguments.length-1),n=0,a=2,o=!0;a<arguments.length;)r[n++]=arguments[a++];return new Promise((function(a,i){r[n]=function(e){if(o)if(o=!1,e)i(e);else{for(var t=new Array(arguments.length-1),r=0;r<t.length;)t[r++]=arguments[r];a.apply(null,t)}};try{e.apply(t||null,r)}catch(e){o&&(o=!1,i(e))}}))}},7419:(e,t)=>{var r=t;r.length=function(e){var t=e.length;if(!t)return 0;for(var r=0;--t%4>1&&"="===e.charAt(t);)++r;return Math.ceil(3*e.length)/4-r};for(var n=new Array(64),a=new Array(123),o=0;o<64;)a[n[o]=o<26?o+65:o<52?o+71:o<62?o-4:o-59|43]=o++;r.encode=function(e,t,r){for(var a,o=null,i=[],s=0,l=0;t<r;){var d=e[t++];switch(l){case 0:i[s++]=n[d>>2],a=(3&d)<<4,l=1;break;case 1:i[s++]=n[a|d>>4],a=(15&d)<<2,l=2;break;case 2:i[s++]=n[a|d>>6],i[s++]=n[63&d],l=0}s>8191&&((o||(o=[])).push(String.fromCharCode.apply(String,i)),s=0)}return l&&(i[s++]=n[a],i[s++]=61,1===l&&(i[s++]=61)),o?(s&&o.push(String.fromCharCode.apply(String,i.slice(0,s))),o.join("")):String.fromCharCode.apply(String,i.slice(0,s))};var i="invalid encoding";r.decode=function(e,t,r){for(var n,o=r,s=0,l=0;l<e.length;){var d=e.charCodeAt(l++);if(61===d&&s>1)break;if(void 0===(d=a[d]))throw Error(i);switch(s){case 0:n=d,s=1;break;case 1:t[r++]=n<<2|(48&d)>>4,n=d,s=2;break;case 2:t[r++]=(15&n)<<4|(60&d)>>2,n=d,s=3;break;case 3:t[r++]=(3&n)<<6|d,s=0}}if(1===s)throw Error(i);return r-o},r.test=function(e){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(e)}},9211:e=>{function t(){this._listeners={}}e.exports=t,t.prototype.on=function(e,t,r){return(this._listeners[e]||(this._listeners[e]=[])).push({fn:t,ctx:r||this}),this},t.prototype.off=function(e,t){if(void 0===e)this._listeners={};else if(void 0===t)this._listeners[e]=[];else for(var r=this._listeners[e],n=0;n<r.length;)r[n].fn===t?r.splice(n,1):++n;return this},t.prototype.emit=function(e){var t=this._listeners[e];if(t){for(var r=[],n=1;n<arguments.length;)r.push(arguments[n++]);for(n=0;n<t.length;)t[n].fn.apply(t[n++].ctx,r)}return this}},945:e=>{function t(e){return"undefined"!=typeof Float32Array?function(){var t=new Float32Array([-0]),r=new Uint8Array(t.buffer),n=128===r[3];function a(e,n,a){t[0]=e,n[a]=r[0],n[a+1]=r[1],n[a+2]=r[2],n[a+3]=r[3]}function o(e,n,a){t[0]=e,n[a]=r[3],n[a+1]=r[2],n[a+2]=r[1],n[a+3]=r[0]}function i(e,n){return r[0]=e[n],r[1]=e[n+1],r[2]=e[n+2],r[3]=e[n+3],t[0]}function s(e,n){return r[3]=e[n],r[2]=e[n+1],r[1]=e[n+2],r[0]=e[n+3],t[0]}e.writeFloatLE=n?a:o,e.writeFloatBE=n?o:a,e.readFloatLE=n?i:s,e.readFloatBE=n?s:i}():function(){function t(e,t,r,n){var a=t<0?1:0;if(a&&(t=-t),0===t)e(1/t>0?0:2147483648,r,n);else if(isNaN(t))e(2143289344,r,n);else if(t>34028234663852886e22)e((a<<31|2139095040)>>>0,r,n);else if(t<11754943508222875e-54)e((a<<31|Math.round(t/1401298464324817e-60))>>>0,r,n);else{var o=Math.floor(Math.log(t)/Math.LN2);e((a<<31|o+127<<23|8388607&Math.round(t*Math.pow(2,-o)*8388608))>>>0,r,n)}}function i(e,t,r){var n=e(t,r),a=2*(n>>31)+1,o=n>>>23&255,i=8388607&n;return 255===o?i?NaN:a*(1/0):0===o?1401298464324817e-60*a*i:a*Math.pow(2,o-150)*(i+8388608)}e.writeFloatLE=t.bind(null,r),e.writeFloatBE=t.bind(null,n),e.readFloatLE=i.bind(null,a),e.readFloatBE=i.bind(null,o)}(),"undefined"!=typeof Float64Array?function(){var t=new Float64Array([-0]),r=new Uint8Array(t.buffer),n=128===r[7];function a(e,n,a){t[0]=e,n[a]=r[0],n[a+1]=r[1],n[a+2]=r[2],n[a+3]=r[3],n[a+4]=r[4],n[a+5]=r[5],n[a+6]=r[6],n[a+7]=r[7]}function o(e,n,a){t[0]=e,n[a]=r[7],n[a+1]=r[6],n[a+2]=r[5],n[a+3]=r[4],n[a+4]=r[3],n[a+5]=r[2],n[a+6]=r[1],n[a+7]=r[0]}function i(e,n){return r[0]=e[n],r[1]=e[n+1],r[2]=e[n+2],r[3]=e[n+3],r[4]=e[n+4],r[5]=e[n+5],r[6]=e[n+6],r[7]=e[n+7],t[0]}function s(e,n){return r[7]=e[n],r[6]=e[n+1],r[5]=e[n+2],r[4]=e[n+3],r[3]=e[n+4],r[2]=e[n+5],r[1]=e[n+6],r[0]=e[n+7],t[0]}e.writeDoubleLE=n?a:o,e.writeDoubleBE=n?o:a,e.readDoubleLE=n?i:s,e.readDoubleBE=n?s:i}():function(){function t(e,t,r,n,a,o){var i=n<0?1:0;if(i&&(n=-n),0===n)e(0,a,o+t),e(1/n>0?0:2147483648,a,o+r);else if(isNaN(n))e(0,a,o+t),e(2146959360,a,o+r);else if(n>17976931348623157e292)e(0,a,o+t),e((i<<31|2146435072)>>>0,a,o+r);else{var s;if(n<22250738585072014e-324)e((s=n/5e-324)>>>0,a,o+t),e((i<<31|s/4294967296)>>>0,a,o+r);else{var l=Math.floor(Math.log(n)/Math.LN2);1024===l&&(l=1023),e(4503599627370496*(s=n*Math.pow(2,-l))>>>0,a,o+t),e((i<<31|l+1023<<20|1048576*s&1048575)>>>0,a,o+r)}}}function i(e,t,r,n,a){var o=e(n,a+t),i=e(n,a+r),s=2*(i>>31)+1,l=i>>>20&2047,d=4294967296*(1048575&i)+o;return 2047===l?d?NaN:s*(1/0):0===l?5e-324*s*d:s*Math.pow(2,l-1075)*(d+4503599627370496)}e.writeDoubleLE=t.bind(null,r,0,4),e.writeDoubleBE=t.bind(null,n,4,0),e.readDoubleLE=i.bind(null,a,0,4),e.readDoubleBE=i.bind(null,o,4,0)}(),e}function r(e,t,r){t[r]=255&e,t[r+1]=e>>>8&255,t[r+2]=e>>>16&255,t[r+3]=e>>>24}function n(e,t,r){t[r]=e>>>24,t[r+1]=e>>>16&255,t[r+2]=e>>>8&255,t[r+3]=255&e}function a(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0}function o(e,t){return(e[t]<<24|e[t+1]<<16|e[t+2]<<8|e[t+3])>>>0}e.exports=t(t)},7199:module=>{function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}module.exports=inquire},6662:e=>{e.exports=function(e,t,r){var n=r||8192,a=n>>>1,o=null,i=n;return function(r){if(r<1||r>a)return e(r);i+r>n&&(o=e(n),i=0);var s=t.call(o,i,i+=r);return 7&i&&(i=1+(7|i)),s}}},4997:(e,t)=>{var r=t;r.length=function(e){for(var t=0,r=0,n=0;n<e.length;++n)(r=e.charCodeAt(n))<128?t+=1:r<2048?t+=2:55296==(64512&r)&&56320==(64512&e.charCodeAt(n+1))?(++n,t+=4):t+=3;return t},r.read=function(e,t,r){if(r-t<1)return"";for(var n,a=null,o=[],i=0;t<r;)(n=e[t++])<128?o[i++]=n:n>191&&n<224?o[i++]=(31&n)<<6|63&e[t++]:n>239&&n<365?(n=((7&n)<<18|(63&e[t++])<<12|(63&e[t++])<<6|63&e[t++])-65536,o[i++]=55296+(n>>10),o[i++]=56320+(1023&n)):o[i++]=(15&n)<<12|(63&e[t++])<<6|63&e[t++],i>8191&&((a||(a=[])).push(String.fromCharCode.apply(String,o)),i=0);return a?(i&&a.push(String.fromCharCode.apply(String,o.slice(0,i))),a.join("")):String.fromCharCode.apply(String,o.slice(0,i))},r.write=function(e,t,r){for(var n,a,o=r,i=0;i<e.length;++i)(n=e.charCodeAt(i))<128?t[r++]=n:n<2048?(t[r++]=n>>6|192,t[r++]=63&n|128):55296==(64512&n)&&56320==(64512&(a=e.charCodeAt(i+1)))?(n=65536+((1023&n)<<10)+(1023&a),++i,t[r++]=n>>18|240,t[r++]=n>>12&63|128,t[r++]=n>>6&63|128,t[r++]=63&n|128):(t[r++]=n>>12|224,t[r++]=n>>6&63|128,t[r++]=63&n|128);return r-o}},3442:(e,t)=>{t.__esModule=!0;var r=function(){function e(t){if(!t)throw new TypeError("Invalid argument; `value` has no value.");this.value=e.EMPTY,t&&e.isGuid(t)&&(this.value=t)}return e.isGuid=function(t){var r=t.toString();return t&&(t instanceof e||e.validator.test(r))},e.create=function(){return new e([e.gen(2),e.gen(1),e.gen(1),e.gen(1),e.gen(3)].join("-"))},e.createEmpty=function(){return new e("emptyguid")},e.parse=function(t){return new e(t)},e.raw=function(){return[e.gen(2),e.gen(1),e.gen(1),e.gen(1),e.gen(3)].join("-")},e.gen=function(e){for(var t="",r=0;r<e;r++)t+=(65536*(1+Math.random())|0).toString(16).substring(1);return t},e.prototype.equals=function(t){return e.isGuid(t)&&this.value===t.toString()},e.prototype.isEmpty=function(){return this.value===e.EMPTY},e.prototype.toString=function(){return this.value},e.prototype.toJSON=function(){return{value:this.value}},e.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),e.EMPTY="00000000-0000-0000-0000-000000000000",e}();t.Guid=r},3720:e=>{e.exports=r;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(e){}function r(e,t,r){this.low=0|e,this.high=0|t,this.unsigned=!!r}function n(e){return!0===(e&&e.__isLong__)}r.prototype.__isLong__,Object.defineProperty(r.prototype,"__isLong__",{value:!0}),r.isLong=n;var a={},o={};function i(e,t){var r,n,i;return t?(i=0<=(e>>>=0)&&e<256)&&(n=o[e])?n:(r=l(e,(0|e)<0?-1:0,!0),i&&(o[e]=r),r):(i=-128<=(e|=0)&&e<128)&&(n=a[e])?n:(r=l(e,e<0?-1:0,!1),i&&(a[e]=r),r)}function s(e,t){if(isNaN(e))return t?m:B;if(t){if(e<0)return m;if(e>=g)return f}else{if(e<=-0x8000000000000000)return Q;if(e+1>=A)return K}return e<0?s(-e,t).neg():l(e%p|0,e/p|0,t)}function l(e,t,n){return new r(e,t,n)}r.fromInt=i,r.fromNumber=s,r.fromBits=l;var d=Math.pow;function u(e,t,r){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return B;if("number"==typeof t?(r=t,t=!1):t=!!t,(r=r||10)<2||36<r)throw RangeError("radix");var n;if((n=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===n)return u(e.substring(1),t,r).neg();for(var a=s(d(r,8)),o=B,i=0;i<e.length;i+=8){var l=Math.min(8,e.length-i),c=parseInt(e.substring(i,i+l),r);if(l<8){var p=s(d(r,l));o=o.mul(p).add(s(c))}else o=(o=o.mul(a)).add(s(c))}return o.unsigned=t,o}function c(e,t){return"number"==typeof e?s(e,t):"string"==typeof e?u(e,t):l(e.low,e.high,"boolean"==typeof t?t:e.unsigned)}r.fromString=u,r.fromValue=c;var p=4294967296,g=p*p,A=g/2,h=i(1<<24),B=i(0);r.ZERO=B;var m=i(0,!0);r.UZERO=m;var C=i(1);r.ONE=C;var w=i(1,!0);r.UONE=w;var b=i(-1);r.NEG_ONE=b;var K=l(-1,2147483647,!1);r.MAX_VALUE=K;var f=l(-1,-1,!0);r.MAX_UNSIGNED_VALUE=f;var Q=l(0,-2147483648,!1);r.MIN_VALUE=Q;var W=r.prototype;W.toInt=function(){return this.unsigned?this.low>>>0:this.low},W.toNumber=function(){return this.unsigned?(this.high>>>0)*p+(this.low>>>0):this.high*p+(this.low>>>0)},W.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(Q)){var t=s(e),r=this.div(t),n=r.mul(t).sub(this);return r.toString(e)+n.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var a=s(d(e,6),this.unsigned),o=this,i="";;){var l=o.div(a),u=(o.sub(l.mul(a)).toInt()>>>0).toString(e);if((o=l).isZero())return u+i;for(;u.length<6;)u="0"+u;i=""+u+i}},W.getHighBits=function(){return this.high},W.getHighBitsUnsigned=function(){return this.high>>>0},W.getLowBits=function(){return this.low},W.getLowBitsUnsigned=function(){return this.low>>>0},W.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Q)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return 0!=this.high?t+33:t+1},W.isZero=function(){return 0===this.high&&0===this.low},W.eqz=W.isZero,W.isNegative=function(){return!this.unsigned&&this.high<0},W.isPositive=function(){return this.unsigned||this.high>=0},W.isOdd=function(){return!(1&~this.low)},W.isEven=function(){return!(1&this.low)},W.equals=function(e){return n(e)||(e=c(e)),(this.unsigned===e.unsigned||this.high>>>31!=1||e.high>>>31!=1)&&this.high===e.high&&this.low===e.low},W.eq=W.equals,W.notEquals=function(e){return!this.eq(e)},W.neq=W.notEquals,W.ne=W.notEquals,W.lessThan=function(e){return this.comp(e)<0},W.lt=W.lessThan,W.lessThanOrEqual=function(e){return this.comp(e)<=0},W.lte=W.lessThanOrEqual,W.le=W.lessThanOrEqual,W.greaterThan=function(e){return this.comp(e)>0},W.gt=W.greaterThan,W.greaterThanOrEqual=function(e){return this.comp(e)>=0},W.gte=W.greaterThanOrEqual,W.ge=W.greaterThanOrEqual,W.compare=function(e){if(n(e)||(e=c(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},W.comp=W.compare,W.negate=function(){return!this.unsigned&&this.eq(Q)?Q:this.not().add(C)},W.neg=W.negate,W.add=function(e){n(e)||(e=c(e));var t=this.high>>>16,r=65535&this.high,a=this.low>>>16,o=65535&this.low,i=e.high>>>16,s=65535&e.high,d=e.low>>>16,u=0,p=0,g=0,A=0;return g+=(A+=o+(65535&e.low))>>>16,p+=(g+=a+d)>>>16,u+=(p+=r+s)>>>16,u+=t+i,l((g&=65535)<<16|(A&=65535),(u&=65535)<<16|(p&=65535),this.unsigned)},W.subtract=function(e){return n(e)||(e=c(e)),this.add(e.neg())},W.sub=W.subtract,W.multiply=function(e){if(this.isZero())return B;if(n(e)||(e=c(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return B;if(this.eq(Q))return e.isOdd()?Q:B;if(e.eq(Q))return this.isOdd()?Q:B;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(h)&&e.lt(h))return s(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,a=65535&this.high,o=this.low>>>16,i=65535&this.low,d=e.high>>>16,u=65535&e.high,p=e.low>>>16,g=65535&e.low,A=0,m=0,C=0,w=0;return C+=(w+=i*g)>>>16,m+=(C+=o*g)>>>16,C&=65535,m+=(C+=i*p)>>>16,A+=(m+=a*g)>>>16,m&=65535,A+=(m+=o*p)>>>16,m&=65535,A+=(m+=i*u)>>>16,A+=r*g+a*p+o*u+i*d,l((C&=65535)<<16|(w&=65535),(A&=65535)<<16|(m&=65535),this.unsigned)},W.mul=W.multiply,W.divide=function(e){if(n(e)||(e=c(e)),e.isZero())throw Error("division by zero");var r,a,o;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?m:B;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return m;if(e.gt(this.shru(1)))return w;o=m}else{if(this.eq(Q))return e.eq(C)||e.eq(b)?Q:e.eq(Q)?C:(r=this.shr(1).div(e).shl(1)).eq(B)?e.isNegative()?C:b:(a=this.sub(e.mul(r)),o=r.add(a.div(e)));if(e.eq(Q))return this.unsigned?m:B;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=B}for(a=this;a.gte(e);){r=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var i=Math.ceil(Math.log(r)/Math.LN2),u=i<=48?1:d(2,i-48),p=s(r),g=p.mul(e);g.isNegative()||g.gt(a);)g=(p=s(r-=u,this.unsigned)).mul(e);p.isZero()&&(p=C),o=o.add(p),a=a.sub(g)}return o},W.div=W.divide,W.modulo=function(e){return n(e)||(e=c(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},W.mod=W.modulo,W.rem=W.modulo,W.not=function(){return l(~this.low,~this.high,this.unsigned)},W.and=function(e){return n(e)||(e=c(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},W.or=function(e){return n(e)||(e=c(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},W.xor=function(e){return n(e)||(e=c(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},W.shiftLeft=function(e){return n(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},W.shl=W.shiftLeft,W.shiftRight=function(e){return n(e)&&(e=e.toInt()),0==(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},W.shr=W.shiftRight,W.shiftRightUnsigned=function(e){if(n(e)&&(e=e.toInt()),0==(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},W.shru=W.shiftRightUnsigned,W.shr_u=W.shiftRightUnsigned,W.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},W.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},W.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},W.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},W.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},r.fromBytes=function(e,t,n){return n?r.fromBytesLE(e,t):r.fromBytesBE(e,t)},r.fromBytesLE=function(e,t){return new r(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},r.fromBytesBE=function(e,t){return new r(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},1446:(e,t,r)=>{var n,a,o,i=r(2100),s=i.Reader,l=i.Writer,d=i.util,u=i.roots.default||(i.roots.default={});u.onnx=((o={}).Version=(n={},(a=Object.create(n))[n[0]="_START_VERSION"]=0,a[n[1]="IR_VERSION_2017_10_10"]=1,a[n[2]="IR_VERSION_2017_10_30"]=2,a[n[3]="IR_VERSION_2017_11_3"]=3,a[n[4]="IR_VERSION_2019_1_22"]=4,a[n[5]="IR_VERSION"]=5,a),o.AttributeProto=function(){function e(e){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.name="",e.prototype.refAttrName="",e.prototype.docString="",e.prototype.type=0,e.prototype.f=0,e.prototype.i=d.Long?d.Long.fromBits(0,0,!1):0,e.prototype.s=d.newBuffer([]),e.prototype.t=null,e.prototype.g=null,e.prototype.floats=d.emptyArray,e.prototype.ints=d.emptyArray,e.prototype.strings=d.emptyArray,e.prototype.tensors=d.emptyArray,e.prototype.graphs=d.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.name&&e.hasOwnProperty("name")&&t.uint32(10).string(e.name),null!=e.f&&e.hasOwnProperty("f")&&t.uint32(21).float(e.f),null!=e.i&&e.hasOwnProperty("i")&&t.uint32(24).int64(e.i),null!=e.s&&e.hasOwnProperty("s")&&t.uint32(34).bytes(e.s),null!=e.t&&e.hasOwnProperty("t")&&u.onnx.TensorProto.encode(e.t,t.uint32(42).fork()).ldelim(),null!=e.g&&e.hasOwnProperty("g")&&u.onnx.GraphProto.encode(e.g,t.uint32(50).fork()).ldelim(),null!=e.floats&&e.floats.length){t.uint32(58).fork();for(var r=0;r<e.floats.length;++r)t.float(e.floats[r]);t.ldelim()}if(null!=e.ints&&e.ints.length){for(t.uint32(66).fork(),r=0;r<e.ints.length;++r)t.int64(e.ints[r]);t.ldelim()}if(null!=e.strings&&e.strings.length)for(r=0;r<e.strings.length;++r)t.uint32(74).bytes(e.strings[r]);if(null!=e.tensors&&e.tensors.length)for(r=0;r<e.tensors.length;++r)u.onnx.TensorProto.encode(e.tensors[r],t.uint32(82).fork()).ldelim();if(null!=e.graphs&&e.graphs.length)for(r=0;r<e.graphs.length;++r)u.onnx.GraphProto.encode(e.graphs[r],t.uint32(90).fork()).ldelim();return null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(106).string(e.docString),null!=e.type&&e.hasOwnProperty("type")&&t.uint32(160).int32(e.type),null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&t.uint32(170).string(e.refAttrName),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.AttributeProto;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.name=e.string();break;case 21:n.refAttrName=e.string();break;case 13:n.docString=e.string();break;case 20:n.type=e.int32();break;case 2:n.f=e.float();break;case 3:n.i=e.int64();break;case 4:n.s=e.bytes();break;case 5:n.t=u.onnx.TensorProto.decode(e,e.uint32());break;case 6:n.g=u.onnx.GraphProto.decode(e,e.uint32());break;case 7:if(n.floats&&n.floats.length||(n.floats=[]),2==(7&a))for(var o=e.uint32()+e.pos;e.pos<o;)n.floats.push(e.float());else n.floats.push(e.float());break;case 8:if(n.ints&&n.ints.length||(n.ints=[]),2==(7&a))for(o=e.uint32()+e.pos;e.pos<o;)n.ints.push(e.int64());else n.ints.push(e.int64());break;case 9:n.strings&&n.strings.length||(n.strings=[]),n.strings.push(e.bytes());break;case 10:n.tensors&&n.tensors.length||(n.tensors=[]),n.tensors.push(u.onnx.TensorProto.decode(e,e.uint32()));break;case 11:n.graphs&&n.graphs.length||(n.graphs=[]),n.graphs.push(u.onnx.GraphProto.decode(e,e.uint32()));break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.name&&e.hasOwnProperty("name")&&!d.isString(e.name))return"name: string expected";if(null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&!d.isString(e.refAttrName))return"refAttrName: string expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!d.isString(e.docString))return"docString: string expected";if(null!=e.type&&e.hasOwnProperty("type"))switch(e.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 6:case 7:case 8:case 9:case 10:}if(null!=e.f&&e.hasOwnProperty("f")&&"number"!=typeof e.f)return"f: number expected";if(null!=e.i&&e.hasOwnProperty("i")&&!(d.isInteger(e.i)||e.i&&d.isInteger(e.i.low)&&d.isInteger(e.i.high)))return"i: integer|Long expected";if(null!=e.s&&e.hasOwnProperty("s")&&!(e.s&&"number"==typeof e.s.length||d.isString(e.s)))return"s: buffer expected";if(null!=e.t&&e.hasOwnProperty("t")&&(r=u.onnx.TensorProto.verify(e.t)))return"t."+r;if(null!=e.g&&e.hasOwnProperty("g")&&(r=u.onnx.GraphProto.verify(e.g)))return"g."+r;if(null!=e.floats&&e.hasOwnProperty("floats")){if(!Array.isArray(e.floats))return"floats: array expected";for(var t=0;t<e.floats.length;++t)if("number"!=typeof e.floats[t])return"floats: number[] expected"}if(null!=e.ints&&e.hasOwnProperty("ints")){if(!Array.isArray(e.ints))return"ints: array expected";for(t=0;t<e.ints.length;++t)if(!(d.isInteger(e.ints[t])||e.ints[t]&&d.isInteger(e.ints[t].low)&&d.isInteger(e.ints[t].high)))return"ints: integer|Long[] expected"}if(null!=e.strings&&e.hasOwnProperty("strings")){if(!Array.isArray(e.strings))return"strings: array expected";for(t=0;t<e.strings.length;++t)if(!(e.strings[t]&&"number"==typeof e.strings[t].length||d.isString(e.strings[t])))return"strings: buffer[] expected"}if(null!=e.tensors&&e.hasOwnProperty("tensors")){if(!Array.isArray(e.tensors))return"tensors: array expected";for(t=0;t<e.tensors.length;++t)if(r=u.onnx.TensorProto.verify(e.tensors[t]))return"tensors."+r}if(null!=e.graphs&&e.hasOwnProperty("graphs")){if(!Array.isArray(e.graphs))return"graphs: array expected";for(t=0;t<e.graphs.length;++t){var r;if(r=u.onnx.GraphProto.verify(e.graphs[t]))return"graphs."+r}}return null},e.fromObject=function(e){if(e instanceof u.onnx.AttributeProto)return e;var t=new u.onnx.AttributeProto;switch(null!=e.name&&(t.name=String(e.name)),null!=e.refAttrName&&(t.refAttrName=String(e.refAttrName)),null!=e.docString&&(t.docString=String(e.docString)),e.type){case"UNDEFINED":case 0:t.type=0;break;case"FLOAT":case 1:t.type=1;break;case"INT":case 2:t.type=2;break;case"STRING":case 3:t.type=3;break;case"TENSOR":case 4:t.type=4;break;case"GRAPH":case 5:t.type=5;break;case"FLOATS":case 6:t.type=6;break;case"INTS":case 7:t.type=7;break;case"STRINGS":case 8:t.type=8;break;case"TENSORS":case 9:t.type=9;break;case"GRAPHS":case 10:t.type=10}if(null!=e.f&&(t.f=Number(e.f)),null!=e.i&&(d.Long?(t.i=d.Long.fromValue(e.i)).unsigned=!1:"string"==typeof e.i?t.i=parseInt(e.i,10):"number"==typeof e.i?t.i=e.i:"object"==typeof e.i&&(t.i=new d.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber())),null!=e.s&&("string"==typeof e.s?d.base64.decode(e.s,t.s=d.newBuffer(d.base64.length(e.s)),0):e.s.length&&(t.s=e.s)),null!=e.t){if("object"!=typeof e.t)throw TypeError(".onnx.AttributeProto.t: object expected");t.t=u.onnx.TensorProto.fromObject(e.t)}if(null!=e.g){if("object"!=typeof e.g)throw TypeError(".onnx.AttributeProto.g: object expected");t.g=u.onnx.GraphProto.fromObject(e.g)}if(e.floats){if(!Array.isArray(e.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");t.floats=[];for(var r=0;r<e.floats.length;++r)t.floats[r]=Number(e.floats[r])}if(e.ints){if(!Array.isArray(e.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");for(t.ints=[],r=0;r<e.ints.length;++r)d.Long?(t.ints[r]=d.Long.fromValue(e.ints[r])).unsigned=!1:"string"==typeof e.ints[r]?t.ints[r]=parseInt(e.ints[r],10):"number"==typeof e.ints[r]?t.ints[r]=e.ints[r]:"object"==typeof e.ints[r]&&(t.ints[r]=new d.LongBits(e.ints[r].low>>>0,e.ints[r].high>>>0).toNumber())}if(e.strings){if(!Array.isArray(e.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");for(t.strings=[],r=0;r<e.strings.length;++r)"string"==typeof e.strings[r]?d.base64.decode(e.strings[r],t.strings[r]=d.newBuffer(d.base64.length(e.strings[r])),0):e.strings[r].length&&(t.strings[r]=e.strings[r])}if(e.tensors){if(!Array.isArray(e.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");for(t.tensors=[],r=0;r<e.tensors.length;++r){if("object"!=typeof e.tensors[r])throw TypeError(".onnx.AttributeProto.tensors: object expected");t.tensors[r]=u.onnx.TensorProto.fromObject(e.tensors[r])}}if(e.graphs){if(!Array.isArray(e.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");for(t.graphs=[],r=0;r<e.graphs.length;++r){if("object"!=typeof e.graphs[r])throw TypeError(".onnx.AttributeProto.graphs: object expected");t.graphs[r]=u.onnx.GraphProto.fromObject(e.graphs[r])}}return t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.floats=[],r.ints=[],r.strings=[],r.tensors=[],r.graphs=[]),t.defaults){if(r.name="",r.f=0,d.Long){var n=new d.Long(0,0,!1);r.i=t.longs===String?n.toString():t.longs===Number?n.toNumber():n}else r.i=t.longs===String?"0":0;t.bytes===String?r.s="":(r.s=[],t.bytes!==Array&&(r.s=d.newBuffer(r.s))),r.t=null,r.g=null,r.docString="",r.type=t.enums===String?"UNDEFINED":0,r.refAttrName=""}if(null!=e.name&&e.hasOwnProperty("name")&&(r.name=e.name),null!=e.f&&e.hasOwnProperty("f")&&(r.f=t.json&&!isFinite(e.f)?String(e.f):e.f),null!=e.i&&e.hasOwnProperty("i")&&("number"==typeof e.i?r.i=t.longs===String?String(e.i):e.i:r.i=t.longs===String?d.Long.prototype.toString.call(e.i):t.longs===Number?new d.LongBits(e.i.low>>>0,e.i.high>>>0).toNumber():e.i),null!=e.s&&e.hasOwnProperty("s")&&(r.s=t.bytes===String?d.base64.encode(e.s,0,e.s.length):t.bytes===Array?Array.prototype.slice.call(e.s):e.s),null!=e.t&&e.hasOwnProperty("t")&&(r.t=u.onnx.TensorProto.toObject(e.t,t)),null!=e.g&&e.hasOwnProperty("g")&&(r.g=u.onnx.GraphProto.toObject(e.g,t)),e.floats&&e.floats.length){r.floats=[];for(var a=0;a<e.floats.length;++a)r.floats[a]=t.json&&!isFinite(e.floats[a])?String(e.floats[a]):e.floats[a]}if(e.ints&&e.ints.length)for(r.ints=[],a=0;a<e.ints.length;++a)"number"==typeof e.ints[a]?r.ints[a]=t.longs===String?String(e.ints[a]):e.ints[a]:r.ints[a]=t.longs===String?d.Long.prototype.toString.call(e.ints[a]):t.longs===Number?new d.LongBits(e.ints[a].low>>>0,e.ints[a].high>>>0).toNumber():e.ints[a];if(e.strings&&e.strings.length)for(r.strings=[],a=0;a<e.strings.length;++a)r.strings[a]=t.bytes===String?d.base64.encode(e.strings[a],0,e.strings[a].length):t.bytes===Array?Array.prototype.slice.call(e.strings[a]):e.strings[a];if(e.tensors&&e.tensors.length)for(r.tensors=[],a=0;a<e.tensors.length;++a)r.tensors[a]=u.onnx.TensorProto.toObject(e.tensors[a],t);if(e.graphs&&e.graphs.length)for(r.graphs=[],a=0;a<e.graphs.length;++a)r.graphs[a]=u.onnx.GraphProto.toObject(e.graphs[a],t);return null!=e.docString&&e.hasOwnProperty("docString")&&(r.docString=e.docString),null!=e.type&&e.hasOwnProperty("type")&&(r.type=t.enums===String?u.onnx.AttributeProto.AttributeType[e.type]:e.type),null!=e.refAttrName&&e.hasOwnProperty("refAttrName")&&(r.refAttrName=e.refAttrName),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.AttributeType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="INT"]=2,t[e[3]="STRING"]=3,t[e[4]="TENSOR"]=4,t[e[5]="GRAPH"]=5,t[e[6]="FLOATS"]=6,t[e[7]="INTS"]=7,t[e[8]="STRINGS"]=8,t[e[9]="TENSORS"]=9,t[e[10]="GRAPHS"]=10,t}(),e}(),o.ValueInfoProto=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.name="",e.prototype.type=null,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.name&&e.hasOwnProperty("name")&&t.uint32(10).string(e.name),null!=e.type&&e.hasOwnProperty("type")&&u.onnx.TypeProto.encode(e.type,t.uint32(18).fork()).ldelim(),null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(26).string(e.docString),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.ValueInfoProto;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.name=e.string();break;case 2:n.type=u.onnx.TypeProto.decode(e,e.uint32());break;case 3:n.docString=e.string();break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.name&&e.hasOwnProperty("name")&&!d.isString(e.name))return"name: string expected";if(null!=e.type&&e.hasOwnProperty("type")){var t=u.onnx.TypeProto.verify(e.type);if(t)return"type."+t}return null!=e.docString&&e.hasOwnProperty("docString")&&!d.isString(e.docString)?"docString: string expected":null},e.fromObject=function(e){if(e instanceof u.onnx.ValueInfoProto)return e;var t=new u.onnx.ValueInfoProto;if(null!=e.name&&(t.name=String(e.name)),null!=e.type){if("object"!=typeof e.type)throw TypeError(".onnx.ValueInfoProto.type: object expected");t.type=u.onnx.TypeProto.fromObject(e.type)}return null!=e.docString&&(t.docString=String(e.docString)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.name="",r.type=null,r.docString=""),null!=e.name&&e.hasOwnProperty("name")&&(r.name=e.name),null!=e.type&&e.hasOwnProperty("type")&&(r.type=u.onnx.TypeProto.toObject(e.type,t)),null!=e.docString&&e.hasOwnProperty("docString")&&(r.docString=e.docString),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),o.NodeProto=function(){function e(e){if(this.input=[],this.output=[],this.attribute=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.input=d.emptyArray,e.prototype.output=d.emptyArray,e.prototype.name="",e.prototype.opType="",e.prototype.domain="",e.prototype.attribute=d.emptyArray,e.prototype.docString="",e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.input&&e.input.length)for(var r=0;r<e.input.length;++r)t.uint32(10).string(e.input[r]);if(null!=e.output&&e.output.length)for(r=0;r<e.output.length;++r)t.uint32(18).string(e.output[r]);if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(26).string(e.name),null!=e.opType&&e.hasOwnProperty("opType")&&t.uint32(34).string(e.opType),null!=e.attribute&&e.attribute.length)for(r=0;r<e.attribute.length;++r)u.onnx.AttributeProto.encode(e.attribute[r],t.uint32(42).fork()).ldelim();return null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(50).string(e.docString),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(58).string(e.domain),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.NodeProto;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.input&&n.input.length||(n.input=[]),n.input.push(e.string());break;case 2:n.output&&n.output.length||(n.output=[]),n.output.push(e.string());break;case 3:n.name=e.string();break;case 4:n.opType=e.string();break;case 7:n.domain=e.string();break;case 5:n.attribute&&n.attribute.length||(n.attribute=[]),n.attribute.push(u.onnx.AttributeProto.decode(e,e.uint32()));break;case 6:n.docString=e.string();break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.input&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(var t=0;t<e.input.length;++t)if(!d.isString(e.input[t]))return"input: string[] expected"}if(null!=e.output&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(!d.isString(e.output[t]))return"output: string[] expected"}if(null!=e.name&&e.hasOwnProperty("name")&&!d.isString(e.name))return"name: string expected";if(null!=e.opType&&e.hasOwnProperty("opType")&&!d.isString(e.opType))return"opType: string expected";if(null!=e.domain&&e.hasOwnProperty("domain")&&!d.isString(e.domain))return"domain: string expected";if(null!=e.attribute&&e.hasOwnProperty("attribute")){if(!Array.isArray(e.attribute))return"attribute: array expected";for(t=0;t<e.attribute.length;++t){var r=u.onnx.AttributeProto.verify(e.attribute[t]);if(r)return"attribute."+r}}return null!=e.docString&&e.hasOwnProperty("docString")&&!d.isString(e.docString)?"docString: string expected":null},e.fromObject=function(e){if(e instanceof u.onnx.NodeProto)return e;var t=new u.onnx.NodeProto;if(e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.NodeProto.input: array expected");t.input=[];for(var r=0;r<e.input.length;++r)t.input[r]=String(e.input[r])}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.NodeProto.output: array expected");for(t.output=[],r=0;r<e.output.length;++r)t.output[r]=String(e.output[r])}if(null!=e.name&&(t.name=String(e.name)),null!=e.opType&&(t.opType=String(e.opType)),null!=e.domain&&(t.domain=String(e.domain)),e.attribute){if(!Array.isArray(e.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");for(t.attribute=[],r=0;r<e.attribute.length;++r){if("object"!=typeof e.attribute[r])throw TypeError(".onnx.NodeProto.attribute: object expected");t.attribute[r]=u.onnx.AttributeProto.fromObject(e.attribute[r])}}return null!=e.docString&&(t.docString=String(e.docString)),t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.input=[],r.output=[],r.attribute=[]),t.defaults&&(r.name="",r.opType="",r.docString="",r.domain=""),e.input&&e.input.length){r.input=[];for(var n=0;n<e.input.length;++n)r.input[n]=e.input[n]}if(e.output&&e.output.length)for(r.output=[],n=0;n<e.output.length;++n)r.output[n]=e.output[n];if(null!=e.name&&e.hasOwnProperty("name")&&(r.name=e.name),null!=e.opType&&e.hasOwnProperty("opType")&&(r.opType=e.opType),e.attribute&&e.attribute.length)for(r.attribute=[],n=0;n<e.attribute.length;++n)r.attribute[n]=u.onnx.AttributeProto.toObject(e.attribute[n],t);return null!=e.docString&&e.hasOwnProperty("docString")&&(r.docString=e.docString),null!=e.domain&&e.hasOwnProperty("domain")&&(r.domain=e.domain),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),o.ModelProto=function(){function e(e){if(this.opsetImport=[],this.metadataProps=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.irVersion=d.Long?d.Long.fromBits(0,0,!1):0,e.prototype.opsetImport=d.emptyArray,e.prototype.producerName="",e.prototype.producerVersion="",e.prototype.domain="",e.prototype.modelVersion=d.Long?d.Long.fromBits(0,0,!1):0,e.prototype.docString="",e.prototype.graph=null,e.prototype.metadataProps=d.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.irVersion&&e.hasOwnProperty("irVersion")&&t.uint32(8).int64(e.irVersion),null!=e.producerName&&e.hasOwnProperty("producerName")&&t.uint32(18).string(e.producerName),null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&t.uint32(26).string(e.producerVersion),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(34).string(e.domain),null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&t.uint32(40).int64(e.modelVersion),null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(50).string(e.docString),null!=e.graph&&e.hasOwnProperty("graph")&&u.onnx.GraphProto.encode(e.graph,t.uint32(58).fork()).ldelim(),null!=e.opsetImport&&e.opsetImport.length)for(var r=0;r<e.opsetImport.length;++r)u.onnx.OperatorSetIdProto.encode(e.opsetImport[r],t.uint32(66).fork()).ldelim();if(null!=e.metadataProps&&e.metadataProps.length)for(r=0;r<e.metadataProps.length;++r)u.onnx.StringStringEntryProto.encode(e.metadataProps[r],t.uint32(114).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.ModelProto;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.irVersion=e.int64();break;case 8:n.opsetImport&&n.opsetImport.length||(n.opsetImport=[]),n.opsetImport.push(u.onnx.OperatorSetIdProto.decode(e,e.uint32()));break;case 2:n.producerName=e.string();break;case 3:n.producerVersion=e.string();break;case 4:n.domain=e.string();break;case 5:n.modelVersion=e.int64();break;case 6:n.docString=e.string();break;case 7:n.graph=u.onnx.GraphProto.decode(e,e.uint32());break;case 14:n.metadataProps&&n.metadataProps.length||(n.metadataProps=[]),n.metadataProps.push(u.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.irVersion&&e.hasOwnProperty("irVersion")&&!(d.isInteger(e.irVersion)||e.irVersion&&d.isInteger(e.irVersion.low)&&d.isInteger(e.irVersion.high)))return"irVersion: integer|Long expected";if(null!=e.opsetImport&&e.hasOwnProperty("opsetImport")){if(!Array.isArray(e.opsetImport))return"opsetImport: array expected";for(var t=0;t<e.opsetImport.length;++t)if(r=u.onnx.OperatorSetIdProto.verify(e.opsetImport[t]))return"opsetImport."+r}if(null!=e.producerName&&e.hasOwnProperty("producerName")&&!d.isString(e.producerName))return"producerName: string expected";if(null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&!d.isString(e.producerVersion))return"producerVersion: string expected";if(null!=e.domain&&e.hasOwnProperty("domain")&&!d.isString(e.domain))return"domain: string expected";if(null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&!(d.isInteger(e.modelVersion)||e.modelVersion&&d.isInteger(e.modelVersion.low)&&d.isInteger(e.modelVersion.high)))return"modelVersion: integer|Long expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!d.isString(e.docString))return"docString: string expected";if(null!=e.graph&&e.hasOwnProperty("graph")&&(r=u.onnx.GraphProto.verify(e.graph)))return"graph."+r;if(null!=e.metadataProps&&e.hasOwnProperty("metadataProps")){if(!Array.isArray(e.metadataProps))return"metadataProps: array expected";for(t=0;t<e.metadataProps.length;++t){var r;if(r=u.onnx.StringStringEntryProto.verify(e.metadataProps[t]))return"metadataProps."+r}}return null},e.fromObject=function(e){if(e instanceof u.onnx.ModelProto)return e;var t=new u.onnx.ModelProto;if(null!=e.irVersion&&(d.Long?(t.irVersion=d.Long.fromValue(e.irVersion)).unsigned=!1:"string"==typeof e.irVersion?t.irVersion=parseInt(e.irVersion,10):"number"==typeof e.irVersion?t.irVersion=e.irVersion:"object"==typeof e.irVersion&&(t.irVersion=new d.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber())),e.opsetImport){if(!Array.isArray(e.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");t.opsetImport=[];for(var r=0;r<e.opsetImport.length;++r){if("object"!=typeof e.opsetImport[r])throw TypeError(".onnx.ModelProto.opsetImport: object expected");t.opsetImport[r]=u.onnx.OperatorSetIdProto.fromObject(e.opsetImport[r])}}if(null!=e.producerName&&(t.producerName=String(e.producerName)),null!=e.producerVersion&&(t.producerVersion=String(e.producerVersion)),null!=e.domain&&(t.domain=String(e.domain)),null!=e.modelVersion&&(d.Long?(t.modelVersion=d.Long.fromValue(e.modelVersion)).unsigned=!1:"string"==typeof e.modelVersion?t.modelVersion=parseInt(e.modelVersion,10):"number"==typeof e.modelVersion?t.modelVersion=e.modelVersion:"object"==typeof e.modelVersion&&(t.modelVersion=new d.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber())),null!=e.docString&&(t.docString=String(e.docString)),null!=e.graph){if("object"!=typeof e.graph)throw TypeError(".onnx.ModelProto.graph: object expected");t.graph=u.onnx.GraphProto.fromObject(e.graph)}if(e.metadataProps){if(!Array.isArray(e.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");for(t.metadataProps=[],r=0;r<e.metadataProps.length;++r){if("object"!=typeof e.metadataProps[r])throw TypeError(".onnx.ModelProto.metadataProps: object expected");t.metadataProps[r]=u.onnx.StringStringEntryProto.fromObject(e.metadataProps[r])}}return t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.opsetImport=[],r.metadataProps=[]),t.defaults){if(d.Long){var n=new d.Long(0,0,!1);r.irVersion=t.longs===String?n.toString():t.longs===Number?n.toNumber():n}else r.irVersion=t.longs===String?"0":0;r.producerName="",r.producerVersion="",r.domain="",d.Long?(n=new d.Long(0,0,!1),r.modelVersion=t.longs===String?n.toString():t.longs===Number?n.toNumber():n):r.modelVersion=t.longs===String?"0":0,r.docString="",r.graph=null}if(null!=e.irVersion&&e.hasOwnProperty("irVersion")&&("number"==typeof e.irVersion?r.irVersion=t.longs===String?String(e.irVersion):e.irVersion:r.irVersion=t.longs===String?d.Long.prototype.toString.call(e.irVersion):t.longs===Number?new d.LongBits(e.irVersion.low>>>0,e.irVersion.high>>>0).toNumber():e.irVersion),null!=e.producerName&&e.hasOwnProperty("producerName")&&(r.producerName=e.producerName),null!=e.producerVersion&&e.hasOwnProperty("producerVersion")&&(r.producerVersion=e.producerVersion),null!=e.domain&&e.hasOwnProperty("domain")&&(r.domain=e.domain),null!=e.modelVersion&&e.hasOwnProperty("modelVersion")&&("number"==typeof e.modelVersion?r.modelVersion=t.longs===String?String(e.modelVersion):e.modelVersion:r.modelVersion=t.longs===String?d.Long.prototype.toString.call(e.modelVersion):t.longs===Number?new d.LongBits(e.modelVersion.low>>>0,e.modelVersion.high>>>0).toNumber():e.modelVersion),null!=e.docString&&e.hasOwnProperty("docString")&&(r.docString=e.docString),null!=e.graph&&e.hasOwnProperty("graph")&&(r.graph=u.onnx.GraphProto.toObject(e.graph,t)),e.opsetImport&&e.opsetImport.length){r.opsetImport=[];for(var a=0;a<e.opsetImport.length;++a)r.opsetImport[a]=u.onnx.OperatorSetIdProto.toObject(e.opsetImport[a],t)}if(e.metadataProps&&e.metadataProps.length)for(r.metadataProps=[],a=0;a<e.metadataProps.length;++a)r.metadataProps[a]=u.onnx.StringStringEntryProto.toObject(e.metadataProps[a],t);return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),o.StringStringEntryProto=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.key="",e.prototype.value="",e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.key&&e.hasOwnProperty("key")&&t.uint32(10).string(e.key),null!=e.value&&e.hasOwnProperty("value")&&t.uint32(18).string(e.value),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.StringStringEntryProto;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.key=e.string();break;case 2:n.value=e.string();break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.key&&e.hasOwnProperty("key")&&!d.isString(e.key)?"key: string expected":null!=e.value&&e.hasOwnProperty("value")&&!d.isString(e.value)?"value: string expected":null},e.fromObject=function(e){if(e instanceof u.onnx.StringStringEntryProto)return e;var t=new u.onnx.StringStringEntryProto;return null!=e.key&&(t.key=String(e.key)),null!=e.value&&(t.value=String(e.value)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.key="",r.value=""),null!=e.key&&e.hasOwnProperty("key")&&(r.key=e.key),null!=e.value&&e.hasOwnProperty("value")&&(r.value=e.value),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),o.TensorAnnotation=function(){function e(e){if(this.quantParameterTensorNames=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.tensorName="",e.prototype.quantParameterTensorNames=d.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.tensorName&&e.hasOwnProperty("tensorName")&&t.uint32(10).string(e.tensorName),null!=e.quantParameterTensorNames&&e.quantParameterTensorNames.length)for(var r=0;r<e.quantParameterTensorNames.length;++r)u.onnx.StringStringEntryProto.encode(e.quantParameterTensorNames[r],t.uint32(18).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.TensorAnnotation;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.tensorName=e.string();break;case 2:n.quantParameterTensorNames&&n.quantParameterTensorNames.length||(n.quantParameterTensorNames=[]),n.quantParameterTensorNames.push(u.onnx.StringStringEntryProto.decode(e,e.uint32()));break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.tensorName&&e.hasOwnProperty("tensorName")&&!d.isString(e.tensorName))return"tensorName: string expected";if(null!=e.quantParameterTensorNames&&e.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(e.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var t=0;t<e.quantParameterTensorNames.length;++t){var r=u.onnx.StringStringEntryProto.verify(e.quantParameterTensorNames[t]);if(r)return"quantParameterTensorNames."+r}}return null},e.fromObject=function(e){if(e instanceof u.onnx.TensorAnnotation)return e;var t=new u.onnx.TensorAnnotation;if(null!=e.tensorName&&(t.tensorName=String(e.tensorName)),e.quantParameterTensorNames){if(!Array.isArray(e.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");t.quantParameterTensorNames=[];for(var r=0;r<e.quantParameterTensorNames.length;++r){if("object"!=typeof e.quantParameterTensorNames[r])throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");t.quantParameterTensorNames[r]=u.onnx.StringStringEntryProto.fromObject(e.quantParameterTensorNames[r])}}return t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.quantParameterTensorNames=[]),t.defaults&&(r.tensorName=""),null!=e.tensorName&&e.hasOwnProperty("tensorName")&&(r.tensorName=e.tensorName),e.quantParameterTensorNames&&e.quantParameterTensorNames.length){r.quantParameterTensorNames=[];for(var n=0;n<e.quantParameterTensorNames.length;++n)r.quantParameterTensorNames[n]=u.onnx.StringStringEntryProto.toObject(e.quantParameterTensorNames[n],t)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),o.GraphProto=function(){function e(e){if(this.node=[],this.initializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.node=d.emptyArray,e.prototype.name="",e.prototype.initializer=d.emptyArray,e.prototype.docString="",e.prototype.input=d.emptyArray,e.prototype.output=d.emptyArray,e.prototype.valueInfo=d.emptyArray,e.prototype.quantizationAnnotation=d.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.node&&e.node.length)for(var r=0;r<e.node.length;++r)u.onnx.NodeProto.encode(e.node[r],t.uint32(10).fork()).ldelim();if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(18).string(e.name),null!=e.initializer&&e.initializer.length)for(r=0;r<e.initializer.length;++r)u.onnx.TensorProto.encode(e.initializer[r],t.uint32(42).fork()).ldelim();if(null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(82).string(e.docString),null!=e.input&&e.input.length)for(r=0;r<e.input.length;++r)u.onnx.ValueInfoProto.encode(e.input[r],t.uint32(90).fork()).ldelim();if(null!=e.output&&e.output.length)for(r=0;r<e.output.length;++r)u.onnx.ValueInfoProto.encode(e.output[r],t.uint32(98).fork()).ldelim();if(null!=e.valueInfo&&e.valueInfo.length)for(r=0;r<e.valueInfo.length;++r)u.onnx.ValueInfoProto.encode(e.valueInfo[r],t.uint32(106).fork()).ldelim();if(null!=e.quantizationAnnotation&&e.quantizationAnnotation.length)for(r=0;r<e.quantizationAnnotation.length;++r)u.onnx.TensorAnnotation.encode(e.quantizationAnnotation[r],t.uint32(114).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.GraphProto;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.node&&n.node.length||(n.node=[]),n.node.push(u.onnx.NodeProto.decode(e,e.uint32()));break;case 2:n.name=e.string();break;case 5:n.initializer&&n.initializer.length||(n.initializer=[]),n.initializer.push(u.onnx.TensorProto.decode(e,e.uint32()));break;case 10:n.docString=e.string();break;case 11:n.input&&n.input.length||(n.input=[]),n.input.push(u.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 12:n.output&&n.output.length||(n.output=[]),n.output.push(u.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 13:n.valueInfo&&n.valueInfo.length||(n.valueInfo=[]),n.valueInfo.push(u.onnx.ValueInfoProto.decode(e,e.uint32()));break;case 14:n.quantizationAnnotation&&n.quantizationAnnotation.length||(n.quantizationAnnotation=[]),n.quantizationAnnotation.push(u.onnx.TensorAnnotation.decode(e,e.uint32()));break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.node&&e.hasOwnProperty("node")){if(!Array.isArray(e.node))return"node: array expected";for(var t=0;t<e.node.length;++t)if(r=u.onnx.NodeProto.verify(e.node[t]))return"node."+r}if(null!=e.name&&e.hasOwnProperty("name")&&!d.isString(e.name))return"name: string expected";if(null!=e.initializer&&e.hasOwnProperty("initializer")){if(!Array.isArray(e.initializer))return"initializer: array expected";for(t=0;t<e.initializer.length;++t)if(r=u.onnx.TensorProto.verify(e.initializer[t]))return"initializer."+r}if(null!=e.docString&&e.hasOwnProperty("docString")&&!d.isString(e.docString))return"docString: string expected";if(null!=e.input&&e.hasOwnProperty("input")){if(!Array.isArray(e.input))return"input: array expected";for(t=0;t<e.input.length;++t)if(r=u.onnx.ValueInfoProto.verify(e.input[t]))return"input."+r}if(null!=e.output&&e.hasOwnProperty("output")){if(!Array.isArray(e.output))return"output: array expected";for(t=0;t<e.output.length;++t)if(r=u.onnx.ValueInfoProto.verify(e.output[t]))return"output."+r}if(null!=e.valueInfo&&e.hasOwnProperty("valueInfo")){if(!Array.isArray(e.valueInfo))return"valueInfo: array expected";for(t=0;t<e.valueInfo.length;++t)if(r=u.onnx.ValueInfoProto.verify(e.valueInfo[t]))return"valueInfo."+r}if(null!=e.quantizationAnnotation&&e.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(e.quantizationAnnotation))return"quantizationAnnotation: array expected";for(t=0;t<e.quantizationAnnotation.length;++t){var r;if(r=u.onnx.TensorAnnotation.verify(e.quantizationAnnotation[t]))return"quantizationAnnotation."+r}}return null},e.fromObject=function(e){if(e instanceof u.onnx.GraphProto)return e;var t=new u.onnx.GraphProto;if(e.node){if(!Array.isArray(e.node))throw TypeError(".onnx.GraphProto.node: array expected");t.node=[];for(var r=0;r<e.node.length;++r){if("object"!=typeof e.node[r])throw TypeError(".onnx.GraphProto.node: object expected");t.node[r]=u.onnx.NodeProto.fromObject(e.node[r])}}if(null!=e.name&&(t.name=String(e.name)),e.initializer){if(!Array.isArray(e.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");for(t.initializer=[],r=0;r<e.initializer.length;++r){if("object"!=typeof e.initializer[r])throw TypeError(".onnx.GraphProto.initializer: object expected");t.initializer[r]=u.onnx.TensorProto.fromObject(e.initializer[r])}}if(null!=e.docString&&(t.docString=String(e.docString)),e.input){if(!Array.isArray(e.input))throw TypeError(".onnx.GraphProto.input: array expected");for(t.input=[],r=0;r<e.input.length;++r){if("object"!=typeof e.input[r])throw TypeError(".onnx.GraphProto.input: object expected");t.input[r]=u.onnx.ValueInfoProto.fromObject(e.input[r])}}if(e.output){if(!Array.isArray(e.output))throw TypeError(".onnx.GraphProto.output: array expected");for(t.output=[],r=0;r<e.output.length;++r){if("object"!=typeof e.output[r])throw TypeError(".onnx.GraphProto.output: object expected");t.output[r]=u.onnx.ValueInfoProto.fromObject(e.output[r])}}if(e.valueInfo){if(!Array.isArray(e.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");for(t.valueInfo=[],r=0;r<e.valueInfo.length;++r){if("object"!=typeof e.valueInfo[r])throw TypeError(".onnx.GraphProto.valueInfo: object expected");t.valueInfo[r]=u.onnx.ValueInfoProto.fromObject(e.valueInfo[r])}}if(e.quantizationAnnotation){if(!Array.isArray(e.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");for(t.quantizationAnnotation=[],r=0;r<e.quantizationAnnotation.length;++r){if("object"!=typeof e.quantizationAnnotation[r])throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");t.quantizationAnnotation[r]=u.onnx.TensorAnnotation.fromObject(e.quantizationAnnotation[r])}}return t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.node=[],r.initializer=[],r.input=[],r.output=[],r.valueInfo=[],r.quantizationAnnotation=[]),t.defaults&&(r.name="",r.docString=""),e.node&&e.node.length){r.node=[];for(var n=0;n<e.node.length;++n)r.node[n]=u.onnx.NodeProto.toObject(e.node[n],t)}if(null!=e.name&&e.hasOwnProperty("name")&&(r.name=e.name),e.initializer&&e.initializer.length)for(r.initializer=[],n=0;n<e.initializer.length;++n)r.initializer[n]=u.onnx.TensorProto.toObject(e.initializer[n],t);if(null!=e.docString&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.input&&e.input.length)for(r.input=[],n=0;n<e.input.length;++n)r.input[n]=u.onnx.ValueInfoProto.toObject(e.input[n],t);if(e.output&&e.output.length)for(r.output=[],n=0;n<e.output.length;++n)r.output[n]=u.onnx.ValueInfoProto.toObject(e.output[n],t);if(e.valueInfo&&e.valueInfo.length)for(r.valueInfo=[],n=0;n<e.valueInfo.length;++n)r.valueInfo[n]=u.onnx.ValueInfoProto.toObject(e.valueInfo[n],t);if(e.quantizationAnnotation&&e.quantizationAnnotation.length)for(r.quantizationAnnotation=[],n=0;n<e.quantizationAnnotation.length;++n)r.quantizationAnnotation[n]=u.onnx.TensorAnnotation.toObject(e.quantizationAnnotation[n],t);return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),o.TensorProto=function(){function e(e){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.dims=d.emptyArray,e.prototype.dataType=0,e.prototype.segment=null,e.prototype.floatData=d.emptyArray,e.prototype.int32Data=d.emptyArray,e.prototype.stringData=d.emptyArray,e.prototype.int64Data=d.emptyArray,e.prototype.name="",e.prototype.docString="",e.prototype.rawData=d.newBuffer([]),e.prototype.externalData=d.emptyArray,e.prototype.dataLocation=0,e.prototype.doubleData=d.emptyArray,e.prototype.uint64Data=d.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.dims&&e.dims.length){t.uint32(10).fork();for(var r=0;r<e.dims.length;++r)t.int64(e.dims[r]);t.ldelim()}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&t.uint32(16).int32(e.dataType),null!=e.segment&&e.hasOwnProperty("segment")&&u.onnx.TensorProto.Segment.encode(e.segment,t.uint32(26).fork()).ldelim(),null!=e.floatData&&e.floatData.length){for(t.uint32(34).fork(),r=0;r<e.floatData.length;++r)t.float(e.floatData[r]);t.ldelim()}if(null!=e.int32Data&&e.int32Data.length){for(t.uint32(42).fork(),r=0;r<e.int32Data.length;++r)t.int32(e.int32Data[r]);t.ldelim()}if(null!=e.stringData&&e.stringData.length)for(r=0;r<e.stringData.length;++r)t.uint32(50).bytes(e.stringData[r]);if(null!=e.int64Data&&e.int64Data.length){for(t.uint32(58).fork(),r=0;r<e.int64Data.length;++r)t.int64(e.int64Data[r]);t.ldelim()}if(null!=e.name&&e.hasOwnProperty("name")&&t.uint32(66).string(e.name),null!=e.rawData&&e.hasOwnProperty("rawData")&&t.uint32(74).bytes(e.rawData),null!=e.doubleData&&e.doubleData.length){for(t.uint32(82).fork(),r=0;r<e.doubleData.length;++r)t.double(e.doubleData[r]);t.ldelim()}if(null!=e.uint64Data&&e.uint64Data.length){for(t.uint32(90).fork(),r=0;r<e.uint64Data.length;++r)t.uint64(e.uint64Data[r]);t.ldelim()}if(null!=e.docString&&e.hasOwnProperty("docString")&&t.uint32(98).string(e.docString),null!=e.externalData&&e.externalData.length)for(r=0;r<e.externalData.length;++r)u.onnx.StringStringEntryProto.encode(e.externalData[r],t.uint32(106).fork()).ldelim();return null!=e.dataLocation&&e.hasOwnProperty("dataLocation")&&t.uint32(112).int32(e.dataLocation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.TensorProto;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:if(n.dims&&n.dims.length||(n.dims=[]),2==(7&a))for(var o=e.uint32()+e.pos;e.pos<o;)n.dims.push(e.int64());else n.dims.push(e.int64());break;case 2:n.dataType=e.int32();break;case 3:n.segment=u.onnx.TensorProto.Segment.decode(e,e.uint32());break;case 4:if(n.floatData&&n.floatData.length||(n.floatData=[]),2==(7&a))for(o=e.uint32()+e.pos;e.pos<o;)n.floatData.push(e.float());else n.floatData.push(e.float());break;case 5:if(n.int32Data&&n.int32Data.length||(n.int32Data=[]),2==(7&a))for(o=e.uint32()+e.pos;e.pos<o;)n.int32Data.push(e.int32());else n.int32Data.push(e.int32());break;case 6:n.stringData&&n.stringData.length||(n.stringData=[]),n.stringData.push(e.bytes());break;case 7:if(n.int64Data&&n.int64Data.length||(n.int64Data=[]),2==(7&a))for(o=e.uint32()+e.pos;e.pos<o;)n.int64Data.push(e.int64());else n.int64Data.push(e.int64());break;case 8:n.name=e.string();break;case 12:n.docString=e.string();break;case 9:n.rawData=e.bytes();break;case 13:n.externalData&&n.externalData.length||(n.externalData=[]),n.externalData.push(u.onnx.StringStringEntryProto.decode(e,e.uint32()));break;case 14:n.dataLocation=e.int32();break;case 10:if(n.doubleData&&n.doubleData.length||(n.doubleData=[]),2==(7&a))for(o=e.uint32()+e.pos;e.pos<o;)n.doubleData.push(e.double());else n.doubleData.push(e.double());break;case 11:if(n.uint64Data&&n.uint64Data.length||(n.uint64Data=[]),2==(7&a))for(o=e.uint32()+e.pos;e.pos<o;)n.uint64Data.push(e.uint64());else n.uint64Data.push(e.uint64());break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.dims&&e.hasOwnProperty("dims")){if(!Array.isArray(e.dims))return"dims: array expected";for(var t=0;t<e.dims.length;++t)if(!(d.isInteger(e.dims[t])||e.dims[t]&&d.isInteger(e.dims[t].low)&&d.isInteger(e.dims[t].high)))return"dims: integer|Long[] expected"}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&!d.isInteger(e.dataType))return"dataType: integer expected";if(null!=e.segment&&e.hasOwnProperty("segment")&&(r=u.onnx.TensorProto.Segment.verify(e.segment)))return"segment."+r;if(null!=e.floatData&&e.hasOwnProperty("floatData")){if(!Array.isArray(e.floatData))return"floatData: array expected";for(t=0;t<e.floatData.length;++t)if("number"!=typeof e.floatData[t])return"floatData: number[] expected"}if(null!=e.int32Data&&e.hasOwnProperty("int32Data")){if(!Array.isArray(e.int32Data))return"int32Data: array expected";for(t=0;t<e.int32Data.length;++t)if(!d.isInteger(e.int32Data[t]))return"int32Data: integer[] expected"}if(null!=e.stringData&&e.hasOwnProperty("stringData")){if(!Array.isArray(e.stringData))return"stringData: array expected";for(t=0;t<e.stringData.length;++t)if(!(e.stringData[t]&&"number"==typeof e.stringData[t].length||d.isString(e.stringData[t])))return"stringData: buffer[] expected"}if(null!=e.int64Data&&e.hasOwnProperty("int64Data")){if(!Array.isArray(e.int64Data))return"int64Data: array expected";for(t=0;t<e.int64Data.length;++t)if(!(d.isInteger(e.int64Data[t])||e.int64Data[t]&&d.isInteger(e.int64Data[t].low)&&d.isInteger(e.int64Data[t].high)))return"int64Data: integer|Long[] expected"}if(null!=e.name&&e.hasOwnProperty("name")&&!d.isString(e.name))return"name: string expected";if(null!=e.docString&&e.hasOwnProperty("docString")&&!d.isString(e.docString))return"docString: string expected";if(null!=e.rawData&&e.hasOwnProperty("rawData")&&!(e.rawData&&"number"==typeof e.rawData.length||d.isString(e.rawData)))return"rawData: buffer expected";if(null!=e.externalData&&e.hasOwnProperty("externalData")){if(!Array.isArray(e.externalData))return"externalData: array expected";for(t=0;t<e.externalData.length;++t){var r;if(r=u.onnx.StringStringEntryProto.verify(e.externalData[t]))return"externalData."+r}}if(null!=e.dataLocation&&e.hasOwnProperty("dataLocation"))switch(e.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:}if(null!=e.doubleData&&e.hasOwnProperty("doubleData")){if(!Array.isArray(e.doubleData))return"doubleData: array expected";for(t=0;t<e.doubleData.length;++t)if("number"!=typeof e.doubleData[t])return"doubleData: number[] expected"}if(null!=e.uint64Data&&e.hasOwnProperty("uint64Data")){if(!Array.isArray(e.uint64Data))return"uint64Data: array expected";for(t=0;t<e.uint64Data.length;++t)if(!(d.isInteger(e.uint64Data[t])||e.uint64Data[t]&&d.isInteger(e.uint64Data[t].low)&&d.isInteger(e.uint64Data[t].high)))return"uint64Data: integer|Long[] expected"}return null},e.fromObject=function(e){if(e instanceof u.onnx.TensorProto)return e;var t=new u.onnx.TensorProto;if(e.dims){if(!Array.isArray(e.dims))throw TypeError(".onnx.TensorProto.dims: array expected");t.dims=[];for(var r=0;r<e.dims.length;++r)d.Long?(t.dims[r]=d.Long.fromValue(e.dims[r])).unsigned=!1:"string"==typeof e.dims[r]?t.dims[r]=parseInt(e.dims[r],10):"number"==typeof e.dims[r]?t.dims[r]=e.dims[r]:"object"==typeof e.dims[r]&&(t.dims[r]=new d.LongBits(e.dims[r].low>>>0,e.dims[r].high>>>0).toNumber())}if(null!=e.dataType&&(t.dataType=0|e.dataType),null!=e.segment){if("object"!=typeof e.segment)throw TypeError(".onnx.TensorProto.segment: object expected");t.segment=u.onnx.TensorProto.Segment.fromObject(e.segment)}if(e.floatData){if(!Array.isArray(e.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");for(t.floatData=[],r=0;r<e.floatData.length;++r)t.floatData[r]=Number(e.floatData[r])}if(e.int32Data){if(!Array.isArray(e.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");for(t.int32Data=[],r=0;r<e.int32Data.length;++r)t.int32Data[r]=0|e.int32Data[r]}if(e.stringData){if(!Array.isArray(e.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");for(t.stringData=[],r=0;r<e.stringData.length;++r)"string"==typeof e.stringData[r]?d.base64.decode(e.stringData[r],t.stringData[r]=d.newBuffer(d.base64.length(e.stringData[r])),0):e.stringData[r].length&&(t.stringData[r]=e.stringData[r])}if(e.int64Data){if(!Array.isArray(e.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");for(t.int64Data=[],r=0;r<e.int64Data.length;++r)d.Long?(t.int64Data[r]=d.Long.fromValue(e.int64Data[r])).unsigned=!1:"string"==typeof e.int64Data[r]?t.int64Data[r]=parseInt(e.int64Data[r],10):"number"==typeof e.int64Data[r]?t.int64Data[r]=e.int64Data[r]:"object"==typeof e.int64Data[r]&&(t.int64Data[r]=new d.LongBits(e.int64Data[r].low>>>0,e.int64Data[r].high>>>0).toNumber())}if(null!=e.name&&(t.name=String(e.name)),null!=e.docString&&(t.docString=String(e.docString)),null!=e.rawData&&("string"==typeof e.rawData?d.base64.decode(e.rawData,t.rawData=d.newBuffer(d.base64.length(e.rawData)),0):e.rawData.length&&(t.rawData=e.rawData)),e.externalData){if(!Array.isArray(e.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");for(t.externalData=[],r=0;r<e.externalData.length;++r){if("object"!=typeof e.externalData[r])throw TypeError(".onnx.TensorProto.externalData: object expected");t.externalData[r]=u.onnx.StringStringEntryProto.fromObject(e.externalData[r])}}switch(e.dataLocation){case"DEFAULT":case 0:t.dataLocation=0;break;case"EXTERNAL":case 1:t.dataLocation=1}if(e.doubleData){if(!Array.isArray(e.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");for(t.doubleData=[],r=0;r<e.doubleData.length;++r)t.doubleData[r]=Number(e.doubleData[r])}if(e.uint64Data){if(!Array.isArray(e.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");for(t.uint64Data=[],r=0;r<e.uint64Data.length;++r)d.Long?(t.uint64Data[r]=d.Long.fromValue(e.uint64Data[r])).unsigned=!0:"string"==typeof e.uint64Data[r]?t.uint64Data[r]=parseInt(e.uint64Data[r],10):"number"==typeof e.uint64Data[r]?t.uint64Data[r]=e.uint64Data[r]:"object"==typeof e.uint64Data[r]&&(t.uint64Data[r]=new d.LongBits(e.uint64Data[r].low>>>0,e.uint64Data[r].high>>>0).toNumber(!0))}return t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.dims=[],r.floatData=[],r.int32Data=[],r.stringData=[],r.int64Data=[],r.doubleData=[],r.uint64Data=[],r.externalData=[]),t.defaults&&(r.dataType=0,r.segment=null,r.name="",t.bytes===String?r.rawData="":(r.rawData=[],t.bytes!==Array&&(r.rawData=d.newBuffer(r.rawData))),r.docString="",r.dataLocation=t.enums===String?"DEFAULT":0),e.dims&&e.dims.length){r.dims=[];for(var n=0;n<e.dims.length;++n)"number"==typeof e.dims[n]?r.dims[n]=t.longs===String?String(e.dims[n]):e.dims[n]:r.dims[n]=t.longs===String?d.Long.prototype.toString.call(e.dims[n]):t.longs===Number?new d.LongBits(e.dims[n].low>>>0,e.dims[n].high>>>0).toNumber():e.dims[n]}if(null!=e.dataType&&e.hasOwnProperty("dataType")&&(r.dataType=e.dataType),null!=e.segment&&e.hasOwnProperty("segment")&&(r.segment=u.onnx.TensorProto.Segment.toObject(e.segment,t)),e.floatData&&e.floatData.length)for(r.floatData=[],n=0;n<e.floatData.length;++n)r.floatData[n]=t.json&&!isFinite(e.floatData[n])?String(e.floatData[n]):e.floatData[n];if(e.int32Data&&e.int32Data.length)for(r.int32Data=[],n=0;n<e.int32Data.length;++n)r.int32Data[n]=e.int32Data[n];if(e.stringData&&e.stringData.length)for(r.stringData=[],n=0;n<e.stringData.length;++n)r.stringData[n]=t.bytes===String?d.base64.encode(e.stringData[n],0,e.stringData[n].length):t.bytes===Array?Array.prototype.slice.call(e.stringData[n]):e.stringData[n];if(e.int64Data&&e.int64Data.length)for(r.int64Data=[],n=0;n<e.int64Data.length;++n)"number"==typeof e.int64Data[n]?r.int64Data[n]=t.longs===String?String(e.int64Data[n]):e.int64Data[n]:r.int64Data[n]=t.longs===String?d.Long.prototype.toString.call(e.int64Data[n]):t.longs===Number?new d.LongBits(e.int64Data[n].low>>>0,e.int64Data[n].high>>>0).toNumber():e.int64Data[n];if(null!=e.name&&e.hasOwnProperty("name")&&(r.name=e.name),null!=e.rawData&&e.hasOwnProperty("rawData")&&(r.rawData=t.bytes===String?d.base64.encode(e.rawData,0,e.rawData.length):t.bytes===Array?Array.prototype.slice.call(e.rawData):e.rawData),e.doubleData&&e.doubleData.length)for(r.doubleData=[],n=0;n<e.doubleData.length;++n)r.doubleData[n]=t.json&&!isFinite(e.doubleData[n])?String(e.doubleData[n]):e.doubleData[n];if(e.uint64Data&&e.uint64Data.length)for(r.uint64Data=[],n=0;n<e.uint64Data.length;++n)"number"==typeof e.uint64Data[n]?r.uint64Data[n]=t.longs===String?String(e.uint64Data[n]):e.uint64Data[n]:r.uint64Data[n]=t.longs===String?d.Long.prototype.toString.call(e.uint64Data[n]):t.longs===Number?new d.LongBits(e.uint64Data[n].low>>>0,e.uint64Data[n].high>>>0).toNumber(!0):e.uint64Data[n];if(null!=e.docString&&e.hasOwnProperty("docString")&&(r.docString=e.docString),e.externalData&&e.externalData.length)for(r.externalData=[],n=0;n<e.externalData.length;++n)r.externalData[n]=u.onnx.StringStringEntryProto.toObject(e.externalData[n],t);return null!=e.dataLocation&&e.hasOwnProperty("dataLocation")&&(r.dataLocation=t.enums===String?u.onnx.TensorProto.DataLocation[e.dataLocation]:e.dataLocation),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.DataType=function(){var e={},t=Object.create(e);return t[e[0]="UNDEFINED"]=0,t[e[1]="FLOAT"]=1,t[e[2]="UINT8"]=2,t[e[3]="INT8"]=3,t[e[4]="UINT16"]=4,t[e[5]="INT16"]=5,t[e[6]="INT32"]=6,t[e[7]="INT64"]=7,t[e[8]="STRING"]=8,t[e[9]="BOOL"]=9,t[e[10]="FLOAT16"]=10,t[e[11]="DOUBLE"]=11,t[e[12]="UINT32"]=12,t[e[13]="UINT64"]=13,t[e[14]="COMPLEX64"]=14,t[e[15]="COMPLEX128"]=15,t[e[16]="BFLOAT16"]=16,t}(),e.Segment=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.begin=d.Long?d.Long.fromBits(0,0,!1):0,e.prototype.end=d.Long?d.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.begin&&e.hasOwnProperty("begin")&&t.uint32(8).int64(e.begin),null!=e.end&&e.hasOwnProperty("end")&&t.uint32(16).int64(e.end),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.TensorProto.Segment;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.begin=e.int64();break;case 2:n.end=e.int64();break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.begin&&e.hasOwnProperty("begin")&&!(d.isInteger(e.begin)||e.begin&&d.isInteger(e.begin.low)&&d.isInteger(e.begin.high))?"begin: integer|Long expected":null!=e.end&&e.hasOwnProperty("end")&&!(d.isInteger(e.end)||e.end&&d.isInteger(e.end.low)&&d.isInteger(e.end.high))?"end: integer|Long expected":null},e.fromObject=function(e){if(e instanceof u.onnx.TensorProto.Segment)return e;var t=new u.onnx.TensorProto.Segment;return null!=e.begin&&(d.Long?(t.begin=d.Long.fromValue(e.begin)).unsigned=!1:"string"==typeof e.begin?t.begin=parseInt(e.begin,10):"number"==typeof e.begin?t.begin=e.begin:"object"==typeof e.begin&&(t.begin=new d.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber())),null!=e.end&&(d.Long?(t.end=d.Long.fromValue(e.end)).unsigned=!1:"string"==typeof e.end?t.end=parseInt(e.end,10):"number"==typeof e.end?t.end=e.end:"object"==typeof e.end&&(t.end=new d.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber())),t},e.toObject=function(e,t){t||(t={});var r={};if(t.defaults){if(d.Long){var n=new d.Long(0,0,!1);r.begin=t.longs===String?n.toString():t.longs===Number?n.toNumber():n}else r.begin=t.longs===String?"0":0;d.Long?(n=new d.Long(0,0,!1),r.end=t.longs===String?n.toString():t.longs===Number?n.toNumber():n):r.end=t.longs===String?"0":0}return null!=e.begin&&e.hasOwnProperty("begin")&&("number"==typeof e.begin?r.begin=t.longs===String?String(e.begin):e.begin:r.begin=t.longs===String?d.Long.prototype.toString.call(e.begin):t.longs===Number?new d.LongBits(e.begin.low>>>0,e.begin.high>>>0).toNumber():e.begin),null!=e.end&&e.hasOwnProperty("end")&&("number"==typeof e.end?r.end=t.longs===String?String(e.end):e.end:r.end=t.longs===String?d.Long.prototype.toString.call(e.end):t.longs===Number?new d.LongBits(e.end.low>>>0,e.end.high>>>0).toNumber():e.end),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),e.DataLocation=function(){var e={},t=Object.create(e);return t[e[0]="DEFAULT"]=0,t[e[1]="EXTERNAL"]=1,t}(),e}(),o.TensorShapeProto=function(){function e(e){if(this.dim=[],e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.dim=d.emptyArray,e.create=function(t){return new e(t)},e.encode=function(e,t){if(t||(t=l.create()),null!=e.dim&&e.dim.length)for(var r=0;r<e.dim.length;++r)u.onnx.TensorShapeProto.Dimension.encode(e.dim[r],t.uint32(10).fork()).ldelim();return t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.TensorShapeProto;e.pos<r;){var a=e.uint32();a>>>3==1?(n.dim&&n.dim.length||(n.dim=[]),n.dim.push(u.onnx.TensorShapeProto.Dimension.decode(e,e.uint32()))):e.skipType(7&a)}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.dim&&e.hasOwnProperty("dim")){if(!Array.isArray(e.dim))return"dim: array expected";for(var t=0;t<e.dim.length;++t){var r=u.onnx.TensorShapeProto.Dimension.verify(e.dim[t]);if(r)return"dim."+r}}return null},e.fromObject=function(e){if(e instanceof u.onnx.TensorShapeProto)return e;var t=new u.onnx.TensorShapeProto;if(e.dim){if(!Array.isArray(e.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");t.dim=[];for(var r=0;r<e.dim.length;++r){if("object"!=typeof e.dim[r])throw TypeError(".onnx.TensorShapeProto.dim: object expected");t.dim[r]=u.onnx.TensorShapeProto.Dimension.fromObject(e.dim[r])}}return t},e.toObject=function(e,t){t||(t={});var r={};if((t.arrays||t.defaults)&&(r.dim=[]),e.dim&&e.dim.length){r.dim=[];for(var n=0;n<e.dim.length;++n)r.dim[n]=u.onnx.TensorShapeProto.Dimension.toObject(e.dim[n],t)}return r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.Dimension=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}var t;return e.prototype.dimValue=d.Long?d.Long.fromBits(0,0,!1):0,e.prototype.dimParam="",e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:d.oneOfGetter(t=["dimValue","dimParam"]),set:d.oneOfSetter(t)}),e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.dimValue&&e.hasOwnProperty("dimValue")&&t.uint32(8).int64(e.dimValue),null!=e.dimParam&&e.hasOwnProperty("dimParam")&&t.uint32(18).string(e.dimParam),null!=e.denotation&&e.hasOwnProperty("denotation")&&t.uint32(26).string(e.denotation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.TensorShapeProto.Dimension;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.dimValue=e.int64();break;case 2:n.dimParam=e.string();break;case 3:n.denotation=e.string();break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";var t={};if(null!=e.dimValue&&e.hasOwnProperty("dimValue")&&(t.value=1,!(d.isInteger(e.dimValue)||e.dimValue&&d.isInteger(e.dimValue.low)&&d.isInteger(e.dimValue.high))))return"dimValue: integer|Long expected";if(null!=e.dimParam&&e.hasOwnProperty("dimParam")){if(1===t.value)return"value: multiple values";if(t.value=1,!d.isString(e.dimParam))return"dimParam: string expected"}return null!=e.denotation&&e.hasOwnProperty("denotation")&&!d.isString(e.denotation)?"denotation: string expected":null},e.fromObject=function(e){if(e instanceof u.onnx.TensorShapeProto.Dimension)return e;var t=new u.onnx.TensorShapeProto.Dimension;return null!=e.dimValue&&(d.Long?(t.dimValue=d.Long.fromValue(e.dimValue)).unsigned=!1:"string"==typeof e.dimValue?t.dimValue=parseInt(e.dimValue,10):"number"==typeof e.dimValue?t.dimValue=e.dimValue:"object"==typeof e.dimValue&&(t.dimValue=new d.LongBits(e.dimValue.low>>>0,e.dimValue.high>>>0).toNumber())),null!=e.dimParam&&(t.dimParam=String(e.dimParam)),null!=e.denotation&&(t.denotation=String(e.denotation)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.denotation=""),null!=e.dimValue&&e.hasOwnProperty("dimValue")&&("number"==typeof e.dimValue?r.dimValue=t.longs===String?String(e.dimValue):e.dimValue:r.dimValue=t.longs===String?d.Long.prototype.toString.call(e.dimValue):t.longs===Number?new d.LongBits(e.dimValue.low>>>0,e.dimValue.high>>>0).toNumber():e.dimValue,t.oneofs&&(r.value="dimValue")),null!=e.dimParam&&e.hasOwnProperty("dimParam")&&(r.dimParam=e.dimParam,t.oneofs&&(r.value="dimParam")),null!=e.denotation&&e.hasOwnProperty("denotation")&&(r.denotation=e.denotation),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),e}(),o.TypeProto=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}var t;return e.prototype.tensorType=null,e.prototype.denotation="",Object.defineProperty(e.prototype,"value",{get:d.oneOfGetter(t=["tensorType"]),set:d.oneOfSetter(t)}),e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.tensorType&&e.hasOwnProperty("tensorType")&&u.onnx.TypeProto.Tensor.encode(e.tensorType,t.uint32(10).fork()).ldelim(),null!=e.denotation&&e.hasOwnProperty("denotation")&&t.uint32(50).string(e.denotation),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.TypeProto;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.tensorType=u.onnx.TypeProto.Tensor.decode(e,e.uint32());break;case 6:n.denotation=e.string();break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.tensorType&&e.hasOwnProperty("tensorType")){var t=u.onnx.TypeProto.Tensor.verify(e.tensorType);if(t)return"tensorType."+t}return null!=e.denotation&&e.hasOwnProperty("denotation")&&!d.isString(e.denotation)?"denotation: string expected":null},e.fromObject=function(e){if(e instanceof u.onnx.TypeProto)return e;var t=new u.onnx.TypeProto;if(null!=e.tensorType){if("object"!=typeof e.tensorType)throw TypeError(".onnx.TypeProto.tensorType: object expected");t.tensorType=u.onnx.TypeProto.Tensor.fromObject(e.tensorType)}return null!=e.denotation&&(t.denotation=String(e.denotation)),t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.denotation=""),null!=e.tensorType&&e.hasOwnProperty("tensorType")&&(r.tensorType=u.onnx.TypeProto.Tensor.toObject(e.tensorType,t),t.oneofs&&(r.value="tensorType")),null!=e.denotation&&e.hasOwnProperty("denotation")&&(r.denotation=e.denotation),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e.Tensor=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.elemType=0,e.prototype.shape=null,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.elemType&&e.hasOwnProperty("elemType")&&t.uint32(8).int32(e.elemType),null!=e.shape&&e.hasOwnProperty("shape")&&u.onnx.TensorShapeProto.encode(e.shape,t.uint32(18).fork()).ldelim(),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.TypeProto.Tensor;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.elemType=e.int32();break;case 2:n.shape=u.onnx.TensorShapeProto.decode(e,e.uint32());break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){if("object"!=typeof e||null===e)return"object expected";if(null!=e.elemType&&e.hasOwnProperty("elemType")&&!d.isInteger(e.elemType))return"elemType: integer expected";if(null!=e.shape&&e.hasOwnProperty("shape")){var t=u.onnx.TensorShapeProto.verify(e.shape);if(t)return"shape."+t}return null},e.fromObject=function(e){if(e instanceof u.onnx.TypeProto.Tensor)return e;var t=new u.onnx.TypeProto.Tensor;if(null!=e.elemType&&(t.elemType=0|e.elemType),null!=e.shape){if("object"!=typeof e.shape)throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");t.shape=u.onnx.TensorShapeProto.fromObject(e.shape)}return t},e.toObject=function(e,t){t||(t={});var r={};return t.defaults&&(r.elemType=0,r.shape=null),null!=e.elemType&&e.hasOwnProperty("elemType")&&(r.elemType=e.elemType),null!=e.shape&&e.hasOwnProperty("shape")&&(r.shape=u.onnx.TensorShapeProto.toObject(e.shape,t)),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),e}(),o.OperatorSetIdProto=function(){function e(e){if(e)for(var t=Object.keys(e),r=0;r<t.length;++r)null!=e[t[r]]&&(this[t[r]]=e[t[r]])}return e.prototype.domain="",e.prototype.version=d.Long?d.Long.fromBits(0,0,!1):0,e.create=function(t){return new e(t)},e.encode=function(e,t){return t||(t=l.create()),null!=e.domain&&e.hasOwnProperty("domain")&&t.uint32(10).string(e.domain),null!=e.version&&e.hasOwnProperty("version")&&t.uint32(16).int64(e.version),t},e.encodeDelimited=function(e,t){return this.encode(e,t).ldelim()},e.decode=function(e,t){e instanceof s||(e=s.create(e));for(var r=void 0===t?e.len:e.pos+t,n=new u.onnx.OperatorSetIdProto;e.pos<r;){var a=e.uint32();switch(a>>>3){case 1:n.domain=e.string();break;case 2:n.version=e.int64();break;default:e.skipType(7&a)}}return n},e.decodeDelimited=function(e){return e instanceof s||(e=new s(e)),this.decode(e,e.uint32())},e.verify=function(e){return"object"!=typeof e||null===e?"object expected":null!=e.domain&&e.hasOwnProperty("domain")&&!d.isString(e.domain)?"domain: string expected":null!=e.version&&e.hasOwnProperty("version")&&!(d.isInteger(e.version)||e.version&&d.isInteger(e.version.low)&&d.isInteger(e.version.high))?"version: integer|Long expected":null},e.fromObject=function(e){if(e instanceof u.onnx.OperatorSetIdProto)return e;var t=new u.onnx.OperatorSetIdProto;return null!=e.domain&&(t.domain=String(e.domain)),null!=e.version&&(d.Long?(t.version=d.Long.fromValue(e.version)).unsigned=!1:"string"==typeof e.version?t.version=parseInt(e.version,10):"number"==typeof e.version?t.version=e.version:"object"==typeof e.version&&(t.version=new d.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber())),t},e.toObject=function(e,t){t||(t={});var r={};if(t.defaults)if(r.domain="",d.Long){var n=new d.Long(0,0,!1);r.version=t.longs===String?n.toString():t.longs===Number?n.toNumber():n}else r.version=t.longs===String?"0":0;return null!=e.domain&&e.hasOwnProperty("domain")&&(r.domain=e.domain),null!=e.version&&e.hasOwnProperty("version")&&("number"==typeof e.version?r.version=t.longs===String?String(e.version):e.version:r.version=t.longs===String?d.Long.prototype.toString.call(e.version):t.longs===Number?new d.LongBits(e.version.low>>>0,e.version.high>>>0).toNumber():e.version),r},e.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},e}(),o),e.exports=u},2100:(e,t,r)=>{e.exports=r(9482)},9482:(e,t,r)=>{var n=t;function a(){n.util._configure(),n.Writer._configure(n.BufferWriter),n.Reader._configure(n.BufferReader)}n.build="minimal",n.Writer=r(1173),n.BufferWriter=r(3155),n.Reader=r(1408),n.BufferReader=r(593),n.util=r(9693),n.rpc=r(5994),n.roots=r(5054),n.configure=a,a()},1408:(e,t,r)=>{e.exports=l;var n,a=r(9693),o=a.LongBits,i=a.utf8;function s(e,t){return RangeError("index out of range: "+e.pos+" + "+(t||1)+" > "+e.len)}function l(e){this.buf=e,this.pos=0,this.len=e.length}var d,u="undefined"!=typeof Uint8Array?function(e){if(e instanceof Uint8Array||Array.isArray(e))return new l(e);throw Error("illegal buffer")}:function(e){if(Array.isArray(e))return new l(e);throw Error("illegal buffer")},c=function(){return a.Buffer?function(e){return(l.create=function(e){return a.Buffer.isBuffer(e)?new n(e):u(e)})(e)}:u};function p(){var e=new o(0,0),t=0;if(!(this.len-this.pos>4)){for(;t<3;++t){if(this.pos>=this.len)throw s(this);if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e}return e.lo=(e.lo|(127&this.buf[this.pos++])<<7*t)>>>0,e}for(;t<4;++t)if(e.lo=(e.lo|(127&this.buf[this.pos])<<7*t)>>>0,this.buf[this.pos++]<128)return e;if(e.lo=(e.lo|(127&this.buf[this.pos])<<28)>>>0,e.hi=(e.hi|(127&this.buf[this.pos])>>4)>>>0,this.buf[this.pos++]<128)return e;if(t=0,this.len-this.pos>4){for(;t<5;++t)if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}else for(;t<5;++t){if(this.pos>=this.len)throw s(this);if(e.hi=(e.hi|(127&this.buf[this.pos])<<7*t+3)>>>0,this.buf[this.pos++]<128)return e}throw Error("invalid varint encoding")}function g(e,t){return(e[t-4]|e[t-3]<<8|e[t-2]<<16|e[t-1]<<24)>>>0}function A(){if(this.pos+8>this.len)throw s(this,8);return new o(g(this.buf,this.pos+=4),g(this.buf,this.pos+=4))}l.create=c(),l.prototype._slice=a.Array.prototype.subarray||a.Array.prototype.slice,l.prototype.uint32=(d=4294967295,function(){if(d=(127&this.buf[this.pos])>>>0,this.buf[this.pos++]<128)return d;if(d=(d|(127&this.buf[this.pos])<<7)>>>0,this.buf[this.pos++]<128)return d;if(d=(d|(127&this.buf[this.pos])<<14)>>>0,this.buf[this.pos++]<128)return d;if(d=(d|(127&this.buf[this.pos])<<21)>>>0,this.buf[this.pos++]<128)return d;if(d=(d|(15&this.buf[this.pos])<<28)>>>0,this.buf[this.pos++]<128)return d;if((this.pos+=5)>this.len)throw this.pos=this.len,s(this,10);return d}),l.prototype.int32=function(){return 0|this.uint32()},l.prototype.sint32=function(){var e=this.uint32();return e>>>1^-(1&e)},l.prototype.bool=function(){return 0!==this.uint32()},l.prototype.fixed32=function(){if(this.pos+4>this.len)throw s(this,4);return g(this.buf,this.pos+=4)},l.prototype.sfixed32=function(){if(this.pos+4>this.len)throw s(this,4);return 0|g(this.buf,this.pos+=4)},l.prototype.float=function(){if(this.pos+4>this.len)throw s(this,4);var e=a.float.readFloatLE(this.buf,this.pos);return this.pos+=4,e},l.prototype.double=function(){if(this.pos+8>this.len)throw s(this,4);var e=a.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,e},l.prototype.bytes=function(){var e=this.uint32(),t=this.pos,r=this.pos+e;if(r>this.len)throw s(this,e);return this.pos+=e,Array.isArray(this.buf)?this.buf.slice(t,r):t===r?new this.buf.constructor(0):this._slice.call(this.buf,t,r)},l.prototype.string=function(){var e=this.bytes();return i.read(e,0,e.length)},l.prototype.skip=function(e){if("number"==typeof e){if(this.pos+e>this.len)throw s(this,e);this.pos+=e}else do{if(this.pos>=this.len)throw s(this)}while(128&this.buf[this.pos++]);return this},l.prototype.skipType=function(e){switch(e){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;4!=(e=7&this.uint32());)this.skipType(e);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+e+" at offset "+this.pos)}return this},l._configure=function(e){n=e,l.create=c(),n._configure();var t=a.Long?"toLong":"toNumber";a.merge(l.prototype,{int64:function(){return p.call(this)[t](!1)},uint64:function(){return p.call(this)[t](!0)},sint64:function(){return p.call(this).zzDecode()[t](!1)},fixed64:function(){return A.call(this)[t](!0)},sfixed64:function(){return A.call(this)[t](!1)}})}},593:(e,t,r)=>{e.exports=o;var n=r(1408);(o.prototype=Object.create(n.prototype)).constructor=o;var a=r(9693);function o(e){n.call(this,e)}o._configure=function(){a.Buffer&&(o.prototype._slice=a.Buffer.prototype.slice)},o.prototype.string=function(){var e=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+e,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+e,this.len))},o._configure()},5054:e=>{e.exports={}},5994:(e,t,r)=>{t.Service=r(7948)},7948:(e,t,r)=>{e.exports=a;var n=r(9693);function a(e,t,r){if("function"!=typeof e)throw TypeError("rpcImpl must be a function");n.EventEmitter.call(this),this.rpcImpl=e,this.requestDelimited=Boolean(t),this.responseDelimited=Boolean(r)}(a.prototype=Object.create(n.EventEmitter.prototype)).constructor=a,a.prototype.rpcCall=function e(t,r,a,o,i){if(!o)throw TypeError("request must be specified");var s=this;if(!i)return n.asPromise(e,s,t,r,a,o);if(s.rpcImpl)try{return s.rpcImpl(t,r[s.requestDelimited?"encodeDelimited":"encode"](o).finish(),(function(e,r){if(e)return s.emit("error",e,t),i(e);if(null!==r){if(!(r instanceof a))try{r=a[s.responseDelimited?"decodeDelimited":"decode"](r)}catch(e){return s.emit("error",e,t),i(e)}return s.emit("data",r,t),i(null,r)}s.end(!0)}))}catch(e){return s.emit("error",e,t),void setTimeout((function(){i(e)}),0)}else setTimeout((function(){i(Error("already ended"))}),0)},a.prototype.end=function(e){return this.rpcImpl&&(e||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}},1945:(e,t,r)=>{e.exports=a;var n=r(9693);function a(e,t){this.lo=e>>>0,this.hi=t>>>0}var o=a.zero=new a(0,0);o.toNumber=function(){return 0},o.zzEncode=o.zzDecode=function(){return this},o.length=function(){return 1};var i=a.zeroHash="\0\0\0\0\0\0\0\0";a.fromNumber=function(e){if(0===e)return o;var t=e<0;t&&(e=-e);var r=e>>>0,n=(e-r)/4294967296>>>0;return t&&(n=~n>>>0,r=~r>>>0,++r>4294967295&&(r=0,++n>4294967295&&(n=0))),new a(r,n)},a.from=function(e){if("number"==typeof e)return a.fromNumber(e);if(n.isString(e)){if(!n.Long)return a.fromNumber(parseInt(e,10));e=n.Long.fromString(e)}return e.low||e.high?new a(e.low>>>0,e.high>>>0):o},a.prototype.toNumber=function(e){if(!e&&this.hi>>>31){var t=1+~this.lo>>>0,r=~this.hi>>>0;return t||(r=r+1>>>0),-(t+4294967296*r)}return this.lo+4294967296*this.hi},a.prototype.toLong=function(e){return n.Long?new n.Long(0|this.lo,0|this.hi,Boolean(e)):{low:0|this.lo,high:0|this.hi,unsigned:Boolean(e)}};var s=String.prototype.charCodeAt;a.fromHash=function(e){return e===i?o:new a((s.call(e,0)|s.call(e,1)<<8|s.call(e,2)<<16|s.call(e,3)<<24)>>>0,(s.call(e,4)|s.call(e,5)<<8|s.call(e,6)<<16|s.call(e,7)<<24)>>>0)},a.prototype.toHash=function(){return String.fromCharCode(255&this.lo,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,255&this.hi,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},a.prototype.zzEncode=function(){var e=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^e)>>>0,this.lo=(this.lo<<1^e)>>>0,this},a.prototype.zzDecode=function(){var e=-(1&this.lo);return this.lo=((this.lo>>>1|this.hi<<31)^e)>>>0,this.hi=(this.hi>>>1^e)>>>0,this},a.prototype.length=function(){var e=this.lo,t=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return 0===r?0===t?e<16384?e<128?1:2:e<2097152?3:4:t<16384?t<128?5:6:t<2097152?7:8:r<128?9:10}},9693:function(e,t,r){var n=t;function a(e,t,r){for(var n=Object.keys(t),a=0;a<n.length;++a)void 0!==e[n[a]]&&r||(e[n[a]]=t[n[a]]);return e}function o(e){function t(e,r){if(!(this instanceof t))return new t(e,r);Object.defineProperty(this,"message",{get:function(){return e}}),Error.captureStackTrace?Error.captureStackTrace(this,t):Object.defineProperty(this,"stack",{value:(new Error).stack||""}),r&&a(this,r)}return(t.prototype=Object.create(Error.prototype)).constructor=t,Object.defineProperty(t.prototype,"name",{get:function(){return e}}),t.prototype.toString=function(){return this.name+": "+this.message},t}n.asPromise=r(4537),n.base64=r(7419),n.EventEmitter=r(9211),n.float=r(945),n.inquire=r(7199),n.utf8=r(4997),n.pool=r(6662),n.LongBits=r(1945),n.isNode=Boolean(void 0!==r.g&&r.g&&r.g.process&&r.g.process.versions&&r.g.process.versions.node),n.global=n.isNode&&r.g||"undefined"!=typeof window&&window||"undefined"!=typeof self&&self||this,n.emptyArray=Object.freeze?Object.freeze([]):[],n.emptyObject=Object.freeze?Object.freeze({}):{},n.isInteger=Number.isInteger||function(e){return"number"==typeof e&&isFinite(e)&&Math.floor(e)===e},n.isString=function(e){return"string"==typeof e||e instanceof String},n.isObject=function(e){return e&&"object"==typeof e},n.isset=n.isSet=function(e,t){var r=e[t];return!(null==r||!e.hasOwnProperty(t))&&("object"!=typeof r||(Array.isArray(r)?r.length:Object.keys(r).length)>0)},n.Buffer=function(){try{var e=n.inquire("buffer").Buffer;return e.prototype.utf8Write?e:null}catch(e){return null}}(),n._Buffer_from=null,n._Buffer_allocUnsafe=null,n.newBuffer=function(e){return"number"==typeof e?n.Buffer?n._Buffer_allocUnsafe(e):new n.Array(e):n.Buffer?n._Buffer_from(e):"undefined"==typeof Uint8Array?e:new Uint8Array(e)},n.Array="undefined"!=typeof Uint8Array?Uint8Array:Array,n.Long=n.global.dcodeIO&&n.global.dcodeIO.Long||n.global.Long||n.inquire("long"),n.key2Re=/^true|false|0|1$/,n.key32Re=/^-?(?:0|[1-9][0-9]*)$/,n.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,n.longToHash=function(e){return e?n.LongBits.from(e).toHash():n.LongBits.zeroHash},n.longFromHash=function(e,t){var r=n.LongBits.fromHash(e);return n.Long?n.Long.fromBits(r.lo,r.hi,t):r.toNumber(Boolean(t))},n.merge=a,n.lcFirst=function(e){return e.charAt(0).toLowerCase()+e.substring(1)},n.newError=o,n.ProtocolError=o("ProtocolError"),n.oneOfGetter=function(e){for(var t={},r=0;r<e.length;++r)t[e[r]]=1;return function(){for(var e=Object.keys(this),r=e.length-1;r>-1;--r)if(1===t[e[r]]&&void 0!==this[e[r]]&&null!==this[e[r]])return e[r]}},n.oneOfSetter=function(e){return function(t){for(var r=0;r<e.length;++r)e[r]!==t&&delete this[e[r]]}},n.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},n._configure=function(){var e=n.Buffer;e?(n._Buffer_from=e.from!==Uint8Array.from&&e.from||function(t,r){return new e(t,r)},n._Buffer_allocUnsafe=e.allocUnsafe||function(t){return new e(t)}):n._Buffer_from=n._Buffer_allocUnsafe=null}},1173:(e,t,r)=>{e.exports=c;var n,a=r(9693),o=a.LongBits,i=a.base64,s=a.utf8;function l(e,t,r){this.fn=e,this.len=t,this.next=void 0,this.val=r}function d(){}function u(e){this.head=e.head,this.tail=e.tail,this.len=e.len,this.next=e.states}function c(){this.len=0,this.head=new l(d,0,0),this.tail=this.head,this.states=null}var p=function(){return a.Buffer?function(){return(c.create=function(){return new n})()}:function(){return new c}};function g(e,t,r){t[r]=255&e}function A(e,t){this.len=e,this.next=void 0,this.val=t}function h(e,t,r){for(;e.hi;)t[r++]=127&e.lo|128,e.lo=(e.lo>>>7|e.hi<<25)>>>0,e.hi>>>=7;for(;e.lo>127;)t[r++]=127&e.lo|128,e.lo=e.lo>>>7;t[r++]=e.lo}function B(e,t,r){t[r]=255&e,t[r+1]=e>>>8&255,t[r+2]=e>>>16&255,t[r+3]=e>>>24}c.create=p(),c.alloc=function(e){return new a.Array(e)},a.Array!==Array&&(c.alloc=a.pool(c.alloc,a.Array.prototype.subarray)),c.prototype._push=function(e,t,r){return this.tail=this.tail.next=new l(e,t,r),this.len+=t,this},A.prototype=Object.create(l.prototype),A.prototype.fn=function(e,t,r){for(;e>127;)t[r++]=127&e|128,e>>>=7;t[r]=e},c.prototype.uint32=function(e){return this.len+=(this.tail=this.tail.next=new A((e>>>=0)<128?1:e<16384?2:e<2097152?3:e<268435456?4:5,e)).len,this},c.prototype.int32=function(e){return e<0?this._push(h,10,o.fromNumber(e)):this.uint32(e)},c.prototype.sint32=function(e){return this.uint32((e<<1^e>>31)>>>0)},c.prototype.uint64=function(e){var t=o.from(e);return this._push(h,t.length(),t)},c.prototype.int64=c.prototype.uint64,c.prototype.sint64=function(e){var t=o.from(e).zzEncode();return this._push(h,t.length(),t)},c.prototype.bool=function(e){return this._push(g,1,e?1:0)},c.prototype.fixed32=function(e){return this._push(B,4,e>>>0)},c.prototype.sfixed32=c.prototype.fixed32,c.prototype.fixed64=function(e){var t=o.from(e);return this._push(B,4,t.lo)._push(B,4,t.hi)},c.prototype.sfixed64=c.prototype.fixed64,c.prototype.float=function(e){return this._push(a.float.writeFloatLE,4,e)},c.prototype.double=function(e){return this._push(a.float.writeDoubleLE,8,e)};var m=a.Array.prototype.set?function(e,t,r){t.set(e,r)}:function(e,t,r){for(var n=0;n<e.length;++n)t[r+n]=e[n]};c.prototype.bytes=function(e){var t=e.length>>>0;if(!t)return this._push(g,1,0);if(a.isString(e)){var r=c.alloc(t=i.length(e));i.decode(e,r,0),e=r}return this.uint32(t)._push(m,t,e)},c.prototype.string=function(e){var t=s.length(e);return t?this.uint32(t)._push(s.write,t,e):this._push(g,1,0)},c.prototype.fork=function(){return this.states=new u(this),this.head=this.tail=new l(d,0,0),this.len=0,this},c.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new l(d,0,0),this.len=0),this},c.prototype.ldelim=function(){var e=this.head,t=this.tail,r=this.len;return this.reset().uint32(r),r&&(this.tail.next=e.next,this.tail=t,this.len+=r),this},c.prototype.finish=function(){for(var e=this.head.next,t=this.constructor.alloc(this.len),r=0;e;)e.fn(e.val,t,r),r+=e.len,e=e.next;return t},c._configure=function(e){n=e,c.create=p(),n._configure()}},3155:(e,t,r)=>{e.exports=o;var n=r(1173);(o.prototype=Object.create(n.prototype)).constructor=o;var a=r(9693);function o(){n.call(this)}function i(e,t,r){e.length<40?a.utf8.write(e,t,r):t.utf8Write?t.utf8Write(e,r):t.write(e,r)}o._configure=function(){o.alloc=a._Buffer_allocUnsafe,o.writeBytesBuffer=a.Buffer&&a.Buffer.prototype instanceof Uint8Array&&"set"===a.Buffer.prototype.set.name?function(e,t,r){t.set(e,r)}:function(e,t,r){if(e.copy)e.copy(t,r,0,e.length);else for(var n=0;n<e.length;)t[r++]=e[n++]}},o.prototype.bytes=function(e){a.isString(e)&&(e=a._Buffer_from(e,"base64"));var t=e.length>>>0;return this.uint32(t),t&&this._push(o.writeBytesBuffer,t,e),this},o.prototype.string=function(e){var t=a.Buffer.byteLength(e);return this.uint32(t),t&&this._push(i,t,e),this},o._configure()},7714:(e,t,r)=>{t.R=void 0;const n=r(6919),a=r(7448);t.R=new class{async init(){}async createSessionHandler(e,t){const r=new n.Session(t);return await r.loadModel(e),new a.OnnxjsSessionHandler(r)}}},4200:(e,t,r)=>{t.c8=t.rX=void 0;const n=r(1670),a=r(5381),o=r(2157),i=r(2306);t.rX=()=>{if(("number"!=typeof n.env.wasm.initTimeout||n.env.wasm.initTimeout<0)&&(n.env.wasm.initTimeout=0),"boolean"!=typeof n.env.wasm.simd&&(n.env.wasm.simd=!0),"boolean"!=typeof n.env.wasm.proxy&&(n.env.wasm.proxy=!1),"number"!=typeof n.env.wasm.numThreads||!Number.isInteger(n.env.wasm.numThreads)||n.env.wasm.numThreads<=0){const e="undefined"==typeof navigator?(0,a.cpus)().length:navigator.hardwareConcurrency;n.env.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},t.c8=new class{async init(){(0,t.rX)(),await(0,o.initWasm)()}async createSessionHandler(e,t){const r=new i.OnnxruntimeWebAssemblySessionHandler;return await r.loadModel(e,t),Promise.resolve(r)}}},6018:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||n(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),a(r(1670),t);const o=r(1670);{const e=r(7714).R;(0,o.registerBackend)("webgl",e,-10)}{const e=r(4200).c8;(0,o.registerBackend)("cpu",e,10),(0,o.registerBackend)("wasm",e,10),(0,o.registerBackend)("xnnpack",e,9)}},246:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createAttributeWithCacheKey=void 0;class r{constructor(e){Object.assign(this,e)}get cacheKey(){return this._cacheKey||(this._cacheKey=Object.getOwnPropertyNames(this).sort().map((e=>`${this[e]}`)).join(";")),this._cacheKey}}t.createAttributeWithCacheKey=e=>new r(e)},7778:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Attribute=void 0;const n=r(1446),a=r(9395),o=r(9162),i=r(2517);var s=a.onnxruntime.experimental.fbs;class l{constructor(e){if(this._attributes=new Map,null!=e){for(const t of e)t instanceof n.onnx.AttributeProto?this._attributes.set(t.name,[l.getValue(t),l.getType(t)]):t instanceof s.Attribute&&this._attributes.set(t.name(),[l.getValue(t),l.getType(t)]);if(this._attributes.size<e.length)throw new Error("duplicated attribute names")}}set(e,t,r){this._attributes.set(e,[r,t])}delete(e){this._attributes.delete(e)}getFloat(e,t){return this.get(e,"float",t)}getInt(e,t){return this.get(e,"int",t)}getString(e,t){return this.get(e,"string",t)}getTensor(e,t){return this.get(e,"tensor",t)}getFloats(e,t){return this.get(e,"floats",t)}getInts(e,t){return this.get(e,"ints",t)}getStrings(e,t){return this.get(e,"strings",t)}getTensors(e,t){return this.get(e,"tensors",t)}get(e,t,r){const n=this._attributes.get(e);if(void 0===n){if(void 0!==r)return r;throw new Error(`required attribute not found: ${e}`)}if(n[1]!==t)throw new Error(`type mismatch: expected ${t} but got ${n[1]}`);return n[0]}static getType(e){const t=e instanceof n.onnx.AttributeProto?e.type:e.type();switch(t){case n.onnx.AttributeProto.AttributeType.FLOAT:return"float";case n.onnx.AttributeProto.AttributeType.INT:return"int";case n.onnx.AttributeProto.AttributeType.STRING:return"string";case n.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case n.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case n.onnx.AttributeProto.AttributeType.INTS:return"ints";case n.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case n.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${n.onnx.AttributeProto.AttributeType[t]}`)}}static getValue(e){const t=e instanceof n.onnx.AttributeProto?e.type:e.type();if(t===n.onnx.AttributeProto.AttributeType.GRAPH||t===n.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");const r=this.getValueNoCheck(e);if(t===n.onnx.AttributeProto.AttributeType.INT&&i.LongUtil.isLong(r))return i.LongUtil.longToNumber(r);if(t===n.onnx.AttributeProto.AttributeType.INTS){const e=r,t=new Array(e.length);for(let r=0;r<e.length;r++){const n=e[r];t[r]=i.LongUtil.longToNumber(n)}return t}if(t===n.onnx.AttributeProto.AttributeType.TENSOR)return e instanceof n.onnx.AttributeProto?o.Tensor.fromProto(r):o.Tensor.fromOrtTensor(r);if(t===n.onnx.AttributeProto.AttributeType.TENSORS){if(e instanceof n.onnx.AttributeProto)return r.map((e=>o.Tensor.fromProto(e)));if(e instanceof s.Attribute)return r.map((e=>o.Tensor.fromOrtTensor(e)))}if(t===n.onnx.AttributeProto.AttributeType.STRING&&e instanceof n.onnx.AttributeProto){const e=r;return(0,i.decodeUtf8String)(e)}return t===n.onnx.AttributeProto.AttributeType.STRINGS&&e instanceof n.onnx.AttributeProto?r.map(i.decodeUtf8String):r}static getValueNoCheck(e){return e instanceof n.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(e):this.getValueNoCheckFromOrtFormat(e)}static getValueNoCheckFromOnnxFormat(e){switch(e.type){case n.onnx.AttributeProto.AttributeType.FLOAT:return e.f;case n.onnx.AttributeProto.AttributeType.INT:return e.i;case n.onnx.AttributeProto.AttributeType.STRING:return e.s;case n.onnx.AttributeProto.AttributeType.TENSOR:return e.t;case n.onnx.AttributeProto.AttributeType.GRAPH:return e.g;case n.onnx.AttributeProto.AttributeType.FLOATS:return e.floats;case n.onnx.AttributeProto.AttributeType.INTS:return e.ints;case n.onnx.AttributeProto.AttributeType.STRINGS:return e.strings;case n.onnx.AttributeProto.AttributeType.TENSORS:return e.tensors;case n.onnx.AttributeProto.AttributeType.GRAPHS:return e.graphs;default:throw new Error(`unsupported attribute type: ${n.onnx.AttributeProto.AttributeType[e.type]}`)}}static getValueNoCheckFromOrtFormat(e){switch(e.type()){case s.AttributeType.FLOAT:return e.f();case s.AttributeType.INT:return e.i();case s.AttributeType.STRING:return e.s();case s.AttributeType.TENSOR:return e.t();case s.AttributeType.GRAPH:return e.g();case s.AttributeType.FLOATS:return e.floatsArray();case s.AttributeType.INTS:{const t=[];for(let r=0;r<e.intsLength();r++)t.push(e.ints(r));return t}case s.AttributeType.STRINGS:{const t=[];for(let r=0;r<e.stringsLength();r++)t.push(e.strings(r));return t}case s.AttributeType.TENSORS:{const t=[];for(let r=0;r<e.tensorsLength();r++)t.push(e.tensors(r));return t}default:throw new Error(`unsupported attribute type: ${s.AttributeType[e.type()]}`)}}}t.Attribute=l},7091:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.resolveBackend=t.backend=void 0;const n=r(5038),a=new Map;async function o(e){const r=t.backend;if(void 0!==r[e]&&function(e){const t=e;return"initialize"in t&&"function"==typeof t.initialize&&"createSessionHandler"in t&&"function"==typeof t.createSessionHandler&&"dispose"in t&&"function"==typeof t.dispose}(r[e])){const t=r[e];let n=t.initialize();if("object"==typeof n&&"then"in n&&(n=await n),n)return a.set(e,t),t}}t.backend={webgl:new n.WebGLBackend},t.resolveBackend=async function e(t){if(!t)return e(["webgl"]);{const e="string"==typeof t?[t]:t;for(const t of e){const e=a.get(t);if(e)return e;const r=await o(t);if(r)return r}}throw new Error("no available backend to use")}},5038:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLBackend=void 0;const n=r(1670),a=r(6231),o=r(6416),i=r(7305);t.WebGLBackend=class{get contextId(){return n.env.webgl.contextId}set contextId(e){n.env.webgl.contextId=e}get matmulMaxBatchSize(){return n.env.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){n.env.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return n.env.webgl.textureCacheMode}set textureCacheMode(e){n.env.webgl.textureCacheMode=e}get pack(){return n.env.webgl.pack}set pack(e){n.env.webgl.pack=e}get async(){return n.env.webgl.async}set async(e){n.env.webgl.async=e}initialize(){try{return this.glContext=(0,i.createWebGLContext)(this.contextId),"number"!=typeof this.matmulMaxBatchSize&&(this.matmulMaxBatchSize=16),"string"!=typeof this.textureCacheMode&&(this.textureCacheMode="full"),"boolean"!=typeof this.pack&&(this.pack=!1),"boolean"!=typeof this.async&&(this.async=!1),a.Logger.setWithEnv(n.env),a.Logger.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return a.Logger.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new o.WebGLSessionHandler(this,e)}dispose(){this.glContext.dispose()}}},5107:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.CoordsGlslLib=void 0;const n=r(2517),a=r(8520),o=r(5060),i=r(7859),s=r(9390);class l extends a.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.offsetToCoords()),this.coordsToOffset()),this.toVec()),this.valueFrom()),this.getCommonUtilFuncs()),this.getInputsSamplingSnippets()),this.getOutputSamplingSnippet())}getCustomTypes(){return{}}offsetToCoords(){return{offsetToCoords:new a.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ")}}coordsToOffset(){return{coordsToOffset:new a.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ")}}getOutputSamplingSnippet(){const e=this.context.outputTextureLayout;return e.isPacked?this.getPackedOutputSamplingSnippet(e):this.getUnpackedOutputSamplingSnippet(e)}getPackedOutputSamplingSnippet(e){const t=e.unpackedShape,r=[e.width,e.height],n={},i="getOutputCoords";switch(t.length){case 0:n[i]=this.getOutputScalarCoords();break;case 1:n[i]=this.getOutputPacked1DCoords(t,r);break;case 2:n[i]=this.getOutputPacked2DCoords(t,r);break;case 3:n[i]=this.getOutputPacked3DCoords(t,r);break;default:n[i]=this.getOutputPackedNDCoords(t,r)}const s=`\n      void setOutput(vec4 val) {\n        ${(0,o.getGlsl)(this.context.glContext.version).output} = val;\n      }\n    `;return n.floatTextureSetRGBA=new a.GlslLibRoutine(s),n}getUnpackedOutputSamplingSnippet(e){const t=e.unpackedShape,r=[e.width,e.height],n={},i="getOutputCoords";switch(t.length){case 0:n[i]=this.getOutputScalarCoords();break;case 1:n[i]=this.getOutputUnpacked1DCoords(t,r);break;case 2:n[i]=this.getOutputUnpacked2DCoords(t,r);break;case 3:n[i]=this.getOutputUnpacked3DCoords(t,r);break;case 4:n[i]=this.getOutputUnpacked4DCoords(t,r);break;case 5:n[i]=this.getOutputUnpacked5DCoords(t,r);break;case 6:n[i]=this.getOutputUnpacked6DCoords(t,r);break;default:throw new Error(`Unsupported output dimensionality: ${t.length}`)}const s=`\n        void setOutput(float val) {\n          ${(0,o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);\n        }\n    `;return n.floatTextureSetR=new a.GlslLibRoutine(s),n}getOutputScalarCoords(){return new a.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ")}getOutputPacked1DCoords(e,t){const r=t;let n="";return 1===r[0]?(n=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.y * ${r[1]}.0);\n          }\n        `,new a.GlslLibRoutine(n)):1===r[1]?(n=`\n          int getOutputCoords() {\n            return 2 * int(TexCoords.x * ${r[0]}.0);\n          }\n        `,new a.GlslLibRoutine(n)):(n=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                 vec2(${r[0]}, ${r[1]}));\n          return 2 * (resTexRC.y * ${r[0]} + resTexRC.x);\n        }\n      `,new a.GlslLibRoutine(n))}getOutputPacked2DCoords(e,t){let r="";if(n.ArrayUtil.arraysEqual(e,t))return r=`\n        ivec2 getOutputCoords() {\n          return 2 * ivec2(TexCoords.xy * vec2(${t[0]}, ${t[1]}));\n        }\n      `,new a.GlslLibRoutine(r);const o=t,i=Math.ceil(e[1]/2);return r=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${o[0]}, ${o[1]}));\n\n          int index = resTexRC.y * ${o[0]} + resTexRC.x;\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${i}) * 2;\n          int c = 2 * (index / ${i});\n\n          return ivec2(r, c);\n        }\n      `,new a.GlslLibRoutine(r)}getOutputPacked3DCoords(e,t){const r=[t[0],t[1]],n=Math.ceil(e[2]/2),o=n*Math.ceil(e[1]/2),i=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${r[0]}, ${r[1]}));\n          int index = resTexRC.y * ${r[0]} + resTexRC.x;\n\n          int b = index / ${o};\n          index -= b * ${o};\n\n          // reverse r and c order for packed texture\n          int r = imod(index, ${n}) * 2;\n          int c = 2 * (index / ${n});\n\n          return ivec3(b, r, c);\n        }\n      `;return new a.GlslLibRoutine(i)}getOutputPackedNDCoords(e,t){const r=[t[0],t[1]],n=Math.ceil(e[e.length-1]/2),o=n*Math.ceil(e[e.length-2]/2);let i=o,s="",l="b, r, c";for(let t=2;t<e.length-1;t++)i*=e[e.length-t-1],s=`\n      int b${t} = index / ${i};\n      index -= b${t} * ${i};\n    `+s,l=`b${t}, `+l;const d=`\n      ivec${e.length} getOutputCoords() {\n        ivec2 resTexRC = ivec2(TexCoords.xy *\n                              vec2(${r[0]}, ${r[1]}));\n        int index = resTexRC.y * ${r[0]} + resTexRC.x;\n\n        ${s}\n\n        int b = index / ${o};\n        index -= b * ${o};\n\n        // reverse r and c order for packed texture\n        int r = imod(index, ${n}) * 2;\n        int c = 2 * (index / ${n});\n\n        return ivec${e.length}(${l});\n      }\n    `;return new a.GlslLibRoutine(d)}getOutputUnpacked1DCoords(e,t){const r=`\n        int getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          return resTexRC.y * ${t[0]} + resTexRC.x;\n        }\n      `;return new a.GlslLibRoutine(r)}getOutputUnpacked2DCoords(e,t){const r=`\n        ivec2 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          int r = index / ${e[1]};\n          int c = index - r * ${e[1]};\n          return ivec2(r, c);\n        }\n      `;return new a.GlslLibRoutine(r)}getOutputUnpacked3DCoords(e,t){let r="";const n=e.length;let o=null;n<2&&(o=[]),o=new Array(n-1),o[n-2]=e[n-1];for(let t=n-3;t>=0;--t)o[t]=o[t+1]*e[t+1];const i=["r","c","d"],s=o.map(((e,t)=>`int ${i[t]} = index / ${e}; ${t===o.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`)).join("");return r=`\n        ivec3 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${s}\n          return ivec3(r, c, d);\n        }\n      `,new a.GlslLibRoutine(r)}getOutputUnpacked4DCoords(e,t){let r="";const n=e.length;let o=null;n<2&&(o=[]),o=new Array(n-1),o[n-2]=e[n-1];for(let t=n-3;t>=0;--t)o[t]=o[t+1]*e[t+1];const i=["r","c","d","d2"],s=o.map(((e,t)=>`int ${i[t]} = index / ${e}; ${t===o.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`)).join("");return r=`\n      ivec4 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${s}\n          return ivec4(r, c, d, d2);\n        }\n      `,new a.GlslLibRoutine(r)}getOutputUnpacked5DCoords(e,t){let r="";const n=e.length;let o=null;n<2&&(o=[]),o=new Array(n-1),o[n-2]=e[n-1];for(let t=n-3;t>=0;--t)o[t]=o[t+1]*e[t+1];const i=["r","c","d","d2","d3"],s=o.map(((e,t)=>`int ${i[t]} = index / ${e}; ${t===o.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`)).join("");return r=`\n      ivec5 getOutputCoords() {\n          ivec2 resTexRC = ivec2(TexCoords.xy *\n                                vec2(${t[0]}, ${t[1]}));\n          int index = resTexRC.y * ${t[0]} + resTexRC.x;\n          ${s}\n          return ivec5(r, c, d, d2, d3);\n        }\n      `,new a.GlslLibRoutine(r)}getOutputUnpacked6DCoords(e,t){let r="";const n=e.length;let o=null;n<2&&(o=[]),o=new Array(n-1),o[n-2]=e[n-1];for(let t=n-3;t>=0;--t)o[t]=o[t+1]*e[t+1];const i=["r","c","d","d2","d3","d4"],s=o.map(((e,t)=>`int ${i[t]} = index / ${e}; ${t===o.length-1?`int ${i[t+1]} = index - ${i[t]} * ${e}`:`index -= ${i[t]} * ${e}`};`)).join("");return r=`\n     ivec6 getOutputCoords() {\n         ivec2 resTexRC = ivec2(TexCoords.xy *\n                               vec2(${t[0]}, ${t[1]}));\n         int index = resTexRC.y * ${t[0]} + resTexRC.x;\n         ${s}\n         return ivec6(r, c, d, d2, d3, d4);\n       }\n     `,new a.GlslLibRoutine(r)}getCommonUtilFuncs(){const e={};let t="uvFromFlat";e[t]=new a.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "),t="packedUVfrom1D",e[t]=new a.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="packedUVfrom2D",e[t]=new a.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="packedUVfrom3D",e[t]=new a.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "),t="sampleTexture";const r=(0,o.getGlsl)(this.context.glContext.version);return e[t]=new a.GlslLibRoutine(`\n        float sampleTexture(sampler2D textureSampler, vec2 uv) {\n            return ${r.texture2D}(textureSampler, uv).r;\n        }`),e}getInputsSamplingSnippets(){const e={},t=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach(((r,n)=>{const a=this.context.inputTextureLayouts[n],o=(0,s.generateShaderFuncNameFromInputSamplerName)(r);a.isPacked?e[o]=this.getPackedSamplerFromInput(o,r,a):e[o]=this.getUnpackedSamplerFromInput(o,r,a);const i=(0,s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(r);a.unpackedShape.length<=t.unpackedShape.length&&(a.isPacked?e[i]=this.getPackedSamplerAtOutputCoords(i,a,t,r):e[i]=this.getUnpackedSamplerAtOutputCoords(i,a,t,r))})),e}getPackedSamplerAtOutputCoords(e,t,r,o){const i=t.unpackedShape,l=r.unpackedShape,d=o,u=(0,s.generateShaderFuncNameFromInputSamplerName)(d),c=i.length,p=l.length,g=n.BroadcastUtil.getBroadcastDims(i,l),A=(0,s.getCoordsDataType)(p),h=p-c;let B;const m=(0,s.getGlChannels)();B=0===c?"":p<2&&g.length>=1?"coords = 0;":g.map((e=>`coords.${m[e+h]} = 0;`)).join("\n");let C="";C=p<2&&c>0?"coords":i.map(((e,t)=>`coords.${m[t+h]}`)).join(", ");let w="return outputValue;";const b=1===n.ShapeUtil.size(i),K=1===n.ShapeUtil.size(l);if(1!==c||b||K){if(b&&!K)w=1===p?"\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        ":"\n          return vec4(outputValue.x);\n        ";else if(g.length){const e=c-2,t=c-1;g.indexOf(e)>-1&&g.indexOf(t)>-1?w="return vec4(outputValue.x);":g.indexOf(e)>-1?w="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":g.indexOf(t)>-1&&(w="return vec4(outputValue.xx, outputValue.zz);")}}else w="\n        return vec4(outputValue.xy, outputValue.xy);\n      ";const f=`\n      vec4 ${e}() {\n        ${A} coords = getOutputCoords();\n        \n        int lastDim = coords.${m[p-1]};\n        coords.${m[p-1]} = coords.${m[p-2]};\n        coords.${m[p-2]} = lastDim;\n      \n        ${B}\n        vec4 outputValue = ${u}(${C});\n        ${w}\n      }\n    `;return new a.GlslLibRoutine(f,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(e,t,r,o){const i=[r.width,r.height],l=[t.width,t.height],d=t.unpackedShape.length,u=r.unpackedShape.length,c=t.unpackedShape,p=r.unpackedShape,g=(0,s.generateShaderFuncNameFromInputSamplerName)(o);if(d===u&&n.ArrayUtil.arraysEqual(l,i)){const t=`\n          float ${e}() {\n            return sampleTexture(${o}, TexCoords);\n          }\n        `;return new a.GlslLibRoutine(t,["coordinates.sampleTexture"])}const A=(0,s.getCoordsDataType)(u),h=n.BroadcastUtil.getBroadcastDims(c,p),B=u-d;let m;const C=(0,s.getGlChannels)();m=0===d?"":u<2&&h.length>=1?"coords = 0;":h.map((e=>`coords.${C[e+B]} = 0;`)).join("\n");let w="";w=u<2&&d>0?"coords":t.unpackedShape.map(((e,t)=>`coords.${C[t+B]}`)).join(", ");const b=`\n        float ${e}() {\n          ${A} coords = getOutputCoords();\n          ${m}\n          return ${g}(${w});\n        }\n      `;return new a.GlslLibRoutine(b,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(e,t,r){switch(r.unpackedShape.length){case 0:return this.getPackedSamplerScalar(e,t);case 1:return this.getPackedSampler1D(e,t,r);case 2:return this.getPackedSampler2D(e,t,r);case 3:return this.getPackedSampler3D(e,t,r);default:return this.getPackedSamplerND(e,t,r)}}getUnpackedSamplerFromInput(e,t,r){const n=r.unpackedShape;switch(n.length){case 0:return this.getUnpackedSamplerScalar(e,t,r);case 1:return this.getUnpackedSampler1D(e,t,r);case 2:return this.getUnpackedSampler2D(e,t,r);case 3:return this.getUnpackedSampler3D(e,t,r);case 4:return this.getUnpackedSampler4D(e,t,r);case 5:return this.getUnpackedSampler5D(e,t,r);case 6:return this.getUnpackedSampler6D(e,t,r);default:throw new Error(`Unsupported dimension ${n.length}-D`)}}getPackedSamplerScalar(e,t){const r=`\n          vec4 ${e}() {\n            return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${t}, halfCR);\n          }\n        `;return new a.GlslLibRoutine(r)}getPackedSampler1D(e,t,r){const n=[r.width,r.height],i=[n[1],n[0]],s=(0,o.getGlsl)(this.context.glContext.version),l=`vec4 ${e}(int index) {\n      vec2 uv = packedUVfrom1D(\n      ${i[0]}, ${i[1]}, index);\n      return ${s.texture2D}(${t}, uv);\n    }`;return new a.GlslLibRoutine(l,["coordinates.packedUVfrom1D"])}getPackedSampler2D(e,t,r){const i=r.unpackedShape,s=[r.width,r.height],l=(0,o.getGlsl)(this.context.glContext.version),d=s[0],u=s[1];if(null!=s&&n.ArrayUtil.arraysEqual(i,s)){const r=`vec4 ${e}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${u}.0, ${d}.0);\n        return ${l.texture2D}(${t}, uv);\n      }`;return new a.GlslLibRoutine(r)}const c=s,p=Math.ceil(i[1]/2),g=`vec4 ${e}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c[1]}, ${c[0]}, ${p}, row, col);\n      return ${l.texture2D}(${t}, uv);\n    }`;return new a.GlslLibRoutine(g,["coordinates.packedUVfrom2D"])}getPackedSampler3D(e,t,r){const n=r.unpackedShape,i=[r.width,r.height],l=[i[0],i[1]],d=(0,o.getGlsl)(this.context.glContext.version);if(1===n[0]){const o=n.slice(1),i=[1,2],l=(0,s.squeezeInputShape)(n,o),d=["b","row","col"],u=JSON.parse(JSON.stringify(r));u.unpackedShape=l;const c=this.getPackedSamplerFromInput(e,t,u),p=`${c.routineBody}\n      vec4 ${e}(int b, int row, int col) {\n        return ${e}(${(0,s.getSqueezedParams)(d,i)});\n      } `;return new a.GlslLibRoutine(p,c.dependencies)}const u=l[0],c=l[1],p=Math.ceil(n[2]/2),g=`vec4 ${e}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${c}, ${u}, ${p*Math.ceil(n[1]/2)}, ${p}, b, row, col);\n      return ${d.texture2D}(${t}, uv);}`;return new a.GlslLibRoutine(g,["coordinates.packedUVfrom3D"])}getPackedSamplerND(e,t,r){const n=r.unpackedShape,i=n.length,s=[r.width,r.height],l=(0,o.getGlsl)(this.context.glContext.version),d=[s[0],s[1]],u=d[1],c=d[0],p=Math.ceil(n[i-1]/2);let g=p*Math.ceil(n[i-2]/2),A="int b, int row, int col",h=`b * ${g} + (row / 2) * ${p} + (col / 2)`;for(let e=2;e<i-1;e++)A=`int b${e}, `+A,g*=n[i-e-1],h=`b${e} * ${g} + `+h;const B=`vec4 ${e}(${A}) {\n      int index = ${h};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${l.texture2D}(${t}, uv);\n    }`;return new a.GlslLibRoutine(B)}getUnpackedSamplerScalar(e,t,r){const[n,o]=[r.width,r.height];if(1===n&&1===o){const r=`\n          float ${e}() {\n            return sampleTexture(${t}, halfCR);\n          }\n        `;return new a.GlslLibRoutine(r,["coordinates.sampleTexture"])}const i=`\n        float ${e}() {\n          int offset_${t} = coordsToOffset(TexCoords, ${n}, ${o});\n          vec2 uv = uvFromFlat(${n}, ${o}, offset_${t});\n          return sampleTexture(${t}, uv);\n        }\n      `;return new a.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(e,t,r){const n=r.width,o=r.height;if(1===o&&1===n){const r=`\n        float ${e}(int index) {\n          return sampleTexture(${t}, halfCR);\n        }\n      `;return new a.GlslLibRoutine(r,["coordinates.sampleTexture"])}if(1===o){const r=`\n          float ${e}(int index) {\n            vec2 uv = vec2((float(index) + 0.5) / ${n}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new a.GlslLibRoutine(r,["coordinates.sampleTexture"])}if(1===n){const r=`\n          float ${e}(int index) {\n            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new a.GlslLibRoutine(r,["coordinates.sampleTexture"])}const i=`\n        float ${e}(int index) {\n          vec2 uv = uvFromFlat(${n}, ${o}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new a.GlslLibRoutine(i,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(e,t,r){const o=r.unpackedShape,l=[r.height,r.width];if(null!=l&&n.ArrayUtil.arraysEqual(o,l)){const r=`\n          float ${e}(int row, int col) {\n            vec2 uv = (vec2(row, col) + halfCR) / vec2(${l[1]}.0, ${l[0]}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new a.GlslLibRoutine(r,["coordinates.sampleTexture"])}const{newShape:d,keptDims:u}=(0,i.squeezeShape)(o),c=d;if(c.length<o.length){const n=(0,s.squeezeInputShape)(o,c),i=JSON.parse(JSON.stringify(r));i.unpackedShape=n;const l=["col","row"],d=`\n          ${this.getUnpackedSamplerFromInput(e,t,i).routineBody}\n          float ${e}(int row, int col) {\n            return ${e}(${(0,s.getSqueezedParams)(l,u)});\n          }\n        `;return new a.GlslLibRoutine(d,["coordinates.sampleTexture"])}const p=l[1],g=l[0];if(1===g){const r=`\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${p}, ${g});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${o[1]}, 1, 1));\n            vec2 uv = vec2(0.5, (index + 0.5) / ${p}.0);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new a.GlslLibRoutine(r,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(1===p){const r=`\n          float ${e}(int row, int col) {\n            int offset_${t} = coordsToOffset(TexCoords, ${p}, ${g});\n            float index = dot(vec3(row, col, offset_${t}), vec3(${o[1]}, 1, 1));\n            vec2 uv = vec2((index + 0.5) / ${g}.0, 0.5);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new a.GlslLibRoutine(r,["coordinates.sampleTexture","coordinates.coordsToOffset"])}const A=`\n        float ${e}(int row, int col) {\n          int index = col * ${o[1]} + row;\n          vec2 uv = uvFromFlat(${p}, ${g}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new a.GlslLibRoutine(A,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(e,t,r){const n=r.unpackedShape,o=n[1]*n[2],l=n[2],{newShape:d,keptDims:u}=(0,i.squeezeShape)(n),c=d;if(c.length<n.length){const o=(0,s.squeezeInputShape)(n,c),i=["batch","col","row"],l=JSON.parse(JSON.stringify(r));l.unpackedShape=o;const d=this.getUnpackedSamplerFromInput(e,t,l),p=u.reverse(),g=`\n          ${d.routineBody}\n          float ${e}(int batch, int row, int col) {\n            return ${e}(${(0,s.getSqueezedParams)(i,p)});\n          }\n        `;return new a.GlslLibRoutine(g,d.dependencies)}const p=`\n          float ${e}(int depth, int row, int col) {\n            // Explicitly use integer operations as dot() only works on floats.\n            int index = depth * ${o} + col * ${l} + row;\n            vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n      `;return new a.GlslLibRoutine(p,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(e,t,r){const n=r.unpackedShape,o=n[3],i=n[2]*o,s=`\n        float ${e}(int row, int col, int depth, int depth2) {\n          int index = row * ${n[1]*i} + col * ${i} +\n              depth2 * ${o} + depth;\n          vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new a.GlslLibRoutine(s,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(e,t,r){const n=r.unpackedShape,o=n[4],l=n[3]*o,d=n[2]*l,u=n[1]*d,{newShape:c,keptDims:p}=(0,i.squeezeShape)(n);if(c.length<n.length){const o=(0,s.squeezeInputShape)(n,c),i=["row","col","depth","depth2","depth3"],l=JSON.parse(JSON.stringify(r));l.unpackedShape=o;const d=`\n          ${this.getUnpackedSamplerFromInput(e,t,l).routineBody}\n          float ${e}(int row, int col, int depth, int depth2, int depth3) {\n            return ${e}(${(0,s.getSqueezedParams)(i,p)});\n          }\n        `;return new a.GlslLibRoutine(d,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const g=`\n        float ${e}(int row, int col, int depth, int depth2, int depth3) {\n          int index = row * ${u} + col * ${d} + depth * ${l} +\n          depth3 * ${o} + depth2;\n          vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);\n          return sampleTexture(${t}, uv);\n        }\n      `;return new a.GlslLibRoutine(g,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(e,t,r){const n=r.unpackedShape,o=n[5],l=n[4]*o,d=n[3]*l,u=n[2]*d,c=n[1]*u,{newShape:p,keptDims:g}=(0,i.squeezeShape)(n);if(p.length<n.length){const o=(0,s.squeezeInputShape)(n,p),i=["row","col","depth","depth2","depth3","depth4"],l=JSON.parse(JSON.stringify(r));l.unpackedShape=o;const d=`\n            ${this.getUnpackedSamplerFromInput(e,t,l).routineBody}\n            float ${e}(int row, int col, int depth,\n              int depth2, int depth3, int depth4) {\n              return ${e}(${(0,s.getSqueezedParams)(i,g)});\n            }\n          `;return new a.GlslLibRoutine(d,["coordinates.sampleTexture","coordinates.uvFromFlat"])}const A=`\n          float ${e}(int row, int col, int depth,\n            int depth2, int depth3, int depth4) {\n            int index = row * ${c} + col * ${u} + depth * ${d} +\n            depth2 * ${l} + depth3 * ${o} + depth4;\n            vec2 uv = uvFromFlat(${r.width}, ${r.height}, index);\n            return sampleTexture(${t}, uv);\n          }\n        `;return new a.GlslLibRoutine(A,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){const e=this.context.outputTextureLayout,t=e.shape.length,r=e.strides,n=e.width,o=e.height,i=[];for(let e=0;e<t-1;++e)i.push(`\n        c[${e}] = offset / ${r[e]};`),i.push(`\n        offset -= c[${e}] * ${r[e]};`);i.push(`\n        c[${t-1}] = offset;`);const s=`\n      void toVec(vec2 texCoords, out int c[${t}]) {\n        int offset = coordsToOffset(texCoords, ${n}, ${o});\n        ${i.join("")}\n      }\n      void toVec(int offset, out int c[${t}]) {\n        ${i.join("")}\n      }\n    `;return{toVec:new a.GlslLibRoutine(s,["coordinates.coordsToOffset"])}}valueFrom(){const e={};return this.context.programInfo.inputNames.forEach(((t,r)=>{const n=this.context.inputTextureLayouts[r],o=(n.unpackedShape.length>0?n.unpackedShape:n.shape).length;let i=`_${t}`;e[i]=new a.GlslLibRoutine(this.getValueFromSingle(t,o,n.width,n.height,!1),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),i+="_T",e[i]=new a.GlslLibRoutine(this.getValueFromSingle(t,o,n.width,n.height,!0),[`shapeUtils.indicesToOffset${i}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])})),e}getValueFromSingle(e,t,r,n,a){let i=`_${e}`;return a&&(i+="_T"),`\n        float ${i}(int m[${t}]) {\n          int offset = indicesToOffset${i}(m);\n          vec2 coords = offsetToCoords(offset, ${r}, ${n});\n          float value = getColorAsFloat(${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords));\n          return value;\n        }\n        `}getPackedValueFrom(e,t,r,n,a){let i=`_${e}_Pack`;return a&&(i+="_T"),`\n        vec4 ${i}(int m[${t}]) {\n          int offset = indicesToOffset_${e}(m);\n          vec2 coords = offsetToCoords(offset, ${r}, ${n});\n          return ${(0,o.getGlsl)(this.context.glContext.version).texture2D}(${e}, coords);\n        }\n        `}}t.CoordsGlslLib=l},8520:(e,t)=>{var r;Object.defineProperty(t,"__esModule",{value:!0}),t.TopologicalSortGlslRoutines=t.GlslLibRoutineNode=t.GlslLibRoutine=t.GlslLib=t.GlslContext=t.FunctionType=void 0,(r=t.FunctionType||(t.FunctionType={}))[r.ValueBased=0]="ValueBased",r[r.Positional=1]="Positional",t.GlslContext=class{constructor(e,t,r,n){this.glContext=e,this.programInfo=t,this.inputTextureLayouts=r,this.outputTextureLayout=n}},t.GlslLib=class{constructor(e){this.context=e}},t.GlslLibRoutine=class{constructor(e,t){this.routineBody=e,this.dependencies=t}},t.GlslLibRoutineNode=class{constructor(e,t,r){this.name=e,this.dependencies=r||[],t&&(this.routineBody=t)}addDependency(e){e&&this.dependencies.push(e)}},t.TopologicalSortGlslRoutines=class{static returnOrderedNodes(e){if(!e||0===e.length)return[];if(1===e.length)return e;const t=new Set,r=new Set,n=new Array;return this.createOrderedNodes(e,t,r,n),n}static createOrderedNodes(e,t,r,n){for(let a=0;a<e.length;++a)this.dfsTraverse(e[a],t,r,n)}static dfsTraverse(e,t,r,n){if(!e||r.has(e.name))return;if(t.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");t.add(e.name);const a=e.dependencies;if(a&&a.length>0)for(let e=0;e<a.length;++e)this.dfsTraverse(a[e],t,r,n);n.push(e),r.add(e.name),t.delete(e.name)}}},7341:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.EncodingGlslLib=void 0;const n=r(8520);class a extends n.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign({},this.encodeFloat32()),this.decodeFloat32())}getCustomTypes(){return{}}encodeFloat32(){return{encode:new n.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ")}}decodeFloat32(){return{decode:new n.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ")}}encodeUint8(){const e=a.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new n.GlslLibRoutine(`\n      highp vec4 encode(highp float f) {\n        highp float F = abs(f);\n        highp float Sign = step(0.0,-f);\n        highp float Exponent = floor(log2(F));\n        highp float Mantissa = (exp2(- Exponent) * F);\n        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));\n        highp vec4 rgba;\n        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));\n        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);\n        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));\n        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));\n        ${e}\n        rgba = rgba / 255.0; // values need to be normalized to [0,1]\n        return rgba;\n    }\n        `)}}decodeUint8(){const e=a.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new n.GlslLibRoutine(`\n        highp float decode(highp vec4 rgba) {\n          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]\n          ${e}\n          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n          return Result;\n      }\n        `)}}static isLittleEndian(){const e=new ArrayBuffer(4),t=new Uint32Array(e),r=new Uint8Array(e);if(t[0]=3735928559,239===r[0])return!0;if(222===r[0])return!1;throw new Error("unknown endianness")}}t.EncodingGlslLib=a},9894:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FragColorGlslLib=void 0;const n=r(8520),a=r(5060);class o extends n.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign({},this.setFragColor()),this.getColorAsFloat())}getCustomTypes(){return{}}setFragColor(){const e=(0,a.getGlsl)(this.context.glContext.version);return{setFragColor:new n.GlslLibRoutine(`\n        void setFragColor(float value) {\n            ${e.output} = encode(value);\n        }\n        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new n.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ",["encoding.decode"])}}}t.FragColorGlslLib=o},2848:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.replaceInlines=void 0;const r=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;t.replaceInlines=function(e){const t={};let n;for(;null!==(n=r.exec(e));){const e=n[3].split(",").map((e=>{const t=e.trim().split(" ");return t&&2===t.length?{type:t[0],name:t[1]}:null})).filter((e=>null!==e));t[n[2]]={params:e,body:n[4]}}for(const r in t){const a="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__",r),o=new RegExp(a,"gm");for(;null!==(n=o.exec(e));){const a=n[1],o=n[2],i=n[3].split(","),s=a?`${a} ${o};`:"";let l=t[r].body,d="";t[r].params.forEach(((e,t)=>{e&&(d+=`${e.type} ${e.name} = ${i[t]};\n`)})),l=`${d}\n ${l}`,l=l.replace("return",`${o} = `);const u=`\n      ${s}\n      {\n        ${l}\n      }\n      `;e=e.replace(n[0],u)}}return e.replace(r,"")}},8879:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.GlslPreprocessor=void 0;const n=r(8520),a=r(2848),o=r(5483),i=r(5060);t.GlslPreprocessor=class{constructor(e,t,r,a){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new n.GlslContext(e,t,r,a),Object.keys(o.glslRegistry).forEach((e=>{const t=new o.glslRegistry[e](this.context);this.libs[e]=t}));const i=this.glslLibRoutineDependencyGraph;for(const e in this.libs){const t=this.libs[e].getFunctions();for(const r in t){const a=e+"."+r;let o;i[a]?(o=i[a],o.routineBody=t[r].routineBody):(o=new n.GlslLibRoutineNode(a,t[r].routineBody),i[a]=o);const s=t[r].dependencies;if(s)for(let e=0;e<s.length;++e)if(i[s[e]])o.addDependency(i[s[e]]);else{const t=new n.GlslLibRoutineNode(s[e]);i[s[e]]=t,o.addDependency(t)}}}}preprocess(){const e=this.context.programInfo;let t=e.shaderSource;return this.context.programInfo.hasMain||(t=`${t}\n      ${(0,i.getDefaultFragShaderMain)(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),t=(0,a.replaceInlines)(t),`${(0,i.getFragShaderPreamble)(this.context.glContext.version)}\n    ${this.getUniforms(e.inputNames,e.variables)}\n    ${this.getImports(t)}\n    ${t}`}getImports(e){const t=this.selectGlslLibRoutinesToBeIncluded(e);if(0===t.length)return"";let r="";for(let e=0;e<t.length;++e){if(!t[e].routineBody)throw new Error(`Missing body for the Glsl Library routine: ${t[e].name}`);r+=t[e].routineBody+"\n"}return r}selectGlslLibRoutinesToBeIncluded(e){const t=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach((r=>{const n=r.split(".")[1];-1!==e.indexOf(n)&&t.push(this.glslLibRoutineDependencyGraph[r])})),n.TopologicalSortGlslRoutines.returnOrderedNodes(t)}getUniforms(e,t){const r=[];if(e)for(const t of e)r.push(`uniform sampler2D ${t};`);if(t)for(const e of t)r.push(`uniform ${e.type} ${e.name}${e.arrayLength?`[${e.arrayLength}]`:""};`);return r.join("\n")}}},5483:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.glslRegistry=void 0;const n=r(5107),a=r(7341),o=r(9894),i=r(2655),s=r(3891);t.glslRegistry={encoding:a.EncodingGlslLib,fragcolor:o.FragColorGlslLib,vec:s.VecGlslLib,shapeUtils:i.ShapeUtilsGlslLib,coordinates:n.CoordsGlslLib}},2655:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ShapeUtilsGlslLib=void 0;const n=r(8520);class a extends n.GlslLib{constructor(e){super(e)}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({},this.bcastIndex()),this.bcastMatmulIndex()),this.offsetToIndices()),this.indicesToOffset()),this.incrementIndices())}getCustomTypes(){return{}}bcastIndex(){const e=this.context.outputTextureLayout.shape.length,t={};return this.context.programInfo.inputNames.forEach(((r,a)=>{const o=this.context.inputTextureLayouts[a].unpackedShape;if(o.length<=e){const a=o.length,i=e-a,s=`bcastIndices_${r}`;let l="";for(let e=0;e<a;++e)l+=`\n          realIndices[${e}] = int( mod(float(bcastedIndices[${i+e}]), ${o[e]}.0) );\n          `;const d=`\n        void ${s} (int bcastedIndices[${e}], out int realIndices[${a}]) {\n          ${l}\n        }\n        `;t[s]=new n.GlslLibRoutine(d)}})),t}bcastMatmulIndex(){const e=this.context.outputTextureLayout.shape.length,t={};return this.context.programInfo.inputNames.forEach(((r,a)=>{const o=this.context.inputTextureLayouts[a].shape;if(!(o.length<2||o.length>e)){const a=o.length,i=e-a,s=`bcastMatmulIndices_${r}`;let l="";for(let e=0;e<a-2;++e)l+=`\n          realIndices[${e}] = int( mod(float(bcastedIndices[${i+e}]), ${o[e]}.0) );\n          `;const d=`\n        void ${s}(int bcastedIndices[${e}], out int realIndices[${a}]) {\n          ${l}\n          realIndices[${a-1}] = bcastedIndices[${e-1}];\n          realIndices[${a-2}] = bcastedIndices[${e-2}];\n        }\n        `;t[s]=new n.GlslLibRoutine(d)}})),t}indicesToOffset(){const e={};return this.context.programInfo.inputNames.forEach(((t,r)=>{const o=this.context.inputTextureLayouts[r].shape,i=this.context.inputTextureLayouts[r].strides,s=o.length;let l=`indicesToOffset_${t}`;e[l]=new n.GlslLibRoutine(a.indexToOffsetSingle(l,s,i)),l=`indicesToOffset_${t}_T`,e[l]=new n.GlslLibRoutine(a.indexToOffsetSingle(l,s,i.slice().reverse()))})),e}static indexToOffsetSingle(e,t,r){let n="";for(let e=t-1;e>=0;--e)n+=`\n        offset += indices[${e}] * ${r[e]};\n        `;return`\n      int ${e}(int indices[${t}]) {\n        int offset = 0;\n        ${n}\n        return offset;\n      }\n      `}offsetToIndices(){const e={};return this.context.programInfo.inputNames.forEach(((t,r)=>{const o=this.context.inputTextureLayouts[r].shape,i=this.context.inputTextureLayouts[r].strides,s=o.length;let l=`offsetToIndices_${t}`;e[l]=new n.GlslLibRoutine(a.offsetToIndicesSingle(l,s,i)),l=`offsetToIndices_${t}_T`,e[l]=new n.GlslLibRoutine(a.offsetToIndicesSingle(l,s,i.slice().reverse()))})),e}static offsetToIndicesSingle(e,t,r){const n=[];for(let e=0;e<t-1;++e)n.push(`\n      indices[${e}] = offset / ${r[e]};`),n.push(`\n        offset -= indices[${e}] * ${r[e]};`);return n.push(`\n      indices[${t-1}] = offset;`),`\n      void ${e}(int offset, out int indices[${t}]) {\n        ${n.join("")}\n      }\n      `}incrementIndices(){const e={};return this.context.programInfo.inputNames.forEach(((t,r)=>{const a=this.context.inputTextureLayouts[r].shape,o=a.length,i=`incrementIndices_${t}`;let s="";for(let e=0;e<o;++e)s+=`\n        shape[${e}] = ${a[e]};`;const l=`\n        void ${i}(int axis, out int indices[${o}]) {\n          int shape[${o}];\n          ${s};\n          for(int i = ${o} -1 ; i >= 0; --i) {\n            if(i > axis) continue;\n            indices[i] += 1;\n            if(indices[i] < shape[i]) {\n              break;\n            }\n            indices[i] = 0;\n          }\n        }\n        `;e[i]=new n.GlslLibRoutine(l)})),e}}t.ShapeUtilsGlslLib=a},5060:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getDefaultFragShaderMain=t.getFragShaderPreamble=t.getVertexShaderSource=t.getGlsl=void 0;const r={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},n={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"};function a(e){return 1===e?r:n}t.getGlsl=a,t.getVertexShaderSource=function(e){const t=a(e);return`${t.version}\n      precision highp float;\n      ${t.attribute} vec3 position;\n      ${t.attribute} vec2 textureCoord;\n\n      ${t.varyingVertex} vec2 TexCoords;\n\n      void main()\n      {\n          gl_Position = vec4(position, 1.0);\n          TexCoords = textureCoord;\n      }`},t.getFragShaderPreamble=function(e){const t=a(e);return`${t.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${t.varyingFrag} vec2 TexCoords;\n    ${t.outputDeclaration}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    // Custom vector types to handle higher dimenalities.\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    `},t.getDefaultFragShaderMain=function(e,t){return`\n  void main() {\n    int indices[${t}];\n    toVec(TexCoords, indices);\n    vec4 result = vec4(process(indices));\n    ${a(e).output} = result;\n  }\n  `}},3891:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.VecGlslLib=void 0;const n=r(8520);class a extends n.GlslLib{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return Object.assign(Object.assign(Object.assign(Object.assign({},this.binaryVecFunctions()),this.copyVec()),this.setVecItem()),this.getVecItem())}binaryVecFunctions(){const e=this.context.outputTextureLayout.shape.length,t={add:"+=",sub:"-=",mul:"*=",div:"/="},r={};for(const a in t){const o=`${a}Vec`;let i="";for(let r=0;r<e;++r)i+=`\n          dest[${r}] ${t[a]} src[${r}];\n          `;const s=`\n        void ${o}(int src[${e}], out int dest[${e}]) {\n          ${i}\n        }\n        `;r[o]=new n.GlslLibRoutine(s)}return r}copyVec(){const e=this.context.outputTextureLayout.shape.length;let t="";for(let r=0;r<e;++r)t+=`\n        dest[${r}] = src[${r}];\n        `;const r=`\n      void copyVec(int src[${e}], out int dest[${e}]) {\n        ${t}\n      }\n      `;return{copyVec:new n.GlslLibRoutine(r)}}setVecItem(){const e=this.context.outputTextureLayout.shape.length;let t=`\n        if(index < 0)\n            index =${e} + index;\n        if (index == 0)\n            m[0] = value;\n        `;for(let r=1;r<e-1;++r)t+=`\n        else if (index == ${r})\n            m[${r}] = value;\n            `;t+=`\n        else\n            m[${e-1}] = value;\n        `;const r=`\n      void setVecItem(out int m[${e}], int index, int value) {\n        ${t}\n      }\n        `;return{setVecItem:new n.GlslLibRoutine(r)}}getVecItem(){const e=this.context.outputTextureLayout.shape.length;let t=`\n        if(index < 0)\n            index = ${e} + index;\n        if (index == 0)\n            return m[0];\n      `;for(let r=1;r<e-1;++r)t+=`\n        else if (index == ${r})\n            return m[${r}];\n      `;t+=`\n        else\n            return m[${e-1}];\n        `;const r=`\n      int getVecItem(int m[${e}], int index) {\n        ${t}\n      }\n    `;return{getVecItem:new n.GlslLibRoutine(r)}}}t.VecGlslLib=a},8316:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLInferenceHandler=void 0;const n=r(6231),a=r(9162),o=r(2517),i=r(2403),s=r(7019),l=r(8710),d=r(5611),u=r(4057),c=r(2039);t.WebGLInferenceHandler=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,t){return(0,u.calculateTextureWidthAndHeight)(this.session.layoutStrategy,e,t)}executeProgram(e,t){if(t.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");const r=[];for(let n=0;n<e.inputNames.length;++n)r[n]=this.getOrCreateTextureData(t[n],e.inputTypes[n]);const n=((e,t)=>{const r=t.map((e=>`${e.unpackedShape.join(",")};${e.width}x${e.height}`)).join("_");let n=e.name;return e.cacheHint&&(n+="["+e.cacheHint+"]"),n+=":"+r,n})(e,r);let a=this.session.programManager.getArtifact(n);const o=a?a.programInfo:"function"==typeof e.get?e.get():e,i=(0,u.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o.output.dims,o.output.textureType),s=this.createTextureData(i,o.output.type);return a||(a=this.session.programManager.build(o,r,s),this.session.programManager.setArtifact(n,a)),this.runProgram(a,r,s),s}run(e,t){return this.executeProgram(e,t).tensor}runProgram(e,t,r){for(let r=0;r<t.length;++r)if(!!t[r].isPacked!=(e.programInfo.inputTypes[r]===c.TextureType.packed))throw new Error(`input[${r}] property packed inconsistent`);if(!!r.isPacked!=(e.programInfo.output.textureType===c.TextureType.packed))throw new Error("output property packed inconsistent");this.session.programManager.run(e,t,r)}getOrCreateTextureData(e,t){let r=this.getTextureData(e.dataId,t===c.TextureType.packed);if(!r&&(r=this.getTextureData(e.dataId,t!==c.TextureType.packed),r))return t===c.TextureType.packed?this.pack(r):this.unpack(r);if(!r){const n=(0,u.createTextureLayoutFromTextureType)(this.session.layoutStrategy,e.dims,t);if(t===c.TextureType.packedLastDimension){const r=1,n=4,a=e.dims;if(4===a.length){const o=[a[0],Math.ceil(a[1]*a[2]*a[3]/n)],i=(0,u.createTextureLayoutFromTextureType)(this.session.layoutStrategy,o,t);let s=e.numberData;if(a[1]*a[2]*a[3]%n!=0){const t=a[0],o=a[1]*a[2]*a[3],i=Math.ceil(o*r/n)*n;s=new Float32Array(t*i);for(let n=0;n<t;++n){const t=n*o,a=n*i+n%r*o;s.set(e.numberData.subarray(t,t+o),a)}}return this.createTextureData(i,e.type,s,e,1)}}if(t===c.TextureType.packed){const t=(0,u.createTextureLayoutFromShape)(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),n=this.createTextureData(t,e.type,e.numberData,e,1);r=this.pack(n)}else r=this.createTextureData(n,e.type,e.numberData,e,1)}return r}createTextureDataFromLayoutBindTensor(e,t,r,n){return this.createTextureData(e,t,r,n,1)}createTextureData(e,t,r,a,o){n.Logger.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);const i=this.session.textureManager.createTextureFromLayout(t,e,r,o);return this.createTextureDataFromTexture(e,t,i,a)}reshapeUnpacked(e,t){const r=this.getOrCreateTextureData(e,c.TextureType.unpacked),n={channels:r.channels,height:r.height,width:r.width,shape:0!==t.length?t:[1],strides:o.ShapeUtil.computeStrides(t),unpackedShape:t};return this.createTextureDataFromTexture(n,e.type,r.texture).tensor}reshapePacked(e,t){const r=this.getOrCreateTextureData(e,c.TextureType.packed);if((0,s.isReshapeCheap)(e.dims,t)){const n={channels:r.channels,height:r.height,width:r.width,shape:0!==t.length?t:[1],strides:o.ShapeUtil.computeStrides(t),unpackedShape:t,isPacked:!0};return this.createTextureDataFromTexture(n,e.type,r.texture).tensor}const n=(0,s.processDims3D)(e.dims),a=(0,s.processDims3D)(t),i=this.reshapePacked(e,n),l=this.run((0,s.createPackedReshape3DProgramInfoLoader)(this,i,a),[i]);return this.reshapePacked(l,t)}cast(e,t){const r=this.getOrCreateTextureData(e,c.TextureType.unpacked);return this.createTextureDataFromTexture(r,t,r.texture).tensor}createTextureDataFromTexture(e,t,r,n,o){const i=Object.assign(Object.assign({},e),{tensor:n||new a.Tensor(e.unpackedShape,t,(e=>this.readTexture(i)),(async e=>this.readTextureAsync(i)),void 0,o),texture:r});return this.setTextureData(i.tensor.dataId,i,e.isPacked),i}getTextureData(e,t=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,t):t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,r=!1){this.session.isInitializer(e)?this.session.setTextureData(e,t,r):(r?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,t)}isTextureLayoutCached(e,t=!1){return!!this.getTextureData(e.dataId,t)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((e=>this.session.textureManager.releaseTexture(e))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((e=>this.session.textureManager.releaseTexture(e))),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,l.encodeAsUint8)(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat((0,l.encodeAsUint8)(this,e))}pack(e){return this.executeProgram((0,i.createPackProgramInfoLoader)(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram((0,d.createUnpackProgramInfoLoader)(this,e.tensor),[e.tensor])}}},1640:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WEBGL_OP_RESOLVE_RULES=void 0;const i=r(2898),s=o(r(7839)),l=r(4196),d=r(2069),u=r(8138),c=r(9663),p=r(5193),g=r(7992),A=r(1253),h=r(4776),B=r(6572),m=r(3346),C=r(5623),w=r(2870),b=r(2143),K=r(4939),f=r(718),Q=r(2268),W=r(8117),F=r(2278),_=r(5524),y=r(5975),v=r(3933),E=r(6558),G=r(5723),R=r(3738),x=o(r(4909)),S=r(8428),T=r(9793);t.WEBGL_OP_RESOLVE_RULES=[["Abs","","6+",x.abs],["Acos","","7+",x.acos],["Add","","7+",s.add],["And","","7+",s.and],["Asin","","7+",x.asin],["Atan","","7+",x.atan],["AveragePool","","7+",b.averagePool,b.parseAveragePoolAttributes],["BatchNormalization","","7+",i.batchNormalization,i.parseBatchNormalizationAttributes],["Cast","","6+",l.cast,l.parseCastAttributes],["Ceil","","6+",x.ceil],["Clip","","6-10",x.clip,x.parseClipAttributes],["Clip","","11+",x.clipV11],["Concat","","4+",d.concat,d.parseConcatAttributes],["Conv","","1+",u.conv,u.parseConvAttributes],["ConvTranspose","","1+",c.convTranspose,c.parseConvTransposeAttributes],["Cos","","7+",x.cos],["Div","","7+",s.div],["Dropout","","7+",x.identity],["DepthToSpace","","1+",p.depthToSpace,p.parseDepthToSpaceAttributes],["Equal","","7+",s.equal],["Elu","","6+",x.elu,x.parseEluAttributes],["Exp","","6+",x.exp],["Flatten","","1+",g.flatten,g.parseFlattenAttributes],["Floor","","6+",x.floor],["FusedConv","com.microsoft","1+",u.conv,u.parseConvAttributes],["Gather","","1+",A.gather,A.parseGatherAttributes],["Gemm","","7-10",h.gemm,h.parseGemmAttributesV7],["Gemm","","11+",h.gemm,h.parseGemmAttributesV11],["GlobalAveragePool","","1+",b.globalAveragePool,b.parseGlobalAveragePoolAttributes],["GlobalMaxPool","","1+",b.globalMaxPool],["Greater","","7+",s.greater],["Identity","","1+",x.identity],["ImageScaler","","1+",B.imageScaler,B.parseImageScalerAttributes],["InstanceNormalization","","6+",m.instanceNormalization,m.parseInstanceNormalizationAttributes],["LeakyRelu","","6+",x.leakyRelu,x.parseLeakyReluAttributes],["Less","","7+",s.less],["Log","","6+",x.log],["MatMul","","1+",C.matMul,C.parseMatMulAttributes],["MaxPool","","1+",b.maxPool,b.parseMaxPoolAttributes],["Mul","","7+",s.mul],["Neg","","6+",x.neg],["Not","","1+",x.not],["Or","","7+",s.or],["Pad","","2-10",w.padV2,w.parsePadAttributesV2],["Pad","","11+",w.padV11,w.parsePadAttributesV11],["Pow","","7+",s.pow],["PRelu","","7+",s.pRelu],["ReduceLogSum","","1+",K.reduceLogSum,K.parseReduceAttributes],["ReduceMax","","1+",K.reduceMax,K.parseReduceAttributes],["ReduceMean","","1+",K.reduceMean,K.parseReduceAttributes],["ReduceMin","","1+",K.reduceMin,K.parseReduceAttributes],["ReduceProd","","1+",K.reduceProd,K.parseReduceAttributes],["ReduceSum","","1-12",K.reduceSum,K.parseReduceAttributes],["ReduceSumSquare","","1+",K.reduceLogSumSquare,K.parseReduceAttributes],["Relu","","6+",x.relu],["Reshape","","5+",f.reshape],["Resize","","10",Q.resize,Q.parseResizeAttributesV10],["Resize","","11+",Q.resize,Q.parseResizeAttributesV11],["Shape","","1+",W.shape],["Sigmoid","","6+",x.sigmoid],["Sin","","7+",x.sin],["Slice","","10+",F.sliceV10],["Slice","","1-9",F.slice,F.parseSliceAttributes],["Softmax","","1-12",_.softmax,_.parseSoftmaxAttributes],["Softmax","","13+",_.softmaxV13,_.parseSoftmaxAttributesV13],["Split","","2-12",y.split,y.parseSplitAttributes],["Sqrt","","6+",x.sqrt],["Squeeze","","1-12",v.squeeze,v.parseSqueezeAttributes],["Squeeze","","13+",v.squeezeV13],["Sub","","7+",s.sub],["Sum","","6+",E.sum],["Tan","","7+",x.tan],["Tanh","","6+",x.tanh],["Tile","","6+",G.tile],["Transpose","","1+",R.transpose,R.parseTransposeAttributes],["Upsample","","7-8",T.upsample,T.parseUpsampleAttributesV7],["Upsample","","9",T.upsample,T.parseUpsampleAttributesV9],["Unsqueeze","","1-12",S.unsqueeze,S.parseUnsqueezeAttributes],["Unsqueeze","","13+",S.unsqueezeV13],["Xor","","7+",s.xor]]},2898:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseBatchNormalizationAttributes=t.batchNormalization=void 0;const n=r(246),a=r(5060),o=r(2039),i={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]};t.batchNormalization=(e,t,r)=>(l(t),[e.run(Object.assign(Object.assign({},i),{cacheHint:r.cacheKey,get:()=>s(e,t,r)}),t)]),t.parseBatchNormalizationAttributes=e=>{const t=e.attributes.getFloat("epsilon",1e-5),r=e.attributes.getFloat("momentum",.9),a=e.attributes.getInt("spatial",1);return(0,n.createAttributeWithCacheKey)({epsilon:t,momentum:r,spatial:a})};const s=(e,t,r)=>{const n=(0,a.getGlsl)(e.session.backend.glContext.version),s=t[0].dims.length,[l,d]=e.calculateTextureWidthAndHeight(t[1].dims,o.TextureType.unpacked),u=`\n  float process(int[${s}] indices) {\n    vec2 position = offsetToCoords(indices[1], ${l}, ${d});\n    float scale = getColorAsFloat(${n.texture2D}(Scale, position));\n    float mean = getColorAsFloat(${n.texture2D}(Mean, position));\n    float variance = getColorAsFloat(${n.texture2D}(Variance, position));\n    float b = getColorAsFloat(${n.texture2D}(B, position));\n\n    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${r.epsilon})) ) + b;\n  }`;return Object.assign(Object.assign({},i),{output:{dims:t[0].dims,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:u})},l=e=>{if(!e||5!==e.length)throw new Error("BatchNormalization requires 5 inputs.");const t=e[0],r=e[1],n=e[2],a=e[3],o=e[4];if(t.dims.length<3||1!==r.dims.length||1!==n.dims.length||1!==a.dims.length||1!==o.dims.length)throw new Error("invalid input shape.");if(r.dims[0]!==t.dims[1]||n.dims[0]!==t.dims[1]||a.dims[0]!==t.dims[1]||o.dims[0]!==t.dims[1])throw new Error("invalid input shape.");if("float32"!==t.type&&"float64"!==t.type||"float32"!==r.type&&"float64"!==r.type||"float32"!==n.type&&"float64"!==n.type||"float32"!==a.type&&"float64"!==a.type||"float32"!==o.type&&"float64"!==o.type)throw new Error("invalid input tensor types.")}},7839:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.xor=t.sub=t.pRelu=t.pow=t.or=t.mul=t.less=t.greater=t.equal=t.div=t.and=t.add=t.glslPRelu=t.glslPow=t.glslXor=t.glslOr=t.glslAnd=t.glslLess=t.glslGreater=t.glslEqual=t.glslSub=t.glslMul=t.glslDiv=t.glslAdd=void 0;const n=r(2517),a=r(8520),o=r(5060),i=r(2039);function s(){const e="add_";return{body:`\n  float ${e}(float a, float b) {\n    return a + b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 + v2;\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function l(){const e="div_";return{body:`\n  float ${e}(float a, float b) {\n    return a / b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 / v2;\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function d(){const e="mul_";return{body:`\n  float ${e}(float a, float b) {\n    return a * b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 * v2;\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function u(){const e="sub_";return{body:`\n  float ${e}(float a, float b) {\n    return a - b;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return v1 - v2;\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function c(){const e="equal_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a == b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4(equal(v1, v2));\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function p(){const e="greater_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a > b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r > v2.r ,\n      v1.g > v2.g,\n      v1.b > v2.b,\n      v1.a > v2.a );\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function g(){const e="less_";return{body:`\n  float ${e}(float a, float b) {\n    return float(a < b);\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4( v1.r < v2.r ,\n                v1.g < v2.g,\n                v1.b < v2.b,\n                v1.a < v2.a );\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function A(){const e="and_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) && bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r && b2.r ,\n                b1.g && b2.g,\n                b1.b && b2.b,\n                b1.a && b2.a );\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function h(){const e="or_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) || bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r || b2.r ,\n                b1.g || b2.g,\n                b1.b || b2.b,\n                b1.a || b2.a );\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function B(){const e="xor_";return{body:`\n  float ${e}(float a, float b) {\n    return float( bool(a) ^^ bool(b) );\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    bvec4 b1 = bvec4(v1);\n    bvec4 b2 = bvec4(v2);\n    return vec4( b1.r ^^ b2.r ,\n                b1.g ^^ b2.g,\n                b1.b ^^ b2.b,\n                b1.a ^^ b2.a );\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}function m(){return function(e){const t=`${e}_`;return{body:`\n  float ${t}(float a, float b) {\n    return ${e}(a, b);\n  }\n  vec4 ${t}(vec4 v1, vec4 v2) {\n    return ${e}(v1, v2);\n  }\n  `,name:t,type:a.FunctionType.ValueBased}}("pow")}function C(){const e="prelu_";return{body:`\n  float ${e}(float a, float b) {\n    return a < 0.0 ? a * b: a;\n  }\n  vec4 ${e}(vec4 v1, vec4 v2) {\n    return vec4(\n      v1.r < 0.0 ? v1.r * v2.r: v1.r,\n      v1.g < 0.0 ? v1.g * v2.g: v1.g,\n      v1.b < 0.0 ? v1.b * v2.b: v1.b,\n      v1.a < 0.0 ? v1.a * v2.a: v1.a\n      );\n  }\n  `,name:e,type:a.FunctionType.ValueBased}}t.glslAdd=s,t.glslDiv=l,t.glslMul=d,t.glslSub=u,t.glslEqual=c,t.glslGreater=p,t.glslLess=g,t.glslAnd=A,t.glslOr=h,t.glslXor=B,t.glslPow=m,t.glslPRelu=C;const w=(e,t,r,n=t[0].type,a)=>{const o=e.session.pack?i.TextureType.packed:i.TextureType.unpacked;return{name:r.name,inputNames:["A","B"],inputTypes:[o,o],cacheHint:a,get:()=>b(e,t,r,n)}},b=(e,t,r,a=t[0].type)=>{const s=e.session.pack?i.TextureType.packed:i.TextureType.unpacked,l=!n.ShapeUtil.areEqual(t[0].dims,t[1].dims);let d=t[0].dims;const u=e.session.pack;if(l){const i=n.BroadcastUtil.calcShape(t[0].dims,t[1].dims,!1);if(!i)throw new Error("Can't perform binary op on the given tensors");d=i;const l=d.length,c=0!==t[0].dims.length?t[0].dims.length:1,p=0!==t[1].dims.length?t[1].dims.length:1,g=0!==t[0].dims.length?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",A=0!==t[1].dims.length?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",h=(0,o.getGlsl)(e.session.backend.glContext.version),B=u?`\n      ${r.body}\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n        vec4 result = ${r.name}(a, b);\n        ${h.output} = result;\n      }`:`\n      ${r.body}\n      float process(int indices[${l}]) {\n        int aindices[${c}];\n        int bindices[${p}];\n        ${g}\n        ${A}\n        return ${r.name}(_A(aindices), _B(bindices));\n      }`;return{name:r.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:d,type:a,textureType:s},shaderSource:B,hasMain:u}}const c=(0,o.getGlsl)(e.session.backend.glContext.version),p=`\n    ${r.body}\n    void main() {\n      vec4 v1 = ${c.texture2D}(A, TexCoords);\n      vec4 v2 = ${c.texture2D}(B, TexCoords);\n      vec4 result = ${r.name}(v1, v2);\n      ${c.output} = result;\n    }\n    `;return{name:r.name,inputNames:["A","B"],inputTypes:[s,s],output:{dims:t[0].dims,type:a,textureType:s},shaderSource:p,hasMain:!0}};t.add=(e,t)=>[e.run(w(e,t,s()),t)],t.and=(e,t)=>[e.run(w(e,t,A(),"bool"),t)],t.div=(e,t)=>[e.run(w(e,t,l()),t)],t.equal=(e,t)=>[e.run(w(e,t,c(),"bool"),t)],t.greater=(e,t)=>[e.run(w(e,t,p(),"bool"),t)],t.less=(e,t)=>[e.run(w(e,t,g(),"bool"),t)],t.mul=(e,t)=>[e.run(w(e,t,d()),t)],t.or=(e,t)=>[e.run(w(e,t,h(),"bool"),t)],t.pow=(e,t)=>[e.run(w(e,t,m()),t)],t.pRelu=(e,t)=>[e.run(w(e,t,C()),t)],t.sub=(e,t)=>[e.run(w(e,t,u()),t)],t.xor=(e,t)=>[e.run(w(e,t,B(),"bool"),t)]},4196:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseCastAttributes=t.cast=void 0;const n=r(2517);t.cast=(e,t,r)=>(a(t),[e.cast(t[0],r)]),t.parseCastAttributes=e=>n.ProtoUtil.tensorDataTypeFromProto(e.attributes.getInt("to"));const a=e=>{if(!e||1!==e.length)throw new Error("Cast requires 1 input.");if("string"===e[0].type)throw new Error("Invalid input type.")}},1163:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedConcatProgramInfoLoader=void 0;const n=r(5060),a=r(2039),o=r(9390),i=r(2827);t.createPackedConcatProgramInfoLoader=(e,t,r)=>{const l=(d=t.length,u=r.cacheKey,{name:"Concat (packed)",inputNames:Array.from({length:d},((e,t)=>`X${t}`)),inputTypes:Array(d).fill(a.TextureType.packed),cacheHint:u});var d,u;return Object.assign(Object.assign({},l),{get:()=>((e,t,r,l)=>{const d=r[0].dims.slice();if(l>=d.length||l<-1*d.length)throw new Error("axis specified for concat doesn't match input dimensionality");l<0&&(l=d.length+l);const u=d.slice(0);for(let e=1;e<r.length;e++){const t=r[e].dims.slice();for(let e=0;e<d.length;e++)if(e===l)u[l]+=t[e];else if(d[e]!==t[e])throw new Error("non concat dimensions must match")}const c=u.length,p=(0,i.getChannels)("coords",c),g=(0,o.getCoordsDataType)(c),A=(0,i.unpackFromChannel)(),h=r.map((e=>e.dims)),B=(0,o.getGlChannels)(c),m=new Array(h.length-1);m[0]=h[0][l];for(let e=1;e<m.length;e++)m[e]=m[e-1]+h[e][l];const C=B[l],w=B.slice(-2),b=B.join();let K=`if (${C} < ${m[0]}) {\n        return getChannel(\n            getX0(${b}), vec2(${w.join()}));\n        }`;for(let e=1;e<m.length;e++){const t=m[e-1];K+=`\n            if (${C} < ${m[e]}  && ${C} >= ${m[e-1]}) {\n              return getChannel(\n                getX${e}(${s(B,C,t)}),\n                vec2(${s(w,C,t)}));\n            }`}const f=m.length,Q=m[m.length-1];K+=`\n            return getChannel(\n              getX${f}(${s(B,C,Q)}),\n              vec2(${s(w,C,Q)}));`;const W=(0,n.getGlsl)(e.session.backend.glContext.version),F=`\n          ${A}\n          float getValue(${B.map((e=>"int "+e))}) {\n            ${K}\n          }\n\n          void main() {\n            ${g} coords = getOutputCoords();\n            int lastDim = coords.${B[c-1]};\n            coords.${B[c-1]} = coords.${B[c-2]};\n            coords.${B[c-2]} = lastDim;\n\n            vec4 result = vec4(getValue(${p}), 0., 0., 0.);\n\n            ${p[c-1]} = ${p[c-1]} + 1;\n            if (${p[c-1]} < ${u[c-1]}) {\n              result.g = getValue(${p});\n            }\n\n            ${p[c-2]} = ${p[c-2]} + 1;\n            if (${p[c-2]} < ${u[c-2]}) {\n              result.a = getValue(${p});\n            }\n\n            ${p[c-1]} = ${p[c-1]} - 1;\n            if (${p[c-2]} < ${u[c-2]} &&\n                ${p[c-1]} < ${u[c-1]}) {\n              result.b = getValue(${p});\n            }\n            ${W.output} = result;\n          }\n        `;return Object.assign(Object.assign({},t),{output:{dims:u,type:r[0].type,textureType:a.TextureType.packed},shaderSource:F,hasMain:!0})})(e,l,t,r.axis)})};const s=(e,t,r)=>{const n=e.indexOf(t);return e.map(((e,t)=>t===n?`${e} - ${r}`:e)).join()}},2069:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseConcatAttributes=t.concat=void 0;const n=r(246),a=r(2039),o=r(1163);t.concat=(e,t,r)=>(c(t),e.session.pack&&t[0].dims.length>1?[e.run((0,o.createPackedConcatProgramInfoLoader)(e,t,r),t)]:[e.run(i(e,t,r),t)]);const i=(e,t,r)=>{const n=(o=t.length,i=r.cacheKey,{name:"Concat",inputNames:Array.from({length:o},((e,t)=>`X${t}`)),inputTypes:Array(o).fill(a.TextureType.unpacked),cacheHint:i});var o,i;return Object.assign(Object.assign({},n),{get:()=>((e,t,r,n)=>{const o=r[0].dims.slice();if(n>=o.length||n<-1*o.length)throw new Error("axis specified for concat doesn't match input dimensionality");n<0&&(n=o.length+n);const i=o.slice(0);for(let e=1;e<r.length;e++){const t=r[e].dims.slice();for(let e=0;e<o.length;e++)if(e===n)i[n]+=t[e];else if(o[e]!==t[e])throw new Error("non concat dimensions must match")}const c=i.length,p=new Array(r.length);let g=0;for(let e=0;e<p.length;++e)g+=r[e].dims[n],p[e]=g;let A="";A=r.length<5?s(p):l(p);const h=`\n        ${d(r.length,c)}\n        ${u(p)}\n        ${A}\n        float process(int indices[${c}]) {\n          int textureIndex = getTextureWhereDataResides (indices[${n}]);\n\n          if(textureIndex != 0) {\n            indices[${n}] = indices[${n}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));\n          }\n\n          return fetchDataFromCorrectTexture(textureIndex, indices);\n        }`;return Object.assign(Object.assign({},t),{output:{dims:i,type:r[0].type,textureType:a.TextureType.unpacked},shaderSource:h})})(0,n,t,r.axis)})},s=e=>`int getTextureWhereDataResides(int index) {\n      ${e.map(((e,t)=>`if(index<${e}) {return ${t};}\n`)).join("")}\n    }`,l=e=>s(e),d=(e,t)=>{const r=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${t}]) {`];for(let t=0;t<e;++t)0===t?r.push(`\tif (textureIndex == ${t}) { return _X${t}(indices); }`):t===e-1?r.push(`\telse { return _X${t}(indices); }`):r.push(`\telse if (textureIndex == ${t}) { return _X${t}(indices); }`);return r.push("\t}"),r.join("\n")},u=e=>{const t=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let r=0;r<e.length;++r)0===r?t.push(`\tif (index == ${r}) { return ${e[r]}; }`):r===e.length-1?t.push(`\telse { return ${e[r]}; }`):t.push(`\telse if (index == ${r}) { return ${e[r]}; }`);return t.push("\t}"),t.join("\n")};t.parseConcatAttributes=e=>(0,n.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis")});const c=e=>{if(!e||e.length<1)throw new Error("too few inputs");const t=e[0].type,r=e[0].dims.length;if("string"===t)throw new Error("string tensor is not supported yet");for(const n of e){if(n.type!==t)throw new Error("input tensors should be one type");if(n.dims.length!==r)throw new Error("input tensors should have the same shape")}}},4770:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackedGroupedConvProgramInfoLoader=void 0;const n=r(6231),a=r(5060),o=r(2039),i=r(8138),s=r(2823);t.createUnpackedGroupedConvProgramInfoLoader=(e,t,r)=>{const l=(d=t.length>2,u=r.cacheKey,{name:"GroupedConv",inputNames:d?["X","W","Bias"]:["X","W"],inputTypes:d?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:u});var d,u;return Object.assign(Object.assign({},l),{get:()=>((e,t,r,l)=>{const d=t.length>2?"value += getBias(output_channel);":"",u=t[0].dims.slice(),c=t[1].dims.slice(),p=c[0]/l.group;n.Logger.verbose("GroupedConv",`autpPad:${l.autoPad}, dilations:${l.dilations}, group:${l.group}, kernelShape:${l.kernelShape}, pads:${l.pads}, strides:${l.strides}`);const g=(0,i.calculateOutputShape)(u,c,l.dilations,l.pads,l.strides),A=(0,a.getGlsl)(e.session.backend.glContext.version),{activationFunction:h,applyActivation:B}=(0,s.getActivationSnippet)(l),m=`\n  const ivec2 strides = ivec2(${l.strides[0]}, ${l.strides[1]});\n  const ivec2 pads = ivec2(${l.pads[0]}, ${l.pads[1]});\n  ${h}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n    ivec2 xRCCorner = coords.zw * strides - pads;\n    int group_id = output_channel / ${p};\n\n    float value = 0.0;\n    for (int wInChannel = 0; wInChannel < ${c[1]}; wInChannel++) {\n      int input_channel = group_id * ${c[1]} + wInChannel;\n      for (int wHeight = 0; wHeight < ${c[2]}; wHeight++) {\n        int xHeight = xRCCorner.x + wHeight * ${l.dilations[0]};\n\n        if (xHeight < 0 || xHeight >= ${u[2]}) {\n          continue;\n        }\n\n        for (int wWidth = 0; wWidth < ${c[3]}; wWidth++) {\n          int xWidth = xRCCorner.y + wWidth * ${l.dilations[1]};\n          if (xWidth < 0 || xWidth >= ${u[3]}) {\n            continue;\n          }\n\n          float xVal = getX(batch, input_channel, xWidth, xHeight);\n          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);\n          value += xVal*wVal;\n        }\n      }\n    }\n    ${d}\n    ${B}\n    ${A.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},r),{output:{dims:g,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:m,hasMain:!0})})(e,t,l,r)})}},1386:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.conv2DPacked=t.conv2DPackedPointwise=void 0;const n=r(8138),a=r(8555),o=r(708);t.conv2DPackedPointwise=(e,t,r)=>{const a=t[0].dims,i=t[1].dims,s=(0,n.calculateOutputShape)(a,i,r.dilations,r.pads,r.strides),l=e.reshapePacked(t[0],[a[1],a[2]*a[3]]),d=e.reshapePacked(t[1],[i[0],i[1]]),u=t.length>2?[d,l,t[2]]:[d,l],c=e.run((0,o.createPackedMatmulProgramInfoLoader)(e,u,r),u);return e.reshapePacked(c,s)},t.conv2DPacked=(e,t,r)=>{const i=t[0].dims,s=t[1].dims,l=(0,n.calculateOutputShape)(i,s,r.dilations,r.pads,r.strides),d=e.run((0,a.createPackedIm2ColProgramInfoLoader)(e,t[0],t[1],l,r),[t[0]]),u=e.reshapePacked(t[1],[s[0],s[1]*s[2]*s[3]]),c=3===t.length?[u,d,t[2]]:[u,d],p=e.run((0,o.createPackedMatmulProgramInfoLoader)(e,c,r),c);return e.reshapePacked(p,l)}},9663:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvTransposeAttributes=t.convTranspose=void 0;const n=r(246),a=r(5060),o=r(2039),i=r(2823),s=(e,t,r,n,a,o)=>(e-1)*t+r+(n-1)*a+1-o,l=(e,t,r,n,a)=>{const o=Math.floor(e/2);"SAME_UPPER"===t?(r[n]=o,r[a]=e-o):"SAME_LOWER"===t&&(r[n]=e-o,r[a]=o)};t.convTranspose=(e,t,r)=>(p(t,r),d(e,t,r));const d=(e,t,r)=>{const n=c(r,t);return[u(e,t,n)]},u=(e,t,r)=>e.run(((e,t,r)=>{const n=(s=t.length>2,l=r.cacheKey,{name:"ConvTranspose",inputNames:s?["X","W","B"]:["X","W"],inputTypes:s?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],cacheHint:l});var s,l;return Object.assign(Object.assign({},n),{get:()=>((e,t,r,n)=>{const s=t.length>2?"getB(output_channel)":"0.0",l=t[0].dims,d=t[1].dims,u=d[1],c=d[0]/n.group,p=[t[0].dims[0],t[1].dims[1]*n.group,...n.outputShape],g=(0,a.getGlsl)(e.session.backend.glContext.version),{activationFunction:A,applyActivation:h}=(0,i.getActivationSnippet)(n),B=`\n  const ivec2 strides = ivec2(${n.strides[0]}, ${n.strides[1]});\n  const ivec2 pads = ivec2(${n.pads[0]}, ${n.pads[1]});\n  ${A}\n  void main() {\n    ivec4 coords = getOutputCoords();\n    int batch = coords.x;\n    int output_channel = coords.y;\n\n    ivec2 loc = coords.zw + pads;\n\n    int group_id = output_channel / ${u};\n    int wOutChannel = output_channel - group_id * ${u};\n\n    float value = ${s};\n    for (int inChannelOffset = 0; inChannelOffset < ${c}; inChannelOffset++) {\n      int input_channel = group_id * ${c} + inChannelOffset;\n      for (int wWOff = 0; wWOff < ${d[2]}; wWOff++) {\n        for (int wHOff = 0; wHOff < ${d[3]}; wHOff++) {\n          ivec2 wOff = ivec2(wWOff * ${n.dilations[0]}, wHOff * ${n.dilations[1]});\n          ivec2 wLoc = loc - wOff;\n          ivec2 wLocIn = wLoc / strides;\n          if (\n            wLocIn * strides == wLoc &&\n            wLocIn.x >= 0 && wLocIn.x < ${l[2]} &&\n            wLocIn.y >= 0 && wLocIn.y < ${l[3]}\n          ) {\n            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);\n            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);\n            value += xVal * wVal;\n          }\n        }\n      }\n    }\n    ${h}\n    ${g.output} = vec4(value, .0, .0, .0);\n  }\n`;return Object.assign(Object.assign({},r),{output:{dims:p,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:B,hasMain:!0})})(e,t,n,r)})})(e,t,r),t),c=(e,t)=>{const r=e.kernelShape.slice();if(0===e.kernelShape.length)for(let e=2;e<t[1].dims.length;++e)r.push(t[1].dims[e]);const n=e.pads.slice(),a=e.outputShape.slice();((e,t,r,n,a,o,i,d)=>{const u=e.length-2,c=0===d.length;for(let p=0;p<u;++p){const g=c?e[p+2]*o[p]:d[p],A=s(e[p+2],o[p],a[p],t[p],r[p],g);l(A,n,a,p,p+u),c&&d.push(o[p]*(e[p+2]-1)+i[p]+(t[p]-1)*r[p]+1-a[p]-a[p+u])}})(t[0].dims,r,e.dilations,e.autoPad,n,e.strides,e.outputPadding,a);const o=Object.assign({},e);return Object.assign(o,{kernelShape:r,pads:n,outputShape:a,cacheKey:e.cacheKey}),o};t.parseConvTransposeAttributes=e=>{const t=e.attributes,r=(0,i.parseInternalActivationAttributes)(t),a=t.getString("auto_pad","NOTSET"),o=t.getInts("dilations",[1,1]),s=t.getInt("group",1),l=t.getInts("kernel_shape",[]),d=t.getInts("output_padding",[0,0]),u=t.getInts("output_shape",[]),c=t.getInts("pads",[0,0,0,0]),p=t.getInts("strides",[1,1]);return(0,n.createAttributeWithCacheKey)(Object.assign({autoPad:a,dilations:o,group:s,kernelShape:l,outputPadding:d,outputShape:u,pads:c,strides:p},r))};const p=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length||4!==e[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[0])throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");const r=e[1].dims[1]*t.group;if(3===e.length&&(1!==e[2].dims.length||e[2].dims[0]!==r))throw new Error("invalid bias");const n=e[0].dims.length-2;if(t.dilations.length!==n)throw new Error(`dilations should be ${n}D`);if(t.strides.length!==n)throw new Error(`strides should be ${n}D`);if(t.pads.length!==2*n)throw new Error(`pads should be ${2*n}D`);if(t.outputPadding.length!==n)throw new Error(`output_padding should be ${n}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(0!==t.outputShape.length&&t.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if("float32"!==e[0].type||"float32"!==e[1].type)throw new Error("ConvTranspose input(X,W) should be float tensor");if(3===e.length&&"float32"!==e[2].type)throw new Error("ConvTranspose input(bias) should be float tensor")}},8138:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseConvAttributes=t.conv=t.calculateOutputShape=void 0;const n=r(246),a=r(2517),o=r(4770),i=r(1386),s=r(9828),l=r(2823),d=r(3248),u=r(5623);t.calculateOutputShape=(e,t,r,n,a)=>{const o=e[0],i=e.slice(2),s=i.length,l=t[0],d=t.slice(2).map(((e,t)=>e+(e-1)*(r[t]-1))),u=i.map(((e,t)=>e+n[t]+n[t+s])).map(((e,t)=>Math.floor((e-d[t]+a[t])/a[t])));return[o,l].concat(...u)},t.conv=(e,t,r)=>(h(t,r),c(e,t,r));const c=(e,t,r)=>{const n=A(r,t),a=e.session.pack,s=1===n.kernelShape[0]&&1===n.kernelShape[1];return n.group>1?[e.run((0,o.createUnpackedGroupedConvProgramInfoLoader)(e,t,n),t)]:s&&a?[p(e,t,n)]:a&&4===t[0].dims.length&&1===t[0].dims[0]&&!s?[(0,i.conv2DPacked)(e,t,n)]:[g(e,t,n)]},p=(e,r,n)=>{const a=r[0].dims,o=r[1].dims,i=(0,t.calculateOutputShape)(a,o,n.dilations,n.pads,n.strides),s=e.reshapeUnpacked(r[0],[a[1],a[2]*a[3]]),l=e.reshapeUnpacked(r[1],[o[0],o[1]]),d=r.length>2?[l,s,r[2]]:[l,s],c=e.run((0,u.createMatmulProgramInfoLoader)(d,n),d);return e.reshapeUnpacked(c,i)},g=(e,r,n)=>{const a=r[0].dims,o=r[1].dims,i=(0,t.calculateOutputShape)(a,o,n.dilations,n.pads,n.strides),l=e.run((0,d.createIm2ColProgramInfoLoader)(e,r[0],r[1],i,n),[r[0]]),u=3===r.length?[l,r[1],r[2]]:[l,r[1]];return e.run((0,s.createDotProductProgramInfoLoader)(e,r,i,n),u)},A=(e,t)=>{const r=e.kernelShape.slice();if(0===e.kernelShape.length)for(let e=2;e<t[1].dims.length;++e)r.push(t[1].dims[e]);const n=e.pads.slice();a.PoolConvUtil.adjustPadsBasedOnAutoPad(t[0].dims,e.strides,e.dilations,r,n,e.autoPad);const o=Object.assign({},e);return Object.assign(o,{kernelShape:r,pads:n,cacheKey:e.cacheKey}),o};t.parseConvAttributes=e=>{const t=e.attributes,r=(0,l.parseInternalActivationAttributes)(t),a=t.getString("auto_pad","NOTSET"),o=t.getInts("dilations",[1,1]),i=t.getInt("group",1),s=t.getInts("kernel_shape",[]),d=t.getInts("pads",[0,0,0,0]),u=t.getInts("strides",[1,1]);return(0,n.createAttributeWithCacheKey)(Object.assign({autoPad:a,dilations:o,group:i,kernelShape:s,pads:d,strides:u},r))};const h=(e,t)=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Conv requires 2 or 3 inputs");if(4!==e[0].dims.length||4!==e[1].dims.length)throw new Error("currently only support 2-dimensional conv");if(e[0].dims[1]!==e[1].dims[1]*t.group)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(3===e.length&&(1!==e[2].dims.length||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");const r=e[0].dims.length-2;if(t.dilations.length!==r)throw new Error(`dilations should be ${r}D`);if(t.strides.length!==r)throw new Error(`strides should be ${r}D`);if(t.pads.length!==2*r)throw new Error(`pads should be ${2*r}D`);if(0!==t.kernelShape.length&&t.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if("float32"!==e[0].type||"float32"!==e[1].type)throw new Error("Conv input(X,W) should be float tensor");if(3===e.length&&"float32"!==e[2].type)throw new Error("Conv input(bias) should be float tensor")}},5193:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseDepthToSpaceAttributes=t.depthToSpace=void 0;const n=r(3738);t.depthToSpace=(e,t,r)=>{a(t);const o=r.blocksize,i=o*o,s="DCR"===r.mode?[0,3,4,1,5,2]:[0,1,4,2,5,3],l="DCR"===r.mode?[t[0].dims[0],o,o,t[0].dims[1]/i,t[0].dims[2],t[0].dims[3]]:[t[0].dims[0],t[0].dims[1]/i,o,o,t[0].dims[2],t[0].dims[3]],d=e.reshapeUnpacked(t[0],l),u={perm:s,cacheKey:`${s}`},[c]=(0,n.transpose)(e,[d],u),p=[t[0].dims[0],t[0].dims[1]/i,t[0].dims[2]*o,t[0].dims[3]*o];return[e.reshapeUnpacked(c,p)]},t.parseDepthToSpaceAttributes=e=>{const t=e.attributes.getInt("blocksize");if(t<1)throw new Error(`blocksize must be >= 1, but got : ${t} for DepthToSpace`);const r=e.attributes.getString("mode","DCR");if("DCR"!==r&&"CRD"!==r)throw new Error(`unrecognized mode: ${r} for DepthToSpace`);return{mode:r,blocksize:t}};const a=e=>{if(1!==e.length)throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);if("string"===e[0].type||4!==e[0].dims.length)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}},9828:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createDotProductProgramInfoLoader=void 0;const n=r(2517),a=r(5060),o=r(2039),i=r(2823),s=r(3248);t.createDotProductProgramInfoLoader=(e,t,r,l)=>{const d=((e,t)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[o.TextureType.unpacked,o.TextureType.packedLastDimension,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.packedLastDimension],cacheKey:t.activationCacheKey}))(t.length>2,l);return Object.assign(Object.assign({},d),{get:()=>((e,t,r,l,d)=>{const u=r[0].dims,c=r[1].dims,p=[c[0],Math.ceil(u[1]*c[2]*c[3]/4)],g=(0,s.calculateIm2ColDims)(u,c,l),[A,h]=e.calculateTextureWidthAndHeight(p,o.TextureType.packedLastDimension),B=n.ShapeUtil.computeStrides(g),[m,C]=e.calculateTextureWidthAndHeight(g,o.TextureType.packedLastDimension),w=l.length,b=r.length<3?"0.0":"_B(b)",K=Math.ceil(u[1]*c[2]*c[3]/4),{activationFunction:f,applyActivation:Q}=(0,i.getActivationSnippet)(d),W=(0,a.getGlsl)(e.session.backend.glContext.version),F=`\n${f}\nfloat process(int indices[${w}]) {\n  int b[1];\n  b[0] = indices[1];\n  int im2col[4];\n  im2col[0] = indices[0];\n  im2col[1] = indices[2];\n  im2col[2] = indices[3];\n  int im2colOffset = im2col[0] * ${B[0]} + im2col[1] * ${B[1]} + im2col[2] * ${B[2]};\n  int kernelOffset = indices[1] * ${p[1]};\n  float value = ${b};\n  for (int i = 0; i < ${K}; ++i) {\n    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${C});\n    vec2 kernelCoords = offsetToCoords(kernelOffset, ${A}, ${h});\n    value += dot(${W.texture2D}(Im2Col, im2colCoords), ${W.texture2D}(K, kernelCoords));\n    ++im2colOffset;\n    ++kernelOffset;\n  }\n  ${Q}\n  return value;\n}`;return Object.assign(Object.assign({},t),{output:{dims:l,type:r[0].type,textureType:o.TextureType.unpacked},shaderSource:F})})(e,d,t,r,l)})}},7992:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseFlattenAttributes=t.flatten=void 0;const n=r(2517);t.flatten=(e,t,r)=>{a(t,r);const o=n.ShapeUtil.flattenShape(t[0].dims,r);return[e.reshapeUnpacked(t[0],o)]},t.parseFlattenAttributes=e=>e.attributes.getInt("axis",1);const a=(e,t)=>{if(!e||1!==e.length)throw new Error("Flatten requires 1 input.");const r=e[0].dims.length;if(0===r)throw new Error("scalar tensor is not supported.");if(t<-r||t>r)throw new Error("Invalid axis");if("string"===e[0].type)throw new Error("string tensor is not supported.")}},2823:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseInternalActivationAttributes=t.getActivationSnippet=void 0;const n=r(2517),a=r(4909);t.getActivationSnippet=function(e){let t;switch(e.activation){case"Relu":t=(0,a.glslRelu)();break;case"Sigmoid":t=(0,a.glslSigmoid)();break;case"Clip":t=(0,a.glslClip)(e.clipMin,e.clipMax);break;default:return{activationFunction:"",applyActivation:""}}const r=t.name;return{activationFunction:t.body,applyActivation:`value = ${r}_(value);`}},t.parseInternalActivationAttributes=e=>{const t=e.getString("activation","");if("Clip"===t){const[r,a]=e.getFloats("activation_params",[n.MIN_CLIP,n.MAX_CLIP]);return{activation:t,clipMax:a,clipMin:r,activationCacheKey:`${t}:${r},${a}`}}return{activation:t,activationCacheKey:t}}},1253:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseGatherAttributes=t.gather=void 0;const n=r(246),a=r(782),o=r(2517),i=r(2039);t.gather=(e,t,r)=>(d(t,r.axis),[e.run(l(e,t,r),t)]),t.parseGatherAttributes=e=>(0,n.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",0)});const s={name:"Gather",inputNames:["A","B"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked]},l=(e,t,r)=>{const n=Object.assign(Object.assign({},s),{cacheHint:r.cacheKey});return Object.assign(Object.assign({},n),{get:()=>((e,t,r,n)=>{const a=r[0].dims.slice(),s=r[1].dims.slice(),l=new Array(a.length+s.length-1);n=o.ShapeUtil.normalizeAxis(n,a.length);const d=[];for(let e=0;e<l.length;e++)e<n?(l[e]=a[e],d.push(`inputIdx[${e}] = outputIdx[${e}];`)):e<n+s.length?(l[e]=s[e-n],d.push(`indexDataIdx[${e-n}] = outputIdx[${e}];`)):(l[e]=a[e-s.length+1],d.push(`inputIdx[${e-s.length+1}] = outputIdx[${e}];`));const u=`\n      float process(int outputIdx[${l.length||1}]) {\n        int inputIdx[${a.length}];\n        int indexDataIdx[${s.length||1}];\n        indexDataIdx[0] = 0;\n        ${d.join("\n        ")}\n        int idx = int(_B(indexDataIdx));\n        inputIdx[${n}] = idx < 0 ? idx + ${a[n]} : idx;\n        return _A(inputIdx);\n      }`;return Object.assign(Object.assign({},t),{output:{dims:l,type:r[0].type,textureType:i.TextureType.unpacked},shaderSource:u})})(0,n,t,r.axis)})},d=(e,t)=>{if(!e||2!==e.length)throw new Error("Gather requires 2 inputs.");const r=e[0].dims.length;if(r<1)throw new Error("Invalid input shape.");if(t<-r||t>r-1)throw new Error("Invalid axis.");if(-1===a.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invaid input type.");if("int32"!==e[1].type&&"int16"!==e[1].type)throw new Error("Invaid input type.")}},4776:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseGemmAttributesV11=t.parseGemmAttributesV7=t.gemm=void 0;const n=r(246),a=r(2517),o=r(2039);t.gemm=(e,t,r)=>(d(t,r),[e.run(s(t,r),t)]);const i=(e,t)=>{const r=0!==e.attributes.getInt("transA",0),a=0!==e.attributes.getInt("transB",0),o=e.attributes.getFloat("alpha",1),i=e.attributes.getFloat("beta",1);return(0,n.createAttributeWithCacheKey)({transA:r,transB:a,alpha:o,beta:i,isOptionalC:t})};t.parseGemmAttributesV7=e=>i(e,!1),t.parseGemmAttributesV11=e=>i(e,!0);const s=(e,t)=>{const r={name:"Gemm",inputNames:3===e.length?["A","B","C"]:["A","B"],inputTypes:3===e.length?[o.TextureType.unpacked,o.TextureType.unpacked,o.TextureType.unpacked]:[o.TextureType.unpacked,o.TextureType.unpacked],key:t.cacheKey};return Object.assign(Object.assign({},r),{get:()=>l(r,e,t)})},l=(e,t,r)=>{const n=t[0].dims.slice(),i=t[1].dims.slice(),[s,l]=a.GemmUtil.getShapeOfGemmResult(n,r.transA,i,r.transB,3===t.length?t[2].dims:void 0),d=[s,l];if(!d)throw new Error("Can't use gemm on the given tensors");let u=n[n.length-1],c="";r.transA&&(u=n[0]),r.transA&&r.transB?c="value += _A_T(a) * _B_T(b);":r.transA&&!r.transB?c="value += _A_T(a) * _B(b);":!r.transA&&r.transB?c="value += _A(a) * _B_T(b);":r.transA||r.transB||(c="value += _A(a) * _B(b);");const p=d.length,g=`\n      float process(int indices[${p}]) {\n          int a[${p}];\n          int b[${p}];\n          ${3===t.length?`int c[${t[2].dims.length}];`:""}\n\n          copyVec(indices, a);\n          copyVec(indices, b);\n          ${3===t.length?"bcastIndices_C(indices, c);":""}\n\n          float value = 0.0;\n          for (int k=0; k<${u}; ++k) {\n              a[${p-1}] = k;\n              b[${p-2}] = k;\n              ${c}\n          }\n\n          value = value * alpha;\n          ${3===t.length?"value += beta * _C(c);":""}\n          return value;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:d,type:t[0].type,textureType:o.TextureType.unpacked},variables:[{name:"alpha",type:"float",data:r.alpha},{name:"beta",type:"float",data:r.beta}],shaderSource:g})},d=(e,t)=>{if(!e)throw new Error("Input is missing");if(t.isOptionalC&&(e.length<2||e.length>3))throw new Error("Invaid input shape.");if(!t.isOptionalC&&3!==e.length)throw new Error("Gemm requires 3 inputs");if(3===e.length&&1!==e[2].dims.length&&2!==e[2].dims.length)throw new Error("Invalid input shape of C");if("float32"!==e[0].type&&"float64"!==e[0].type||"float32"!==e[1].type&&"float64"!==e[1].type||3===e.length&&"float32"!==e[2].type&&"float64"!==e[2].type)throw new Error("Invalid input type.");if(e[0].type!==e[1].type||3===e.length&&e[0].type!==e[2].type)throw new Error("Input types are mismatched")}},8555:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedIm2ColProgramInfoLoader=void 0;const n=r(5060),a=r(2039),o=r(2827);t.createPackedIm2ColProgramInfoLoader=(e,t,r,i,s)=>{const l=(d=s.cacheKey,{name:"Im2Col (packed)",inputNames:["A"],inputTypes:[a.TextureType.packed],cacheHint:d});var d;return Object.assign(Object.assign({},l),{get:()=>((e,t,r,i,s,l)=>{const d=r.dims,u=i.dims,c=s.length,p=[u[1]*u[2]*u[3],s[2]*s[3]],g=u[2]*u[3],A=(0,o.unpackFromChannel)(),h=(0,n.getGlsl)(e.session.backend.glContext.version);let B="";for(let e=0;e<=1;e++)for(let t=0;t<=1;t++)B+=`\n            blockIndex = rc.x + ${t};\n            pos = rc.y + ${e};\n\n            if(blockIndex < ${p[1]} && pos < ${p[0]}) {\n              offsetY = int(blockIndex / (${s[c-1]})) * ${l.strides[0]} -\n                ${l.pads[0]};\n              d0 = offsetY + ${l.dilations[0]} * (imod(pos, ${g}) / ${u[2]});\n\n              if(d0 < ${d[2]} && d0 >= 0) {\n                offsetX = imod(blockIndex, ${s[c-1]}) * ${l.strides[1]} -\n                  ${l.pads[1]};\n                d1 = offsetX + ${l.dilations[1]} * imod(imod(pos, ${g}), ${u[2]});\n\n                if(d1 < ${d[3]} && d1 >= 0) {\n\n                  ch = int(float(pos)/ ${g}.);\n                    innerDims = vec2(d0, d1);\n                    result[${2*e+t}] = getChannel(\n                      getA(0, ch, int(innerDims.x),\n                      int(innerDims.y)), innerDims);\n                }\n              }\n            }\n\n          `;const m=`\n      ${A}\n\n      void main() {\n        ivec2 rc = getOutputCoords();\n          vec4 result = vec4(0.0);\n          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n          vec2 innerDims;\n          ${B}\n          ${h.output} = result;\n      }\n            `;return Object.assign(Object.assign({},t),{output:{dims:p,type:r.type,textureType:a.TextureType.packed},shaderSource:m,hasMain:!0})})(e,l,t,r,i,s)})}},3248:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.calculateIm2ColDims=t.createIm2ColProgramInfoLoader=void 0;const n=r(2039);t.createIm2ColProgramInfoLoader=(e,r,a,o,i)=>{const s=(l=i.cacheKey,{name:"Im2Col",inputNames:["X"],inputTypes:[n.TextureType.unpacked],cacheHint:l});var l;return Object.assign(Object.assign({},s),{get:()=>((e,r,a,o,i,s)=>{const l=a.dims,d=o.dims,u=i.length,c=(0,t.calculateIm2ColDims)(l,d,i,4),p=`\n        const int XC = ${l[1]};\n        const int XH = ${l[2]};\n        const int XW = ${l[3]};\n        const int KH = ${s.kernelShape[0]};\n        const int KW = ${s.kernelShape[1]};\n        const int dilationH = ${s.dilations[0]};\n        const int dilationW = ${s.dilations[1]};\n        const int strideH = ${s.strides[0]};\n        const int strideW = ${s.strides[1]};\n        const int padH = ${s.pads[0]};\n        const int padW = ${s.pads[1]};\n        const int KHKW = KH*KW;\n        const int XCKHKW = XC * KHKW;\n        const int outputChannels = 4;\n        vec4 process(int indices[${u}]) {\n          int b  = indices[0]; // batch size\n          int oh = indices[1] * strideH - padH; //output height\n          int ow = indices[2] * strideW - padW; //output width\n          int p = indices[3] * outputChannels; //patch\n          vec4 value = vec4(0.0);\n          for(int i=0; i < outputChannels; ++i) {\n            if(p < XCKHKW) {\n              int patchC = p / KHKW;\n              int patchH = (p - patchC*KHKW) / KW;\n              int patchW = (p - patchC*KHKW) - patchH * KW;\n              int xh2 = oh + patchH * dilationH;\n              int xw2 = ow + patchW * dilationW;\n              int x[${l.length}];\n              x[0] = b;\n              x[1] = patchC;\n              x[2] = xh2;\n              x[3] = xw2;\n              if(xh2 >= 0 &&\n                  xh2 < XH &&\n                  xw2 >= 0 &&\n                  xw2 < XW) {\n                value[i] = _X(x);\n              }\n            }\n            ++p;\n          }\n          return value;\n        }\n        `;return Object.assign(Object.assign({},r),{output:{dims:c,type:a.type,textureType:n.TextureType.packedLastDimension},shaderSource:p})})(0,s,r,a,o,i)})},t.calculateIm2ColDims=(e,t,r,n=4)=>[r[0],r[2],r[3],Math.ceil(e[1]*t[2]*t[3]/n)]},6572:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseImageScalerAttributes=t.imageScaler=void 0;const n=r(246),a=r(2039);t.imageScaler=(e,t,r)=>(l(t),[e.run(i(e,t,r),t)]),t.parseImageScalerAttributes=e=>{const t=e.attributes.getFloat("scale"),r=e.attributes.getFloats("bias");return(0,n.createAttributeWithCacheKey)({scale:t,bias:r})};const o={name:"ImageScaler",inputNames:["X"],inputTypes:[a.TextureType.unpacked]},i=(e,t,r)=>{const n=Object.assign(Object.assign({},o),{cacheHint:r.cacheKey});return Object.assign(Object.assign({},n),{get:()=>((e,t,r,n)=>{const o=r[0].dims.slice(),i=o.length,l=`\n      ${s(n.bias.length)}\n      float process(int indices[${i}]) {\n        return _X(indices) * scale + getBias(bias, indices[1]);\n      }`;return Object.assign(Object.assign({},t),{output:{dims:o,type:r[0].type,textureType:a.TextureType.unpacked},variables:[{name:"bias",type:"float",arrayLength:n.bias.length,data:n.bias},{name:"scale",type:"float",data:n.scale}],shaderSource:l})})(0,n,t,r)})},s=e=>{const t=[`float getBias(float bias[${e}], int channel) {`];for(let r=0;r<e;++r)0===r?t.push(`\tif (channel == ${r}) { return bias[${r}]; }`):r===e-1?t.push(`\telse { return bias[${r}]; }`):t.push(`\telse if (channel == ${r}) { return bias[${r}]; }`);return t.push("\t}"),t.join("\n")},l=e=>{if(!e||1!==e.length)throw new Error("ImageScaler requires 1 input.");if(4!==e[0].dims.length)throw new Error("Invalid input shape.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")}},3346:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseInstanceNormalizationAttributes=t.instanceNormalization=void 0;const n=r(5060),a=r(2039);t.instanceNormalization=(e,t,r)=>{d(t);const n=e.run(i(t[0]),t);return[e.run(l(e,t[0],r,n.dims),[t[0],n,t[1],t[2]])]},t.parseInstanceNormalizationAttributes=e=>e.attributes.getFloat("epsilon",1e-5);const o={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[a.TextureType.unpacked]},i=e=>Object.assign(Object.assign({},o),{get:()=>((e,t)=>{const r=t.dims.slice(),n=r[1],o=r[2]*r[3],i=[r[0],n],s=`\n      vec4 process(int[2] indices) {\n        vec4 v = vec4(0.0);\n        int a[4];\n        a[0] = indices[0];\n        a[1] = indices[1];\n        float temp = 0.0;\n        for(int a2=0; a2<${r[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${r[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += x;\n          }\n        }\n        float mean = temp / float(${o});\n        temp = 0.0;\n        for(int a2=0; a2<${r[2]}; a2++) {\n          a[2] = a2;\n          for(int a3=0; a3<${r[3]}; a3++) {\n            a[3] = a3;\n            float x = _X(a);\n            temp += (x - mean) * (x - mean);\n          }\n        }\n        v.r = mean;\n        v.g = temp / float(${o});\n\n        return v;\n      }`;return Object.assign(Object.assign({},e),{output:{dims:i,type:t.type,textureType:a.TextureType.packedLastDimension},shaderSource:s})})(o,e)}),s={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[a.TextureType.unpacked,a.TextureType.packedLastDimension,a.TextureType.unpacked,a.TextureType.unpacked]},l=(e,t,r,o)=>{const i=Object.assign(Object.assign({},s),{cacheHint:`${r}`});return Object.assign(Object.assign({},i),{get:()=>((e,t,r,o,i)=>{const s=(0,n.getGlsl)(e.session.backend.glContext.version),[l,d]=e.calculateTextureWidthAndHeight(i,a.TextureType.packedLastDimension),[u,c]=[l/4,d],p=`\n      vec4 get_MeanAndVariance(int[2] mv) {\n        int offset = indicesToOffset_MeanAndVariance(mv);\n        vec2 coords = offsetToCoords(offset, ${u}, ${c});\n        return ${s.texture2D}(MeanAndVariance, coords);\n      }\n\n      float process(int[4] indices) {\n        int mv[2];\n        mv[0] = indices[0];\n        mv[1] = indices[1];\n        vec4 mean_and_variance = get_MeanAndVariance(mv);\n        float mean = mean_and_variance.r;\n        float variance = mean_and_variance.g;\n\n        int sb[1];\n        sb[0] = indices[1];\n        float scale = _Scale(sb);\n        float b = _B(sb);\n\n        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;\n      }`;return Object.assign(Object.assign({},t),{output:{dims:r.dims,type:r.type,textureType:a.TextureType.unpacked},variables:[{name:"epsilon",type:"float",data:o}],shaderSource:p})})(e,i,t,r,o)})},d=e=>{if(!e||3!==e.length)throw new Error("InstanceNormalization requires 3 inputs.");const t=e[0],r=e[1],n=e[2];if(t.dims.length<3||1!==r.dims.length||1!==n.dims.length)throw new Error("Invalid input shape.");if(r.dims[0]!==t.dims[1]||n.dims[0]!==t.dims[1])throw new Error("Input shapes are mismatched.");if("float32"!==t.type&&"float64"!==t.type||"float32"!==r.type&&"float64"!==r.type||"float32"!==n.type&&"float64"!==n.type)throw new Error("Invalid input type.");if(4!==e[0].dims.length)throw new Error("Only support 4-D input shape.")}},708:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackedMatmulProgramInfoLoader=void 0;const n=r(2517),a=r(5060),o=r(2039),i=r(9390),s=r(2823),l=r(5623);t.createPackedMatmulProgramInfoLoader=(e,t,r)=>{const d=(u=t.length>2,c=r.activationCacheKey,{name:"MatMul (packed)",inputNames:u?["A","B","Bias"]:["A","B"],inputTypes:u?[o.TextureType.packed,o.TextureType.packed,o.TextureType.packed]:[o.TextureType.packed,o.TextureType.packed],cacheHint:c});var u,c;return Object.assign(Object.assign({},d),{get:()=>((e,t,r,d)=>{const u=r.length>2,c=u?"value += getBiasForMatmul();":"",p=r[0].dims,g=r[1].dims,A=n.BroadcastUtil.calcShape(p,g,!0),h=!n.ShapeUtil.areEqual(r[0].dims,r[1].dims);if(!A)throw new Error("Can't use matmul on the given tensors");const B=p[p.length-1],m=Math.ceil(B/2),C=p.length,w=g.length,b=(0,a.getGlsl)(e.session.backend.glContext.version),K=(0,i.getCoordsDataType)(A.length),f=A.length,Q=(0,i.getGlChannels)(),{activationFunction:W,applyActivation:F}=(0,s.getActivationSnippet)(d),_=u?`${(0,l.getBiasForMatmul)(K,Q,r[2].dims,A,!0)}`:"",y=h?`${function(e,t,r,a){let o=[],i=[];const s=r[0].dims,l=r[1].dims,d=s.length,u=l.length,c=a.length,p=c-d,g=c-u;o=s.map(((e,r)=>`coords.${t[r+p]}`)),o[d-1]="i*2",o.join(", "),i=l.map(((e,r)=>`coords.${t[r+g]}`)),i[u-2]="i*2",i.join(", ");const A=n.BroadcastUtil.getBroadcastDims(s,a),h=n.BroadcastUtil.getBroadcastDims(l,a),B=A.map((e=>`coords.${t[e+p]} = 0;`)).join("\n"),m=h.map((e=>`coords.${t[e+g]} = 0;`)).join("\n"),C=`int lastDim = coords.${t[c-1]};\n  coords.${t[c-1]} = coords.${t[c-2]};\n  coords.${t[c-2]} = lastDim;`;return`\nvec4 getAAtOutCoordsMatmul(int i) {\n  ${e} coords = getOutputCoords();\n  ${C}\n  ${B}\n  vec4 outputValue = getA(${o});\n  return outputValue;\n}\n\nvec4 getBAtOutCoordsMatmul(int i) {\n  ${e} coords = getOutputCoords();\n  ${C}\n  ${m}\n  vec4 outputValue = getB(${i});\n  return outputValue;\n}`}(K,Q,r,A)}`:"",v=h?"getAAtOutCoordsMatmul(i)":`getA(${function(e,t){let r="";for(let n=0;n<t-2;n++)r+=`rc.${e[n]}, `;return r+=`rc.${e[t-2]}, i*2`,r}(Q,C)})`,E=h?"getBAtOutCoordsMatmul(i)":`getB(${function(e,t){let r="";for(let n=0;n<t-2;n++)r+=`rc.${e[n]}, `;return r+=`i*2, rc.${e[t-1]}`,r}(Q,w)})`,G=`\n            ${y}\n            ${_}\n            ${W}\n            void main() {\n              ${h?"":`${K} rc =\n          getOutputCoords(); int lastDim = rc.${Q[f-1]}; rc.${Q[f-1]} =\n          rc.${Q[f-2]}; rc.${Q[f-2]} = lastDim;\n      `}\n\n              vec4 value = vec4(0);\n              for (int i = 0; i < ${m}; i++) {\n                vec4 a = ${v};\n                vec4 b = ${E};\n\n                value += (a.rrbb * b.rgrg);\n                value += (a.ggaa * b.baba);\n              }\n              ${c}\n              ${F}\n              ${b.output} = value;\n            }`;return Object.assign(Object.assign({},t),{output:{dims:A,type:r[0].type,textureType:o.TextureType.packed},shaderSource:G,hasMain:!0})})(e,d,t,r)})}},5623:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getBiasForMatmul=t.createMatmulProgramInfoLoader=t.parseMatMulAttributes=t.matMul=void 0;const n=r(2517),a=r(2039),o=r(9390),i=r(2823),s=r(708);function l(e,t){const r=(s=e.length>2,l=t.activationCacheKey,{name:"MatMul",inputNames:s?["A","B","Bias"]:["A","B"],inputTypes:s?[a.TextureType.unpacked,a.TextureType.unpacked,a.TextureType.unpacked]:[a.TextureType.unpacked,a.TextureType.unpacked],cacheHint:l});var s,l;return Object.assign(Object.assign({},r),{get:()=>function(e,t,r){const s=t[0].dims,l=t[1].dims,d=n.BroadcastUtil.calcShape(s,l,!0);if(!d)throw new Error("Can't use matmul on the given tensors");const c=(0,o.getCoordsDataType)(d.length),p=(0,o.getGlChannels)(),{activationFunction:g,applyActivation:A}=(0,i.getActivationSnippet)(r),h=t.length>2,B=h?"value += getBiasForMatmul();":"",m=h?`${u(c,p,t[2].dims,d,!1)}`:"",C=d.length,w=s.length,b=l.length,K=`\n    ${g}\n    ${m}\n    float process(int indices[${C}]) {\n        int a[${w}];\n        int b[${b}];\n        bcastMatmulIndices_A(indices, a);\n        bcastMatmulIndices_B(indices, b);\n\n        float value;\n        for (int k=0; k<${s[s.length-1]}; ++k) {\n            a[${w-1}] = k;\n            b[${b-2}] = k;\n            value += _A(a) * _B(b);\n        }\n        ${B}\n        ${A}\n        return value;\n    }`;return Object.assign(Object.assign({},e),{output:{dims:d,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:K})}(r,e,t)})}t.matMul=(e,t,r)=>(d(t),e.session.pack?[e.run((0,s.createPackedMatmulProgramInfoLoader)(e,t,r),t)]:[e.run(l(t,r),t)]),t.parseMatMulAttributes=e=>(0,i.parseInternalActivationAttributes)(e.attributes),t.createMatmulProgramInfoLoader=l;const d=e=>{if(!e||2!==e.length)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if("float32"!==e[0].type&&"float64"!==e[0].type||"float32"!==e[1].type&&"float64"!==e[1].type)throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")};function u(e,t,r,a,o){let i="";const s=r.length,l=a.length,d=l-s;i=l<2&&s>0?"coords":r.map(((e,r)=>`coords.${t[r+d]}`)).join(", ");const u=n.BroadcastUtil.getBroadcastDims(r,a).map((e=>`coords.${t[e+d]} = 0;`)).join("\n");let c="vec4(outputValue.xx, outputValue.yy)";return 1===n.ShapeUtil.size(r)&&(c="vec4(outputValue.x)"),o?`\nvec4 getBiasForMatmul() {\n  ${e} coords = getOutputCoords();\n  ${u}\n  vec4 outputValue = getBias(${i});\n  return ${c};\n}`:`\nfloat getBiasForMatmul() {\n  ${e} coords = getOutputCoords();\n  ${u}\n  return getBias(coords.x);\n}`}t.getBiasForMatmul=u},2403:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createPackProgramInfoLoader=void 0;const n=r(5060),a=r(2039),o=r(9390),i=r(2827),s={name:"pack",inputNames:["A"],inputTypes:[a.TextureType.unpackedReversed]};t.createPackProgramInfoLoader=(e,t)=>Object.assign(Object.assign({},s),{get:()=>((e,t)=>{const r=(0,n.getGlsl)(e.session.backend.glContext.version),l=t.dims,d=l.length,u=t.dims.length,c=(0,o.getCoordsDataType)(u),p=(0,i.getChannels)("rc",u),g=(A=u,h=p,B=l[l.length-2],m=l[l.length-1],0===A||1===A?"":`\n    int r = ${h[A-2]};\n    int c = ${h[A-1]};\n    int rp1 = ${h[A-2]} + 1;\n    int cp1 = ${h[A-1]} + 1;\n    bool rEdge = rp1 >= ${m};\n    bool cEdge = cp1 >= ${B};\n    `);var A,h,B,m;let C;C=0===d?[1,1]:1===d?[l[0],1]:[l[u-1],l[u-2]];const w=function(e,t,r){if(0===e)return"false";if(1===e)return`rc > ${t[0]}`;let n="";for(let a=e-2;a<e;a++)n+=`${r[a]} >= ${t[a-e+2]}`,a<e-1&&(n+="||");return n}(u,C,p),b=function(e,t){const r=e.length;if(0===r)return"getA(), 0, 0, 0";if(1===r)return`getA(rc),\n            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),\n            0, 0`;let n="";if(r>2)for(let e=0;e<r-2;++e)n+=`${t[e]},`;return`getA(${n}r, c),\n          rEdge ? 0. : getA(${n}rp1, c),\n          cEdge ? 0. : getA(${n}r, cp1),\n          rEdge || cEdge ? 0. : getA(${n}rp1, cp1)`}(l,p),K=`\n        void main() {\n          ${c} rc = getOutputCoords();\n\n          if(${w}) {\n            ${r.output} = vec4(0);\n          } else {\n            ${g}\n\n            ${r.output} = vec4(${b});\n          }\n        }\n      `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:a.TextureType.packed},shaderSource:K})})(e,t)})},2827:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.unpackFromChannel=t.getChannels=t.getVecChannels=void 0;const n=r(9390);function a(e,t){return(0,n.getGlChannels)(t).map((t=>`${e}.${t}`))}t.getVecChannels=a,t.getChannels=function(e,t){return 1===t?[e]:a(e,t)},t.unpackFromChannel=function(){return"\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  "}},2870:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parsePadAttributesV11=t.padV11=t.parsePadAttributesV2=t.padV2=void 0;const n=r(246),a=r(2517),o=r(5060),i=r(2039),s={name:"Pad",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};t.padV2=(e,t,r)=>(u(t),[e.run(Object.assign(Object.assign({},s),{cacheHint:r.cacheKey,get:()=>d(e,t[0],r)}),t)]),t.parsePadAttributesV2=e=>{const t=e.attributes.getString("mode","constant"),r=e.attributes.getFloat("value",0),a=e.attributes.getInts("pads");return(0,n.createAttributeWithCacheKey)({mode:t,value:r,pads:a})},t.padV11=(e,r,n)=>{c(r);const a=l(e,r,n);return(0,t.padV2)(e,[r[0]],a)},t.parsePadAttributesV11=e=>e.attributes.getString("mode","constant");const l=(e,t,r)=>{if(!e.session.isInitializer(t[1].dataId)||t.length>=3&&!e.session.isInitializer(t[2].dataId))throw new Error("dynamic pad attributes are not allowed");const a=Array.from(t[1].integerData),o=t.length>=3?t[2].floatData[0]:0;return(0,n.createAttributeWithCacheKey)({mode:r,pads:a,value:o})},d=(e,t,r)=>{const n=a.ShapeUtil.padShape(t.dims.slice(),r.pads),o=n.length,s=`\n      ${p(e,t,r)}\n      float process(int[${o}] indices) {\n          return padA(indices);\n      }`;return{name:"Pad",inputNames:["A"],inputTypes:[i.TextureType.unpacked],output:{dims:n,type:t.type,textureType:i.TextureType.unpacked},shaderSource:s}},u=e=>{if(!e||1!==e.length)throw new Error("Pad requires 1 input");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")},c=e=>{if(!e||2!==e.length&&3!==e.length)throw new Error("Pad requires 2 or 3 inputs");if("int32"!==e[1].type)throw new Error("Invalid input type.");if(e.length>=3&&"string"===e[2].type)throw new Error("Invalid input type.")},p=(e,t,r)=>{const n=(0,o.getGlsl)(e.session.backend.glContext.version),[s,l]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),d=a.ShapeUtil.computeStrides(t.dims);switch(r.mode){case"constant":return g(n,t.dims,d,s,l,r.pads,r.value);case"reflect":return A(n,t.dims,d,s,l,r.pads);case"edge":return h(n,t.dims,d,s,l,r.pads);default:throw new Error("Invalid mode")}},g=(e,t,r,n,a,o,i)=>{const s=t.length;let l="";for(let e=s-1;e>=0;--e)l+=`\n        k = m[${e}] - ${o[e]};\n        if (k < 0)  return constant;\n        if (k >= ${t[e]}) return constant;\n        offset += k * ${r[e]};\n        `;return`\n      float padA(int m[${s}]) {\n        const float constant = float(${i});\n        int offset = 0;\n        int k = 0;\n        ${l}\n        vec2 coords = offsetToCoords(offset, ${n}, ${a});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `},A=(e,t,r,n,a,o)=>{const i=t.length;let s="";for(let e=i-1;e>=0;--e)s+=`\n        k = m[${e}] - ${o[e]};\n        if (k < 0) { k = -k; }\n        {\n          const int _2n_1 = ${2*(t[e]-1)};\n          k = int( mod( float(k), float(_2n_1) ) ) ;\n          if(k >= ${t[e]}) { k = _2n_1 - k; }\n        }\n        offset += k * ${r[e]};\n        `;return`\n      float padA(int m[${i}]) {\n        int offset = 0;\n        int k = 0;\n        ${s}\n        vec2 coords = offsetToCoords(offset, ${n}, ${a});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `},h=(e,t,r,n,a,o)=>{const i=t.length;let s="";for(let e=i-1;e>=0;--e)s+=`\n        k = m[${e}] - ${o[e]};\n        if (k < 0)  k = 0;\n        if (k >= ${t[e]}) k = ${t[e]-1};\n        offset += k * ${r[e]};\n      `;return`\n      float padA(int m[${i}]) {\n        int offset = 0;\n        int k = 0;\n        ${s}\n        vec2 coords = offsetToCoords(offset, ${n}, ${a});\n        float value = getColorAsFloat(${e.texture2D}(A, coords));\n        return value;\n      }\n      `}},2143:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.globalMaxPool=t.parseMaxPoolAttributes=t.maxPool=t.parseGlobalAveragePoolAttributes=t.globalAveragePool=t.parseAveragePoolAttributes=t.averagePool=void 0;const n=r(246),a=r(2517),o=r(2039);t.averagePool=(e,t,r)=>{c(t);const n={name:"AveragePool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:r.cacheKey};return[e.run(Object.assign(Object.assign({},n),{get:()=>i(t,n,!1,r)}),t)]},t.parseAveragePoolAttributes=e=>{const t=e.attributes.getString("auto_pad","NOTSET"),r=e.attributes.getInt("ceil_mode",0),a=0!==e.attributes.getInt("count_include_pad",0),o=e.attributes.getInts("kernel_shape"),i=e.attributes.getInts("strides",[]),s=e.attributes.getInts("pads",[]);if(0!==r)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return(0,n.createAttributeWithCacheKey)({autoPad:t,ceilMode:r,countIncludePad:a,kernelShape:o,strides:i,pads:s})};const i=(e,t,r,n)=>{const[i,s]=l(e,n,r),d=a.ShapeUtil.size(i.kernelShape);let u="";i.countIncludePad?u+=`value /= float(${d});`:u+=`value /= float(${d} - pad);`;const c=`\n        ${p(e[0].dims,i,"value += _X(x);",u,"0.0")}\n      `;return Object.assign(Object.assign({},t),{output:{dims:s,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:c})};t.globalAveragePool=(e,t,r)=>{c(t);const n={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:`${r.countIncludePad}`};return[e.run(Object.assign(Object.assign({},n),{get:()=>i(t,n,!0,r)}),t)]},t.parseGlobalAveragePoolAttributes=e=>{const t=0!==e.attributes.getInt("count_include_pad",0);return(0,n.createAttributeWithCacheKey)({autoPad:"",ceilMode:0,countIncludePad:t,kernelShape:[],strides:[],pads:[]})},t.maxPool=(e,t,r)=>{c(t);const n={name:"MaxPool",inputNames:["X"],inputTypes:[o.TextureType.unpacked],cacheHint:r.cacheKey};return[e.run(Object.assign(Object.assign({},n),{get:()=>s(t,n,!1,r)}),t)]},t.parseMaxPoolAttributes=e=>{const t=e.attributes.getString("auto_pad","NOTSET"),r=e.attributes.getInt("ceil_mode",0),a=e.attributes.getInts("kernel_shape"),o=e.attributes.getInts("strides",[]),i=e.attributes.getInts("pads",[]),s=e.attributes.getInt("storage_order",0),l=e.attributes.getInts("dilations",[]);if(0!==s)throw new Error("column major storage order is not yet supported for MaxPool");if(0!==r)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return(0,n.createAttributeWithCacheKey)({autoPad:t,ceilMode:r,countIncludePad:!1,kernelShape:a,strides:o,pads:i,storageOrder:s,dilations:l})};const s=(e,t,r,n)=>{const[a,i]=l(e,n,r),s=`\n      ${p(e[0].dims,a,"\n      value = max(_X(x), value);\n    ","","-1e5")}\n    `;return Object.assign(Object.assign({},t),{output:{dims:i,type:e[0].type,textureType:o.TextureType.unpacked},shaderSource:s})},l=(e,t,r)=>{const n=e[0].dims.slice(),o=Object.hasOwnProperty.call(t,"dilations"),i=t.kernelShape.slice(),s=t.strides.slice(),l=o?t.dilations.slice():[],d=t.pads.slice();a.PoolConvUtil.adjustPoolAttributes(r,n,i,s,l,d);const u=a.PoolConvUtil.computePoolOutputShape(r,n,s,l,i,d,t.autoPad),c=Object.assign({},t);return o?Object.assign(c,{kernelShape:i,strides:s,pads:d,dilations:l,cacheKey:t.cacheKey}):Object.assign(c,{kernelShape:i,strides:s,pads:d,cacheKey:t.cacheKey}),[c,u]},d={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},u={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[o.TextureType.unpacked]};t.globalMaxPool=(e,t)=>(c(t),[e.run(Object.assign(Object.assign({},u),{get:()=>s(t,u,!0,d)}),t)]);const c=e=>{if(!e||1!==e.length)throw new Error("Pool ops requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.")},p=(e,t,r,n,o)=>{const i=e.length;if(t.kernelShape.length<=2){const a=t.kernelShape[t.kernelShape.length-1],s=t.strides[t.strides.length-1],l=t.pads[t.pads.length/2-1],d=t.pads[t.pads.length-1],u=e[i-1];let c="",p="",g="";if(c=l+d!==0?`\n          for (int i = 0; i < ${a}; i++) {\n            x[${i} - 1] = indices[${i} - 1] * ${s} - ${l} + i;\n            if (x[${i} - 1] < 0 || x[${i} - 1] >= ${u}) {\n              pad++;\n              continue;\n            }\n            ${r}\n          }`:`\n          for (int i = 0; i < ${a}; i++) {\n            x[${i} - 1] = indices[${i} - 1] * ${s} - ${l} + i;\n            ${r}\n          }`,2===t.kernelShape.length){const r=t.kernelShape[t.kernelShape.length-2],n=t.strides[t.strides.length-2],o=t.pads[t.pads.length/2-2],s=t.pads[t.pads.length-2],l=e[i-2];p=o+s!==0?`\n            for (int j = 0; j < ${r}; j++) {\n              x[${i} - 2] = indices[${i} - 2] * ${n} - ${o} + j;\n              if (x[${i} - 2] < 0 || x[${i} - 2] >= ${l}) {\n                pad+= ${a};\n                continue;\n              }\n          `:`\n            for (int j = 0; j < ${r}; j++) {\n              x[${i} - 2] = indices[${i} - 2] * ${n} - ${o} + j;\n            `,g="\n          }\n        "}return`\n        float process(int indices[${i}]) {\n          int x[${i}];\n          copyVec(indices, x);\n\n          float value = ${o};\n          int pad = 0;\n          ${p}\n          ${c}\n          ${g}\n          ${n}\n          return value;\n        }\n      `}{const s=a.ShapeUtil.size(t.kernelShape),l=a.ShapeUtil.computeStrides(t.kernelShape),d=l.length,u=t.pads.length,c=A(d),p=g(e,"inputDims"),h=g(t.pads,"pads"),B=g(l,"kernelStrides"),m=g(t.strides,"strides");let C="";return C=t.pads.reduce(((e,t)=>e+t))?`\n            if (x[j] >= inputDims[j] || x[j] < 0) {\n              pad++;\n              isPad = true;\n              break;\n            }\n          }\n          if (!isPad) {\n            ${r}\n          }`:`\n          }\n          ${r}\n        `,`\n        ${c}\n        float process(int indices[${i}]) {\n          int x[${i}];\n          copyVec(indices, x);\n          int offset[${d}];\n          int pads[${u}];\n          int inputDims[${i}];\n          int kernelStrides[${d}];\n          int strides[${d}];\n          ${h}\n          ${p}\n          ${m}\n          ${B}\n\n          float value = ${o};\n          int pad = 0;\n          bool isPad = false;\n          for (int i = 0; i < ${s}; i++) {\n            offsetToIndices(i, kernelStrides, offset);\n            isPad = false;\n            for (int j = ${i} - ${d}; j < ${i}; j++) {\n              x[j] = indices[j] * strides[j - ${i} + ${d}]\n                + offset[j - ${i} + ${d}] - pads[j - 2];\n              ${C}\n          }\n          ${n}\n\n          return value;\n        }\n      `}},g=(e,t)=>{let r="";for(let n=0;n<e.length;n++)r+=`\n      ${t}[${n}] = ${e[n]};\n    `;return r},A=e=>`\n  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {\n    if (${e} == 0) {\n      return;\n    }\n    for (int i = 0; i < ${e} - 1; ++i) {\n      indices[i] = offset / strides[i];\n      offset -= indices[i] * strides[i];\n    }\n    indices[${e} - 1] = offset;\n  }`},4939:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.reduceLogSumSquare=t.reduceLogSum=t.reduceProd=t.reduceMin=t.reduceMax=t.reduceMean=t.reduceSum=t.parseReduceAttributes=void 0;const n=r(246),a=r(782),o=r(2517),i=r(2039),s=(e,t,r,n,a)=>{d(t);const o={name:n,inputNames:["A"],inputTypes:[i.TextureType.unpacked]};return[e.run(Object.assign(Object.assign({},o),{cacheHint:r.cacheKey,get:()=>l(e,t,r,n,a,o)}),t)]};t.parseReduceAttributes=e=>{const t=e.attributes.getInts("axes",[]),r=1===e.attributes.getInt("keepdims",1);return(0,n.createAttributeWithCacheKey)({axes:t,keepDims:r})};const l=(e,t,r,n,a,s)=>{const l=[],d=t[0].dims.length||1,u=[],c=o.ShapeUtil.normalizeAxes(r.axes,t[0].dims.length),p=a(t,c);let g=p[1];for(let e=0;e<t[0].dims.length;e++)c.indexOf(e)>=0||0===c.length?(r.keepDims&&l.push(1),g=`\n          for(int j${e} = 0; j${e} < ${t[0].dims[e]}; j${e}++) {\n            inputIdx[${e}] = j${e};\n            ${g}\n          }`):(u.push(`inputIdx[${e}] = outputIdx[${l.length}];`),l.push(t[0].dims[e]));const A=`\n      float process(int outputIdx[${l.length||1}]) {\n        float value;                 // final result\n        int inputIdx[${d}];      // addressing input data\n        ${u.join("\n")}\n        ${p[0]}       // init ops for reduce max/min\n        ${g}\n        ${p[2]}       // final computation for reduce mean\n        return value;\n      }`;return Object.assign(Object.assign({},s),{output:{dims:l,type:t[0].type,textureType:i.TextureType.unpacked},shaderSource:A})},d=e=>{if(!e||1!==e.length)throw new Error("Reduce op requires 1 input.");if(-1===a.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.")};t.reduceSum=(e,t,r)=>s(e,t,r,"ReduceSum",(()=>["value = 0.0;","value += _A(inputIdx);",""])),t.reduceMean=(e,t,r)=>s(e,t,r,"ReduceMean",((e,t)=>{let r=1;for(let n=0;n<e[0].dims.length;n++)(t.indexOf(n)>=0||0===t.length)&&(r*=e[0].dims[n]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${r}.;`]})),t.reduceMax=(e,t,r)=>s(e,t,r,"ReduceMax",((e,t)=>{const r=[];for(let n=0;n<e[0].dims.length;n++)(t.indexOf(n)>=0||0===t.length)&&r.push(`inputIdx[${n}] = 0;`);return[`${r.join("\n")}\nvalue = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]})),t.reduceMin=(e,t,r)=>s(e,t,r,"ReduceMin",((e,t)=>{const r=[];for(let n=0;n<e[0].dims.length;n++)(t.indexOf(n)>=0||0===t.length)&&r.push(`inputIdx[${n}] = 0;`);return[`${r.join("\n")}\nvalue = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]})),t.reduceProd=(e,t,r)=>s(e,t,r,"ReduceProd",(()=>["value = 1.0;","value *= _A(inputIdx);",""])),t.reduceLogSum=(e,t,r)=>s(e,t,r,"ReduceLogSum",(()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"])),t.reduceLogSumSquare=(e,t,r)=>s(e,t,r,"ReduceLogSumSquare",(()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""]))},7019:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.isReshapeCheap=t.processDims3D=t.createPackedReshape3DProgramInfoLoader=void 0;const n=r(2517),a=r(5060),o=r(2039),i=r(2827);t.createPackedReshape3DProgramInfoLoader=(e,t,r)=>{const s=(e=>({name:"Reshape (packed)",inputTypes:[o.TextureType.packed],inputNames:["A"],cacheHint:`${e}`}))(r);return Object.assign(Object.assign({},s),{get:()=>((e,t,r,s)=>{const l=t.dims,d=s;let u="";for(let e=0;e<4;e++){let t="";switch(e){case 0:t="outputCoords = rc;";break;case 1:t="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:t="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:t="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}u+=`\n        ${t}\n        ${e>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}\n          int flattenedIndex = getFlattenedIndex(outputCoords);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);\n          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${e}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);\n\n        ${e>0?"}":""}\n      `}const c=(0,a.getGlsl)(e.session.backend.glContext.version),p=`\n      ${function(e){const t=n.ShapeUtil.computeStrides(e),r=["b","r","c"],a="index";return`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${t.map(((e,n)=>`int ${r[n]} = ${a} / ${e}; ${n===t.length-1?`int ${r[n+1]} = ${a} - ${r[n]} * ${e}`:`index -= ${r[n]} * ${e}`};`)).join("")}\n      return ivec3(b, r, c);\n    }\n  `}(l)}\n      ${function(e){const t=n.ShapeUtil.computeStrides(e);return`\n  int getFlattenedIndex(ivec3 coords) {\n    // reverse y, z order\n    return coords.x * ${t[0]} + coords.z * ${t[1]} + coords.y;\n  }\n`}(d)}\n      ${(0,i.unpackFromChannel)()}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.0);\n\n        ivec3 outputCoords;\n        int rows = ${d[2]};\n        int cols = ${d[1]};\n\n        ${u}\n        ${c.output} = result;\n      }\n    `;return Object.assign(Object.assign({},r),{output:{dims:d,type:t.type,textureType:o.TextureType.packed},shaderSource:p,hasMain:!0})})(e,t,s,r)})},t.processDims3D=function(e){if(0===e.length)return[1,1,1];let t=1;for(let r=0;r<e.length-2;++r)t*=e[r];return[t,e.length>1?e[e.length-2]:1,e[e.length-1]]},t.isReshapeCheap=function(e,t){let r=!1;return r=0===e.length||0===t.length||(e.length<2||t.length<2?e[e.length-1]===t[t.length-1]:e[e.length-1]===t[t.length-1]&&e[e.length-2]===t[t.length-2]),r}},718:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.reshape=void 0;const n=r(2517);t.reshape=(e,t)=>{const r=n.ShapeUtil.calculateReshapedDims(t[0].dims,t[1].integerData);return e.session.pack?[e.reshapePacked(t[0],r)]:[e.reshapeUnpacked(t[0],r)]}},2268:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseResizeAttributesV11=t.parseResizeAttributesV10=t.resize=void 0;const n=r(5060),a=r(2039),o=r(9390),i=r(2827),s=r(9793),l={name:"Resize",inputNames:["A"],inputTypes:[a.TextureType.packed]};t.resize=(e,t,r)=>((0,s.validateInputs)(t,r),[e.run(Object.assign(Object.assign({},l),{cacheHint:r.cacheKey,get:()=>d(e,t,r)}),t)]),t.parseResizeAttributesV10=e=>(0,s.parseUpsampleAttributes)(e,10),t.parseResizeAttributesV11=e=>(0,s.parseUpsampleAttributes)(e,11);const d=(e,t,r)=>{const s=(0,n.getGlsl)(e.session.backend.glContext.version),[d,c]=u(t,r);if(d.every((e=>1===e))&&"tf_crop_and_resize"!==r.coordinateTransformMode)return Object.assign(Object.assign({},l),{output:{dims:c,type:t[0].type,textureType:a.TextureType.packed},hasMain:!0,shaderSource:`void main() {\n                    vec4 v = ${s.texture2D}(X, TexCoords);\n                    ${s.output} = v;\n                }`});const p=c.length;if(p<2)throw new Error(`output dimension should be at least 2, but got ${p}`);const g=c[p-2],A=c[p-1],h=t[0].dims;if(p!==h.length)throw new Error(`output dimension should match input ${h.length}, but got ${p}`);const B=h[p-2],m=h[p-1],C=d[p-2],w=d[p-1];let b="";if("linear"!==r.mode)throw new Error(`resize (packed) does not support mode: '${r.mode}'`);switch(r.coordinateTransformMode){case"asymmetric":b="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";break;case"half_pixel":b="\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";break;case"pytorch_half_pixel":b=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 fcoords = vec4(coords);\n                        return vec4(\n                            ${A}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,\n                            ${g}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,\n                            ${A}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,\n                            ${g}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0\n                          );\n                    }\n                `;break;case"align_corners":b=`\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        vec4 resized = vec4(${A}.0 - 1.0, ${g}.0 - 1.0, ${A}.0 - 1.0,\n                            ${g}.0 - 1.0);\n                        vec4 original = vec4(${m}.0 - 1.0, ${B}.0 - 1.0, ${m}.0 - 1.0,\n                            ${B}.0 - 1.0);\n                        vec4 new_scale = original / resized;\n                        return vec4(coords) * new_scale;\n                    }\n                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${r.coordinateTransformMode}'`)}const K=(0,o.getCoordsDataType)(p),f=`\n            const vec2 inputWH = vec2(${B}.0, ${m}.0);\n            const vec4 scaleWHWH = vec4(float(${C}), float(${w}), float(${C}), float(${w}));\n            ${(0,i.unpackFromChannel)()}\n            ${b}\n            float getAValue(int x10, int r, int c, int d) {\n                return getChannel(getA(x10, r, c, d), vec2(c, d));\n            }\n            void main() {\n                ${K} rc = getOutputCoords();\n\n                int batch = rc[0];\n                int depth = rc[1];\n\n                // retrieve the 4 coordinates that is used in the 4 packed output values.\n                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);\n\n                // calculate the source index in fraction\n                vec4 sourceFrac = getSourceFracIndex(coords);\n\n                // get the lower and upper bound of the 4 values that will be packed into one texel.\n                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));\n                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));\n                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));\n                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));\n\n                bool hasNextRow = rc.w < ${g-1};\n                bool hasNextCol = rc.z < ${A-1};\n\n                // pack x00, x01, x10, x11's top-left corner into one vec4 structure\n                vec4 topLeft = vec4(\n                    getAValue(batch, depth, x00.x, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's top-right corner into one vec4 structure\n                vec4 topRight = vec4(\n                    getAValue(batch, depth, x00.x, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure\n                vec4 bottomLeft = vec4(\n                    getAValue(batch, depth, x00.z, x00.y),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);\n\n                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure\n                vec4 bottomRight = vec4(\n                    getAValue(batch, depth, x00.z, x00.w),\n                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,\n                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,\n                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);\n\n                // calculate the interpolation fraction on u and v direction\n                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);\n                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));\n\n                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);\n                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);\n                vec4 newValue = mix(top, bottom, clampFrac.xxzz);\n\n                ${s.output} = vec4(newValue);\n            }\n        `;return Object.assign(Object.assign({},l),{output:{dims:c,type:t[0].type,textureType:a.TextureType.packed},hasMain:!0,shaderSource:f})},u=(e,t)=>{const r=e[0].dims;let n,a=t.scales;if(0===a.length){const o=e[t.scalesInputIdx];if(o&&0!==o.size){if(e[t.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");a=c(o,t.mode,t.isResize)}else{const o=e[t.sizesInputIdx];if(!o||0===o.size)throw new Error("Either scales or sizes MUST be provided as input.");n=Array.from(o.integerData),a=p(n,r,t.mode,t.isResize)}}else if(e[t.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");const o=n||r.map(((e,t)=>Math.floor(e*a[t])));return[a,o]},c=(e,t,r)=>{const n=Array.from(e.floatData);return(0,s.scalesValidation)(n,t,r),n},p=(e,t,r,n)=>{const a=t.length,o=new Array(a);for(let r=0,n=a;r<n;r++)if(0===t[r]){if(0!==e[r])throw new Error("Input dim is zero but required output dim is non-zero.");o[r]=1}else o[r]=e[r]/t[r];return(0,s.scalesValidation)(o,r,n),o}},8117:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.shape=void 0;const n=r(9162);t.shape=(e,t)=>(a(t),[new n.Tensor([t[0].dims.length],"int32",void 0,void 0,new Int32Array(t[0].dims))]);const a=e=>{if(!e||1!==e.length)throw new Error("Shape requires 1 input.")}},2278:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.sliceV10=t.parseSliceAttributes=t.slice=void 0;const n=r(246),a=r(782),o=r(2517),i=r(2039),s={name:"Slice",inputNames:["A"],inputTypes:[i.TextureType.unpacked]};t.slice=(e,t,r)=>(d(t),[e.run(Object.assign(Object.assign({},s),{cacheHint:r.cacheKey,get:()=>l(e,t[0],r)}),t)]),t.parseSliceAttributes=e=>{const t=e.attributes.getInts("starts"),r=e.attributes.getInts("ends"),a=e.attributes.getInts("axes",[]);return(0,n.createAttributeWithCacheKey)({starts:t,ends:r,axes:a})};const l=(e,t,r)=>{const n=0===r.axes.length?t.dims.slice(0).map(((e,t)=>t)):r.axes,a=o.ShapeUtil.normalizeAxes(n,t.dims.length),l=r.starts.map(((e,r)=>e>t.dims[a[r]]-1?t.dims[a[r]]:o.ShapeUtil.normalizeAxis(e,t.dims[a[r]]))),d=r.ends.map(((e,r)=>e>t.dims[a[r]]-1?t.dims[a[r]]:o.ShapeUtil.normalizeAxis(e,t.dims[a[r]]))),u=t.dims.slice(),c=[];for(let e=0;e<a.length;e++)u[a[e]]=d[e]-l[e],l[e]>0&&c.push(`outputIdx[${a[e]}] += ${l[e]};`);const p=`\n      float process(int outputIdx[${u.length}]) {\n        ${c.join("\n      ")}\n        return _A(outputIdx);\n      }`;return Object.assign(Object.assign({},s),{output:{dims:u,type:t.type,textureType:i.TextureType.unpacked},shaderSource:p})},d=e=>{if(!e||1!==e.length)throw new Error("Slice requires 1 input.");if(-1===a.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.")};t.sliceV10=(e,t)=>{c(t);const r=u(e,t);return[e.run(Object.assign(Object.assign({},s),{cacheHint:r.cacheKey,get:()=>l(e,t[0],r)}),[t[0]])]};const u=(e,t)=>{if(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)||t.length>=4&&!e.session.isInitializer(t[3].dataId)||t.length>=5&&!e.session.isInitializer(t[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(t.length>=5&&t[4].integerData.some((e=>1!==e)))throw new Error("currently non-1 steps is not supported for Slice");const r=Array.from(t[1].integerData),n=Array.from(t[2].integerData),a=t.length>=4?Array.from(t[3].integerData):[];return{starts:r,ends:n,axes:a,cacheKey:`${a};${r};${n}`}},c=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if("int32"!==e[1].type||1!==e[1].dims.length)throw new Error("Invalid input type.");if("int32"!==e[2].type||1!==e[2].dims.length)throw new Error("Invalid input type.");if(e.length>=4&&("int32"!==e[3].type||1!==e[3].dims.length))throw new Error("Invalid input type.");if(e.length>=5&&("int32"!==e[4].type||1!==e[4].dims.length))throw new Error("Invalid input type.")}},5524:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.softmaxV13=t.parseSoftmaxAttributesV13=t.parseSoftmaxAttributes=t.softmax=void 0;const n=r(246),a=r(2517),o=r(5060),i=r(2039),s=r(3738),l={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[i.TextureType.unpacked]},d={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked]},u={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[i.TextureType.unpacked,i.TextureType.unpacked,i.TextureType.unpacked]};t.softmax=(e,t,r)=>{h(t);const n=t[0].dims.slice(),o=a.ShapeUtil.normalizeAxis(r.axis,n.length),i=a.ShapeUtil.sizeToDimension(n,o),s=a.ShapeUtil.sizeFromDimension(n,o);return c(e,t,r,i,s)},t.parseSoftmaxAttributes=e=>(0,n.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",1)}),t.parseSoftmaxAttributesV13=e=>(0,n.createAttributeWithCacheKey)({axis:e.attributes.getInt("axis",-1)}),t.softmaxV13=(e,t,r)=>{h(t);const o=t[0].dims.slice(),i=a.ShapeUtil.normalizeAxis(r.axis,o.length),l=o.length,d=i!==l-1,u=[];let p,g=[],A=[];d&&(g=Array.from({length:l}).map(((e,t)=>t)),g[i]=l-1,g[l-1]=i,g.map((e=>u.push(o[e]))),p=(0,n.createAttributeWithCacheKey)({perm:g}),A=(0,s.transpose)(e,t,p));const B=d?a.ShapeUtil.sizeToDimension(u,l-1):a.ShapeUtil.sizeToDimension(o,l-1),m=d?a.ShapeUtil.sizeFromDimension(u,l-1):a.ShapeUtil.sizeFromDimension(o,l-1),C=c(e,d?A:t,r,B,m);return d?(0,s.transpose)(e,C,p):C};const c=(e,t,r,n,a)=>{const o=p(e,t[0],n,a,[n]),i=e.run(Object.assign(Object.assign({},l),{cacheHint:r.cacheKey,get:()=>o}),t),s=g(e,t[0],n,a,o.output.dims,[n]),c=e.run(Object.assign(Object.assign({},d),{cacheHint:r.cacheKey,get:()=>s}),[t[0],i]),h=A(e,t[0],n,a,o.output.dims,s.output.dims);return[e.run(Object.assign(Object.assign({},u),{cacheHint:r.cacheKey,get:()=>h}),[t[0],i,c])]},p=(e,t,r,n,a)=>{const[s,d]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),u=a.length;if(r<1||n<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==a.length)throw new Error("Dimensionality of the output should be 1");if(a[0]!==r)throw new Error("Shape of the output should be equal to logical row count");const c=(0,o.getGlsl)(e.session.backend.glContext.version),p=`\n      float process(int[${u}] indices) {\n        int logical_row_start_offset = indices[0] * ${n};\n\n        float max = getColorAsFloat(${c.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s},\n        ${d} )));\n        for(int i=1; i<${n}; ++i)\n        {\n          float current = getColorAsFloat(${c.texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${s}, ${d})));\n          if(current > max)\n          max = current;\n        }\n\n        return max;\n      }`;return Object.assign(Object.assign({},l),{output:{dims:a,type:t.type,textureType:i.TextureType.unpacked},shaderSource:p})},g=(e,t,r,n,a,s)=>{const[l,u]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),c=s.length;if(r<1||n<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==s.length)throw new Error("Dimensionality of the output should be 1");if(s[0]!==r)throw new Error("Shape of the output should be equal to logical row count");if(1!==a.length)throw new Error("Dimensionality of the intermediate results should be 1");if(a[0]!==r)throw new Error("Shape of the intermediate results should be equal to logical row count");const p=`\n      float process(int[${c}] indices) {\n        int logical_row_start_offset = indices[0] * ${n};\n\n        float norm_factor = 0.0;\n        float max = _Max(indices);\n        for(int i=0; i<${n}; ++i)\n        {\n          norm_factor += exp(getColorAsFloat(${(0,o.getGlsl)(e.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,\n            ${l}, ${u}))) - max);\n        }\n\n        return norm_factor;\n      }`;return Object.assign(Object.assign({},d),{output:{dims:s,type:t.type,textureType:i.TextureType.unpacked},shaderSource:p})},A=(e,t,r,n,a,o)=>{const[s,l]=e.calculateTextureWidthAndHeight(t.dims,i.TextureType.unpacked),d=t.dims.length;if(r<1||n<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(1!==a.length||1!==o.length)throw new Error("Dimensionality of the intermediate results should be 1");if(a[0]!==r||o[0]!==r)throw new Error("Shape of the intermediate results should be equal to logical row count");const c=`\n      float process(int[${d}] indices) {\n\n      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)\n      int offset = coordsToOffset(TexCoords, ${s}, ${l});\n\n      //determine the logical row for this index\n      int logical_row_index[1];\n      logical_row_index[0] = offset / ${n};\n\n      float norm_factor = _Norm(logical_row_index);\n\n      // avoid possible division by 0\n      // if norm_facor is 0, all elements are zero\n      // if so, return 0\n      if(norm_factor == 0.0)\n        return 0.0;\n\n      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;\n    }`;return Object.assign(Object.assign({},u),{output:{dims:t.dims,type:t.type,textureType:i.TextureType.unpacked},shaderSource:c})},h=e=>{if(!e||1!==e.length)throw new Error("Softmax requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type")}},5975:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSplitAttributes=t.split=void 0;const n=r(246),a=r(2517),o=r(2039),i={name:"Split",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};t.split=(e,t,r)=>{d(t);const n=a.ShapeUtil.normalizeAxis(r.axis,t[0].dims.length),o=s(e,t,n,r),u=[];for(let a=0;a<o;++a)u.push(e.run(Object.assign(Object.assign({},i),{cacheHint:`${r.cacheKey};${a}`,get:()=>l(e,t[0],r,n,a)}),t));return u},t.parseSplitAttributes=e=>{const t=e.attributes.getInt("axis",0),r=e.attributes.getInts("split",[]),a=e.outputs.length;return(0,n.createAttributeWithCacheKey)({axis:t,split:r,numOutputs:a})};const s=(e,t,r,n)=>{const[,o]=a.SplitUtil.splitShape(t[0].dims,r,n.split,n.numOutputs);return o.length},l=(e,t,r,n,s)=>{const[l,d]=a.SplitUtil.splitShape(t.dims,n,r.split,r.numOutputs),u=d[s],c=l[s],p=`\n      float process(int indices[${c.length}]) {\n        indices[${n}] += ${u};\n        return _A(indices);\n      }\n    `;return Object.assign(Object.assign({},i),{cacheHint:`${r.cacheKey}:${s}`,output:{dims:c,type:t.type,textureType:o.TextureType.unpacked},shaderSource:p})},d=e=>{if(!e||1!==e.length)throw new Error("Split requires one input.");if("int8"!==e[0].type&&"uint8"!==e[0].type&&"int16"!==e[0].type&&"uint16"!==e[0].type&&"int32"!==e[0].type&&"uint32"!==e[0].type&&"float32"!==e[0].type&&"float64"!==e[0].type&&"bool"!==e[0].type)throw new Error("Invalid input type.")}},3933:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseSqueezeAttributes=t.squeezeV13=t.squeeze=void 0;const n=r(2517);t.squeeze=(e,t,r)=>{a(t);const o=n.ShapeUtil.squeezeShape(t[0].dims,r);return[e.reshapeUnpacked(t[0],o)]},t.squeezeV13=(e,r)=>(o(r),(0,t.squeeze)(e,[r[0]],Array.from(r[1].integerData))),t.parseSqueezeAttributes=e=>e.attributes.getInts("axes");const a=e=>{if(!e||1!==e.length)throw new Error("Squeeze requires 1 input.");if("string"===e[0].type)throw new Error("invalid input tensor types.")},o=e=>{if(!e||2!==e.length)throw new Error("Squeeze requires 2 inputs.");if("int32"!==e[1].type)throw new Error("Invalid input type.")}},6558:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.sum=void 0;const n=r(5060),a=r(2039);t.sum=(e,t)=>{i(t);const r={name:"Sum",inputNames:t.map(((e,t)=>`X${t}`)),inputTypes:new Array(t.length).fill(a.TextureType.unpacked)};return[e.run(Object.assign(Object.assign({},r),{get:()=>o(e,t,r)}),t)]};const o=(e,t,r)=>{const o=(0,n.getGlsl)(e.session.backend.glContext.version),i=t[0].dims.slice(),s=`\n      void main() {\n        vec4 result = ${t.map(((e,t)=>`${o.texture2D}(X${t},TexCoords)`)).join(" + ")};\n        ${o.output} = result;\n      }\n    `;return Object.assign(Object.assign({},r),{output:{dims:i,type:t[0].type,textureType:a.TextureType.unpacked},hasMain:!0,shaderSource:s})},i=e=>{if(!e||0===e.length)throw new Error("Sum requires inputs.");const t=e[0].dims.length;for(let r=1;r<e.length;r++){if(t!==e[r].dims.length)throw new Error("Input shapes are mismatched.");for(let n=0;n<t;n++)if(e[0].dims[n]!==e[r].dims[n])throw new Error("Input shapes are not matched.")}if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("Invalid input type.");for(let t=1;t<e.length;t++)if(e[0].type!==e[t].type)throw new Error("Input types are not matched.")}},5723:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.tile=void 0;const n=r(782),a=r(2039);t.tile=(e,t)=>{i(t);const r={name:"Tile",inputNames:["A"],inputTypes:[a.TextureType.unpacked]};return[e.run(Object.assign(Object.assign({},r),{get:()=>o(e,t,r)}),t)]};const o=(e,t,r)=>{const n=t[0].dims.slice(),o=new Array(n.length),i=[];for(let e=0;e<n.length;e++)o[e]=n[e]*t[1].numberData[e],i.push(`inputIdx[${e}] = int(mod(float(outputIdx[${e}]), ${n[e]}.));`);const s=o.length,l=`\n      float process(int outputIdx[${s}]) {\n        int inputIdx[${s}];\n        ${i.join("\n")}\n        return _A(inputIdx);\n      }\n    `;return Object.assign(Object.assign({},r),{output:{dims:o,type:t[0].type,textureType:a.TextureType.unpacked},shaderSource:l})},i=e=>{if(!e||2!==e.length)throw new Error("Tile requires 2 input.");if(1!==e[1].dims.length)throw new Error("The second input shape must 1 dimension.");if(e[1].dims[0]!==e[0].dims.length)throw new Error("Invalid input shape.");if(-1===n.NUMBER_TYPES.indexOf(e[0].type))throw new Error("Invalid input type.");if("int32"!==e[1].type&&"int16"!==e[1].type)throw new Error("Invalid repeat type.")}},3738:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseTransposeAttributes=t.transpose=void 0;const n=r(246),a=r(2517),o=r(2039),i={name:"Transpose",inputNames:["A"],inputTypes:[o.TextureType.unpacked]};t.transpose=(e,t,r)=>(c(t),[e.run(Object.assign(Object.assign({},i),{cacheHint:r.cacheKey,get:()=>s(e,t[0],r.perm)}),t)]),t.parseTransposeAttributes=e=>(0,n.createAttributeWithCacheKey)({perm:e.attributes.getInts("perm",[])});const s=(e,t,r)=>{const n=t.dims;r=l(n,r);const a=d(n,r),s=n.length,c=`\n      ${u("perm",r,s)}\n      float process(int indices[${s}]) {\n        int a[${s}];\n        perm(a, indices);\n        return _A(a);\n      }`;return Object.assign(Object.assign({},i),{output:{dims:a,type:t.type,textureType:o.TextureType.unpacked},shaderSource:c})},l=(e,t)=>(t&&t.length!==e.length&&(t=[...e.keys()].reverse()),t),d=(e,t)=>(t=l(e,t),a.ShapeUtil.sortBasedOnPerm(e,t)),u=(e,t,r)=>{const n=[];n.push(`void ${e}(out int a[${r}], int src[${r}]) {`);for(let e=0;e<r;++e)n.push(`\ta[${t[e]}]=src[${e}];`);return n.push("\t}"),n.join("\n")},c=e=>{if(!e||1!==e.length)throw new Error("Transpose requires 1 input.");if("float32"!==e[0].type&&"float64"!==e[0].type)throw new Error("input should be float tensor")}},8710:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.encodeAsUint8=void 0;const n=r(5060),a=r(2039);t.encodeAsUint8=(e,t)=>{const r=t.shape,o=(0,n.getGlsl)(e.session.backend.glContext.version),i=`\n    const float FLOAT_MAX = 1.70141184e38;\n    const float FLOAT_MIN = 1.17549435e-38;\n\n    bool isNaN(float val) {\n      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;\n    }\n\n    highp vec4 encodeAsUint8(highp float v) {\n      if (isNaN(v)) {\n        return vec4(255, 255, 255, 255);\n      }\n\n      highp float av = abs(v);\n\n      if(av < FLOAT_MIN) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n      } else if(v > FLOAT_MAX) {\n        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n      } else if(v < -FLOAT_MAX) {\n        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n      }\n\n      highp vec4 c = vec4(0,0,0,0);\n\n      highp float e = floor(log2(av));\n      highp float m = exp2(fract(log2(av))) - 1.0;\n\n      c[2] = floor(128.0 * m);\n      m -= c[2] / 128.0;\n      c[1] = floor(32768.0 * m);\n      m -= c[1] / 32768.0;\n      c[0] = floor(8388608.0 * m);\n\n      highp float ebias = e + 127.0;\n      c[3] = floor(ebias / 2.0);\n      ebias -= c[3] * 2.0;\n      c[2] += floor(ebias) * 128.0;\n\n      c[3] += 128.0 * step(0.0, -v);\n\n      return c / 255.0;\n    }\n\n    void main() {\n      float value = ${o.texture2D}(X,TexCoords).r;\n      ${o.output} = encodeAsUint8(value);\n    }`,s={name:"Uint8Encode",inputTypes:[a.TextureType.unpacked],inputNames:["X"],output:{dims:r,type:t.tensor.type,textureType:a.TextureType.downloadUint8AsFloat},shaderSource:i,hasMain:!0};return e.executeProgram(s,[t.tensor])}},4909:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.tanh=t.tan=t.sqrt=t.sin=t.sigmoid=t.relu=t.not=t.neg=t.log=t.parseLeakyReluAttributes=t.leakyRelu=t.identity=t.floor=t.exp=t.parseEluAttributes=t.elu=t.cos=t.ceil=t.clipV11=t.parseClipAttributes=t.clip=t.atan=t.asin=t.acos=t.abs=t.glslTanh=t.glslTan=t.glslSqrt=t.glslSigmoid=t.glslRelu=t.glslSin=t.glslNot=t.glslNeg=t.glslLog=t.glslLeakyRelu=t.glslIdentity=t.glslClip=t.glslFloor=t.glslExp=t.glslElu=t.glslCos=t.glslCeil=t.glslAtan=t.glslAsin=t.glslAcos=t.glslAbs=void 0;const n=r(246),a=r(2517),o=r(8520),i=r(5060),s=r(2039);function l(){return E("abs")}function d(){return E("acos")}function u(){return E("asin")}function c(){return E("atan")}function p(){return E("ceil")}function g(){return E("cos")}function A(e){const t="elu";return{body:`\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function h(){return E("exp")}function B(){return E("floor")}function m(e,t){const r="clip";return{body:`\n  const float min = float(${e});\n  const float max = float(${t});\n\n  float ${r}_(float a) {\n    return clamp(a, min, max);\n  }\n  vec4 ${r}_(vec4 v) {\n    return clamp(v, min, max);\n  }\n  `,name:r,type:o.FunctionType.ValueBased}}function C(){const e="indentity";return{body:`\n  float ${e}_(float a) {\n    return a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return v;\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function w(e){const t="leakyRelu";return{body:`\n  const float alpha = float(${e});\n\n  float ${t}_(float a) {\n    return a < 0.0 ? a * alpha : a;\n  }\n  vec4 ${t}_(vec4 v) {\n    return vec4(${t}_(v.x), ${t}_(v.y), ${t}_(v.z), ${t}_(v.w));\n  }\n  `,name:t,type:o.FunctionType.ValueBased}}function b(){return E("log")}function K(){const e="neg";return{body:`\n  float ${e}_(float a) {\n    return -a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return -v;\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function f(){const e="not";return{body:`\n  float ${e}_(float a) {\n    return float( ! bool(a) );\n  }\n  bool ${e}_(bool a) {\n    return !a;\n  }\n  vec4 ${e}_(vec4 v) {\n    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));\n  }\n  bvec4 ${e}_(bvec4 v) {\n    return bvec4(!v.x, !v.y, !v.z, !v.w);\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function Q(){return E("sin")}function W(){const e="relu";return{body:`\n  float ${e}_(float a) {\n    return max( a, 0.0 );\n  }\n  vec4 ${e}_(vec4 v) {\n    return max( v, 0.0 );\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function F(){const e="sigmoid";return{body:`\n  float ${e}_(float a) {\n    return 1.0 / (1.0 + exp(-a));\n  }\n  vec4 ${e}_(vec4 v) {\n    return 1.0 / (1.0 + exp(-v));\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function _(){return E("sqrt")}function y(){return E("tan")}function v(){const e="tanh";return{body:`\n  float ${e}_(float a) {\n    a = clamp(a, -10., 10.);\n    a = exp(2.*a);\n    return (a - 1.) / (a + 1.);\n  }\n  vec4 ${e}_(vec4 v) {\n    v = clamp(v, -10., 10.);\n    v = exp(2.*v);\n    return (v - 1.) / (v + 1.);\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}function E(e){return{body:`\n  float ${e}_(float a) {\n    return ${e}(a);\n  }\n  vec4 ${e}_(vec4 v) {\n    return ${e}(v);\n  }\n  `,name:e,type:o.FunctionType.ValueBased}}t.glslAbs=l,t.glslAcos=d,t.glslAsin=u,t.glslAtan=c,t.glslCeil=p,t.glslCos=g,t.glslElu=A,t.glslExp=h,t.glslFloor=B,t.glslClip=m,t.glslIdentity=C,t.glslLeakyRelu=w,t.glslLog=b,t.glslNeg=K,t.glslNot=f,t.glslSin=Q,t.glslRelu=W,t.glslSigmoid=F,t.glslSqrt=_,t.glslTan=y,t.glslTanh=v;const G=(e,t,r,n)=>{const a=e.session.pack?s.TextureType.packed:s.TextureType.unpacked,o={name:r.name,inputTypes:[a],inputNames:["A"],cacheHint:n};return Object.assign(Object.assign({},o),{get:()=>((e,t,r,n)=>{const a=e.session.pack?s.TextureType.packed:s.TextureType.unpacked,o=(0,i.getGlsl)(e.session.backend.glContext.version);return Object.assign(Object.assign({},t),{output:{dims:r.dims,type:r.type,textureType:a},shaderSource:`\n     ${n.body}\n     void main() {\n       vec4 v = ${o.texture2D}(A, TexCoords);\n       v = ${n.name}_(v);\n       ${o.output} = v;\n     }\n     `,hasMain:!0})})(e,o,t,r)})};t.abs=(e,t)=>[e.run(G(e,t[0],l()),t)],t.acos=(e,t)=>[e.run(G(e,t[0],d()),t)],t.asin=(e,t)=>[e.run(G(e,t[0],u()),t)],t.atan=(e,t)=>[e.run(G(e,t[0],c()),t)],t.clip=(e,t,r)=>[e.run(G(e,t[0],m(r.min,r.max),r.cacheKey),t)],t.parseClipAttributes=e=>(0,n.createAttributeWithCacheKey)({min:e.attributes.getFloat("min",a.MIN_CLIP),max:e.attributes.getFloat("max",a.MAX_CLIP)}),t.clipV11=(e,r)=>{const n=R(e,r);return(0,t.clip)(e,[r[0]],n)};const R=(e,t)=>{if(t.length>=3&&(!e.session.isInitializer(t[1].dataId)||!e.session.isInitializer(t[2].dataId)))throw new Error("dynamic clip attributes are not allowed");const r=t.length>=3?t[1].numberData[0]:a.MIN_CLIP,o=t.length>=3?t[2].numberData[0]:a.MAX_CLIP;return(0,n.createAttributeWithCacheKey)({min:r,max:o})};t.ceil=(e,t)=>[e.run(G(e,t[0],p()),t)],t.cos=(e,t)=>[e.run(G(e,t[0],g()),t)],t.elu=(e,t,r)=>[e.run(G(e,t[0],A(r.alpha),r.cacheKey),t)],t.parseEluAttributes=e=>(0,n.createAttributeWithCacheKey)({alpha:e.attributes.getFloat("alpha",1)}),t.exp=(e,t)=>[e.run(G(e,t[0],h()),t)],t.floor=(e,t)=>[e.run(G(e,t[0],B()),t)],t.identity=(e,t)=>[e.run(G(e,t[0],C()),t)],t.leakyRelu=(e,t,r)=>[e.run(G(e,t[0],w(r.alpha),r.cacheKey),t)],t.parseLeakyReluAttributes=e=>(0,n.createAttributeWithCacheKey)({alpha:e.attributes.getFloat("alpha",.01)}),t.log=(e,t)=>[e.run(G(e,t[0],b()),t)],t.neg=(e,t)=>[e.run(G(e,t[0],K()),t)],t.not=(e,t)=>[e.run(G(e,t[0],f()),t)],t.relu=(e,t)=>[e.run(G(e,t[0],W()),t)],t.sigmoid=(e,t)=>[e.run(G(e,t[0],F()),t)],t.sin=(e,t)=>[e.run(G(e,t[0],Q()),t)],t.sqrt=(e,t)=>[e.run(G(e,t[0],_()),t)],t.tan=(e,t)=>[e.run(G(e,t[0],y()),t)],t.tanh=(e,t)=>[e.run(G(e,t[0],v()),t)]},5611:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createUnpackProgramInfoLoader=t.createUnpackProgramInfo=void 0;const n=r(5060),a=r(2039),o=r(9390),i=r(2827),s={name:"unpack",inputNames:["A"],inputTypes:[a.TextureType.packed]};t.createUnpackProgramInfo=(e,t)=>{const r=t.dims.length,l=(0,i.getChannels)("rc",r),d=l.slice(-2),u=(0,o.getCoordsDataType)(r),c=(0,i.unpackFromChannel)(),p=0===t.dims.length?"":function(e,t){if(1===e)return"rc";let r="";for(let n=0;n<e;n++)r+=t[n],n<e-1&&(r+=",");return r}(r,l),g=r<=1?"rc":`vec2(${d.join(",")})`,A=`\n    ${c}\n    void main() {\n      ${u} rc = getOutputCoords();\n\n       // Sample the texture with the coords to get the rgba channel value.\n       vec4 packedInput = getA(${p});\n\n       ${(0,n.getGlsl)(e.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${g}), 0, 0, 0);\n     }\n   `;return Object.assign(Object.assign({},s),{hasMain:!0,output:{dims:t.dims,type:t.type,textureType:a.TextureType.unpacked},shaderSource:A})},t.createUnpackProgramInfoLoader=(e,r)=>Object.assign(Object.assign({},s),{get:()=>(0,t.createUnpackProgramInfo)(e,r)})},8428:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.parseUnsqueezeAttributes=t.unsqueezeV13=t.unsqueeze=void 0;const n=r(2517);t.unsqueeze=(e,t,r)=>{a(t);const o=n.ShapeUtil.unsqueezeShape(t[0].dims,r);return[e.reshapeUnpacked(t[0],o)]},t.unsqueezeV13=(e,r)=>(o(r),(0,t.unsqueeze)(e,[r[0]],Array.from(r[1].integerData))),t.parseUnsqueezeAttributes=e=>e.attributes.getInts("axes");const a=e=>{if(!e||1!==e.length)throw new Error("Unsqueeze requires 1 input.");if("string"===e[0].type)throw new Error("invalid input tensor types.")},o=e=>{if(!e||2!==e.length)throw new Error("Unsqueeze requires 2 inputs.");if("int32"!==e[1].type)throw new Error("Invalid input type.")}},9793:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.scalesValidation=t.validateInputs=t.parseUpsampleAttributes=t.parseUpsampleAttributesV9=t.parseUpsampleAttributesV7=t.upsample=void 0;const n=r(246),a=r(5060),o=r(2039),i={name:"Upsample",inputNames:["X"],inputTypes:[o.TextureType.unpacked]};t.upsample=(e,r,n)=>((0,t.validateInputs)(r,n),[e.run(Object.assign(Object.assign({},i),{cacheHint:n.cacheKey,get:()=>s(e,r,n)}),r)]),t.parseUpsampleAttributesV7=e=>(0,t.parseUpsampleAttributes)(e,7),t.parseUpsampleAttributesV9=e=>(0,t.parseUpsampleAttributes)(e,9),t.parseUpsampleAttributes=(e,r)=>{const a=r>=10,o=e.attributes.getString("mode","nearest");if("nearest"!==o&&"linear"!==o&&(r<11||"cubic"!==o))throw new Error(`unrecognized mode: ${o}`);let i=[];r<9&&(i=e.attributes.getFloats("scales"),(0,t.scalesValidation)(i,o,a));const s=e.attributes.getFloat("extrapolation_value",0),l=r>10?e.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(-1===["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(l))throw new Error(`coordinate_transform_mode '${l}' is not supported`);const d="tf_crop_and_resize"===l,u=d,c="nearest"===o&&r>=11?e.attributes.getString("nearest_mode","round_prefer_floor"):"";if(-1===["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(c))throw new Error(`nearest_mode '${c}' is not supported`);const p=e.attributes.getFloat("cubic_coeff_a",-.75),g=0!==e.attributes.getInt("exclude_outside",0);if(g&&"cubic"!==o)throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");const A=r<11||"nearest"===o&&"asymmetric"===l&&"floor"===c;let h=0,B=0,m=0;return r>10?e.inputs.length>2?(h=1,B=2,m=3):(B=1,m=2):9===r&&(B=1),(0,n.createAttributeWithCacheKey)({opset:r,isResize:a,mode:o,scales:i,extrapolationValue:s,coordinateTransformMode:l,useExtrapolation:u,needRoiInput:d,nearestMode:c,cubicCoefficientA:p,excludeOutside:g,useNearest2xOptimization:A,roiInputIdx:h,scalesInputIdx:B,sizesInputIdx:m})};const s=(e,t,r)=>{const n=(0,a.getGlsl)(e.session.backend.glContext.version),[s,l]=e.calculateTextureWidthAndHeight(t[0].dims,o.TextureType.unpacked),d=t[0].dims.map(((e,t)=>Math.floor(e*r.scales[t]))),[u,c]=e.calculateTextureWidthAndHeight(d,o.TextureType.unpacked),p=d.length,g=new Array(p),A=new Array(p);let h=`\n      int output_pitches[${p}];\n      int input_pitches[${p}];\n      `;for(let e=p-1;e>=0;e--)g[e]=e===p-1?1:g[e+1]*d[e+1],A[e]=e===p-1?1:A[e+1]*t[0].dims[e+1],h+=`\n        output_pitches[${e}] = ${g[e]};\n        input_pitches[${e}] = ${A[e]};\n        `;const B=`\n      float getInputFloat(int index) {\n        vec2 coords = offsetToCoords(index, ${s}, ${l});\n        float value = getColorAsFloat(${n.texture2D}(X, coords));\n        return value;\n      }\n      `,m="nearest"===r.mode?`\n    ${B}\n    float process(int indices[${p}]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${u}, ${c});\n\n      ${h}\n\n      int d, m;\n      for (int dim = 0; dim < ${p}; ++dim) {\n        d = output_index / output_pitches[dim];\n        m = output_index - d * output_pitches[dim];\n        output_index = m;\n\n        if (scales[dim] != 1 && d > 0) {\n          int d2 = d / scales[dim];\n          m = d - d2 * scales[dim];\n          d = d2;\n        }\n        input_index += input_pitches[dim] * d;\n      }\n\n      return getInputFloat(input_index);\n    }`:4===p?`\n    ${B}\n    float process(int indices[4]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${u}, ${c});\n\n      ${h}\n\n      int m;\n      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m / output_pitches[1];\n      m = m - index_of_dim1 * output_pitches[1];\n      index_of_dim2 = m / output_pitches[2];\n      m = m - index_of_dim2 * output_pitches[2];\n      index_of_dim3 = m;\n\n      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;\n      index_of_input_dim2 = index_of_dim2 / scales[2];\n      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];\n      index_of_input_dim3 = index_of_dim3 / scales[3];\n      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];\n\n      input_index = index_of_dim0 * input_pitches[0] +\n            index_of_dim1 * input_pitches[1] +\n            index_of_input_dim2 * input_pitches[2] +\n            index_of_input_dim3;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim2 = false;\n      if (index_of_input_dim2 == (${t[0].dims[2]} - 1)) {\n        // It's the end in dimension 2\n        x01 = x00;\n        end_of_dim2 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[2]);\n      }\n\n      if (index_of_input_dim3 == (input_pitches[2] - 1)) {\n        // It's the end in dimension 3\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);\n    }`:`\n    ${B}\n    float process(int indices[2]) {\n      int input_index = 0;\n      int output_index = coordsToOffset(TexCoords, ${u}, ${c});\n\n      ${h}\n\n      int m;\n      int index_of_dim0, index_of_dim1;\n      index_of_dim0 = output_index / output_pitches[0];\n      m = output_index - index_of_dim0 * output_pitches[0];\n      index_of_dim1 = m;\n\n      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;\n      index_of_input_dim0 = index_of_dim0 / scales[0];\n      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];\n      index_of_input_dim1 = index_of_dim1 / scales[1];\n      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];\n\n      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;\n\n      float x00 = getInputFloat(input_index);\n      float x10, x01, x11;\n\n      bool end_of_dim0 = false;\n      if (index_of_input_dim0 == (${t[0].dims[0]} - 1)) {\n        // It's the end in dimension 0\n        x01 = x00;\n        end_of_dim0 = true;\n      } else {\n        x01 = getInputFloat(input_index + input_pitches[0]);\n      }\n\n      if (index_of_input_dim1 == (input_pitches[0] - 1)) {\n        // It's the end in dimension 1\n        x10 = x00;\n        x11 = x01;\n      }\n      else {\n        x10 = getInputFloat(input_index + 1);\n        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);\n      }\n\n      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);\n      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);\n      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);\n    }`;return Object.assign(Object.assign({},i),{output:{dims:d,type:t[0].type,textureType:o.TextureType.unpacked},shaderSource:m,variables:[{name:"scales",type:"int",arrayLength:r.scales.length,data:r.scales.map((e=>Math.ceil(e)))}]})};t.validateInputs=(e,t)=>{if(!e||t.opset<9&&1!==e.length||t.opset>=9&&t.opset<11&&2!==e.length||t.opset>=11&&e.length<2)throw new Error("invalid inputs.");if(t.scales.length>0&&e[0].dims.length!==t.scales.length)throw new Error("Invalid input shape.");if("string"===e[0].type)throw new Error("Invalid input tensor types.")},t.scalesValidation=(e,t,r)=>{if(r){for(const t of e)if(t<=0)throw new Error("Scale value should be greater than 0.")}else for(const t of e)if(t<1)throw new Error("Scale value should be greater than or equal to 1.");if(!("linear"!==t&&"cubic"!==t||2===e.length||4===e.length&&1===e[0]&&1===e[1]))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${r?"Resize":"Upsample"} opeartor.`)}},1958:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ProgramManager=void 0;const n=r(1670),a=r(6231),o=r(8879),i=r(5060);t.ProgramManager=class{constructor(e,t,r){this.profiler=e,this.glContext=t,this.textureLayoutStrategy=r,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,t){this.repo.set(e,t)}run(e,t,r){var n;this.profiler.event("op",`ProgramManager.run ${null!==(n=e.programInfo.name)&&void 0!==n?n:"unknown kernel"}`,(()=>{var n;const o=this.glContext.gl,i=e.program;o.useProgram(i);try{this.bindOutput(r),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,null!==(n=e.programInfo.variables)&&void 0!==n?n:[],t)}catch(t){throw a.Logger.error("ProgramManager",e.programInfo.shaderSource),t}this.profiler.event("backend","GlContext.draw()",(()=>{this.glContext.draw()}))}),this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach((e=>this.glContext.deleteProgram(e.program)))}build(e,t,r){return this.profiler.event("backend","ProgramManager.build",(()=>{const n=new o.GlslPreprocessor(this.glContext,e,t,r),a=n.preprocess(),i=this.compile(a);return{programInfo:e,program:i,uniformLocations:this.getUniformLocations(i,n.context.programInfo.inputNames,n.context.programInfo.variables),attribLocations:this.getAttribLocations(i)}}))}compile(e){if(!this.vertexShader){a.Logger.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");const e=(0,i.getVertexShaderSource)(this.glContext.version);this.vertexShader=this.glContext.compileShader(e,this.glContext.gl.VERTEX_SHADER)}n.env.debug&&a.Logger.verbose("ProrgramManager",`FragShader:\n${e}\n`);const t=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),r=this.glContext.createProgram(this.vertexShader,t);return this.glContext.deleteShader(t),r}bindOutput(e){const t=e.width,r=e.height;a.Logger.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${t}/${r}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,t,r)}bindAttributes(e){const t=e.position,r=e.textureCoord;this.glContext.setVertexAttributes(t,r),this.attributesBound=!0}bindUniforms(e,t,r){var n;const a=this.glContext.gl;let o=0;for(const{name:i,type:s,location:l,arrayLength:d}of e){const e=null===(n=t.find((e=>e.name===i)))||void 0===n?void 0:n.data;if("sampler2D"!==s&&!e)throw new Error(`variable '${i}' does not have data defined in program info`);switch(s){case"sampler2D":this.bindTexture(r[o],l,o),o++;break;case"float":d?a.uniform1fv(l,e):a.uniform1f(l,e);break;case"int":d?a.uniform1iv(l,e):a.uniform1i(l,e);break;default:throw new Error(`Uniform not implemented: ${s}`)}}}bindTexture(e,t,r){this.glContext.bindTextureToUniform(e.texture,r,t)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,t,r){const n=[];if(t)for(const r of t)n.push({name:r,type:"sampler2D",location:this.getUniformLocation(e,r)});if(r)for(const t of r)n.push(Object.assign(Object.assign({},t),{location:this.getUniformLocation(e,t.name)}));return n}getUniformLocation(e,t){const r=this.glContext.gl.getUniformLocation(e,t);if(null===r)throw new Error(`Uniform ${t} not found.`);return r}getAttribLocation(e,t){return this.glContext.gl.getAttribLocation(e,t)}}},6416:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLSessionHandler=void 0;const n=r(6231),a=r(1047),o=r(8316),i=r(1640),s=r(1958),l=r(7859),d=r(5702);t.WebGLSessionHandler=class{constructor(e,t){this.backend=e,this.context=t,this.layoutStrategy=new l.PreferLogicalStrategy(e.glContext.maxTextureSize),this.programManager=new s.ProgramManager(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new d.TextureManager(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:"full"===e.textureCacheMode}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new o.WebGLInferenceHandler(this)}onGraphInitialized(e){const t=e.getValues().filter((e=>-1===e.from&&e.tensor)).map((e=>e.tensor.dataId));this.initializers=new Set(t)}isInitializer(e){return!!this.initializers&&this.initializers.has(e)}addInitializer(e){this.initializers.add(e)}getTextureData(e,t){return t?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,t,r=!1){n.Logger.verbose("WebGLSessionHandler","Storing Texture data in cache"),r?this.packedTextureDataCache.set(e,t):this.unpackedTextureDataCache.set(e,t)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach((e=>this.textureManager.releaseTexture(e,!0))),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach((e=>this.textureManager.releaseTexture(e,!0))),this.unpackedTextureDataCache=new Map}resolve(e,t,r){const n=(0,a.resolveOperator)(e,t,i.WEBGL_OP_RESOLVE_RULES);return{impl:n.opImpl,context:n.opInit?n.opInit(e,r):e}}}},7769:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Uint8DataEncoder=t.RGBAFloatDataEncoder=t.RedFloat32DataEncoder=void 0;const n=r(6231);t.RedFloat32DataEncoder=class{constructor(e,t=1){if(1===t)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=t;else{if(4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=t}}encode(e,t){let r,a;return e.constructor!==Float32Array&&(n.Logger.warning("Encoder","data was not of type Float32; creating new Float32Array"),a=new Float32Array(e)),t*this.channelSize>e.length?(n.Logger.warning("Encoder","Source data too small. Allocating larger array"),a=e,r=this.allocate(t*this.channelSize),a.forEach(((e,t)=>r[t]=e))):(a=e,r=a),r}allocate(e){return new Float32Array(4*e)}decode(e,t){return 1===this.channelSize?e.filter(((e,t)=>t%4==0)).subarray(0,t):e.subarray(0,t)}},t.RGBAFloatDataEncoder=class{constructor(e,t=1,r){if(1!==t&&4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=t,this.textureType=r||e.FLOAT}encode(e,t){let r=e;return 1===this.channelSize&&(n.Logger.verbose("Encoder","Exploding into a larger array"),r=this.allocate(t),e.forEach(((e,t)=>r[4*t]=e))),r}allocate(e){return new Float32Array(4*e)}decode(e,t){return 1===this.channelSize?e.filter(((e,t)=>t%4==0)).subarray(0,t):e.subarray(0,t)}},t.Uint8DataEncoder=class{constructor(e,t=1){if(this.channelSize=4,1===t)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=t;else{if(4!==t)throw new Error(`Invalid number of channels: ${t}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=t}}encode(e,t){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,t){if(e instanceof Uint8Array)return e.subarray(0,t);throw new Error(`Invalid array type: ${e.constructor}`)}}},7859:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getBatchDim=t.sizeToSquarishShape=t.getRowsCols=t.sizeFromShape=t.isInt=t.parseAxisParam=t.squeezeShape=t.PreferLogicalStrategy=t.AlwaysKeepOriginalSizeStrategy=void 0;const n=r(6231),a=r(2517);function o(e,t){const r=[],n=[],a=null!=t&&Array.isArray(t)&&0===t.length,o=null==t||a?null:i(t,e).sort();let s=0;for(let t=0;t<e.length;++t){if(null!=o){if(o[s]===t&&1!==e[t])throw new Error(`Can't squeeze axis ${t} since its dim '${e[t]}' is not 1`);(null==o[s]||o[s]>t)&&1===e[t]&&(r.push(e[t]),n.push(t)),o[s]<=t&&s++}1!==e[t]&&(r.push(e[t]),n.push(t))}return{newShape:r,keptDims:n}}function i(e,t){const r=t.length;return e=null==e?t.map(((e,t)=>t)):[].concat(e),(0,a.assert)(e.every((e=>e>=-r&&e<r)),(()=>`All values in axis param must be in range [-${r}, ${r}) but got axis ${e}`)),(0,a.assert)(e.every(s),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?r+e:e))}function s(e){return e%1==0}function l(e){if(0===e.length)return 1;let t=e[0];for(let r=1;r<e.length;r++)t*=e[r];return t}function d(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}t.AlwaysKeepOriginalSizeStrategy=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,t){if(0===e.length)return[1,1];const r=this.maxTextureSize;if(t&&void 0!==t.breakAxis){const a=t.breakAxis>=e.length?1:e.slice(t.breakAxis).reduce(((e,t)=>e*t)),o=t.breakAxis<=0?1:e.slice(0,t.breakAxis).reduce(((e,t)=>e*t));if(!(a>r||o>r))return[a,o];n.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`)}const a=e.reduce(((e,t)=>e*t));let o=Math.floor(Math.sqrt(a));for(;o<r&&o<a&&a%o!=0;o++);if(o>=r||a%o!=0)throw new Error(`The given dimensions are outside this GPU's boundaries: ${e}`);return[o,a/o]}},t.PreferLogicalStrategy=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,t){const r=this.computeTexture(e,t);return t&&t.isPacked&&(r[0]/=2,r[1]/=2),t&&t.reverseWH?[r[1],r[0]]:r}computeTexture(e,t){const r=t&&t.isPacked;if(0===e.length)return r?[2,2]:[1,1];let a=this.maxTextureSize;if(t&&void 0!==t.breakAxis){const r=t.breakAxis>=e.length?1:e.slice(t.breakAxis).reduce(((e,t)=>e*t)),o=t.breakAxis<=0?1:e.slice(0,t.breakAxis).reduce(((e,t)=>e*t));if(!(r>a||o>a))return[r,o];n.Logger.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${t.breakAxis}`)}let i=e.slice(0);if(r&&(a*=2,i=i.map(((e,t)=>t>=i.length-2?i[t]%2==0?i[t]:i[t]+1:i[t])),1===i.length&&(i=[2,i[0]])),2!==i.length){const e=o(i);i=e.newShape}const s=l(i);return i.length<=1&&s<=a?[1,s]:2===i.length&&i[0]<=a&&i[1]<=a?i:3===i.length&&i[0]*i[1]<=a&&i[2]<=a?[i[0]*i[1],i[2]]:3===i.length&&i[0]<=a&&i[1]*i[2]<=a?[i[0],i[1]*i[2]]:4===i.length&&i[0]*i[1]*i[2]<=a&&i[3]<=a?[i[0]*i[1]*i[2],i[3]]:4===i.length&&i[0]<=a&&i[1]*i[2]*i[3]<=a?[i[0],i[1]*i[2]*i[3]]:r?d(s/4).map((e=>2*e)):d(s)}},t.squeezeShape=o,t.parseAxisParam=i,t.isInt=s,t.sizeFromShape=l,t.getRowsCols=function(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]},t.sizeToSquarishShape=d,t.getBatchDim=function(e,t=2){return l(e.slice(0,e.length-t))}},4057:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createTextureLayoutFromShape=t.calculateTextureWidthAndHeight=t.createTextureLayoutFromTextureType=void 0;const n=r(2517),a=r(2039);t.createTextureLayoutFromTextureType=(e,r,n)=>{const o=n===a.TextureType.unpacked||n===a.TextureType.unpackedReversed?1:4,i=n===a.TextureType.packed,s=n===a.TextureType.unpackedReversed||n===a.TextureType.packed,l=n===a.TextureType.packedLastDimension?r.length-1:void 0,d=n===a.TextureType.packedLastDimension?r.map(((e,t)=>t===r.length-1?4*e:e)):void 0;return(0,t.createTextureLayoutFromShape)(e,r,o,d,{isPacked:i,reverseWH:s,breakAxis:l})},t.calculateTextureWidthAndHeight=(e,r,n)=>{const a=(0,t.createTextureLayoutFromTextureType)(e,r,n);return[a.width,a.height]},t.createTextureLayoutFromShape=(e,t,r=1,a,o)=>{const i=!(!o||!o.isPacked),[s,l]=e.computeTextureWH(i&&a||t,o),d=t.length;let u=t.slice(0);if(0===d&&(u=[1]),1===r)a=t;else if(i){if(4!==r)throw new Error("a packed texture must be 4-channel");a=t,d>0&&(u[d-1]=Math.ceil(u[d-1]/2)),d>1&&(u[d-2]=Math.ceil(u[d-2]/2))}else if(!a)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:l,channels:r,isPacked:i,shape:u,strides:n.ShapeUtil.computeStrides(u),unpackedShape:a,reversedWH:o&&o.reverseWH}}},5702:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TextureManager=void 0;const n=r(6231);t.TextureManager=class{constructor(e,t,r,n){this.glContext=e,this.layoutStrategy=t,this.profiler=r,this.config=n,this.pendingRead=new Map,n.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,t,r,a){const o=this.toEncoderType(e),i=this.glContext.getEncoder(o,t.channels||1,a);if(t.isPacked&&1===a)throw new Error("not implemented");const s=t.width,l=t.height;let d,u;if(this.config.reuseTextures){d=`${s}x${l}_${i.format}_${i.internalFormat}_${i.textureType}`,u=this.inUseTextures.get(d),u||(u=[],this.inUseTextures.set(d,u));const t=this.idleTextures.get(d);if(t&&t.length>0){const n=t.pop();return u.push(n),1===a&&this.glContext.updateTexture(n,s,l,i,this.toTextureData(e,r)),n}}n.Logger.verbose("TextureManager",`Creating new texture of size ${t.width}x${t.height}`);const c=this.glContext.allocateTexture(s,l,i,this.toTextureData(e,r));return this.config.reuseTextures&&(u.push(c),this.textureLookup.set(c,d)),c}readTexture(e,t,r){return r||(r=1),this.profiler.event("backend","TextureManager.readTexture",(()=>{const n=e.shape.reduce(((e,t)=>e*t))*r,a=this.glContext.readTexture(e.texture,e.width,e.height,n,this.toEncoderType(t),r);return this.toTensorData(t,a)}))}async readTextureAsync(e,t,r){const n=e.tensor.dataId;if(r||(r=1),this.pendingRead.has(n)){const e=this.pendingRead.get(n);return new Promise((t=>null==e?void 0:e.push(t)))}return this.profiler.event("backend","TextureManager.readTextureAsync",(async()=>{this.pendingRead.set(n,[]);const a=e.shape.reduce(((e,t)=>e*t))*r;await this.glContext.createAndWaitForFence();const o=this.glContext.readTexture(e.texture,e.width,e.height,a,this.toEncoderType(t),r),i=this.toTensorData(t,o),s=this.pendingRead.get(n);return this.pendingRead.delete(n),null==s||s.forEach((e=>e(i))),i}))}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",(()=>{const t=e.shape.reduce(((e,t)=>e*t)),r=this.glContext.readTexture(e.texture,e.width,e.height,4*t,"byte",4);return new Float32Array(r.buffer,r.byteOffset,t)}))}releaseTexture(e,t){let r;if(this.config.reuseTextures&&(r=this.textureLookup.get(e.texture),r)){t&&this.textureLookup.delete(r);const n=this.inUseTextures.get(r);if(n){const t=n.indexOf(e.texture);if(-1!==t){n.splice(t,1);let a=this.idleTextures.get(r);a||(a=[],this.idleTextures.set(r,a)),a.push(e.texture)}}}r&&!t||(n.Logger.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,t){switch(e){case"int16":return t instanceof Int16Array?t:Int16Array.from(t);case"int32":return t instanceof Int32Array?t:Int32Array.from(t);case"int8":return t instanceof Int8Array?t:Int8Array.from(t);case"uint16":return t instanceof Uint16Array?t:Uint16Array.from(t);case"uint32":return t instanceof Uint32Array?t:Uint32Array.from(t);case"uint8":case"bool":return t instanceof Uint8Array?t:Uint8Array.from(t);case"float32":return t instanceof Float32Array?t:Float32Array.from(t);case"float64":return t instanceof Float64Array?t:Float64Array.from(t);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,t){if(t)return t instanceof Float32Array?t:new Float32Array(t)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}},2039:(e,t)=>{var r;Object.defineProperty(t,"__esModule",{value:!0}),t.TextureType=void 0,(r=t.TextureType||(t.TextureType={}))[r.unpacked=0]="unpacked",r[r.unpackedReversed=1]="unpackedReversed",r[r.packed=2]="packed",r[r.downloadUint8AsFloat=3]="downloadUint8AsFloat",r[r.packedLastDimension=4]="packedLastDimension"},9390:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.getGlChannels=t.getCoordsDataType=t.getSqueezedParams=t.squeezeInputShape=t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=t.generateShaderFuncNameFromInputSamplerName=t.repeatedTry=t.getPackedShape=void 0;const n=r(2517);t.getPackedShape=function(e){const t=e.length;return e.slice(0,t-1).concat(e[t-1]/4)},t.repeatedTry=async function(e,t=e=>0,r){return new Promise(((n,a)=>{let o=0;const i=()=>{if(e())return void n();o++;const s=t(o);null!=r&&o>=r?a():setTimeout(i,s)};i()}))},t.generateShaderFuncNameFromInputSamplerName=function(e){return(0,n.assert)(void 0!==e&&0!==e.length,(()=>"empty string found for sampler name")),"get"+e.charAt(0).toUpperCase()+e.slice(1)},t.generateShaderFuncNameFromInputSamplerNameAtOutCoords=function(e){return(0,n.assert)(void 0!==e&&0!==e.length,(()=>"empty string found for sampler name")),"get"+e.charAt(0).toUpperCase()+e.slice(1)+"AtOutCoords"},t.squeezeInputShape=function(e,t){let r=JSON.parse(JSON.stringify(e));return r=t,r},t.getSqueezedParams=function(e,t){return t.map((t=>e[t])).join(", ")},t.getCoordsDataType=function(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)},t.getGlChannels=function(e=6){return["x","y","z","w","u","v"].slice(0,e)}},7305:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.createNewWebGLContext=t.createWebGLContext=void 0;const n=r(6231),a=r(1713),o={};function i(e){const t=function(){if("undefined"==typeof document){if("undefined"==typeof OffscreenCanvas)throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}const e=document.createElement("canvas");return e.width=1,e.height=1,e}();let r;const o={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1};if((!e||"webgl2"===e)&&(r=t.getContext("webgl2",o),r))try{return new a.WebGLContext(r,2)}catch(e){n.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${e}`)}if((!e||"webgl"===e)&&(r=t.getContext("webgl",o)||t.getContext("experimental-webgl",o),r))try{return new a.WebGLContext(r,1)}catch(e){n.Logger.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${e}`)}throw new Error("WebGL is not supported")}t.createWebGLContext=function e(t){let r;t&&"webgl2"!==t||!("webgl2"in o)?t&&"webgl"!==t||!("webgl"in o)||(r=o.webgl):r=o.webgl2,r=r||i(t),t=t||1===r.version?"webgl":"webgl2";const n=r.gl;return o[t]=r,n.isContextLost()?(delete o[t],e(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),r)},t.createNewWebGLContext=i},1713:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.WebGLContext=t.linearSearchLastTrue=void 0;const i=r(1670),s=o(r(7769)),l=r(9390);function d(e){let t=0;for(;t<e.length&&e[t]();++t);return t-1}t.linearSearchLastTrue=d,t.WebGLContext=class{constructor(e,t){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=e,this.version=t,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,t,r,n){const a=this.gl,o=a.createTexture();a.bindTexture(a.TEXTURE_2D,o),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE);const i=n?r.encode(n,e*t):null;return a.texImage2D(a.TEXTURE_2D,0,r.internalFormat,e,t,0,r.format,r.textureType,i),this.checkError(),o}updateTexture(e,t,r,n,a){const o=this.gl;o.bindTexture(o.TEXTURE_2D,e);const i=n.encode(a,t*r);o.texSubImage2D(o.TEXTURE_2D,0,0,0,t,r,n.format,n.textureType,i),this.checkError()}attachFramebuffer(e,t,r){const n=this.gl;n.bindTexture(n.TEXTURE_2D,e),n.bindFramebuffer(n.FRAMEBUFFER,this.framebuffer),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0),this.checkError(),n.viewport(0,0,t,r),n.scissor(0,0,t,r)}readTexture(e,t,r,n,a,o){const i=this.gl;o||(o=1),this.frameBufferBound||this.attachFramebuffer(e,t,r);const s=this.getEncoder(a,o),l=s.allocate(t*r);return i.bindTexture(i.TEXTURE_2D,e),i.framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,e,0),i.readPixels(0,0,t,r,i.RGBA,s.textureType,l),this.checkError(),s.decode(l,n)}isFramebufferReady(){return!0}getActiveTexture(){const e=this.gl;return"TEXTURE"+(e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0)}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,t){const r=this.gl;r.vertexAttribPointer(e,3,r.FLOAT,!1,20,0),r.enableVertexAttribArray(e),-1!==t&&(r.vertexAttribPointer(t,2,r.FLOAT,!1,20,12),r.enableVertexAttribArray(t)),this.checkError()}createProgram(e,t){const r=this.gl,n=r.createProgram();return r.attachShader(n,e),r.attachShader(n,t),r.linkProgram(n),n}compileShader(e,t){const r=this.gl,n=r.createShader(t);if(!n)throw new Error(`createShader() returned null with type ${t}`);if(r.shaderSource(n,e),r.compileShader(n),!1===r.getShaderParameter(n,r.COMPILE_STATUS))throw new Error(`Failed to compile shader: ${r.getShaderInfoLog(n)}\nShader source:\n${e}`);return n}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,t,r){const n=this.gl;n.activeTexture(n.TEXTURE0+t),this.checkError(),n.bindTexture(n.TEXTURE_2D,e),this.checkError(),n.uniform1i(r,t),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(i.env.debug){const e=this.gl,t=e.getError();let r="";switch(t){case e.NO_ERROR:return;case e.INVALID_ENUM:r="INVALID_ENUM";break;case e.INVALID_VALUE:r="INVALID_VALUE";break;case e.INVALID_OPERATION:r="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:r="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:r="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:r="CONTEXT_LOST_WEBGL";break;default:r=`Unknown WebGL Error: ${t.toString(16)}`}throw new Error(r)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,t,r=0){if(2===this.version)return new s.RedFloat32DataEncoder(this.gl,t);switch(e){case"float":return 1===r||this.isRenderFloat32Supported?new s.RGBAFloatDataEncoder(this.gl,t):new s.RGBAFloatDataEncoder(this.gl,t,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new s.Uint8DataEncoder(this.gl,t);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){const e=this.gl;for(let t=0;t<this.maxTextureImageUnits;++t)e.activeTexture(e.TEXTURE0+t),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;const e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){const e=this.gl,t=e.createBuffer();if(!t)throw new Error("createBuffer() returned null");const r=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,t),e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW),this.checkError(),t}createFramebuffer(){const e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){const e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),1===this.version&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){2===this.version?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){const e=this.gl,t=e.createTexture();e.bindTexture(e.TEXTURE_2D,t);const r=2===this.version?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,r,1,1,0,e.RGBA,e.FLOAT,null);const n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(t),e.deleteFramebuffer(n),a}checkRenderFloat32(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(2===this.version){if(!this.colorBufferFloatExtension)return!1}else{if(!this.textureFloatExtension)return!1;if(!this.gl.getExtension("WEBGL_color_buffer_float"))return!1}return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){const e=this.gl;let t,r,n,a,o;try{t=e.createTexture(),r=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,t);const i=2===this.version?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,i,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0),e.enable(e.BLEND),n=e.createShader(e.VERTEX_SHADER),!!n&&(e.shaderSource(n,"void main(){}"),e.compileShader(n),a=e.createShader(e.FRAGMENT_SHADER),!!a&&(e.shaderSource(a,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(a),o=e.createProgram(),!!o&&(e.attachShader(o,n),e.attachShader(o,a),e.linkProgram(o),e.useProgram(o),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)))}finally{e.disable(e.BLEND),o&&e.deleteProgram(o),n&&e.deleteShader(n),a&&e.deleteShader(a),r&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(r)),t&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(t))}}beginTimer(){if(2===this.version&&this.disjointTimerQueryWebgl2Extension){const e=this.gl,t=this.disjointTimerQueryWebgl2Extension,r=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,r),r}throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const e=this.gl,t=this.disjointTimerQueryWebgl2Extension;e.endQuery(t.TIME_ELAPSED_EXT)}}isTimerResultAvailable(e){let t=!1,r=!1;if(2!==this.version||!this.disjointTimerQueryWebgl2Extension)throw new Error("WebGL1 profiling currently not supported");{const n=this.gl,a=this.disjointTimerQueryWebgl2Extension;t=n.getQueryParameter(e,n.QUERY_RESULT_AVAILABLE),r=n.getParameter(a.GPU_DISJOINT_EXT)}return t&&!r}getTimerResult(e){let t=0;if(2!==this.version)throw new Error("WebGL1 profiling currently not supported");{const r=this.gl;t=r.getQueryParameter(e,r.QUERY_RESULT),r.deleteQuery(e)}return t/1e6}async waitForQueryAndGetTime(e){return await(0,l.repeatedTry)((()=>this.isTimerResultAvailable(e))),this.getTimerResult(e)}async createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t;const r=e,n=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),t=null===n?()=>!0:()=>{const e=r.clientWaitSync(n,0,0);return e===r.ALREADY_SIGNALED||e===r.CONDITION_SATISFIED},{query:n,isFencePassed:t}}async pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=d(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1||await(0,l.repeatedTry)((()=>(this.pollItems(),0===this.itemsToPoll.length)))}}},1036:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.ExecutionPlan=void 0;const n=r(6231);class a{constructor(e,t){this.op=e,this.node=t}}t.ExecutionPlan=class{constructor(e,t,r){this.graph=e,this.profiler=r,this.initialize(t)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",(()=>{const t=this.graph.getNodes();if(t.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map(((e,r)=>new a(e,t[r]))),this.reset(),this._starter=[],this._ops.forEach(((e,t)=>{let r=!0;for(const t of e.node.inputs)if(!this._values[t]&&-1===this.graph.getInputIndices().indexOf(t)){r=!1;break}r&&this._starter.push(t)}))}))}reset(){this._values=this.graph.getValues().map((e=>e.tensor))}async execute(e,t){return this.profiler.event("session","ExecutionPlan.execute",(async()=>{this.reset();const r=e.createInferenceHandler(),a=this.graph.getInputIndices();if(t.length!==a.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${t.length} expected: ${a.length}`);t.forEach(((e,t)=>{const r=a[t];this._values[r]=e}));const o=this._starter.slice(0),i=this.graph.getValues(),s=this.graph.getNodes();let l=0;for(;l<o.length;){const e=o[l++],t=this._ops[e],a=t.node.inputs.map((e=>this._values[e]));if(-1!==a.indexOf(void 0))throw new Error(`unresolved input detected: op: ${t.node}`);const d=a;n.Logger.verbose("ExecPlan",`Runing op:${t.node.name} (${d.map(((e,r)=>`'${t.node.inputs[r]}': ${e.type}[${e.dims.join(",")}]`)).join(", ")})`);const u=await this.profiler.event("node",t.node.name,(async()=>t.op.impl(r,d,t.op.context)));if(u.length!==t.node.outputs.length)throw new Error("the size of output does not match model definition.");u.forEach(((e,r)=>{const n=t.node.outputs[r];if(this._values[n])throw new Error(`output [${n}] already has value: op:${t.node.name}`);this._values[n]=e}));const c=new Set;u.forEach(((e,r)=>{const n=t.node.outputs[r];for(const e of i[n].to){const t=s[e];let r=!0;for(const e of t.inputs)if(!this._values[e]){r=!1;break}r&&c.add(e)}})),o.push(...c)}const d=[];for(let e=0;e<this.graph.getOutputIndices().length;e++){const t=this.graph.getOutputIndices()[e],r=this._values[t];if(void 0===r)throw new Error(`required output [${t}] does not have value`);0===t?await r.getData():r.data,d.push(r)}return n.Logger.verbose("ExecPlan","disposing of inferenceHandler"),r.dispose(),d}))}}},7070:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Graph=void 0;const n=r(1446),a=r(7778),o=r(9395),i=r(9162),s=r(2517);var l=o.onnxruntime.experimental.fbs;t.Graph={from:(e,t)=>new c(e,t)};class d{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=s.ProtoUtil.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}}class u{constructor(e,t){e instanceof n.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new a.Attribute(e.attribute)):e instanceof l.Node&&(this.name=null!=t?t:e.name(),this.opType=e.opType(),this.attributes=new a.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}}class c{constructor(e,t){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(t),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof n.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else{if(!(e instanceof l.Graph))throw new TypeError("Graph type is not supported.");this.buildGraphFromOrtFormat(e)}}buildGraphFromOnnxFormat(e){const t=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const r=new Map;if(!e.input)throw new Error("missing information in graph: input");const n=[];for(const r of e.input){if(t.has(r.name))throw new Error(`duplicated input name: ${r.name}`);const e=this._allData.push(new d(r))-1;t.set(r.name,e),n.push(r.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(const r of e.initializer){let e=t.get(r.name);if(void 0===e){const n=new d;n.type={shape:{dims:s.ProtoUtil.tensorDimsFromProto(r.dims)},tensorType:s.ProtoUtil.tensorDataTypeFromProto(r.dataType)},e=this._allData.push(n)-1,t.set(r.name,e)}this._allData[e]._from=-1,this._allData[e].tensor=i.Tensor.fromProto(r)}for(let e=0;e<this._allData.length;e++)this._allData[e].tensor||(this._allInputIndices.push(e),this._allInputNames.push(n[e]));if(!e.output)throw new Error("missing information in graph: output");for(const r of e.output){if(t.has(r.name))throw new Error(`duplicated output name: ${r.name}`);const e=this._allData.push(new d(r))-1;t.set(r.name,e),this._allOutputIndices.push(e),this._allOutputNames.push(r.name)}if(!e.node)throw new Error("missing information in graph: node");for(const t of e.node){if(!t.name)for(let e=0;;e++){const n=`unnamed_${t.opType}_${e}`;if(!r.has(n)){t.name=n;break}}if(r.has(t.name))throw new Error(`duplicated node name: ${t.name}`);const e=this._nodes.push(new u(t))-1;r.set(t.name,e)}for(let r=0;r<this._nodes.length;r++){const n=this._nodes[r],a=e.node[r];if(!a.output)throw new Error(`missing output for node: ${a.name}`);for(const e of a.output){let o=t.get(e);if(void 0===o&&(o=this._allData.push(new d)-1,t.set(e,o)),n.outputs.push(o),void 0!==this._allData[o]._from)throw new Error(`multiple nodes output to one data value: ${o}`);if(this._allData[o]._from=r,"Constant"===a.opType){if(!a.attribute||1!==a.attribute.length||!a.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!a.output||1!==a.output.length)throw new Error("missing output or incorrect number of outputs for this Constant operator");n.outputs.pop(),n.executeNode=!1,this._allData[o]._from=-1,this._allData[o].tensor=i.Tensor.fromProto(a.attribute[0].t)}}}for(let r=0;r<this._nodes.length;r++){const n=this._nodes[r],a=e.node[r];if(!a.input)throw new Error(`missing input for node: ${a.name}`);for(const e of a.input){const o=t.get(e);if(void 0===o){if(""===e&&3===a.input.length&&"Resize"===a.opType)continue;throw new Error(`unrecognized input '${e}' for node: ${a.name}`)}n.inputs.push(o),this._allData[o]._to.push(r)}}return!0}buildGraphFromOrtFormat(e){var t,r,n;const a=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];const o=new Map,c=[];for(let o=0;o<e.inputsLength();o++){const i=e.inputs(o);if(a.has(i))throw new Error(`duplicated input name: ${i}`);for(let o=0;o<e.nodeArgsLength();o++)if((null===(t=e.nodeArgs(o))||void 0===t?void 0:t.name())===i){const t=new d;if((null===(n=null===(r=e.nodeArgs(o))||void 0===r?void 0:r.type())||void 0===n?void 0:n.valueType())!==l.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");const u=e.nodeArgs(o).type().value(new l.TensorTypeAndShape),p=s.ProtoUtil.tensorDataTypeFromProto(u.elemType()),g=u.shape(),A=[];for(let e=0;e<g.dimLength();e++)A.push(s.LongUtil.longToNumber(g.dim(e).value().dimValue()));t.type={shape:{dims:A},tensorType:p};const h=this._allData.push(t)-1;a.set(i,h),c.push(i)}}for(let t=0;t<e.initializersLength();t++){const r=e.initializers(t);let n=a.get(r.name());if(void 0===n){const e=new d,t=s.ProtoUtil.tensorDimsFromORTFormat(r),o=s.ProtoUtil.tensorDataTypeFromProto(r.dataType());e.type={shape:{dims:t},tensorType:o},n=this._allData.push(e)-1,a.set(r.name(),n)}this._allData[n]._from=-1,this._allData[n].tensor=i.Tensor.fromOrtTensor(r)}for(let e=0;e<this._allData.length;e++)this._allData[e].tensor||(this._allInputIndices.push(e),this._allInputNames.push(c[e]));for(let t=0;t<e.outputsLength();t++){const r=e.outputs(t);if(a.has(r))throw new Error(`duplicated output name: ${r}`);const n=this._allData.push(new d)-1;a.set(r,n),this._allOutputIndices.push(n),this._allOutputNames.push(r)}if(!e.nodes)throw new Error("missing information in graph: node");for(let t=0;t<e.nodesLength();t++){const r=e.nodes(t);let n=r.name();if(!n)for(let e=0;n=`unnamed_${r.opType()}_${e}`,o.has(n);e++);if(o.has(n))throw new Error(`duplicated node name: ${n}`);const a=this._nodes.push(new u(r,n))-1;o.set(n,a)}for(let t=0;t<this._nodes.length;t++){const r=this._nodes[t],n=e.nodes(t);if(null==n)throw new Error(`No node exists at index ${t}`);if(0===(null==n?void 0:n.outputsLength()))throw new Error(`missing output for node: ${n.name}`);for(let e=0;e<(null==n?void 0:n.outputsLength());e++){const o=null==n?void 0:n.outputs(e);let s=a.get(o);if(void 0===s&&(s=this._allData.push(new d)-1,a.set(o,s)),r.outputs.push(s),void 0!==this._allData[s]._from)throw new Error(`multiple nodes output to one data value: ${s}`);if(this._allData[s]._from=t,"Constant"===n.opType()){if(1!==n.attributesLength()||!n.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(1!==n.outputsLength())throw new Error("missing output or incorrect number of outputs for this Constant operator");r.outputs.pop(),r.executeNode=!1,this._allData[s]._from=-1,this._allData[s].tensor=i.Tensor.fromOrtTensor(n.attributes(0).t())}}}for(let t=0;t<this._nodes.length;t++){const r=this._nodes[t],n=e.nodes(t);if(0===n.inputsLength())throw new Error(`missing input for node: ${n.name}`);for(let e=0;e<n.inputsLength();e++){const o=n.inputs(e),i=a.get(o);if(void 0===i)throw new Error(`unrecognized input '${o}' for node: ${n.name()}`);r.inputs.push(i),this._allData[i]._to.push(t)}}}checkIsAcyclic(){const e=new Set;this._allInputIndices.forEach((t=>{this._allData[t]._to.forEach((t=>{e.add(t)}))}));const t=Array.from(e),r=new Array(this._nodes.length).fill("white");for(;t.length>0;){const e=t.pop();"gray"===r[e]?r[e]="black":(t.push(e),r[e]="gray",this._nodes[e].outputs.forEach((n=>{const a=this._allData[n];if(void 0!==a.tensor)throw new Error("node outputs should not be initialized");if(a._from!==e)throw new Error("from property of the Value object doesn't match index of Node being processed");a._to.forEach((e=>{if("gray"===r[e])throw new Error("model graph is cyclic");"white"===r[e]&&t.push(e)}))})))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0;for(let t=0;t<this._nodes.length;t++)this._nodes[t].executeNode?e>0&&(this._nodes[t].inputs.forEach((r=>{const n=this._allData[r]._to.indexOf(t+e);-1!==n&&(this._allData[r]._to[n]=t)})),this._nodes[t].outputs.forEach((r=>{this._allData[r]._from&&this._allData[r]._from===t+e&&(this._allData[r]._from=t)}))):(e++,this._nodes[t].outputs.forEach((e=>{this._allData[e]._from=-2})),this._nodes.splice(t,1),t--);e=0;for(let t=0;t<this._allData.length;t++)if(-2!==this._allData[t].from||-1!==this._allOutputIndices.indexOf(t+e)){if(e>0){let r=-1;void 0!==this._allData[t].from&&-1!==this._allData[t].from?(r=this._nodes[this._allData[t].from].outputs.indexOf(t+e),-1!==r&&(this._nodes[this._allData[t].from].outputs[r]=t)):(r=this._allInputIndices.indexOf(t+e),-1!==r&&(this._allInputIndices[r]=t)),this._allData[t].to.forEach((n=>{r=this._nodes[n].inputs.indexOf(t+e),-1!==r&&(this._nodes[n].inputs[r]=t)})),0===this._allData[t].to.length&&(r=this._allOutputIndices.indexOf(t+e),-1!==r&&(this._allOutputIndices[r]=t))}}else e++,this._allData.splice(t,1),t--}deleteNode(e){const t=this._nodes[e];if(t.outputs.length>1)for(let e=1;e<t.outputs.length;e++)if(this._allData[t.outputs[e]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");t.executeNode=!1;const r=t.inputs[0],n=t.outputs[0],a=this._allData[n].to,o=this._allData[r].to.indexOf(e);if(-1===o)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[r].to.splice(o,1),this._allData[n]._to=[];const i=this._allOutputIndices.indexOf(n);if(-1!==i&&(this._allOutputIndices[i]=r),a&&a.length>0)for(const e of a){const t=this._nodes[e].inputs.indexOf(n);if(-1===t)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[e].inputs[t]=r,this._allData[r].to.push(e)}}removeAllDropoutNodes(){let e=0;for(const t of this._nodes){if("Dropout"===t.opType){if(1!==t.inputs.length)throw new Error("Dropout nodes should only contain one input. ");if(1!==t.outputs.length&&2!==t.outputs.length)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(2===t.outputs.length&&0!==this._allData[t.outputs[1]]._to.length)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(const t of this._nodes)"Identity"===t.opType&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(const e of this._nodes)if("Conv"===e.opType){const t=this._allData[e.outputs[0]]._to;if(1===t.length&&this.isActivation(this._nodes[t[0]])){const r=this._nodes[t[0]];if("Clip"===r.opType)if(1===r.inputs.length)try{e.attributes.set("activation_params","floats",[r.attributes.getFloat("min"),r.attributes.getFloat("max")])}catch(t){e.attributes.set("activation_params","floats",[s.MIN_CLIP,s.MAX_CLIP])}else{if(!(r.inputs.length>=3&&void 0!==this._allData[r.inputs[1]].tensor&&void 0!==this._allData[r.inputs[2]].tensor))continue;e.attributes.set("activation_params","floats",[this._allData[r.inputs[1]].tensor.floatData[0],this._allData[r.inputs[2]].tensor.floatData[0]])}e.attributes.set("activation","string",r.opType),this.deleteNode(t[0])}}}}},6231:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.now=t.Profiler=t.Logger=void 0;const r={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},n={none:new class{log(e,t,r){}},console:new class{log(e,t,r){console.log(`${this.color(e)} ${r?"[35m"+r+"[0m ":""}${t}`)}color(e){switch(e){case"verbose":return"[34;40mv[0m";case"info":return"[32mi[0m";case"warning":return"[30;43mw[0m";case"error":return"[31;40me[0m";case"fatal":return"[101mf[0m";default:throw new Error(`unsupported severity: ${e}`)}}}},a={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1};let o={"":a};function i(e,t,r,n){if(void 0===t)return a=e,{verbose:i.verbose.bind(null,a),info:i.info.bind(null,a),warning:i.warning.bind(null,a),error:i.error.bind(null,a),fatal:i.fatal.bind(null,a)};if(void 0===r)s(e,t);else if("number"==typeof r&&void 0===n)s(e,t);else if("string"==typeof r&&void 0===n)s(e,r,0,t);else{if("string"!=typeof r||"number"!=typeof n)throw new TypeError("input is valid");s(e,r,0,t)}var a}function s(e,t,a,i){const s=o[i||""]||o[""];r[e]<r[s.minimalSeverity]||(s.logDateTime&&(t=`${(new Date).toISOString()}|${t}`),s.logSourceLocation,n[s.provider].log(e,t,i))}!function(e){function t(e){o={},r("",e||{})}function r(e,r){if("*"===e)t(r);else{const t=o[e]||a;o[e]={provider:r.provider||t.provider,minimalSeverity:r.minimalSeverity||t.minimalSeverity,logDateTime:void 0===r.logDateTime?t.logDateTime:r.logDateTime,logSourceLocation:void 0===r.logSourceLocation?t.logSourceLocation:r.logSourceLocation}}}e.verbose=function(t,r){e("verbose",t,r)},e.info=function(t,r){e("info",t,r)},e.warning=function(t,r){e("warning",t,r)},e.error=function(t,r){e("error",t,r)},e.fatal=function(t,r){e("fatal",t,r)},e.reset=t,e.set=r,e.setWithEnv=function(e){const t={};e.logLevel&&(t.minimalSeverity=e.logLevel),r("",t)}}(i||(i={})),t.Logger=i;class l{constructor(e,t,r,n,a,o){this.category=e,this.name=t,this.startTime=r,this.endCallback=n,this.timer=a,this.ctx=o}end(){return this.endCallback(this)}async checkTimer(){if(void 0===this.ctx||void 0===this.timer)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}}class d{constructor(e,t,r,n){this.category=e,this.name=t,this.startTime=r,this.endTime=n}}t.Profiler=class{static create(e){return void 0===e?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}constructor(e,t,r){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=void 0===e?1e4:e,this._flushBatchSize=void 0===t?10:t,this._flushIntervalInMilliseconds=void 0===r?5e3:r}start(){this._started=!0,this._timingEvents=[],this._flushTime=(0,t.now)(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,t,r,n){const a=this._started?this.begin(e,t,n):void 0;let o=!1;const i=r();if(i&&"function"==typeof i.then)return o=!0,new Promise(((e,t)=>{i.then((async t=>{a&&await a.end(),e(t)}),(async e=>{a&&await a.end(),t(e)}))}));if(!o&&a){const e=a.end();if(e&&"function"==typeof e.then)return new Promise(((t,r)=>{e.then((()=>{t(i)}),(e=>{r(e)}))}))}return i}begin(e,r,n){if(!this._started)throw new Error("profiler is not started yet");if(void 0===n){const n=(0,t.now)();return this.flush(n),new l(e,r,n,(e=>this.endSync(e)))}{const t=n.beginTimer();return new l(e,r,0,(async e=>this.end(e)),t,n)}}async end(e){const t=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new d(e.category,e.name,e.startTime,t)),this.flush(t))}endSync(e){const r=(0,t.now)();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new d(e.category,e.name,e.startTime,r)),this.flush(r))}logOneEvent(e){t.Logger.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(const e=this._flushPointer;this._flushPointer<e+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=(0,t.now)()}}get started(){return this._started}},t.now="undefined"!=typeof performance&&performance.now?()=>performance.now():Date.now},2644:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Model=void 0;const n=r(5686),a=r(1446),o=r(7070),i=r(9395),s=r(2517);var l=i.onnxruntime.experimental.fbs;t.Model=class{constructor(){}load(e,t,r){if(!r)try{return void this.loadFromOnnxFormat(e,t)}catch(e){if(void 0!==r)throw e}this.loadFromOrtFormat(e,t)}loadFromOnnxFormat(e,t){const r=a.onnx.ModelProto.decode(e);if(s.LongUtil.longToNumber(r.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=r.opsetImport.map((e=>({domain:e.domain,version:s.LongUtil.longToNumber(e.version)}))),this._graph=o.Graph.from(r.graph,t)}loadFromOrtFormat(e,t){const r=new n.flatbuffers.ByteBuffer(e),a=l.InferenceSession.getRootAsInferenceSession(r).model();if(s.LongUtil.longToNumber(a.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let e=0;e<a.opsetImportLength();e++){const t=a.opsetImport(e);this._opsets.push({domain:null==t?void 0:t.domain(),version:s.LongUtil.longToNumber(t.version())})}this._graph=o.Graph.from(a.graph(),t)}get graph(){return this._graph}get opsets(){return this._opsets}}},782:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.FLOAT_TYPES=t.INT_TYPES=t.NUMBER_TYPES=void 0,t.NUMBER_TYPES=["float32","float64","int32","int16","int8","uint16","uint32","uint8"],t.INT_TYPES=["int32","int16","int8","uint16","uint32","uint8"],t.FLOAT_TYPES=["float32","float64"]},1047:(e,t)=>{function r(e,t){if(t.endsWith("+")){const r=Number.parseInt(t.substring(0,t.length-1),10);return!isNaN(r)&&r<=e}if(2===t.split("-").length){const r=t.split("-"),n=Number.parseInt(r[0],10),a=Number.parseInt(r[1],10);return!isNaN(n)&&!isNaN(a)&&n<=e&&e<=a}return Number.parseInt(t,10)===e}Object.defineProperty(t,"__esModule",{value:!0}),t.resolveOperator=void 0,t.resolveOperator=function(e,t,n){for(const a of n){const n=a[0],o=a[1],i=a[2],s=a[3],l=a[4];if(e.opType===n)for(const e of t)if((e.domain===o||"ai.onnx"===e.domain&&""===o)&&r(e.version,i))return{opImpl:s,opInit:l}}throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${t.map((e=>`${e.domain||"ai.onnx"} v${e.version}`)).join(", ")}`)}},9395:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.onnxruntime=void 0;const n=r(5686);var a,o;(function(e){!function(e){e[e.UNDEFINED=0]="UNDEFINED",e[e.FLOAT=1]="FLOAT",e[e.INT=2]="INT",e[e.STRING=3]="STRING",e[e.TENSOR=4]="TENSOR",e[e.GRAPH=5]="GRAPH",e[e.FLOATS=6]="FLOATS",e[e.INTS=7]="INTS",e[e.STRINGS=8]="STRINGS",e[e.TENSORS=9]="TENSORS",e[e.GRAPHS=10]="GRAPHS",e[e.SPARSE_TENSOR=11]="SPARSE_TENSOR",e[e.SPARSE_TENSORS=12]="SPARSE_TENSORS"}(e.AttributeType||(e.AttributeType={}))})((o=(a=t.onnxruntime||(t.onnxruntime={})).experimental||(a.experimental={})).fbs||(o.fbs={})),function(e){!function(e){!function(e){!function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.VALUE=1]="VALUE",e[e.PARAM=2]="PARAM"}(e.DimensionValueType||(e.DimensionValueType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){!function(e){e[e.UNDEFINED=0]="UNDEFINED",e[e.FLOAT=1]="FLOAT",e[e.UINT8=2]="UINT8",e[e.INT8=3]="INT8",e[e.UINT16=4]="UINT16",e[e.INT16=5]="INT16",e[e.INT32=6]="INT32",e[e.INT64=7]="INT64",e[e.STRING=8]="STRING",e[e.BOOL=9]="BOOL",e[e.FLOAT16=10]="FLOAT16",e[e.DOUBLE=11]="DOUBLE",e[e.UINT32=12]="UINT32",e[e.UINT64=13]="UINT64",e[e.COMPLEX64=14]="COMPLEX64",e[e.COMPLEX128=15]="COMPLEX128",e[e.BFLOAT16=16]="BFLOAT16"}(e.TensorDataType||(e.TensorDataType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){!function(e){e[e.Primitive=0]="Primitive",e[e.Fused=1]="Fused"}(e.NodeType||(e.NodeType={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){!function(e){e[e.NONE=0]="NONE",e[e.tensor_type=1]="tensor_type",e[e.sequence_type=2]="sequence_type",e[e.map_type=3]="map_type"}(e.TypeInfoValue||(e.TypeInfoValue={}))}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsShape(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsShape(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}dim(t,r){let n=this.bb.__offset(this.bb_pos,4);return n?(r||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}dimLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}static startShape(e){e.startObject(1)}static addDim(e,t){e.addFieldOffset(0,t,0)}static createDimVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startDimVector(e,t){e.startVector(4,t,4)}static endShape(e){return e.endObject()}static createShape(e,t){return r.startShape(e),r.addDim(e,t),r.endShape(e)}}t.Shape=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimension(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimension(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}value(t){let r=this.bb.__offset(this.bb_pos,4);return r?(t||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}denotation(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimension(e){e.startObject(2)}static addValue(e,t){e.addFieldOffset(0,t,0)}static addDenotation(e,t){e.addFieldOffset(1,t,0)}static endDimension(e){return e.endObject()}static createDimension(e,t,n){return r.startDimension(e),r.addValue(e,t),r.addDenotation(e,n),r.endDimension(e)}}t.Dimension=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsDimensionValue(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsDimensionValue(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}dimType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt8(this.bb_pos+t):e.experimental.fbs.DimensionValueType.UNKNOWN}dimValue(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}dimParam(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}static startDimensionValue(e){e.startObject(3)}static addDimType(t,r){t.addFieldInt8(0,r,e.experimental.fbs.DimensionValueType.UNKNOWN)}static addDimValue(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static addDimParam(e,t){e.addFieldOffset(2,t,0)}static endDimensionValue(e){return e.endObject()}static createDimensionValue(e,t,n,a){return r.startDimensionValue(e),r.addDimType(e,t),r.addDimValue(e,n),r.addDimParam(e,a),r.endDimensionValue(e)}}t.DimensionValue=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensorTypeAndShape(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensorTypeAndShape(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}elemType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}shape(t){let r=this.bb.__offset(this.bb_pos,6);return r?(t||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startTensorTypeAndShape(e){e.startObject(2)}static addElemType(t,r){t.addFieldInt32(0,r,e.experimental.fbs.TensorDataType.UNDEFINED)}static addShape(e,t){e.addFieldOffset(1,t,0)}static endTensorTypeAndShape(e){return e.endObject()}static createTensorTypeAndShape(e,t,n){return r.startTensorTypeAndShape(e),r.addElemType(e,t),r.addShape(e,n),r.endTensorTypeAndShape(e)}}t.TensorTypeAndShape=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsMapType(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsMapType(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}keyType(){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}valueType(t){let r=this.bb.__offset(this.bb_pos,6);return r?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startMapType(e){e.startObject(2)}static addKeyType(t,r){t.addFieldInt32(0,r,e.experimental.fbs.TensorDataType.UNDEFINED)}static addValueType(e,t){e.addFieldOffset(1,t,0)}static endMapType(e){return e.endObject()}static createMapType(e,t,n){return r.startMapType(e),r.addKeyType(e,t),r.addValueType(e,n),r.endMapType(e)}}t.MapType=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSequenceType(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSequenceType(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}elemType(t){let r=this.bb.__offset(this.bb_pos,4);return r?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startSequenceType(e){e.startObject(1)}static addElemType(e,t){e.addFieldOffset(0,t,0)}static endSequenceType(e){return e.endObject()}static createSequenceType(e,t){return r.startSequenceType(e),r.addElemType(e,t),r.endSequenceType(e)}}t.SequenceType=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){(e.fbs||(e.fbs={})).EdgeEnd=class{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(e,t,r,n){return e.prep(4,12),e.writeInt32(n),e.writeInt32(r),e.writeInt32(t),e.offset()}}}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNodeEdge(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNodeEdge(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}nodeIndex(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readUint32(this.bb_pos+e):0}inputEdges(t,r){let n=this.bb.__offset(this.bb_pos,6);return n?(r||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+n)+12*t,this.bb):null}inputEdgesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}outputEdges(t,r){let n=this.bb.__offset(this.bb_pos,8);return n?(r||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+n)+12*t,this.bb):null}outputEdgesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNodeEdge(e){e.startObject(3)}static addNodeIndex(e,t){e.addFieldInt32(0,t,0)}static addInputEdges(e,t){e.addFieldOffset(1,t,0)}static startInputEdgesVector(e,t){e.startVector(12,t,4)}static addOutputEdges(e,t){e.addFieldOffset(2,t,0)}static startOutputEdgesVector(e,t){e.startVector(12,t,4)}static endNodeEdge(e){return e.endObject()}static createNodeEdge(e,t,n,a){return r.startNodeEdge(e),r.addNodeIndex(e,t),r.addInputEdges(e,n),r.addOutputEdges(e,a),r.endNodeEdge(e)}}t.NodeEdge=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsNode(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsNode(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}sinceVersion(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readInt32(this.bb_pos+e):0}index(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb_pos+e):0}opType(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.NodeType.Primitive}executionProviderType(e){let t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__string(this.bb_pos+t,e):null}inputs(e,t){let r=this.bb.__offset(this.bb_pos,20);return r?this.bb.__string(this.bb.__vector(this.bb_pos+r)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let r=this.bb.__offset(this.bb_pos,22);return r?this.bb.__string(this.bb.__vector(this.bb_pos+r)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}attributes(t,r){let n=this.bb.__offset(this.bb_pos,24);return n?(r||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}attributesLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCounts(e){let t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readInt32(this.bb.__vector(this.bb_pos+t)+4*e):0}inputArgCountsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}inputArgCountsArray(){let e=this.bb.__offset(this.bb_pos,26);return e?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}implicitInputs(e,t){let r=this.bb.__offset(this.bb_pos,28);return r?this.bb.__string(this.bb.__vector(this.bb_pos+r)+4*e,t):null}implicitInputsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startNode(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDomain(e,t){e.addFieldOffset(2,t,0)}static addSinceVersion(e,t){e.addFieldInt32(3,t,0)}static addIndex(e,t){e.addFieldInt32(4,t,0)}static addOpType(e,t){e.addFieldOffset(5,t,0)}static addType(t,r){t.addFieldInt32(6,r,e.experimental.fbs.NodeType.Primitive)}static addExecutionProviderType(e,t){e.addFieldOffset(7,t,0)}static addInputs(e,t){e.addFieldOffset(8,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(9,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addAttributes(e,t){e.addFieldOffset(10,t,0)}static createAttributesVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startAttributesVector(e,t){e.startVector(4,t,4)}static addInputArgCounts(e,t){e.addFieldOffset(11,t,0)}static createInputArgCountsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addInt32(t[r]);return e.endVector()}static startInputArgCountsVector(e,t){e.startVector(4,t,4)}static addImplicitInputs(e,t){e.addFieldOffset(12,t,0)}static createImplicitInputsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startImplicitInputsVector(e,t){e.startVector(4,t,4)}static endNode(e){return e.endObject()}static createNode(e,t,n,a,o,i,s,l,d,u,c,p,g,A){return r.startNode(e),r.addName(e,t),r.addDocString(e,n),r.addDomain(e,a),r.addSinceVersion(e,o),r.addIndex(e,i),r.addOpType(e,s),r.addType(e,l),r.addExecutionProviderType(e,d),r.addInputs(e,u),r.addOutputs(e,c),r.addAttributes(e,p),r.addInputArgCounts(e,g),r.addImplicitInputs(e,A),r.endNode(e)}}t.Node=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsValueInfo(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsValueInfo(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(t){let r=this.bb.__offset(this.bb_pos,8);return r?(t||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startValueInfo(e){e.startObject(3)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(e,t){e.addFieldOffset(2,t,0)}static endValueInfo(e){return e.endObject()}static createValueInfo(e,t,n,a){return r.startValueInfo(e),r.addName(e,t),r.addDocString(e,n),r.addType(e,a),r.endValueInfo(e)}}t.ValueInfo=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTypeInfo(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTypeInfo(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}denotation(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}valueType(){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint8(this.bb_pos+t):e.experimental.fbs.TypeInfoValue.NONE}value(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__union(e,this.bb_pos+t):null}static startTypeInfo(e){e.startObject(3)}static addDenotation(e,t){e.addFieldOffset(0,t,0)}static addValueType(t,r){t.addFieldInt8(1,r,e.experimental.fbs.TypeInfoValue.NONE)}static addValue(e,t){e.addFieldOffset(2,t,0)}static endTypeInfo(e){return e.endObject()}static createTypeInfo(e,t,n,a){return r.startTypeInfo(e),r.addDenotation(e,t),r.addValueType(e,n),r.addValue(e,a),r.endTypeInfo(e)}}t.TypeInfo=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){class t{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsOperatorSetId(e,r){return(r||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsOperatorSetId(e,r){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new t).__init(e.readInt32(e.position())+e.position(),e)}domain(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}version(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}static startOperatorSetId(e){e.startObject(2)}static addDomain(e,t){e.addFieldOffset(0,t,0)}static addVersion(e,t){e.addFieldInt64(1,t,e.createLong(0,0))}static endOperatorSetId(e){return e.endObject()}static createOperatorSetId(e,r,n){return t.startOperatorSetId(e),t.addDomain(e,r),t.addVersion(e,n),t.endOperatorSetId(e)}}e.OperatorSetId=t}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsTensor(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsTensor(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}dataType(){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.TensorDataType.UNDEFINED}rawData(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.readUint8(this.bb.__vector(this.bb_pos+t)+e):0}rawDataLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}rawDataArray(){let e=this.bb.__offset(this.bb_pos,12);return e?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}stringData(e,t){let r=this.bb.__offset(this.bb_pos,14);return r?this.bb.__string(this.bb.__vector(this.bb_pos+r)+4*e,t):null}stringDataLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}static startTensor(e){e.startObject(6)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let r=t.length-1;r>=0;r--)e.addInt64(t[r]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static addDataType(t,r){t.addFieldInt32(3,r,e.experimental.fbs.TensorDataType.UNDEFINED)}static addRawData(e,t){e.addFieldOffset(4,t,0)}static createRawDataVector(e,t){e.startVector(1,t.length,1);for(let r=t.length-1;r>=0;r--)e.addInt8(t[r]);return e.endVector()}static startRawDataVector(e,t){e.startVector(1,t,1)}static addStringData(e,t){e.addFieldOffset(5,t,0)}static createStringDataVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startStringDataVector(e,t){e.startVector(4,t,4)}static endTensor(e){return e.endObject()}static createTensor(e,t,n,a,o,i,s){return r.startTensor(e),r.addName(e,t),r.addDocString(e,n),r.addDims(e,a),r.addDataType(e,o),r.addRawData(e,i),r.addStringData(e,s),r.endTensor(e)}}t.Tensor=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSparseTensor(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSparseTensor(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}values(t){let r=this.bb.__offset(this.bb_pos,4);return r?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}indices(t){let r=this.bb.__offset(this.bb_pos,6);return r?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}dims(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}dimsLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSparseTensor(e){e.startObject(3)}static addValues(e,t){e.addFieldOffset(0,t,0)}static addIndices(e,t){e.addFieldOffset(1,t,0)}static addDims(e,t){e.addFieldOffset(2,t,0)}static createDimsVector(e,t){e.startVector(8,t.length,8);for(let r=t.length-1;r>=0;r--)e.addInt64(t[r]);return e.endVector()}static startDimsVector(e,t){e.startVector(8,t,8)}static endSparseTensor(e){return e.endObject()}static createSparseTensor(e,t,n,a){return r.startSparseTensor(e),r.addValues(e,t),r.addIndices(e,n),r.addDims(e,a),r.endSparseTensor(e)}}t.SparseTensor=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsAttribute(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAttribute(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}name(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}docString(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__string(this.bb_pos+t,e):null}type(){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.readInt32(this.bb_pos+t):e.experimental.fbs.AttributeType.UNDEFINED}f(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb_pos+e):0}i(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}s(e){let t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__string(this.bb_pos+t,e):null}t(t){let r=this.bb.__offset(this.bb_pos,16);return r?(t||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}g(t){let r=this.bb.__offset(this.bb_pos,18);return r?(t||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}floats(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.readFloat32(this.bb.__vector(this.bb_pos+t)+4*e):0}floatsLength(){let e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__vector_len(this.bb_pos+e):0}floatsArray(){let e=this.bb.__offset(this.bb_pos,20);return e?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}ints(e){let t=this.bb.__offset(this.bb_pos,22);return t?this.bb.readInt64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}intsLength(){let e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__vector_len(this.bb_pos+e):0}strings(e,t){let r=this.bb.__offset(this.bb_pos,24);return r?this.bb.__string(this.bb.__vector(this.bb_pos+r)+4*e,t):null}stringsLength(){let e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__vector_len(this.bb_pos+e):0}tensors(t,r){let n=this.bb.__offset(this.bb_pos,26);return n?(r||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}tensorsLength(){let e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__vector_len(this.bb_pos+e):0}graphs(t,r){let n=this.bb.__offset(this.bb_pos,28);return n?(r||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}graphsLength(){let e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__vector_len(this.bb_pos+e):0}static startAttribute(e){e.startObject(13)}static addName(e,t){e.addFieldOffset(0,t,0)}static addDocString(e,t){e.addFieldOffset(1,t,0)}static addType(t,r){t.addFieldInt32(2,r,e.experimental.fbs.AttributeType.UNDEFINED)}static addF(e,t){e.addFieldFloat32(3,t,0)}static addI(e,t){e.addFieldInt64(4,t,e.createLong(0,0))}static addS(e,t){e.addFieldOffset(5,t,0)}static addT(e,t){e.addFieldOffset(6,t,0)}static addG(e,t){e.addFieldOffset(7,t,0)}static addFloats(e,t){e.addFieldOffset(8,t,0)}static createFloatsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addFloat32(t[r]);return e.endVector()}static startFloatsVector(e,t){e.startVector(4,t,4)}static addInts(e,t){e.addFieldOffset(9,t,0)}static createIntsVector(e,t){e.startVector(8,t.length,8);for(let r=t.length-1;r>=0;r--)e.addInt64(t[r]);return e.endVector()}static startIntsVector(e,t){e.startVector(8,t,8)}static addStrings(e,t){e.addFieldOffset(10,t,0)}static createStringsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startStringsVector(e,t){e.startVector(4,t,4)}static addTensors(e,t){e.addFieldOffset(11,t,0)}static createTensorsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startTensorsVector(e,t){e.startVector(4,t,4)}static addGraphs(e,t){e.addFieldOffset(12,t,0)}static createGraphsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startGraphsVector(e,t){e.startVector(4,t,4)}static endAttribute(e){return e.endObject()}static createAttribute(e,t,n,a,o,i,s,l,d,u,c,p,g,A){return r.startAttribute(e),r.addName(e,t),r.addDocString(e,n),r.addType(e,a),r.addF(e,o),r.addI(e,i),r.addS(e,s),r.addT(e,l),r.addG(e,d),r.addFloats(e,u),r.addInts(e,c),r.addStrings(e,p),r.addTensors(e,g),r.addGraphs(e,A),r.endAttribute(e)}}t.Attribute=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsGraph(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsGraph(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}initializers(t,r){let n=this.bb.__offset(this.bb_pos,4);return n?(r||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}initializersLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeArgs(t,r){let n=this.bb.__offset(this.bb_pos,6);return n?(r||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}nodeArgsLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}nodes(t,r){let n=this.bb.__offset(this.bb_pos,8);return n?(r||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}nodesLength(){let e=this.bb.__offset(this.bb_pos,8);return e?this.bb.__vector_len(this.bb_pos+e):0}maxNodeIndex(){let e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb_pos+e):0}nodeEdges(t,r){let n=this.bb.__offset(this.bb_pos,12);return n?(r||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}nodeEdgesLength(){let e=this.bb.__offset(this.bb_pos,12);return e?this.bb.__vector_len(this.bb_pos+e):0}inputs(e,t){let r=this.bb.__offset(this.bb_pos,14);return r?this.bb.__string(this.bb.__vector(this.bb_pos+r)+4*e,t):null}inputsLength(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.__vector_len(this.bb_pos+e):0}outputs(e,t){let r=this.bb.__offset(this.bb_pos,16);return r?this.bb.__string(this.bb.__vector(this.bb_pos+r)+4*e,t):null}outputsLength(){let e=this.bb.__offset(this.bb_pos,16);return e?this.bb.__vector_len(this.bb_pos+e):0}sparseInitializers(t,r){let n=this.bb.__offset(this.bb_pos,18);return n?(r||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}sparseInitializersLength(){let e=this.bb.__offset(this.bb_pos,18);return e?this.bb.__vector_len(this.bb_pos+e):0}static startGraph(e){e.startObject(8)}static addInitializers(e,t){e.addFieldOffset(0,t,0)}static createInitializersVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startInitializersVector(e,t){e.startVector(4,t,4)}static addNodeArgs(e,t){e.addFieldOffset(1,t,0)}static createNodeArgsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startNodeArgsVector(e,t){e.startVector(4,t,4)}static addNodes(e,t){e.addFieldOffset(2,t,0)}static createNodesVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startNodesVector(e,t){e.startVector(4,t,4)}static addMaxNodeIndex(e,t){e.addFieldInt32(3,t,0)}static addNodeEdges(e,t){e.addFieldOffset(4,t,0)}static createNodeEdgesVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startNodeEdgesVector(e,t){e.startVector(4,t,4)}static addInputs(e,t){e.addFieldOffset(5,t,0)}static createInputsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startInputsVector(e,t){e.startVector(4,t,4)}static addOutputs(e,t){e.addFieldOffset(6,t,0)}static createOutputsVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startOutputsVector(e,t){e.startVector(4,t,4)}static addSparseInitializers(e,t){e.addFieldOffset(7,t,0)}static createSparseInitializersVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startSparseInitializersVector(e,t){e.startVector(4,t,4)}static endGraph(e){return e.endObject()}static createGraph(e,t,n,a,o,i,s,l,d){return r.startGraph(e),r.addInitializers(e,t),r.addNodeArgs(e,n),r.addNodes(e,a),r.addMaxNodeIndex(e,o),r.addNodeEdges(e,i),r.addInputs(e,s),r.addOutputs(e,l),r.addSparseInitializers(e,d),r.endGraph(e)}}t.Graph=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsModel(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsModel(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}irVersion(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}opsetImport(t,r){let n=this.bb.__offset(this.bb_pos,6);return n?(r||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}opsetImportLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}producerName(e){let t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__string(this.bb_pos+t,e):null}producerVersion(e){let t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__string(this.bb_pos+t,e):null}domain(e){let t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__string(this.bb_pos+t,e):null}modelVersion(){let e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readInt64(this.bb_pos+e):this.bb.createLong(0,0)}docString(e){let t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__string(this.bb_pos+t,e):null}graph(t){let r=this.bb.__offset(this.bb_pos,18);return r?(t||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}graphDocString(e){let t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__string(this.bb_pos+t,e):null}static startModel(e){e.startObject(9)}static addIrVersion(e,t){e.addFieldInt64(0,t,e.createLong(0,0))}static addOpsetImport(e,t){e.addFieldOffset(1,t,0)}static createOpsetImportVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startOpsetImportVector(e,t){e.startVector(4,t,4)}static addProducerName(e,t){e.addFieldOffset(2,t,0)}static addProducerVersion(e,t){e.addFieldOffset(3,t,0)}static addDomain(e,t){e.addFieldOffset(4,t,0)}static addModelVersion(e,t){e.addFieldInt64(5,t,e.createLong(0,0))}static addDocString(e,t){e.addFieldOffset(6,t,0)}static addGraph(e,t){e.addFieldOffset(7,t,0)}static addGraphDocString(e,t){e.addFieldOffset(8,t,0)}static endModel(e){return e.endObject()}static createModel(e,t,n,a,o,i,s,l,d,u){return r.startModel(e),r.addIrVersion(e,t),r.addOpsetImport(e,n),r.addProducerName(e,a),r.addProducerVersion(e,o),r.addDomain(e,i),r.addModelVersion(e,s),r.addDocString(e,l),r.addGraph(e,d),r.addGraphDocString(e,u),r.endModel(e)}}t.Model=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(e){!function(e){class t{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsKernelCreateInfos(e,r){return(r||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsKernelCreateInfos(e,r){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(r||new t).__init(e.readInt32(e.position())+e.position(),e)}nodeIndices(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb.__vector(this.bb_pos+t)+4*e):0}nodeIndicesLength(){let e=this.bb.__offset(this.bb_pos,4);return e?this.bb.__vector_len(this.bb_pos+e):0}nodeIndicesArray(){let e=this.bb.__offset(this.bb_pos,4);return e?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+e),this.bb.__vector_len(this.bb_pos+e)):null}kernelDefHashes(e){let t=this.bb.__offset(this.bb_pos,6);return t?this.bb.readUint64(this.bb.__vector(this.bb_pos+t)+8*e):this.bb.createLong(0,0)}kernelDefHashesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startKernelCreateInfos(e){e.startObject(2)}static addNodeIndices(e,t){e.addFieldOffset(0,t,0)}static createNodeIndicesVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addInt32(t[r]);return e.endVector()}static startNodeIndicesVector(e,t){e.startVector(4,t,4)}static addKernelDefHashes(e,t){e.addFieldOffset(1,t,0)}static createKernelDefHashesVector(e,t){e.startVector(8,t.length,8);for(let r=t.length-1;r>=0;r--)e.addInt64(t[r]);return e.endVector()}static startKernelDefHashesVector(e,t){e.startVector(8,t,8)}static endKernelCreateInfos(e){return e.endObject()}static createKernelCreateInfos(e,r,n){return t.startKernelCreateInfos(e),t.addNodeIndices(e,r),t.addKernelDefHashes(e,n),t.endKernelCreateInfos(e)}}e.KernelCreateInfos=t}(e.fbs||(e.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSubGraphSessionState(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSubGraphSessionState(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}graphId(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}sessionState(t){let r=this.bb.__offset(this.bb_pos,6);return r?(t||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startSubGraphSessionState(e){e.startObject(2)}static addGraphId(e,t){e.addFieldOffset(0,t,0)}static addSessionState(e,t){e.addFieldOffset(1,t,0)}static endSubGraphSessionState(e){let t=e.endObject();return e.requiredField(t,4),t}static createSubGraphSessionState(e,t,n){return r.startSubGraphSessionState(e),r.addGraphId(e,t),r.addSessionState(e,n),r.endSubGraphSessionState(e)}}t.SubGraphSessionState=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsSessionState(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsSessionState(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}kernels(t){let r=this.bb.__offset(this.bb_pos,4);return r?(t||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}subGraphSessionStates(t,r){let n=this.bb.__offset(this.bb_pos,6);return n?(r||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+n)+4*t),this.bb):null}subGraphSessionStatesLength(){let e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__vector_len(this.bb_pos+e):0}static startSessionState(e){e.startObject(2)}static addKernels(e,t){e.addFieldOffset(0,t,0)}static addSubGraphSessionStates(e,t){e.addFieldOffset(1,t,0)}static createSubGraphSessionStatesVector(e,t){e.startVector(4,t.length,4);for(let r=t.length-1;r>=0;r--)e.addOffset(t[r]);return e.endVector()}static startSubGraphSessionStatesVector(e,t){e.startVector(4,t,4)}static endSessionState(e){return e.endObject()}static createSessionState(e,t,n){return r.startSessionState(e),r.addKernels(e,t),r.addSubGraphSessionStates(e,n),r.endSessionState(e)}}t.SessionState=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={})),function(e){!function(t){!function(t){class r{constructor(){this.bb=null,this.bb_pos=0}__init(e,t){return this.bb_pos=e,this.bb=t,this}static getRootAsInferenceSession(e,t){return(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsInferenceSession(e,t){return e.setPosition(e.position()+n.flatbuffers.SIZE_PREFIX_LENGTH),(t||new r).__init(e.readInt32(e.position())+e.position(),e)}static bufferHasIdentifier(e){return e.__has_identifier("ORTM")}ortVersion(e){let t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__string(this.bb_pos+t,e):null}model(t){let r=this.bb.__offset(this.bb_pos,6);return r?(t||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}sessionState(t){let r=this.bb.__offset(this.bb_pos,8);return r?(t||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+r),this.bb):null}static startInferenceSession(e){e.startObject(3)}static addOrtVersion(e,t){e.addFieldOffset(0,t,0)}static addModel(e,t){e.addFieldOffset(1,t,0)}static addSessionState(e,t){e.addFieldOffset(2,t,0)}static endInferenceSession(e){return e.endObject()}static finishInferenceSessionBuffer(e,t){e.finish(t,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(e,t){e.finish(t,"ORTM",!0)}static createInferenceSession(e,t,n,a){return r.startInferenceSession(e),r.addOrtVersion(e,t),r.addModel(e,n),r.addSessionState(e,a),r.endInferenceSession(e)}}t.InferenceSession=r}(t.fbs||(t.fbs={}))}(e.experimental||(e.experimental={}))}(t.onnxruntime||(t.onnxruntime={}))},7448:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxjsSessionHandler=void 0;const n=r(1670),a=r(9162);t.OnnxjsSessionHandler=class{constructor(e){this.session=e,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,t,r){const o=new Map;for(const t in e)if(Object.hasOwnProperty.call(e,t)){const r=e[t];o.set(t,new a.Tensor(r.dims,r.type,void 0,void 0,r.data))}const i=await this.session.run(o),s={};return i.forEach(((e,t)=>{s[t]=new n.Tensor(e.type,e.data,e.dims)})),s}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}},6919:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Session=void 0;const n=r(7067),a=r(1296),o=r(7091),i=r(1036),s=r(6231),l=r(2644);t.Session=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=s.Profiler.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,t,r){await this.profiler.event("session","Session.loadModel",(async()=>{const i=await(0,o.resolveBackend)(this.backendHint);if(this.sessionHandler=i.createSessionHandler(this.context),this._model=new l.Model,"string"==typeof e){const t=e.endsWith(".ort");if("undefined"==typeof fetch){const r=await(0,a.promisify)(n.readFile)(e);this.initialize(r,t)}else{const r=await fetch(e),n=await r.arrayBuffer();this.initialize(new Uint8Array(n),t)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{const n=new Uint8Array(e,t||0,r||e.byteLength);this.initialize(n)}}))}initialize(e,t){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",(()=>{const r=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,r,t),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new i.ExecutionPlan(this._model.graph,this._ops,this.profiler)})),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",(async()=>{const t=this.normalizeAndValidateInputs(e),r=await this._executionPlan.execute(this.sessionHandler,t);return this.createOutput(r)}))}normalizeAndValidateInputs(e){const t=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==t.length)throw new Error(`incorrect input array length: expected ${t.length} but got ${e.length}`)}else{if(e.size!==t.length)throw new Error(`incorrect input map size: expected ${t.length} but got ${e.size}`);const r=new Array(e.size);let n=0;for(let a=0;a<t.length;++a){const o=e.get(t[a]);if(!o)throw new Error(`missing input tensor for: '${name}'`);r[n++]=o}e=r}if(this.context.graphInputTypes&&0!==this.context.graphInputTypes.length&&this.context.graphInputDims&&0!==this.context.graphInputDims.length)this.validateInputTensorDims(this.context.graphInputDims,e,!1);else{const t=this._model.graph.getInputIndices(),r=this._model.graph.getValues(),n=new Array(t.length);for(let a=0;a<t.length;++a){const o=r[t[a]];n[a]=o.type.shape.dims,this.context.graphInputTypes.push(o.type.tensorType),this.context.graphInputDims.push(e[a].dims)}this.validateInputTensorDims(n,e,!0)}return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,t){for(let r=0;r<t.length;r++){const n=e[r],a=t[r].type;if(n!==a)throw new Error(`input tensor[${r}] check failed: expected type '${n}' but got ${a}`)}}validateInputTensorDims(e,t,r){for(let n=0;n<t.length;n++){const a=e[n],o=t[n].dims;if(!this.compareTensorDims(a,o,r))throw new Error(`input tensor[${n}] check failed: expected shape '[${a.join(",")}]' but got [${o.join(",")}]`)}}compareTensorDims(e,t,r){if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(e[n]!==t[n]&&(!r||0!==e[n]))return!1;return!0}createOutput(e){const t=this._model.graph.getOutputNames();if(e.length!==t.length)throw new Error("expected number of outputs do not match number of generated outputs");const r=new Map;for(let n=0;n<t.length;++n)r.set(t[n],e[n]);return r}initializeOps(e){const t=e.getNodes();this._ops=new Array(t.length);for(let r=0;r<t.length;r++)this._ops[r]=this.sessionHandler.resolve(t[r],this._model.opsets,e)}}},9162:function(e,t,r){var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.Tensor=void 0;const a=r(3442),o=n(r(3720)),i=r(1446),s=r(9395),l=r(2517);var d=s.onnxruntime.experimental.fbs;class u{get data(){if(void 0===this.cache){const e=this.dataProvider(this.dataId);if(e.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=e}return this.cache}get stringData(){if("string"!==this.type)throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if("string"!==this.type)return this.data;throw new TypeError("type cannot be non-number (string)")}get(e){return this.data[l.ShapeUtil.indicesToOffset(e,this.strides)]}set(e,t){this.data[l.ShapeUtil.indicesToOffset(e,this.strides)]=t}async getData(){return void 0===this.cache&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=l.ShapeUtil.computeStrides(this.dims)),this._strides}constructor(e,t,r,n,o,i=a.Guid.create()){this.dims=e,this.type=t,this.dataProvider=r,this.asyncDataProvider=n,this.cache=o,this.dataId=i,this.size=l.ShapeUtil.validateDimsAndCalcSize(e);const s=this.size,d=void 0===r&&void 0===n&&void 0===o;if(void 0!==o&&o.length!==s)throw new RangeError("Input dims doesn't match data length.");if("string"===t){if(!(void 0===o||Array.isArray(o)&&o.every((e=>"string"==typeof e))))throw new TypeError("cache should be a string array");d&&(this.cache=new Array(s))}else{if(void 0!==o){const e=p(t);if(!(o instanceof e))throw new TypeError(`cache should be type ${e.name}`)}if(d){const e=new ArrayBuffer(s*function(e){switch(e){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${e}`)}}(t));this.cache=function(e,t){return new(p(t))(e)}(e,t)}}}static fromProto(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const t=l.ProtoUtil.tensorDataTypeFromProto(e.dataType),r=l.ProtoUtil.tensorDimsFromProto(e.dims),n=new u(r,t);if("string"===t)e.stringData.forEach(((e,t)=>{n.data[t]=(0,l.decodeUtf8String)(e)}));else if(e.rawData&&"number"==typeof e.rawData.byteLength&&e.rawData.byteLength>0){const t=n.data,r=new DataView(e.rawData.buffer,e.rawData.byteOffset,e.rawData.byteLength),a=c(e.dataType),o=e.rawData.byteLength/a;if(e.rawData.byteLength%a!=0)throw new Error("invalid buffer length");if(t.length!==o)throw new Error("buffer length mismatch");for(let n=0;n<o;n++){const o=A(r,e.dataType,n*a);t[n]=o}}else{let t;switch(e.dataType){case i.onnx.TensorProto.DataType.FLOAT:t=e.floatData;break;case i.onnx.TensorProto.DataType.INT32:case i.onnx.TensorProto.DataType.INT16:case i.onnx.TensorProto.DataType.UINT16:case i.onnx.TensorProto.DataType.INT8:case i.onnx.TensorProto.DataType.UINT8:case i.onnx.TensorProto.DataType.BOOL:t=e.int32Data;break;case i.onnx.TensorProto.DataType.INT64:t=e.int64Data;break;case i.onnx.TensorProto.DataType.DOUBLE:t=e.doubleData;break;case i.onnx.TensorProto.DataType.UINT32:case i.onnx.TensorProto.DataType.UINT64:t=e.uint64Data;break;default:throw new Error("unspecific error")}if(null==t)throw new Error("failed to populate data from a tensorproto value");const r=n.data;if(r.length!==t.length)throw new Error("array length mismatch");for(let n=0;n<t.length;n++){const a=t[n];o.default.isLong(a)?r[n]=g(a,e.dataType):r[n]=a}}return n}static fromData(e,t,r){return new u(t,r,void 0,void 0,e)}static fromOrtTensor(e){if(!e)throw new Error("cannot construct Value from an empty tensor");const t=l.ProtoUtil.tensorDimsFromORTFormat(e),r=l.ProtoUtil.tensorDataTypeFromProto(e.dataType()),n=new u(t,r);if("string"===r)for(let t=0;t<e.stringDataLength();t++)n.data[t]=e.stringData(t);else if(e.rawDataArray()&&"number"==typeof e.rawDataLength()&&e.rawDataLength()>0){const t=n.data,r=new DataView(e.rawDataArray().buffer,e.rawDataArray().byteOffset,e.rawDataLength()),a=c(e.dataType()),o=e.rawDataLength()/a;if(e.rawDataLength()%a!=0)throw new Error("invalid buffer length");if(t.length!==o)throw new Error("buffer length mismatch");for(let n=0;n<o;n++){const o=A(r,e.dataType(),n*a);t[n]=o}}return n}}function c(e){switch(e){case i.onnx.TensorProto.DataType.UINT8:case i.onnx.TensorProto.DataType.INT8:case i.onnx.TensorProto.DataType.BOOL:return 1;case i.onnx.TensorProto.DataType.UINT16:case i.onnx.TensorProto.DataType.INT16:return 2;case i.onnx.TensorProto.DataType.FLOAT:case i.onnx.TensorProto.DataType.INT32:case i.onnx.TensorProto.DataType.UINT32:return 4;case i.onnx.TensorProto.DataType.INT64:case i.onnx.TensorProto.DataType.DOUBLE:case i.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${i.onnx.TensorProto.DataType[e]}`)}}function p(e){switch(e){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function g(e,t){if(t===i.onnx.TensorProto.DataType.INT64||t===d.TensorDataType.INT64){if(e.greaterThanOrEqual(2147483648)||e.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else{if(t!==i.onnx.TensorProto.DataType.UINT32&&t!==d.TensorDataType.UINT32&&t!==i.onnx.TensorProto.DataType.UINT64&&t!==d.TensorDataType.UINT64)throw new TypeError(`not a LONG type: ${i.onnx.TensorProto.DataType[t]}`);if(e.greaterThanOrEqual(4294967296)||e.lessThan(0))throw new TypeError("uint64 is not supported")}return e.toNumber()}function A(e,t,r){switch(t){case i.onnx.TensorProto.DataType.BOOL:case i.onnx.TensorProto.DataType.UINT8:return e.getUint8(r);case i.onnx.TensorProto.DataType.INT8:return e.getInt8(r);case i.onnx.TensorProto.DataType.UINT16:return e.getUint16(r,!0);case i.onnx.TensorProto.DataType.INT16:return e.getInt16(r,!0);case i.onnx.TensorProto.DataType.FLOAT:return e.getFloat32(r,!0);case i.onnx.TensorProto.DataType.INT32:return e.getInt32(r,!0);case i.onnx.TensorProto.DataType.UINT32:return e.getUint32(r,!0);case i.onnx.TensorProto.DataType.INT64:return g(o.default.fromBits(e.getUint32(r,!0),e.getUint32(r+4,!0),!1),t);case i.onnx.TensorProto.DataType.DOUBLE:return e.getFloat64(r,!0);case i.onnx.TensorProto.DataType.UINT64:return g(o.default.fromBits(e.getUint32(r,!0),e.getUint32(r+4,!0),!0),t);default:throw new Error(`cannot read from DataView for type ${i.onnx.TensorProto.DataType[t]}`)}}t.Tensor=u},2517:function(e,t,r){var n=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeUtf8String=t.MAX_CLIP=t.MIN_CLIP=t.PoolConvUtil=t.ReduceUtil=t.SplitUtil=t.MathUtil=t.ShapeUtil=t.LongUtil=t.ProtoUtil=t.GemmUtil=t.arrayCopyHelper=t.BroadcastUtil=t.MatMulUtil=t.ArrayUtil=t.assert=t.checkInputsShape=void 0;const a=r(5686),o=n(r(3720)),i=r(1446),s=r(9162);t.checkInputsShape=function(e,...t){if(!e||e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(!e[r].dims||e[r].dims.length!==t[r])return!1;return!0},t.assert=function(e,t){if(!e)throw new Error("string"==typeof t?t:t())},t.ArrayUtil=class{static arraysEqual(e,t){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0}};class l{static preprocessInputShapes(e,t){return[1===e.length?[1,e[0]]:e,1===t.length?[t[0],1]:t]}static postprocessOutputShape(e,t,r){1===t&&e.splice(e.length-2,1),1===r&&e.pop()}static calcMatMulShape(e,t){return e[1]!==t[0]?void 0:[e[0],t[1]]}}t.MatMulUtil=l;class d{static calcShape(e,t,r=!1){const n=e.length,a=t.length;if(0===n)return t;if(0===a)return e;const o=Math.max(e.length,t.length),i=new Array(o);if(r){if(n<2||a<2)return;const r=l.calcMatMulShape([e[n-2],e[n-1]],[t[a-2],t[a-1]]);if(void 0===r)return;[i[o-2],i[o-1]]=r}for(let s=r?3:1;s<=o;s++){const r=n-s<0?1:e[n-s],l=a-s<0?1:t[a-s];if(r!==l&&r>1&&l>1)return;i[o-s]=Math.max(r,l)}return i}static index(e,t){const r=new Array(t.length);return d.fillIndex(e,t,r),r}static fillIndex(e,t,r){const n=e.length-t.length;for(let a=0;a<t.length;a++)r[a]=e[n+a]%t[a]}static calc(e,t,r,n,a){const o=d.calcShape(e.dims,t.dims);if(o){if(n&&!p.areEqual(o,e.dims))return;const i=p.size(o),l=n?e:new s.Tensor(o,a||e.type);if(0===o.length)l.set([],r(e.get([]),t.get([])));else{const n=new Array(o.length),a=new Array(e.dims.length),s=new Array(t.dims.length);let u,c=0,p=0,g=!1,A=!1;0===e.dims.length&&(c=e.get([]),g=!0),0===t.dims.length&&(p=t.get([]),A=!0);for(let h=0;h<i;h++){u=h;for(let e=o.length-1;e>=0;e--)n[e]=u%o[e],u=Math.floor(u/o[e]);g||(d.fillIndex(n,e.dims,a),c=e.get(a)),A||(d.fillIndex(n,t.dims,s),p=t.get(s)),l.set(n,r(c,p))}}return l}}static isValidBroadcast(e,t){const r=e.length,n=t.length;if(r>n)return!1;for(let a=1;a<=r;a++)if(1!==e[r-a]&&e[r-a]!==t[n-a])return!1;return!0}static getBroadcastDims(e,t){const r=e.length,n=[];for(let a=0;a<r;a++){const o=r-1-a,i=e[o]||1;(t[t.length-1-a]||1)>1&&1===i&&n.unshift(o)}return n}}t.BroadcastUtil=d,t.arrayCopyHelper=function(e,t,r,n,a){if(n<0||n>=t.length)throw new Error("sourceIndex out of bounds");if(r<0||r>=e.length)throw new Error("targetIndex out of bounds");if(n+a>t.length)throw new Error("source indices to be copied are outside bounds");if(r+a>e.length)throw new Error("target array is too small to hold result");for(let o=0;o<a;o++)e[r+o]=t[n+o]},t.GemmUtil=class{static getShapeOfGemmResult(e,t,r,n,a){if(2!==e.length||2!==r.length)throw new Error("shape need to be of size 2");let o,i,s;t?(o=e[1],i=e[0]):(o=e[0],i=e[1]);let l=-1;if(n?(s=r[0],l=1):(s=r[1],l=0),r[l]!==i)throw new Error("dimension mismatch");if(o<=0||s<=0||i<=0)throw new Error("invalid shape specified");if(a&&!d.isValidBroadcast(a,[o,s]))throw new Error("gemm: invalid bias shape for broadcast");return[o,s,i]}};class u{static tensorDataTypeFromProto(e){switch(e){case i.onnx.TensorProto.DataType.INT8:return"int8";case i.onnx.TensorProto.DataType.UINT8:return"uint8";case i.onnx.TensorProto.DataType.BOOL:return"bool";case i.onnx.TensorProto.DataType.INT16:return"int16";case i.onnx.TensorProto.DataType.UINT16:return"uint16";case i.onnx.TensorProto.DataType.INT32:return"int32";case i.onnx.TensorProto.DataType.UINT32:return"uint32";case i.onnx.TensorProto.DataType.FLOAT:return"float32";case i.onnx.TensorProto.DataType.DOUBLE:return"float64";case i.onnx.TensorProto.DataType.STRING:return"string";case i.onnx.TensorProto.DataType.INT64:return"int32";case i.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${i.onnx.TensorProto.DataType[e]}`)}}static tensorDataTypeStringToEnum(e){switch(e){case"int8":return i.onnx.TensorProto.DataType.INT8;case"uint8":return i.onnx.TensorProto.DataType.UINT8;case"bool":return i.onnx.TensorProto.DataType.BOOL;case"int16":return i.onnx.TensorProto.DataType.INT16;case"uint16":return i.onnx.TensorProto.DataType.UINT16;case"int32":return i.onnx.TensorProto.DataType.INT32;case"uint32":return i.onnx.TensorProto.DataType.UINT32;case"float32":return i.onnx.TensorProto.DataType.FLOAT;case"float64":return i.onnx.TensorProto.DataType.DOUBLE;case"string":return i.onnx.TensorProto.DataType.STRING;case"int64":return i.onnx.TensorProto.DataType.INT64;case"uint64":return i.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${e}`)}}static tensorDimsFromProto(e){return e.map((e=>o.default.isLong(e)?e.toNumber():e))}static tensorValueTypeFromProto(e){return{tensorType:u.tensorDataTypeFromProto(e.elemType),shape:{dims:u.tensorDimsFromProto(e.shape.dim.map((e=>e.dimValue)))}}}static tensorDimsFromORTFormat(e){const t=[];for(let r=0;r<e.dimsLength();r++)t.push(c.longToNumber(e.dims(r)));return t}static tensorAttributesFromORTFormat(e){const t=[];for(let r=0;r<e.attributesLength();r++)t.push(e.attributes(r));return t}}t.ProtoUtil=u;class c{static longToNumber(e,t){return o.default.isLong(e)?e.toNumber():e instanceof a.flatbuffers.Long?o.default.fromValue({low:e.low,high:e.high,unsigned:null!=t&&t}).toNumber():e}static isLong(e){return o.default.isLong(e)||e instanceof a.flatbuffers.Long}}t.LongUtil=c;class p{static size(e){return p.getSizeFromDimensionRange(e,0,e.length)}static sizeFromDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeFromDimension as Tensor has ${e.length} dimensions.`);return p.getSizeFromDimensionRange(e,t,e.length)}static sizeToDimension(e,t){if(t<0||t>e.length)throw new Error(`invalid dimension of ${t} for sizeToDimension as Tensor has ${e.length} dimensions.`);return p.getSizeFromDimensionRange(e,0,t)}static getSizeFromDimensionRange(e,t,r){let n=1;for(let a=t;a<r;a++){if(e[a]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");n*=e[a]}return n}static computeStrides(e){const t=e.length;if(0===t)return[];if(1===t)return[1];const r=new Array(t);r[t-1]=1,r[t-2]=e[t-1];for(let n=t-3;n>=0;--n)r[n]=r[n+1]*e[n+1];return r}static transpose(e){return e.slice().reverse()}static indicesToOffset(e,t,r){void 0===r&&(r=e.length);let n=0;for(let a=0;a<r;++a)n+=t[a]*e[a];return n}static offsetToIndices(e,t){const r=t.length;if(0===r)return[];if(1===r)return[e*t[0]];const n=new Array(t.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/t[r]),e-=n[r]*t[r];return n[n.length-1]=e,n}static normalizeAxis(e,t){if(e<-t&&e>=t)throw new Error("unsupported axis for this operation.");return e<0?e+t:e}static normalizeAxes(e,t){return e.map((e=>this.normalizeAxis(e,t)))}static incrementIndex(e,t,r){if(0===t.length||0===e.length)throw new Error("Index incrementing unsupported for scalar Tensor");if(void 0===r)r=t.length;else if(r<=0||r>t.length)throw new Error("Incorrect axis to increment on");for(let n=r-1;n>=0&&(e[n]++,!(e[n]<t[n]));--n)e[n]=0}static calculateReshapedDims(e,t){if(0===t.length){if(0===e.length||1===p.size(e))return[];throw new Error("cannot reshape to a scalar Tensor")}const r=t.length,n=new Array(r);let a=-1,o=1;for(let i=0;i<r;i++){if(t[i]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(-1===t[i]){if(-1!==a)throw new Error("at most one dimension in shape hints can be -1");a=i}else{if(0===t[i]){if(i>=e.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");n[i]=e[i]}else n[i]=t[i];o*=n[i]}}const i=p.size(e);if(-1!==a){if(i%o!=0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${e}] Output shape: [${t}]`);n[a]=i/o}else if(o!==i)throw new Error("reshapedDims and originalDims don't have matching sizes");return n}static sortBasedOnPerm(e,t){return t?t.map((t=>e[t])):e.slice().reverse()}static padShape(e,t){const r=e.length;return e.map(((e,n)=>e+t[n]+t[n+r]))}static areEqual(e,t){return e.length===t.length&&e.every(((e,r)=>e===t[r]))}static validateDimsAndCalcSize(e){if(e.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let t=1;for(const r of e){if(!Number.isInteger(r))throw new TypeError(`Invalid shape: ${r} is not an integer`);if(r<0||r>2147483647)throw new TypeError(`Invalid shape: length ${r} is not allowed`);t*=r}return t}static flattenShape(e,t){t<0&&(t+=e.length);const r=e.reduce(((e,t)=>e*t),1),n=e.slice(t).reduce(((e,t)=>e*t),1);return[r/n,n]}static squeezeShape(e,t){const r=new Array;t=p.normalizeAxes(t,e.length);for(let n=0;n<e.length;n++){const a=t.indexOf(n)>=0;if(a&&1!==e[n])throw new Error("squeeze an axis of size different than 1");(0===t.length&&e[n]>1||t.length>0&&!a)&&r.push(e[n])}return r}static unsqueezeShape(e,t){const r=new Array(e.length+t.length);r.fill(0);for(let e=0;e<t.length;e++){const n=p.normalizeAxis(t[e],r.length);if(n>=r.length)throw new Error("'axes' has an out of range axis");if(0!==r[n])throw new Error("'axes' has a duplicate axis");r[n]=1}let n=0;for(let t=0;t<r.length;t++)0===r[t]&&(r[t]=e[n++]);if(n!==e.length)throw new Error("the unsqueezed dimension could not be established");return r}}t.ShapeUtil=p,t.MathUtil=class{static sqr(e,t,r,n,a){if(n<0||n>=t.length)throw new Error("sourceIndex out of bounds");if(r<0||r>=e.length)throw new Error("targetIndex out of bounds");if(n+a>t.length)throw new Error("source indices to be copied are outside bounds");if(r+a>e.length)throw new Error("target array is too small to hold result");for(let o=0;o<a;o++)e[r+o]+=Math.pow(t[n+o],2)}static axpy(e,t,r,n,a,o){if(n<0||n>=t.length)throw new Error("sourceIndex out of bounds");if(r<0||r>=e.length)throw new Error("targetIndex out of bounds");if(n+a>t.length)throw new Error("source indices to be copied are outside bounds");if(r+a>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<a;i++)e[r+i]+=o*t[n+i]}static powx(e,t,r,n,a,o){if(n<0||n>=t.length)throw new Error("sourceIndex out of bounds");if(r<0||r>=e.length)throw new Error("targetIndex out of bounds");if(n+a>t.length)throw new Error("source indices to be copied are outside bounds");if(r+a>e.length)throw new Error("target array is too small to hold result");for(let i=0;i<a;i++)e[r+i]=Math.pow(t[n+i],o)}static mul(e,t,r,n,a){if(n<0||n>=t.length)throw new Error("sourceIndex out of bounds");if(r<0||r>=e.length)throw new Error("targetIndex out of bounds");if(n+a>t.length)throw new Error("source indices to be copied are outside bounds");if(r+a>e.length)throw new Error("target array is too small to hold result");for(let o=0;o<a;o++)e[r+o]=t[n+o]*e[r+o]}};class g{static splitShape(e,t,r,n){if(0===r.length){if(!n)throw new Error("need to know number of outputs when the 'split' attribute is not specified");g.determineSplit(e[t],n,r)}const a=[],o=[0];for(let n=0;n<r.length;++n){0!==n&&o.push(o[n-1]+r[n-1]);const i=e.slice();i[t]=r[n],a.push(i)}return[a,o]}static determineSplit(e,t,r){if(e%t!=0)throw new Error("cannot split tensor to equal sized parts");for(let n=0;n<t;++n)r.push(e/t)}}t.SplitUtil=g;class A{static calcReduce(e,t,r,n,a){const o=e.dims.slice(0);0===t.length&&o.forEach(((e,r)=>t.push(r)));const i=A.calcReduceShape(o,t,!0),l=p.size(i),u=new s.Tensor(i,e.type),c=p.computeStrides(i),g=p.computeStrides(o),h=new Array(o.length);for(let r=0;r<l;r++){const i=p.offsetToIndices(r,c);d.fillIndex(i,o,h),u.set(i,A.calcReduceByAxis(e.numberData,t,o,0,p.indicesToOffset(h,g),n,a))}return r?u:new s.Tensor(A.calcReduceShape(o,t,r),u.type,void 0,void 0,u.data,u.dataId)}static calcReduceByAxis(e,t,r,n,a,o,i){let s=0;if(n>=t.length)return o(e[a]);const l=t[n],d=l>=r.length?1:p.size(r.slice(l+1));for(let u=0;u<r[l];u++)s=0===u?A.calcReduceByAxis(e,t,r,n+1,a,o,i):i(s,A.calcReduceByAxis(e,t,r,n+1,a,o,i)),a+=d;return s}static calcReduceShape(e,t,r){const n=e.slice();for(let e=0;e<t.length;e++)n[t[e]]=r?1:0;return n.filter((e=>0!==e))}}t.ReduceUtil=A;class h{static adjustPoolAttributes(e,t,r,n,a,o){if(!e&&r.length!==t.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(e)for(let e=0;e<t.length-2;e++)e>=r.length?r.push(t[e+2]):r[e]=t[e+2];for(let e=0;e<r.length;e++)if(e<n.length){if(n[e]<0)throw new Error("strides should be greater than or equal to 1")}else n.push(1);for(let e=0;e<r.length;e++)if(e<a.length){if(a[e]<0)throw new Error("dilations should be greater than or equal to 1")}else a.push(1);for(let e=0;e<2*r.length;e++)if(e<o.length){if(o[e]<0)throw new Error("pad should be greater than or equal to 1")}else o.push(0);for(let e=0;e<r.length;e++){if(r[e]<=0)throw new Error("kernel shapes need to be greater than 0");if(o[e]>=r[e]||o[e+r.length]>=r[e])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(e,t,r,n,a,o){if(o){if(a.length!==2*(e.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(t.length!==e.length-2)throw new Error("length of strides should be the length of data dimensions");if(n.length!==e.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let i=0;i<e.length-2;i++)h.adjustPadAndReturnShape(e[i+2],t[i],r[i],n[i],a,i,i+e.length-2,o)}}static computePoolOutputShape(e,t,r,n,a,o,i){if(t.length<=0)throw new Error("input shape must be of size greater than 0");const s=[t[0],t[1]];return h.computeShapeHelper(e,t,s,r,n,a,o,i),s}static computeConvOutputShape(e,t,r,n,a,o,i){if(e.length<=0||t.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");const s=[e[0],t[0]];return h.computeShapeHelper(!1,e,s,r,n,a,o,i),s}static computeShapeHelper(e,t,r,n,a,o,i,s){if(e)for(let e=0;e<t.length-2;e++)r.push(1);else for(let e=0;e<t.length-2;e++)r.push(h.adjustPadAndReturnShape(t[e+2],n[e],a[e],o[e],i,e,e+t.length-2,s))}static adjustPadAndReturnShape(e,t,r,n,a,o,i,s){const l=r*(n-1)+1;if(!s||"NOTSET"===s)return Math.floor((e+a[o]+a[i]-l)/t+1);switch(s){case"VALID":return a[o]=0,a[i]=0,Math.floor((e-l)/t+1);case"SAME_LOWER":case"SAME_UPPER":if(1!==r)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{const r=((e+t-1)/t-1)*t+n-e;return a[o]="SAME_LOWER"===s?Math.floor((r+1)/2):Math.floor(r/2),a[i]=r-a[o],Math.floor((e+r-n)/t+1)}default:throw new Error("Unsupported AutoPad type")}}}t.PoolConvUtil=h,t.MIN_CLIP=-34028234663852886e22,t.MAX_CLIP=34028234663852886e22,t.decodeUtf8String=function(e){return(new TextDecoder).decode(e)}},7967:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,r,n,a)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw new Error("Circular reference in options");n.add(e)}Object.entries(e).forEach((([e,o])=>{const i=r?r+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",n,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can't handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},2157:function(e,t,r){var n,a=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),o=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&a(t,e,r);return o(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=t.initWasm=void 0;const s=r(1670),l=i(r(349)),d=r(6361),u=()=>!!s.env.wasm.proxy&&"undefined"!=typeof document;let c,p,g,A=!1,h=!1,B=!1;const m=[],C=[],w=[],b=[],K=[],f=[],Q=()=>{if(A||!h||B||!c)throw new Error("worker not ready")},W=e=>{switch(e.data.type){case"init-wasm":A=!1,e.data.err?(B=!0,p[1](e.data.err)):(h=!0,p[0]());break;case"init-ort":e.data.err?g[1](e.data.err):g[0]();break;case"create_allocate":e.data.err?m.shift()[1](e.data.err):m.shift()[0](e.data.out);break;case"create_finalize":e.data.err?C.shift()[1](e.data.err):C.shift()[0](e.data.out);break;case"create":e.data.err?w.shift()[1](e.data.err):w.shift()[0](e.data.out);break;case"release":e.data.err?b.shift()[1](e.data.err):b.shift()[0]();break;case"run":e.data.err?K.shift()[1](e.data.err):K.shift()[0](e.data.out);break;case"end-profiling":e.data.err?f.shift()[1](e.data.err):f.shift()[0]()}},F="undefined"!=typeof document?null===(n=null===document||void 0===document?void 0:document.currentScript)||void 0===n?void 0:n.src:void 0;t.initWasm=async()=>{if(u()){if(h)return;if(A)throw new Error("multiple calls to 'initWasm()' detected.");if(B)throw new Error("previous call to 'initWasm()' failed.");return A=!0,void 0===s.env.wasm.wasmPaths&&F&&0!==F.indexOf("blob:")&&(s.env.wasm.wasmPaths=F.substr(0,+F.lastIndexOf("/")+1)),new Promise(((e,t)=>{null==c||c.terminate(),c=r(9710).Z(),c.onmessage=W,p=[e,t];const n={type:"init-wasm",in:s.env.wasm};c.postMessage(n)}))}return(0,d.initializeWebAssembly)(s.env.wasm)},t.initOrt=async(e,t)=>{if(u())return Q(),new Promise(((r,n)=>{g=[r,n];const a={type:"init-ort",in:{numThreads:e,loggingLevel:t}};c.postMessage(a)}));l.initOrt(e,t)},t.createSessionAllocate=async e=>u()?(Q(),new Promise(((t,r)=>{m.push([t,r]);const n={type:"create_allocate",in:{model:e}};c.postMessage(n,[e.buffer])}))):l.createSessionAllocate(e),t.createSessionFinalize=async(e,t)=>u()?(Q(),new Promise(((r,n)=>{C.push([r,n]);const a={type:"create_finalize",in:{modeldata:e,options:t}};c.postMessage(a)}))):l.createSessionFinalize(e,t),t.createSession=async(e,t)=>u()?(Q(),new Promise(((r,n)=>{w.push([r,n]);const a={type:"create",in:{model:e,options:t}};c.postMessage(a,[e.buffer])}))):l.createSession(e,t),t.releaseSession=async e=>{if(u())return Q(),new Promise(((t,r)=>{b.push([t,r]);const n={type:"release",in:e};c.postMessage(n)}));l.releaseSession(e)},t.run=async(e,t,r,n,a)=>u()?(Q(),new Promise(((o,i)=>{K.push([o,i]);const s={type:"run",in:{sessionId:e,inputIndices:t,inputs:r,outputIndices:n,options:a}};c.postMessage(s,l.extractTransferableBuffers(r))}))):l.run(e,t,r,n,a),t.endProfiling=async e=>{if(u())return Q(),new Promise(((t,r)=>{f.push([t,r]);const n={type:"end-profiling",in:e};c.postMessage(n)}));l.endProfiling(e)}},586:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const n=r(7967),a=r(4983),o=r(6361);t.setRunOptions=e=>{const t=(0,o.getInstance)();let r=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=(0,a.allocWasmString)(e.tag,i)),r=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===r)throw new Error("Can't create run options");return void 0!==(null==e?void 0:e.extra)&&(0,n.iterateExtraOptions)(e.extra,"",new WeakSet,((e,n)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(n,i);if(0!==t._OrtAddRunConfigEntry(r,o,s))throw new Error(`Can't set a run config entry: ${e} - ${n}`)})),[r,i]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),i.forEach(t._free),e}}},2306:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.OnnxruntimeWebAssemblySessionHandler=void 0;const n=r(2806),a=r(1670),o=r(2850),i=r(2157);let s;t.OnnxruntimeWebAssemblySessionHandler=class{async createSessionAllocate(e){const t=await fetch(e),r=await t.arrayBuffer();return(0,i.createSessionAllocate)(new Uint8Array(r))}async loadModel(e,t){if(s||(await(0,i.initOrt)(a.env.wasm.numThreads,(e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}})(a.env.logLevel)),s=!0),"string"==typeof e)if("undefined"==typeof fetch){const r=await(0,o.promisify)(n.readFile)(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSession)(r,t)}else{const r=await this.createSessionAllocate(e);[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSessionFinalize)(r,t)}else[this.sessionId,this.inputNames,this.outputNames]=await(0,i.createSession)(e,t)}async dispose(){return(0,i.releaseSession)(this.sessionId)}async run(e,t,r){const n=[],o=[];Object.entries(e).forEach((e=>{const t=e[0],r=e[1],a=this.inputNames.indexOf(t);if(-1===a)throw new Error(`invalid input '${t}'`);n.push(r),o.push(a)}));const s=[];Object.entries(t).forEach((e=>{const t=e[0],r=this.outputNames.indexOf(t);if(-1===r)throw new Error(`invalid output '${t}'`);s.push(r)}));const l=await(0,i.run)(this.sessionId,o,n.map((e=>[e.type,e.dims,e.data])),s,r),d={};for(let e=0;e<l.length;e++)d[this.outputNames[s[e]]]=new a.Tensor(l[e][0],l[e][2],l[e][1]);return d}startProfiling(){}endProfiling(){(0,i.endProfiling)(this.sessionId)}}},4919:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const n=r(7967),a=r(4983),o=r(6361);t.setSessionOptions=e=>{const t=(0,o.getInstance)();let r=0;const i=[],s=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1")})(s);try{void 0===(null==e?void 0:e.graphOptimizationLevel)&&(s.graphOptimizationLevel="all");const l=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(s.graphOptimizationLevel);void 0===(null==e?void 0:e.enableCpuMemArena)&&(s.enableCpuMemArena=!0),void 0===(null==e?void 0:e.enableMemPattern)&&(s.enableMemPattern=!0),void 0===(null==e?void 0:e.executionMode)&&(s.executionMode="sequential");const d=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(s.executionMode);let u=0;if(void 0!==(null==e?void 0:e.logId)&&(u=(0,a.allocWasmString)(e.logId,i)),void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);if(void 0===(null==e?void 0:e.enableProfiling)&&(s.enableProfiling=!1),r=t._OrtCreateSessionOptions(l,!!s.enableCpuMemArena,!!s.enableMemPattern,d,!!s.enableProfiling,0,u,s.logSeverityLevel,s.logVerbosityLevel),0===r)throw new Error("Can't create session options");return(null==e?void 0:e.executionProviders)&&((e,t,r)=>{for(const n of t){let t="string"==typeof n?n:n.name;switch(t){case"xnnpack":t="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,a.allocWasmString)(t,r);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can't append execution provider: ${t}`)}})(r,e.executionProviders,i),void 0!==(null==e?void 0:e.extra)&&(0,n.iterateExtraOptions)(e.extra,"",new WeakSet,((e,n)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(n,i);if(0!==t._OrtAddSessionConfigEntry(r,o,s))throw new Error(`Can't set a session config entry: ${e} - ${n}`)})),[r,i]}catch(e){throw 0!==r&&t._OrtReleaseSessionOptions(r),i.forEach(t._free),e}}},4983:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const n=r(6361);t.allocWasmString=(e,t)=>{const r=(0,n.getInstance)(),a=r.lengthBytesUTF8(e)+1,o=r._malloc(a);return r.stringToUTF8(e,o,a),t.push(o),o}},349:(e,t,r)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const n=r(586),a=r(4919),o=r(4983),i=r(6361);t.initOrt=(e,t)=>{const r=(0,i.getInstance)()._OrtInit(e,t);if(0!==r)throw new Error(`Can't initialize onnxruntime. error code = ${r}`)};const s=new Map;t.createSessionAllocate=e=>{const t=(0,i.getInstance)(),r=t._malloc(e.byteLength);return t.HEAPU8.set(e,r),[r,e.byteLength]},t.createSessionFinalize=(e,t)=>{const r=(0,i.getInstance)();let n=0,o=0,l=[];try{if([o,l]=(0,a.setSessionOptions)(t),n=r._OrtCreateSession(e[0],e[1],o),0===n)throw new Error("Can't create a session")}finally{r._free(e[0]),r._OrtReleaseSessionOptions(o),l.forEach(r._free)}const d=r._OrtGetInputCount(n),u=r._OrtGetOutputCount(n),c=[],p=[],g=[],A=[];for(let e=0;e<d;e++){const t=r._OrtGetInputName(n,e);if(0===t)throw new Error("Can't get an input name");p.push(t),c.push(r.UTF8ToString(t))}for(let e=0;e<u;e++){const t=r._OrtGetOutputName(n,e);if(0===t)throw new Error("Can't get an output name");A.push(t),g.push(r.UTF8ToString(t))}return s.set(n,[n,p,A]),[n,c,g]},t.createSession=(e,r)=>{const n=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(n,r)},t.releaseSession=e=>{const t=(0,i.getInstance)(),r=s.get(e);if(!r)throw new Error("invalid session id");const n=r[0],a=r[1],o=r[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(n),s.delete(e)};const l=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},d=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},u=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}};t.run=(e,t,r,a,c)=>{const p=(0,i.getInstance)(),g=s.get(e);if(!g)throw new Error("invalid session id");const A=g[0],h=g[1],B=g[2],m=t.length,C=a.length;let w=0,b=[];const K=[],f=[];try{[w,b]=(0,n.setRunOptions)(c);for(let e=0;e<m;e++){const t=r[e][0],n=r[e][1],a=r[e][2];let i,s;if(Array.isArray(a)){s=4*a.length,i=p._malloc(s),f.push(i);let e=i/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);p.HEAPU32[e++]=(0,o.allocWasmString)(a[t],f)}}else s=a.byteLength,i=p._malloc(s),f.push(i),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,s),i);const d=p.stackSave(),u=p.stackAlloc(4*n.length);try{let e=u/4;n.forEach((t=>p.HEAP32[e++]=t));const r=p._OrtCreateTensor(l(t),i,s,u,n.length);if(0===r)throw new Error("Can't create a tensor");K.push(r)}finally{p.stackRestore(d)}}const e=p.stackSave(),i=p.stackAlloc(4*m),s=p.stackAlloc(4*m),g=p.stackAlloc(4*C),Q=p.stackAlloc(4*C);try{let e=i/4,r=s/4,n=g/4,o=Q/4;for(let n=0;n<m;n++)p.HEAPU32[e++]=K[n],p.HEAPU32[r++]=h[t[n]];for(let e=0;e<C;e++)p.HEAPU32[n++]=0,p.HEAPU32[o++]=B[a[e]];let l=p._OrtRun(A,s,i,m,Q,C,g,w);const c=[];if(0===l)for(let e=0;e<C;e++){const t=p.HEAPU32[g/4+e],r=p.stackSave(),n=p.stackAlloc(16);let a,o=0;try{if(l=p._OrtGetTensorData(t,n,n+4,n+8,n+12),0!==l)throw new Error(`Can't access output tensor data. error code = ${l}`);let e=n/4;const r=p.HEAPU32[e++];o=p.HEAPU32[e++];const i=p.HEAPU32[e++],s=p.HEAPU32[e++],g=[];for(let e=0;e<s;e++)g.push(p.HEAPU32[i/4+e]);p._OrtFree(i);const A=0===g.length?1:g.reduce(((e,t)=>e*t));if(a=d(r),"string"===a){const e=[];let t=o/4;for(let r=0;r<A;r++){const n=p.HEAPU32[t++],a=r===A-1?void 0:p.HEAPU32[t]-n;e.push(p.UTF8ToString(n,a))}c.push([a,g,e])}else{const e=new(u(a))(A);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(p.HEAPU8.subarray(o,o+e.byteLength)),c.push([a,g,e])}}finally{p.stackRestore(r),"string"===a&&o&&p._free(o),p._OrtReleaseTensor(t)}}if(0===l)return c;throw new Error(`failed to call OrtRun(). error code = ${l}.`)}finally{p.stackRestore(e)}}finally{K.forEach(p._OrtReleaseTensor),f.forEach(p._free),p._OrtReleaseRunOptions(w),b.forEach(p._free)}},t.endProfiling=e=>{const t=(0,i.getInstance)(),r=s.get(e);if(!r)throw new Error("invalid session id");const n=r[0],a=t._OrtEndProfiling(n);if(0===a)throw new Error("Can't get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const r of e){const e=r[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},6361:function(e,t,r){var n=this&&this.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&n(t,e,r);return a(t,e),t},i=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const s=o(r(6449)),l=i(r(932)),d=r(3474);let u,c=!1,p=!1,g=!1;const A=(e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm";t.initializeWebAssembly=async e=>{if(c)return Promise.resolve();if(p)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(g)throw new Error("previous call to 'initializeWebAssembly()' failed.");p=!0;const t=e.initTimeout,n=e.numThreads,a=e.simd,o=n>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),i=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),h="string"==typeof e.wasmPaths?e.wasmPaths:void 0,B=A(!1,o),m=A(i,o),C="object"==typeof e.wasmPaths?e.wasmPaths[m]:void 0;let w=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{w=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const n=o?d:l.default,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([r(4154)],{type:"text/javascript"})):e===B?null!=C?C:(null!=h?h:t)+m:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=s.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${n.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}n(a).then((t=>{p=!1,c=!0,u=t,e()}),(e=>{p=!1,g=!0,t(e)}))}))),await Promise.race(b),w)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(c&&u)return u;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!c||p||g||(p=!0,null===(e=u.PThread)||void 0===e||e.terminateAllThreads(),u=void 0,p=!1,c=!1,g=!0)}},9710:(e,t,r)=>{r.d(t,{Z:()=>o});var n=r(477),a=r.n(n);function o(){return a()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n',"Worker",void 0,void 0)}},477:e=>{e.exports=function(e,t,r,n){var a=self||window;try{try{var o;try{o=new a.Blob([e])}catch(t){(o=new(a.BlobBuilder||a.WebKitBlobBuilder||a.MozBlobBuilder||a.MSBlobBuilder)).append(e),o=o.getBlob()}var i=a.URL||a.webkitURL,s=i.createObjectURL(o),l=new a[t](s,r);return i.revokeObjectURL(s),l}catch(n){return new a[t]("data:application/javascript,".concat(encodeURIComponent(e)),r)}}catch(e){if(!n)throw Error("Inline worker is not supported");return new a[t](n,r)}}},4154:e=>{e.exports='"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n'},1670:e=>{e.exports=__WEBPACK_EXTERNAL_MODULE__1670__},7067:()=>{},1296:()=>{},1384:()=>{},3993:()=>{},908:()=>{},6953:()=>{},9925:()=>{},2806:()=>{},6449:()=>{},2850:()=>{},5381:()=>{},5686:(e,t,r)=>{r.r(t),r.d(t,{flatbuffers:()=>n});var n={};n.Offset,n.Table,n.SIZEOF_SHORT=2,n.SIZEOF_INT=4,n.FILE_IDENTIFIER_LENGTH=4,n.SIZE_PREFIX_LENGTH=4,n.Encoding={UTF8_BYTES:1,UTF16_STRING:2},n.int32=new Int32Array(2),n.float32=new Float32Array(n.int32.buffer),n.float64=new Float64Array(n.int32.buffer),n.isLittleEndian=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0],n.Long=function(e,t){this.low=0|e,this.high=0|t},n.Long.create=function(e,t){return 0==e&&0==t?n.Long.ZERO:new n.Long(e,t)},n.Long.prototype.toFloat64=function(){return(this.low>>>0)+4294967296*this.high},n.Long.prototype.equals=function(e){return this.low==e.low&&this.high==e.high},n.Long.ZERO=new n.Long(0,0),n.Builder=function(e){if(e)t=e;else var t=1024;this.bb=n.ByteBuffer.allocate(t),this.space=t,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},n.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},n.Builder.prototype.forceDefaults=function(e){this.force_defaults=e},n.Builder.prototype.dataBuffer=function(){return this.bb},n.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},n.Builder.prototype.prep=function(e,t){e>this.minalign&&(this.minalign=e);for(var r=1+~(this.bb.capacity()-this.space+t)&e-1;this.space<r+e+t;){var a=this.bb.capacity();this.bb=n.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-a}this.pad(r)},n.Builder.prototype.pad=function(e){for(var t=0;t<e;t++)this.bb.writeInt8(--this.space,0)},n.Builder.prototype.writeInt8=function(e){this.bb.writeInt8(this.space-=1,e)},n.Builder.prototype.writeInt16=function(e){this.bb.writeInt16(this.space-=2,e)},n.Builder.prototype.writeInt32=function(e){this.bb.writeInt32(this.space-=4,e)},n.Builder.prototype.writeInt64=function(e){this.bb.writeInt64(this.space-=8,e)},n.Builder.prototype.writeFloat32=function(e){this.bb.writeFloat32(this.space-=4,e)},n.Builder.prototype.writeFloat64=function(e){this.bb.writeFloat64(this.space-=8,e)},n.Builder.prototype.addInt8=function(e){this.prep(1,0),this.writeInt8(e)},n.Builder.prototype.addInt16=function(e){this.prep(2,0),this.writeInt16(e)},n.Builder.prototype.addInt32=function(e){this.prep(4,0),this.writeInt32(e)},n.Builder.prototype.addInt64=function(e){this.prep(8,0),this.writeInt64(e)},n.Builder.prototype.addFloat32=function(e){this.prep(4,0),this.writeFloat32(e)},n.Builder.prototype.addFloat64=function(e){this.prep(8,0),this.writeFloat64(e)},n.Builder.prototype.addFieldInt8=function(e,t,r){(this.force_defaults||t!=r)&&(this.addInt8(t),this.slot(e))},n.Builder.prototype.addFieldInt16=function(e,t,r){(this.force_defaults||t!=r)&&(this.addInt16(t),this.slot(e))},n.Builder.prototype.addFieldInt32=function(e,t,r){(this.force_defaults||t!=r)&&(this.addInt32(t),this.slot(e))},n.Builder.prototype.addFieldInt64=function(e,t,r){!this.force_defaults&&t.equals(r)||(this.addInt64(t),this.slot(e))},n.Builder.prototype.addFieldFloat32=function(e,t,r){(this.force_defaults||t!=r)&&(this.addFloat32(t),this.slot(e))},n.Builder.prototype.addFieldFloat64=function(e,t,r){(this.force_defaults||t!=r)&&(this.addFloat64(t),this.slot(e))},n.Builder.prototype.addFieldOffset=function(e,t,r){(this.force_defaults||t!=r)&&(this.addOffset(t),this.slot(e))},n.Builder.prototype.addFieldStruct=function(e,t,r){t!=r&&(this.nested(t),this.slot(e))},n.Builder.prototype.nested=function(e){if(e!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},n.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},n.Builder.prototype.slot=function(e){this.vtable[e]=this.offset()},n.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},n.Builder.growByteBuffer=function(e){var t=e.capacity();if(3221225472&t)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var r=t<<1,a=n.ByteBuffer.allocate(r);return a.setPosition(r-t),a.bytes().set(e.bytes(),r-t),a},n.Builder.prototype.addOffset=function(e){this.prep(n.SIZEOF_INT,0),this.writeInt32(this.offset()-e+n.SIZEOF_INT)},n.Builder.prototype.startObject=function(e){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=e;for(var t=0;t<e;t++)this.vtable[t]=0;this.isNested=!0,this.object_start=this.offset()},n.Builder.prototype.endObject=function(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var e=this.offset(),t=this.vtable_in_use-1;t>=0&&0==this.vtable[t];t--);for(var r=t+1;t>=0;t--)this.addInt16(0!=this.vtable[t]?e-this.vtable[t]:0);this.addInt16(e-this.object_start);var a=(r+2)*n.SIZEOF_SHORT;this.addInt16(a);var o=0,i=this.space;e:for(t=0;t<this.vtables.length;t++){var s=this.bb.capacity()-this.vtables[t];if(a==this.bb.readInt16(s)){for(var l=n.SIZEOF_SHORT;l<a;l+=n.SIZEOF_SHORT)if(this.bb.readInt16(i+l)!=this.bb.readInt16(s+l))continue e;o=this.vtables[t];break}}return o?(this.space=this.bb.capacity()-e,this.bb.writeInt32(this.space,o-e)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-e,this.offset()-e)),this.isNested=!1,e},n.Builder.prototype.finish=function(e,t,r){var a=r?n.SIZE_PREFIX_LENGTH:0;if(t){var o=t;if(this.prep(this.minalign,n.SIZEOF_INT+n.FILE_IDENTIFIER_LENGTH+a),o.length!=n.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+n.FILE_IDENTIFIER_LENGTH);for(var i=n.FILE_IDENTIFIER_LENGTH-1;i>=0;i--)this.writeInt8(o.charCodeAt(i))}this.prep(this.minalign,n.SIZEOF_INT+a),this.addOffset(e),a&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},n.Builder.prototype.finishSizePrefixed=function(e,t){this.finish(e,t,!0)},n.Builder.prototype.requiredField=function(e,t){var r=this.bb.capacity()-e,n=r-this.bb.readInt32(r);if(0==this.bb.readInt16(n+t))throw new Error("FlatBuffers: field "+t+" must be set")},n.Builder.prototype.startVector=function(e,t,r){this.notNested(),this.vector_num_elems=t,this.prep(n.SIZEOF_INT,e*t),this.prep(r,e*t)},n.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},n.Builder.prototype.createString=function(e){if(e instanceof Uint8Array)var t=e;else{t=[];for(var r=0;r<e.length;){var n,a=e.charCodeAt(r++);(n=a<55296||a>=56320?a:(a<<10)+e.charCodeAt(r++)+-56613888)<128?t.push(n):(n<2048?t.push(n>>6&31|192):(n<65536?t.push(n>>12&15|224):t.push(n>>18&7|240,n>>12&63|128),t.push(n>>6&63|128)),t.push(63&n|128))}}this.addInt8(0),this.startVector(1,t.length,1),this.bb.setPosition(this.space-=t.length),r=0;for(var o=this.space,i=this.bb.bytes();r<t.length;r++)i[o++]=t[r];return this.endVector()},n.Builder.prototype.createLong=function(e,t){return n.Long.create(e,t)},n.ByteBuffer=function(e){this.bytes_=e,this.position_=0},n.ByteBuffer.allocate=function(e){return new n.ByteBuffer(new Uint8Array(e))},n.ByteBuffer.prototype.clear=function(){this.position_=0},n.ByteBuffer.prototype.bytes=function(){return this.bytes_},n.ByteBuffer.prototype.position=function(){return this.position_},n.ByteBuffer.prototype.setPosition=function(e){this.position_=e},n.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},n.ByteBuffer.prototype.readInt8=function(e){return this.readUint8(e)<<24>>24},n.ByteBuffer.prototype.readUint8=function(e){return this.bytes_[e]},n.ByteBuffer.prototype.readInt16=function(e){return this.readUint16(e)<<16>>16},n.ByteBuffer.prototype.readUint16=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8},n.ByteBuffer.prototype.readInt32=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8|this.bytes_[e+2]<<16|this.bytes_[e+3]<<24},n.ByteBuffer.prototype.readUint32=function(e){return this.readInt32(e)>>>0},n.ByteBuffer.prototype.readInt64=function(e){return new n.Long(this.readInt32(e),this.readInt32(e+4))},n.ByteBuffer.prototype.readUint64=function(e){return new n.Long(this.readUint32(e),this.readUint32(e+4))},n.ByteBuffer.prototype.readFloat32=function(e){return n.int32[0]=this.readInt32(e),n.float32[0]},n.ByteBuffer.prototype.readFloat64=function(e){return n.int32[n.isLittleEndian?0:1]=this.readInt32(e),n.int32[n.isLittleEndian?1:0]=this.readInt32(e+4),n.float64[0]},n.ByteBuffer.prototype.writeInt8=function(e,t){this.bytes_[e]=t},n.ByteBuffer.prototype.writeUint8=function(e,t){this.bytes_[e]=t},n.ByteBuffer.prototype.writeInt16=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8},n.ByteBuffer.prototype.writeUint16=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8},n.ByteBuffer.prototype.writeInt32=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8,this.bytes_[e+2]=t>>16,this.bytes_[e+3]=t>>24},n.ByteBuffer.prototype.writeUint32=function(e,t){this.bytes_[e]=t,this.bytes_[e+1]=t>>8,this.bytes_[e+2]=t>>16,this.bytes_[e+3]=t>>24},n.ByteBuffer.prototype.writeInt64=function(e,t){this.writeInt32(e,t.low),this.writeInt32(e+4,t.high)},n.ByteBuffer.prototype.writeUint64=function(e,t){this.writeUint32(e,t.low),this.writeUint32(e+4,t.high)},n.ByteBuffer.prototype.writeFloat32=function(e,t){n.float32[0]=t,this.writeInt32(e,n.int32[0])},n.ByteBuffer.prototype.writeFloat64=function(e,t){n.float64[0]=t,this.writeInt32(e,n.int32[n.isLittleEndian?0:1]),this.writeInt32(e+4,n.int32[n.isLittleEndian?1:0])},n.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+n.SIZEOF_INT+n.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var e="",t=0;t<n.FILE_IDENTIFIER_LENGTH;t++)e+=String.fromCharCode(this.readInt8(this.position_+n.SIZEOF_INT+t));return e},n.ByteBuffer.prototype.__offset=function(e,t){var r=e-this.readInt32(e);return t<this.readInt16(r)?this.readInt16(r+t):0},n.ByteBuffer.prototype.__union=function(e,t){return e.bb_pos=t+this.readInt32(t),e.bb=this,e},n.ByteBuffer.prototype.__string=function(e,t){e+=this.readInt32(e);var r=this.readInt32(e),a="",o=0;if(e+=n.SIZEOF_INT,t===n.Encoding.UTF8_BYTES)return this.bytes_.subarray(e,e+r);for(;o<r;){var i,s=this.readUint8(e+o++);if(s<192)i=s;else{var l=this.readUint8(e+o++);if(s<224)i=(31&s)<<6|63&l;else{var d=this.readUint8(e+o++);i=s<240?(15&s)<<12|(63&l)<<6|63&d:(7&s)<<18|(63&l)<<12|(63&d)<<6|63&this.readUint8(e+o++)}}i<65536?a+=String.fromCharCode(i):(i-=65536,a+=String.fromCharCode(55296+(i>>10),56320+(1023&i)))}return a},n.ByteBuffer.prototype.__indirect=function(e){return e+this.readInt32(e)},n.ByteBuffer.prototype.__vector=function(e){return e+this.readInt32(e)+n.SIZEOF_INT},n.ByteBuffer.prototype.__vector_len=function(e){return this.readInt32(e+this.readInt32(e))},n.ByteBuffer.prototype.__has_identifier=function(e){if(e.length!=n.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+n.FILE_IDENTIFIER_LENGTH);for(var t=0;t<n.FILE_IDENTIFIER_LENGTH;t++)if(e.charCodeAt(t)!=this.readInt8(this.position_+n.SIZEOF_INT+t))return!1;return!0},n.ByteBuffer.prototype.createLong=function(e,t){return n.Long.create(e,t)}}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var r=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(r.exports,r,r.exports,__webpack_require__),r.exports}__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var r in t)__webpack_require__.o(t,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__(6018);return __webpack_exports__})()))}(ortWeb_min)),ortWeb_min.exports}var assetPath={},hasRequiredAssetPath;function requireAssetPath(){if(hasRequiredAssetPath)return assetPath;hasRequiredAssetPath=1,Object.defineProperty(assetPath,"__esModule",{value:!0}),assetPath.baseAssetPath=void 0;const e="undefined"!=typeof window&&void 0!==window.document?window.document.currentScript:null;let t="/";return e&&(t=e.src.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/")),assetPath.baseAssetPath=t,assetPath}var defaultModelFetcher={},hasRequiredDefaultModelFetcher;function requireDefaultModelFetcher(){if(hasRequiredDefaultModelFetcher)return defaultModelFetcher;hasRequiredDefaultModelFetcher=1,Object.defineProperty(defaultModelFetcher,"__esModule",{value:!0}),defaultModelFetcher.defaultModelFetcher=void 0;return defaultModelFetcher.defaultModelFetcher=e=>fetch(e).then((e=>e.arrayBuffer())),defaultModelFetcher}var frameProcessor={},logging={},hasRequiredLogging;function requireLogging(){return hasRequiredLogging||(hasRequiredLogging=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.log=e.LOG_PREFIX=void 0,e.LOG_PREFIX="[VAD]";const t=["error","debug","warn"].reduce(((t,r)=>(t[r]=function(t){return(...r)=>{console[t](e.LOG_PREFIX,...r)}}(r),t)),{});e.log=t}(logging)),logging}var messages={},hasRequiredMessages,hasRequiredFrameProcessor;function requireMessages(){return hasRequiredMessages||(hasRequiredMessages=1,Object.defineProperty(messages,"__esModule",{value:!0}),messages.Message=void 0,function(e){e.AudioFrame="AUDIO_FRAME",e.SpeechStart="SPEECH_START",e.VADMisfire="VAD_MISFIRE",e.SpeechEnd="SPEECH_END",e.SpeechStop="SPEECH_STOP"}(e||(messages.Message=e={}))),messages;var e}function requireFrameProcessor(){if(hasRequiredFrameProcessor)return frameProcessor;hasRequiredFrameProcessor=1,Object.defineProperty(frameProcessor,"__esModule",{value:!0}),frameProcessor.FrameProcessor=frameProcessor.validateOptions=frameProcessor.defaultV5FrameProcessorOptions=frameProcessor.defaultLegacyFrameProcessorOptions=void 0;const e=requireLogging(),t=requireMessages(),r=[512,1024,1536];frameProcessor.defaultLegacyFrameProcessorOptions={positiveSpeechThreshold:.5,negativeSpeechThreshold:.35,preSpeechPadFrames:1,redemptionFrames:8,frameSamples:1536,minSpeechFrames:3,submitUserSpeechOnPause:!1},frameProcessor.defaultV5FrameProcessorOptions={positiveSpeechThreshold:.5,negativeSpeechThreshold:.35,preSpeechPadFrames:3,redemptionFrames:24,frameSamples:512,minSpeechFrames:9,submitUserSpeechOnPause:!1},frameProcessor.validateOptions=function(t){r.includes(t.frameSamples)||e.log.warn("You are using an unusual frame size"),(t.positiveSpeechThreshold<0||t.positiveSpeechThreshold>1)&&e.log.error("positiveSpeechThreshold should be a number between 0 and 1"),(t.negativeSpeechThreshold<0||t.negativeSpeechThreshold>t.positiveSpeechThreshold)&&e.log.error("negativeSpeechThreshold should be between 0 and positiveSpeechThreshold"),t.preSpeechPadFrames<0&&e.log.error("preSpeechPadFrames should be positive"),t.redemptionFrames<0&&e.log.error("redemptionFrames should be positive")};const n=e=>{const t=e.reduce(((e,t)=>(e.push(e.at(-1)+t.length),e)),[0]),r=new Float32Array(t.at(-1));return e.forEach(((e,n)=>{const a=t[n];r.set(e,a)})),r};return frameProcessor.FrameProcessor=class{constructor(e,r,a){this.modelProcessFunc=e,this.modelResetFunc=r,this.options=a,this.speaking=!1,this.redemptionCounter=0,this.active=!1,this.reset=()=>{this.speaking=!1,this.audioBuffer=[],this.modelResetFunc(),this.redemptionCounter=0},this.pause=()=>(this.active=!1,this.options.submitUserSpeechOnPause?this.endSegment():(this.reset(),{})),this.resume=()=>{this.active=!0},this.endSegment=()=>{const e=this.audioBuffer;this.audioBuffer=[];const r=this.speaking;this.reset();const a=e.reduce(((e,t)=>e+ +t.isSpeech),0);if(r){if(a>=this.options.minSpeechFrames){const r=n(e.map((e=>e.frame)));return{msg:t.Message.SpeechEnd,audio:r}}return{msg:t.Message.VADMisfire}}return{}},this.process=async e=>{if(!this.active)return{};const r=await this.modelProcessFunc(e);if(this.audioBuffer.push({frame:e,isSpeech:r.isSpeech>=this.options.positiveSpeechThreshold}),r.isSpeech>=this.options.positiveSpeechThreshold&&this.redemptionCounter&&(this.redemptionCounter=0),r.isSpeech>=this.options.positiveSpeechThreshold&&!this.speaking)return this.speaking=!0,{probs:r,msg:t.Message.SpeechStart,frame:e};if(r.isSpeech<this.options.negativeSpeechThreshold&&this.speaking&&++this.redemptionCounter>=this.options.redemptionFrames){this.redemptionCounter=0,this.speaking=!1;const a=this.audioBuffer;this.audioBuffer=[];if(a.reduce(((e,t)=>e+ +t.isSpeech),0)>=this.options.minSpeechFrames){const o=n(a.map((e=>e.frame)));return{probs:r,msg:t.Message.SpeechEnd,audio:o,frame:e}}return{probs:r,msg:t.Message.VADMisfire,frame:e}}if(!this.speaking)for(;this.audioBuffer.length>this.options.preSpeechPadFrames;)this.audioBuffer.shift();return{probs:r,frame:e}},this.audioBuffer=[],this.reset()}},frameProcessor}var nonRealTimeVad={},models={},common={},hasRequiredCommon;function requireCommon(){return hasRequiredCommon||(hasRequiredCommon=1,Object.defineProperty(common,"__esModule",{value:!0})),common}var legacy={},hasRequiredLegacy;function requireLegacy(){if(hasRequiredLegacy)return legacy;var e;hasRequiredLegacy=1,Object.defineProperty(legacy,"__esModule",{value:!0}),legacy.SileroLegacy=void 0;const t=requireLogging();class r{constructor(e,t,r,n,a){this.ortInstance=e,this._session=t,this._h=r,this._c=n,this._sr=a,this.reset_state=()=>{const e=Array(128).fill(0);this._h=new this.ortInstance.Tensor("float32",e,[2,1,64]),this._c=new this.ortInstance.Tensor("float32",e,[2,1,64])},this.process=async e=>{const t={input:new this.ortInstance.Tensor("float32",e,[1,e.length]),h:this._h,c:this._c,sr:this._sr},r=await this._session.run(t);this._h=r.hn,this._c=r.cn;const[n]=r.output?.data;return{notSpeech:1-n,isSpeech:n}}}}return legacy.SileroLegacy=r,e=r,r.new=async(r,n)=>{t.log.debug("initializing vad");const a=await n(),o=await r.InferenceSession.create(a),i=new r.Tensor("int64",[16000n]),s=Array(128).fill(0),l=new r.Tensor("float32",s,[2,1,64]),d=new r.Tensor("float32",s,[2,1,64]);t.log.debug("vad is initialized");return new e(r,o,l,d,i)},legacy}var v5={},hasRequiredV5,hasRequiredModels;function requireV5(){if(hasRequiredV5)return v5;var e;hasRequiredV5=1,Object.defineProperty(v5,"__esModule",{value:!0}),v5.SileroV5=void 0;const t=requireLogging();function r(e){const t=Array(256).fill(0);return new e.Tensor("float32",t,[2,1,128])}class n{constructor(e,t,n,a){this._session=e,this._state=t,this._sr=n,this.ortInstance=a,this.reset_state=()=>{this._state=r(this.ortInstance)},this.process=async e=>{const t={input:new this.ortInstance.Tensor("float32",e,[1,e.length]),state:this._state,sr:this._sr},r=await this._session.run(t);this._state=r.stateN;const[n]=r.output?.data;return{notSpeech:1-n,isSpeech:n}}}}return v5.SileroV5=n,e=n,n.new=async(n,a)=>{t.log.debug("Loading VAD...");const o=await a(),i=await n.InferenceSession.create(o),s=new n.Tensor("int64",[16000n]),l=r(n);return t.log.debug("...finished loading VAD"),new e(i,l,s,n)},v5}function requireModels(){return hasRequiredModels||(hasRequiredModels=1,function(e){var t=models&&models.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),r=models&&models.__exportStar||function(e,r){for(var n in e)"default"===n||Object.prototype.hasOwnProperty.call(r,n)||t(r,e,n)};Object.defineProperty(e,"__esModule",{value:!0}),e.SileroV5=e.SileroLegacy=void 0,r(requireCommon(),e);var n=requireLegacy();Object.defineProperty(e,"SileroLegacy",{enumerable:!0,get:function(){return n.SileroLegacy}});var a=requireV5();Object.defineProperty(e,"SileroV5",{enumerable:!0,get:function(){return a.SileroV5}})}(models)),models}var resampler={},hasRequiredResampler,hasRequiredNonRealTimeVad;function requireResampler(){if(hasRequiredResampler)return resampler;hasRequiredResampler=1,Object.defineProperty(resampler,"__esModule",{value:!0}),resampler.Resampler=void 0;const e=requireLogging();return resampler.Resampler=class{constructor(t){this.options=t,this.process=e=>{const t=[];for(const r of e)for(this.inputBuffer.push(r);this.hasEnoughDataForFrame();){const e=this.generateOutputFrame();t.push(e)}return t},this.stream=async function*(e){for(const t of e)for(this.inputBuffer.push(t);this.hasEnoughDataForFrame();){const e=this.generateOutputFrame();yield e}},t.nativeSampleRate<16e3&&e.log.error("nativeSampleRate is too low. Should have 16000 = targetSampleRate <= nativeSampleRate"),this.inputBuffer=[]}hasEnoughDataForFrame(){return this.inputBuffer.length*this.options.targetSampleRate/this.options.nativeSampleRate>=this.options.targetFrameSize}generateOutputFrame(){const e=new Float32Array(this.options.targetFrameSize);let t=0,r=0;for(;t<this.options.targetFrameSize;){let n=0,a=0;for(;r<Math.min(this.inputBuffer.length,(t+1)*this.options.nativeSampleRate/this.options.targetSampleRate);){const e=this.inputBuffer[r];void 0!==e&&(n+=e,a++),r++}e[t]=n/a,t++}return this.inputBuffer=this.inputBuffer.slice(r),e}},resampler}function requireNonRealTimeVad(){return hasRequiredNonRealTimeVad||(hasRequiredNonRealTimeVad=1,function(e){Object.defineProperty(e,"__esModule",{value:!0}),e.PlatformAgnosticNonRealTimeVAD=e.defaultNonRealTimeVADOptions=void 0;const t=requireFrameProcessor(),r=requireMessages(),n=requireModels(),a=requireResampler();e.defaultNonRealTimeVADOptions={...t.defaultLegacyFrameProcessorOptions,ortConfig:void 0};e.PlatformAgnosticNonRealTimeVAD=class{static async _new(t,r,n={}){const a={...e.defaultNonRealTimeVADOptions,...n};void 0!==a.ortConfig&&a.ortConfig(r);const o=new this(t,r,a);return await o.init(),o}constructor(e,o,i){this.modelFetcher=e,this.ort=o,this.options=i,this.init=async()=>{const e=await n.SileroLegacy.new(this.ort,this.modelFetcher);this.frameProcessor=new t.FrameProcessor(e.process,e.reset_state,{frameSamples:this.options.frameSamples,positiveSpeechThreshold:this.options.positiveSpeechThreshold,negativeSpeechThreshold:this.options.negativeSpeechThreshold,redemptionFrames:this.options.redemptionFrames,preSpeechPadFrames:this.options.preSpeechPadFrames,minSpeechFrames:this.options.minSpeechFrames,submitUserSpeechOnPause:this.options.submitUserSpeechOnPause}),this.frameProcessor.resume()},this.run=async function*(e,t){const n={nativeSampleRate:t,targetSampleRate:16e3,targetFrameSize:this.options.frameSamples},o=new a.Resampler(n);let i=0,s=0,l=0;for await(const t of o.stream(e)){const{msg:e,audio:n}=await this.frameProcessor.process(t);switch(e){case r.Message.SpeechStart:i=l*this.options.frameSamples/16;break;case r.Message.SpeechEnd:s=(l+1)*this.options.frameSamples/16,yield{audio:n,start:i,end:s}}l++}const{msg:d,audio:u}=this.frameProcessor.endSegment();d==r.Message.SpeechEnd&&(yield{audio:u,start:i,end:l*this.options.frameSamples/16})},(0,t.validateOptions)(i)}}}(nonRealTimeVad)),nonRealTimeVad}var utils={},hasRequiredUtils;function requireUtils(){if(hasRequiredUtils)return utils;function e(e,t,r){for(var n=0;n<r.length;n++)e.setUint8(t+n,r.charCodeAt(n))}return hasRequiredUtils=1,Object.defineProperty(utils,"__esModule",{value:!0}),utils.audioFileToArray=utils.encodeWAV=utils.arrayBufferToBase64=utils.minFramesForTargetMS=void 0,utils.minFramesForTargetMS=function(e,t,r=16e3){return Math.ceil(e*r/1e3/t)},utils.arrayBufferToBase64=function(e){const t=new Uint8Array(e),r=t.byteLength,n=new Array(r);for(var a=0;a<r;a++){const e=t[a];if(void 0===e)break;n[a]=String.fromCharCode(e)}return btoa(n.join(""))},utils.encodeWAV=function(t,r=3,n=16e3,a=1,o=32){var i=o/8,s=a*i,l=new ArrayBuffer(44+t.length*i),d=new DataView(l);return e(d,0,"RIFF"),d.setUint32(4,36+t.length*i,!0),e(d,8,"WAVE"),e(d,12,"fmt "),d.setUint32(16,16,!0),d.setUint16(20,r,!0),d.setUint16(22,a,!0),d.setUint32(24,n,!0),d.setUint32(28,n*s,!0),d.setUint16(32,s,!0),d.setUint16(34,o,!0),e(d,36,"data"),d.setUint32(40,t.length*i,!0),1===r?function(e,t,r){for(var n=0;n<r.length;n++,t+=2){var a=Math.max(-1,Math.min(1,r[n]));e.setInt16(t,a<0?32768*a:32767*a,!0)}}(d,44,t):function(e,t,r){for(var n=0;n<r.length;n++,t+=4)e.setFloat32(t,r[n],!0)}(d,44,t),l},utils.audioFileToArray=async function(e){const t=new OfflineAudioContext(1,1,44100),r=new FileReader;let n=null;if(await new Promise((a=>{r.addEventListener("loadend",(e=>{const o=r.result;t.decodeAudioData(o,(e=>{n=e,t.startRendering().then((e=>{console.log("Rendering completed successfully"),a()})).catch((e=>{console.error(`Rendering failed: ${e}`)}))}),(e=>{console.log(`Error with decoding audio data: ${e}`)}))})),r.readAsArrayBuffer(e)})),null===n)throw Error("some shit");let a=n,o=new Float32Array(a.length);for(let e=0;e<a.length;e++)for(let t=0;t<a.numberOfChannels;t++)o[e]+=a.getChannelData(t)[e];return{audio:o,sampleRate:a.sampleRate}},utils}var realTimeVad={},hasRequiredRealTimeVad,hasRequiredDist;function requireRealTimeVad(){return hasRequiredRealTimeVad||(hasRequiredRealTimeVad=1,function(e){var t=realTimeVad&&realTimeVad.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),r=realTimeVad&&realTimeVad.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),n=realTimeVad&&realTimeVad.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var a in e)"default"!==a&&Object.prototype.hasOwnProperty.call(e,a)&&t(n,e,a);return r(n,e),n};Object.defineProperty(e,"__esModule",{value:!0}),e.AudioNodeVAD=e.MicVAD=e.getDefaultRealTimeVADOptions=e.ort=e.DEFAULT_MODEL=void 0;const a=n(requireOrtWeb_min()),o=requireDefaultModelFetcher(),i=requireFrameProcessor(),s=requireLogging(),l=requireMessages(),d=requireModels(),u=requireResampler();e.DEFAULT_MODEL="legacy",e.ort=a;e.getDefaultRealTimeVADOptions=t=>({..."v5"===t?i.defaultV5FrameProcessorOptions:i.defaultLegacyFrameProcessorOptions,onFrameProcessed:e=>{},onVADMisfire:()=>{s.log.debug("VAD misfire")},onSpeechStart:()=>{s.log.debug("Detected speech start")},onSpeechEnd:()=>{s.log.debug("Detected speech end")},baseAssetPath:"https://cdn.jsdelivr.net/npm/@ricky0123/vad-web@0.0.22/dist/",onnxWASMBasePath:"https://cdn.jsdelivr.net/npm/onnxruntime-web@1.14.0/dist/",stream:void 0,ortConfig:void 0,model:e.DEFAULT_MODEL,workletOptions:{}});class c{static async new(t={}){const r={...(0,e.getDefaultRealTimeVADOptions)(t.model??e.DEFAULT_MODEL),...t};let n;(0,i.validateOptions)(r),n=void 0===r.stream?await navigator.mediaDevices.getUserMedia({audio:{...r.additionalAudioConstraints,channelCount:1,echoCancellation:!0,autoGainControl:!0,noiseSuppression:!0}}):r.stream;const a=new AudioContext,o=new MediaStreamAudioSourceNode(a,{mediaStream:n}),s=await p.new(a,r);return s.receive(o),new c(r,a,n,s,o)}constructor(e,t,r,n,a,o=!1){this.options=e,this.audioContext=t,this.stream=r,this.audioNodeVAD=n,this.sourceNode=a,this.listening=o,this.pause=()=>{this.audioNodeVAD.pause(),this.listening=!1},this.start=()=>{this.audioNodeVAD.start(),this.listening=!0},this.destroy=()=>{this.listening&&this.pause(),void 0===this.options.stream&&this.stream.getTracks().forEach((e=>e.stop())),this.sourceNode.disconnect(),this.audioNodeVAD.destroy(),this.audioContext.close()}}}e.MicVAD=c;class p{static async new(t,r={}){const n={...(0,e.getDefaultRealTimeVADOptions)(r.model??e.DEFAULT_MODEL),...r};(0,i.validateOptions)(n),e.ort.env.wasm.wasmPaths=n.onnxWASMBasePath,void 0!==n.ortConfig&&n.ortConfig(e.ort);const a="v5"===n.model?"silero_vad_v5.onnx":"silero_vad_legacy.onnx",s=n.baseAssetPath+a,l="v5"===n.model?d.SileroV5.new:d.SileroLegacy.new;let u;try{u=await l(e.ort,(()=>(0,o.defaultModelFetcher)(s)))}catch(e){throw console.error(`Encountered an error while loading model file ${s}`),e}const c=new i.FrameProcessor(u.process,u.reset_state,{frameSamples:n.frameSamples,positiveSpeechThreshold:n.positiveSpeechThreshold,negativeSpeechThreshold:n.negativeSpeechThreshold,redemptionFrames:n.redemptionFrames,preSpeechPadFrames:n.preSpeechPadFrames,minSpeechFrames:n.minSpeechFrames,submitUserSpeechOnPause:n.submitUserSpeechOnPause}),g=new p(t,n,c);return await g.setupAudioNode(),g}constructor(e,t,r){this.ctx=e,this.options=t,this.bufferIndex=0,this.pause=()=>{const e=this.frameProcessor.pause();this.handleFrameProcessorEvent(e)},this.start=()=>{this.frameProcessor.resume()},this.receive=e=>{e.connect(this.audioNode)},this.processFrame=async e=>{const t=await this.frameProcessor.process(e);this.handleFrameProcessorEvent(t)},this.handleFrameProcessorEvent=e=>{switch(void 0!==e.probs&&this.options.onFrameProcessed(e.probs,e.frame),e.msg){case l.Message.SpeechStart:this.options.onSpeechStart();break;case l.Message.VADMisfire:this.options.onVADMisfire();break;case l.Message.SpeechEnd:this.options.onSpeechEnd(e.audio)}},this.destroy=()=>{this.audioNode instanceof AudioWorkletNode&&this.audioNode.port.postMessage({message:l.Message.SpeechStop}),this.audioNode.disconnect(),this.gainNode?.disconnect()},this.frameProcessor=r}async setupAudioNode(){if("audioWorklet"in this.ctx&&"function"==typeof AudioWorkletNode)try{const e=this.options.baseAssetPath+"vad.worklet.bundle.min.js";await this.ctx.audioWorklet.addModule(e);const t=this.options.workletOptions??{};return t.processorOptions={...t.processorOptions??{},frameSamples:this.options.frameSamples},this.audioNode=new AudioWorkletNode(this.ctx,"vad-helper-worklet",t),void(this.audioNode.port.onmessage=async e=>{if(e.data?.message===l.Message.AudioFrame){let t=e.data.data;t instanceof ArrayBuffer||(t=new ArrayBuffer(e.data.data.byteLength),new Uint8Array(t).set(new Uint8Array(e.data.data)));const r=new Float32Array(t);await this.processFrame(r)}})}catch(e){console.log("AudioWorklet setup failed, falling back to ScriptProcessor",e)}this.resampler=new u.Resampler({nativeSampleRate:this.ctx.sampleRate,targetSampleRate:16e3,targetFrameSize:this.options.frameSamples??480});this.audioNode=this.ctx.createScriptProcessor(4096,1,1),this.gainNode=this.ctx.createGain(),this.gainNode.gain.value=0;let e=!1;this.audioNode.onaudioprocess=async t=>{if(!e){e=!0;try{const e=t.inputBuffer.getChannelData(0);if(t.outputBuffer.getChannelData(0).fill(0),this.resampler){const t=this.resampler.process(e);for(const e of t)await this.processFrame(e)}}catch(e){console.error("Error processing audio:",e)}finally{e=!1}}},this.audioNode.connect(this.gainNode),this.gainNode.connect(this.ctx.destination)}}e.AudioNodeVAD=p}(realTimeVad)),realTimeVad}function requireDist(){return hasRequiredDist||(hasRequiredDist=1,function(e){var t=dist&&dist.__createBinding||(Object.create?function(e,t,r,n){void 0===n&&(n=r);var a=Object.getOwnPropertyDescriptor(t,r);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,n,a)}:function(e,t,r,n){void 0===n&&(n=r),e[n]=t[r]}),r=dist&&dist.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),n=dist&&dist.__importStar||function(e){if(e&&e.__esModule)return e;var n={};if(null!=e)for(var a in e)"default"!==a&&Object.prototype.hasOwnProperty.call(e,a)&&t(n,e,a);return r(n,e),n};Object.defineProperty(e,"__esModule",{value:!0}),e.NonRealTimeVAD=e.Message=e.FrameProcessor=e.getDefaultRealTimeVADOptions=e.MicVAD=e.DEFAULT_MODEL=e.AudioNodeVAD=e.utils=e.defaultNonRealTimeVADOptions=void 0;const a=n(requireOrtWeb_min()),o=requireAssetPath(),i=requireDefaultModelFetcher(),s=requireFrameProcessor();Object.defineProperty(e,"FrameProcessor",{enumerable:!0,get:function(){return s.FrameProcessor}});const l=requireMessages();Object.defineProperty(e,"Message",{enumerable:!0,get:function(){return l.Message}});const d=requireNonRealTimeVad(),u=requireUtils();e.defaultNonRealTimeVADOptions={modelURL:o.baseAssetPath+"silero_vad_legacy.onnx",modelFetcher:i.defaultModelFetcher};class c extends d.PlatformAgnosticNonRealTimeVAD{static async new(t={}){const{modelURL:r,modelFetcher:n}={...e.defaultNonRealTimeVADOptions,...t};return await this._new((()=>n(r)),a,t)}}e.NonRealTimeVAD=c,e.utils={audioFileToArray:u.audioFileToArray,minFramesForTargetMS:u.minFramesForTargetMS,arrayBufferToBase64:u.arrayBufferToBase64,encodeWAV:u.encodeWAV};var p=requireRealTimeVad();Object.defineProperty(e,"AudioNodeVAD",{enumerable:!0,get:function(){return p.AudioNodeVAD}}),Object.defineProperty(e,"DEFAULT_MODEL",{enumerable:!0,get:function(){return p.DEFAULT_MODEL}}),Object.defineProperty(e,"MicVAD",{enumerable:!0,get:function(){return p.MicVAD}}),Object.defineProperty(e,"getDefaultRealTimeVADOptions",{enumerable:!0,get:function(){return p.getDefaultRealTimeVADOptions}})}(dist)),dist}var distExports=requireDist(),StreamTranscriber=function(e){function t(t,r,n){void 0===r&&(r={}),void 0===n&&(n=!0);var a=e.call(this,t,r)||this;return a.mediaRecorder=void 0,a.audioContext=void 0,a.audioBuffer=void 0,a.voiceActivityDetector=void 0,a.committedTranscript="",a.isActive=!1,n?(a.audioContext=new AudioContext,distExports.AudioNodeVAD.new(a.audioContext,{onFrameProcessed:function(e,t){},onVADMisfire:function(){Log.log("StreamTranscriber.onVADMisfire()")},onSpeechStart:function(){Log.log("StreamTranscriber.onSpeechStart()"),a.callbacks.onSpeechStart()},onSpeechEnd:function(e){var t;Log.log("StreamTranscriber.onSpeechEnd()"),a.callbacks.onSpeechEnd(),null===(t=Transcriber.model)||void 0===t||t.generate(e).then((function(e){a.callbacks.onTranscriptionUpdated(e),a.callbacks.onTranscriptionCommitted(a.committedTranscript),a.committedTranscript+=" "+e}))}}).then((function(e){a.voiceActivityDetector=e}))):a.audioContext=new AudioContext({sampleRate:16e3}),a}return __extends(t,e),t.prototype.attachStream=function(e){if(this.mediaRecorder=new MediaRecorder(e),this.voiceActivityDetector){var t=new MediaStreamAudioSourceNode(this.audioContext,{mediaStream:e});this.voiceActivityDetector.receive(t)}},t.prototype.detachStream=function(){this.mediaRecorder&&(this.stop(),this.mediaRecorder.stream.getTracks().forEach((function(e){return e.stop()})),this.mediaRecorder=void 0)},t.prototype.getAudioBuffer=function(){return this.audioBuffer},t.prototype.start=function(){return __awaiter(this,void 0,void 0,(function(){var t,r,n,a=this;return __generator(this,(function(o){switch(o.label){case 0:return this.isActive?[3,3]:(this.isActive=!0,this.committedTranscript="",Transcriber.model.isLoaded()?[3,2]:[4,e.prototype.loadModel.call(this)]);case 1:o.sent(),o.label=2;case 2:this.voiceActivityDetector?(this.callbacks.onTranscribeStarted(),this.voiceActivityDetector.start()):(this.callbacks.onTranscribeStarted(),t=[],r=!1,this.mediaRecorder.ondataavailable=function(e){Math.floor(t.length*Settings.FRAME_SIZE/1e3)>=Settings.MAX_SPEECH_SECS&&(r=!0),t.push(e.data),new Blob(t,{type:"audio/wav"}).arrayBuffer().then((function(e){var n;null===(n=a.audioContext)||void 0===n||n.decodeAudioData(e).then((function(e){var n;a.audioBuffer=e;var o=new Float32Array(e.length);o.length>48e4&&(o=o.subarray(0,48e4)),e.copyFromChannel(o,0),null===(n=Transcriber.model)||void 0===n||n.generate(o).then((function(e){if(r&&e){a.committedTranscript=a.committedTranscript+" "+e,a.callbacks.onTranscriptionCommitted(a.committedTranscript);var n=t[0];(t=[]).push(n),r=!1}else r||a.callbacks.onTranscriptionUpdated(e)}))})).catch((function(){}))}))}),this.mediaRecorder.start(Settings.FRAME_SIZE),n=void 0,Settings.MAX_RECORD_MS&&(n=setTimeout((function(){a.stop()}),Settings.MAX_RECORD_MS)),this.mediaRecorder.onstop=function(){n&&clearTimeout(n),a.callbacks.onTranscribeStopped()},o.label=3;case 3:return[2]}}))}))},t.prototype.stop=function(){this.isActive=!1,this.voiceActivityDetector&&this.voiceActivityDetector.pause(),this.mediaRecorder&&(this.audioBuffer=void 0,this.mediaRecorder.stop())},t}(Transcriber),MediaElementTranscriber=function(e){function t(t,r,n,a){void 0===n&&(n={}),void 0===a&&(a=!1);var o=e.call(this,r,n,a)||this;return o.mediaElement=t,o.mediaElement.addEventListener("play",(function(){o.start()})),o.mediaElement.addEventListener("pause",(function(){o.stop()})),o}return __extends(t,e),t.prototype.start=function(){return __awaiter(this,void 0,void 0,(function(){var t,r,n;return __generator(this,(function(a){return this.mediaRecorder||(t=this.audioContext.createMediaElementSource(this.mediaElement),r=this.audioContext.createMediaStreamDestination(),n=r.stream,t.connect(this.audioContext.destination),t.connect(r),e.prototype.attachStream.call(this,n)),e.prototype.start.call(this),[2]}))}))},t}(StreamTranscriber),MicrophoneTranscriber=function(e){function t(t,r,n){return void 0===r&&(r={}),void 0===n&&(n=!1),e.call(this,t,r,n)||this}return __extends(t,e),t.prototype.start=function(){return __awaiter(this,void 0,void 0,(function(){var t;return __generator(this,(function(r){switch(r.label){case 0:return[4,navigator.mediaDevices.getUserMedia({audio:{channelCount:1,echoCancellation:!0,autoGainControl:!0,noiseSuppression:!0}})];case 1:return t=r.sent(),e.prototype.attachStream.call(this,t),e.prototype.start.call(this),[2]}}))}))},t}(StreamTranscriber),MoonshineSpeechRecognitionEvent=function(e,t){var r,n,a;this.type=e,this.results=t.results,this.resultIndex=t.resultIndex,this.bubbles=null!==(r=t.bubbles)&&void 0!==r&&r,this.cancelable=null!==(n=t.cancelable)&&void 0!==n&&n,this.composed=null!==(a=t.composed)&&void 0!==a&&a},MoonshineSpeechRecognitionResult=function(){function e(e,t){this._alternatives=e,this.isFinal=t;for(var r=0;r<e.length;r++)this[r]=e[r]}return Object.defineProperty(e.prototype,"length",{get:function(){return this._alternatives.length},enumerable:!1,configurable:!0}),e.prototype.item=function(e){return this._alternatives[e]||null},e}(),MoonshineSpeechRecognitionResultList=function(){function e(e){this._results=e;for(var t=0;t<e.length;t++)this[t]=e[t];return new Proxy(this,{get:function(e,t){return"string"==typeof t&&/^\d+$/.test(t)?e._results[+t]:e[t]}})}return Object.defineProperty(e.prototype,"length",{get:function(){return this._results.length},enumerable:!1,configurable:!0}),e.prototype.item=function(e){return this._results[e]||null},e}(),MoonshineSpeechRecognition=function(){function e(e){void 0===e&&(e="model/tiny"),this.resultIndex=0,this.transcriber=new MicrophoneTranscriber(e,{},!0)}return e.prototype.removeEventListener=function(e,t,r){throw new Error("Method not implemented.")},e.prototype.dispatchEvent=function(e){throw new Error("Method not implemented.")},e.prototype.start=function(){this.transcriber.start()},e.prototype.stop=function(){this.transcriber.stop()},e.prototype.abort=function(){this.transcriber.stop()},Object.defineProperty(e.prototype,"onaudiostart",{set:function(e){Log.warn("onaudiostart is not implemented for SpeechRecognition polyfill")},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onaudioend",{set:function(e){Log.warn("onaudioend is not implemented for SpeechRecognition polyfill")},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onend",{set:function(e){this.transcriber.callbacks.onTranscribeStopped=function(){e(new Event(""))}},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onerror",{set:function(e){Log.warn("onerror is not implemented for SpeechRecognition polyfill")},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onnomatch",{set:function(e){Log.warn("nomatch is not implemented for SpeechRecognition polyfill")},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onresult",{set:function(e){var t=this;this.transcriber.callbacks.onTranscriptionUpdated=function(r){if(r||t.interimResults){var n=new MoonshineSpeechRecognitionResult([{transcript:r,confidence:void 0}],!0),a=new MoonshineSpeechRecognitionResultList([n]),o=new MoonshineSpeechRecognitionEvent("result",{bubbles:!1,cancelable:!1,composed:!1,results:a,resultIndex:0});e(o)}}},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onsoundstart",{set:function(e){Log.warn("onsoundstart is not implemented for SpeechRecognition polyfill")},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onsoundend",{set:function(e){Log.warn("onsoundend is not implemented for SpeechRecognition polyfill")},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onspeechstart",{set:function(e){this.transcriber.callbacks.onSpeechStart=function(){e(new Event(""))}},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onspeechend",{set:function(e){this.transcriber.callbacks.onSpeechEnd=function(){e(new Event(""))}},enumerable:!1,configurable:!0}),Object.defineProperty(e.prototype,"onstart",{set:function(e){this.transcriber.callbacks.onTranscribeStarted=function(){e(new Event(""))}},enumerable:!1,configurable:!0}),e.prototype.addEventListener=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];var r=e[1];switch(e[0]){case"audiostart":this.onaudiostart=r;break;case"audioend":this.onaudioend=r;break;case"end":this.onend=r;break;case"error":this.onerror=r;break;case"nomatch":this.onnomatch=r;break;case"result":this.onresult=r;break;case"soundstart":this.onsoundstart=r;break;case"soundend":this.onsoundend=r;break;case"speechstart":this.onspeechstart=r;break;case"speechend":this.onspeechend=r;break;case"start":this.onstart=r}},e}();const backends=new Map,backendsSortedByPriority=[],registerBackend=(e,t,r)=>{if(!t||"function"!=typeof t.init||"function"!=typeof t.createInferenceSessionHandler)throw new TypeError("not a valid backend");{const n=backends.get(e);if(void 0===n)backends.set(e,{backend:t,priority:r});else{if(n.priority>r)return;if(n.priority===r&&n.backend!==t)throw new Error(`cannot register backend "${e}" using priority ${r}`)}if(r>=0){const t=backendsSortedByPriority.indexOf(e);-1!==t&&backendsSortedByPriority.splice(t,1);for(let t=0;t<backendsSortedByPriority.length;t++)if(backends.get(backendsSortedByPriority[t]).priority<=r)return void backendsSortedByPriority.splice(t,0,e);backendsSortedByPriority.push(e)}}},tryResolveAndInitializeBackend=async e=>{const t=backends.get(e);if(!t)return"backend not found.";if(t.initialized)return t.backend;if(t.aborted)return t.error;{const r=!!t.initPromise;try{return r||(t.initPromise=t.backend.init(e)),await t.initPromise,t.initialized=!0,t.backend}catch(e){return r||(t.error=`${e}`,t.aborted=!0),t.error}finally{delete t.initPromise}}},resolveBackendAndExecutionProviders=async e=>{const t=e.executionProviders||[],r=t.map((e=>"string"==typeof e?e:e.name)),n=0===r.length?backendsSortedByPriority:r;let a;const o=[],i=new Set;for(const e of n){const t=await tryResolveAndInitializeBackend(e);"string"==typeof t?o.push({name:e,err:t}):(a||(a=t),a===t&&i.add(e))}if(!a)throw new Error(`no available backend found. ERR: ${o.map((e=>`[${e.name}] ${e.err}`)).join(", ")}`);for(const{name:e,err:t}of o)r.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);const s=t.filter((e=>i.has("string"==typeof e?e:e.name)));return[a,new Proxy(e,{get:(e,t)=>"executionProviders"===t?s:Reflect.get(e,t)})]},version="1.20.1";let logLevelValue="warning";const env$1={wasm:{},webgl:{},webgpu:{},versions:{common:version},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw new Error(`Unsupported logging level: ${e}`);logLevelValue=e}},get logLevel(){return logLevelValue}};Object.defineProperty(env$1,"logLevel",{enumerable:!0});const env=env$1,tensorToDataURL=(e,t)=>{const r="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];const n=r.getContext("2d");if(null!=n){let a,o;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],o=e.dims[3]):(a=e.dims[3],o=e.dims[2]);const i=void 0!==t?.format?t.format:"RGB",s=t?.norm;let l,d;void 0===s||void 0===s.mean?l=[255,255,255,255]:"number"==typeof s.mean?l=[s.mean,s.mean,s.mean,s.mean]:(l=[s.mean[0],s.mean[1],s.mean[2],0],void 0!==s.mean[3]&&(l[3]=s.mean[3])),void 0===s||void 0===s.bias?d=[0,0,0,0]:"number"==typeof s.bias?d=[s.bias,s.bias,s.bias,s.bias]:(d=[s.bias[0],s.bias[1],s.bias[2],0],void 0!==s.bias[3]&&(d[3]=s.bias[3]));const u=o*a;let c=0,p=u,g=2*u,A=-1;"RGBA"===i?(c=0,p=u,g=2*u,A=3*u):"RGB"===i?(c=0,p=u,g=2*u):"RBG"===i&&(c=0,g=u,p=2*u);for(let t=0;t<o;t++)for(let r=0;r<a;r++){const a=(e.data[c++]-d[0])*l[0],o=(e.data[p++]-d[1])*l[1],i=(e.data[g++]-d[2])*l[2],s=-1===A?255:(e.data[A++]-d[3])*l[3];n.fillStyle="rgba("+a+","+o+","+i+","+s+")",n.fillRect(r,t,1,1)}if("toDataURL"in r)return r.toDataURL();throw new Error("toDataURL is not supported")}throw new Error("Can not access image data")},tensorToImageData=(e,t)=>{const r="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");let n;if(null==r)throw new Error("Can not access image data");{let a,o,i;void 0!==t?.tensorLayout&&"NHWC"===t.tensorLayout?(a=e.dims[2],o=e.dims[1],i=e.dims[3]):(a=e.dims[3],o=e.dims[2],i=e.dims[1]);const s=void 0!==t&&void 0!==t.format?t.format:"RGB",l=t?.norm;let d,u;void 0===l||void 0===l.mean?d=[255,255,255,255]:"number"==typeof l.mean?d=[l.mean,l.mean,l.mean,l.mean]:(d=[l.mean[0],l.mean[1],l.mean[2],255],void 0!==l.mean[3]&&(d[3]=l.mean[3])),void 0===l||void 0===l.bias?u=[0,0,0,0]:"number"==typeof l.bias?u=[l.bias,l.bias,l.bias,l.bias]:(u=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(u[3]=l.bias[3]));const c=o*a;if(void 0!==t&&(void 0!==t.format&&4===i&&"RGBA"!==t.format||3===i&&"RGB"!==t.format&&"BGR"!==t.format))throw new Error("Tensor format doesn't match input tensor dims");const p=4;let g=0,A=1,h=2,B=3,m=0,C=c,w=2*c,b=-1;"RGBA"===s?(m=0,C=c,w=2*c,b=3*c):"RGB"===s?(m=0,C=c,w=2*c):"RBG"===s&&(m=0,w=c,C=2*c),n=r.createImageData(a,o);for(let t=0;t<o*a;g+=p,A+=p,h+=p,B+=p,t++)n.data[g]=(e.data[m++]-u[0])*d[0],n.data[A]=(e.data[C++]-u[1])*d[1],n.data[h]=(e.data[w++]-u[2])*d[2],n.data[B]=-1===b?255:(e.data[b++]-u[3])*d[3]}return n},bufferToTensor=(e,t)=>{if(void 0===e)throw new Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw new Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw new Error("NHWC Tensor layout is not supported yet");const{height:r,width:n}=t,a=t.norm??{mean:255,bias:0};let o,i;o="number"==typeof a.mean?[a.mean,a.mean,a.mean,a.mean]:[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],i="number"==typeof a.bias?[a.bias,a.bias,a.bias,a.bias]:[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];const s=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",d=r*n,u="RGBA"===l?new Float32Array(4*d):new Float32Array(3*d);let c=4,p=0,g=1,A=2,h=3,B=0,m=d,C=2*d,w=-1;"RGB"===s&&(c=3,p=0,g=1,A=2,h=-1),"RGBA"===l?w=3*d:"RBG"===l?(B=0,C=d,m=2*d):"BGR"===l&&(C=0,m=d,B=2*d);for(let t=0;t<d;t++,p+=c,A+=c,g+=c,h+=c)u[B++]=(e[p]+i[0])/o[0],u[m++]=(e[g]+i[1])/o[1],u[C++]=(e[A]+i[2])/o[2],-1!==w&&-1!==h&&(u[w++]=(e[h]+i[3])/o[3]);return new Tensor$1("float32",u,"RGBA"===l?[1,4,r,n]:[1,3,r,n])},tensorFromImage=async(e,t)=>{const r="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,n="undefined"!=typeof ImageData&&e instanceof ImageData,a="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,o="string"==typeof e;let i,s=t??{};const l=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},d=e=>"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(r){const r=l();r.width=e.width,r.height=e.height;const n=d(r);if(null==n)throw new Error("Can not access image data");{let r=e.height,a=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(r=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw new Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=r,s.width=a}else s.tensorFormat="RGBA",s.height=r,s.width=a;n.drawImage(e,0,0),i=n.getImageData(0,0,a,r).data}}else{if(!n){if(a){if(void 0===t)throw new Error("Please provide image config with format for Imagebitmap");const r=l();r.width=e.width,r.height=e.height;const n=d(r);if(null!=n){const t=e.height,r=e.width;return n.drawImage(e,0,0,r,t),i=n.getImageData(0,0,r,t).data,s.height=t,s.width=r,bufferToTensor(i,s)}throw new Error("Can not access image data")}if(o)return new Promise(((t,r)=>{const n=l(),a=d(n);if(!e||!a)return r();const o=new Image;o.crossOrigin="Anonymous",o.src=e,o.onload=()=>{n.width=o.width,n.height=o.height,a.drawImage(o,0,0,n.width,n.height);const e=a.getImageData(0,0,n.width,n.height);s.height=n.height,s.width=n.width,t(bufferToTensor(e.data,s))}}));throw new Error("Input data provided is not supported - aborted tensor creation")}{let r,n;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(r=t.resizedHeight,n=t.resizedWidth):(r=e.height,n=e.width),void 0!==t&&(s=t),s.format="RGBA",s.height=r,s.width=n,void 0!==t){const t=l();t.width=n,t.height=r;const a=d(t);if(null==a)throw new Error("Can not access image data");a.putImageData(e,0,0),i=a.getImageData(0,0,n,r).data}else i=e.data}}if(void 0!==i)return bufferToTensor(i,s);throw new Error("Input data provided is not supported - aborted tensor creation")},tensorFromTexture=(e,t)=>{const{width:r,height:n,download:a,dispose:o}=t;return new Tensor$1({location:"texture",type:"float32",texture:e,dims:[1,n,r,4],download:a,dispose:o})},tensorFromGpuBuffer=(e,t)=>{const{dataType:r,dims:n,download:a,dispose:o}=t;return new Tensor$1({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:n,download:a,dispose:o})},tensorFromMLTensor=(e,t)=>{const{dataType:r,dims:n,download:a,dispose:o}=t;return new Tensor$1({location:"ml-tensor",type:r??"float32",mlTensor:e,dims:n,download:a,dispose:o})},tensorFromPinnedBuffer=(e,t,r)=>new Tensor$1({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]}),NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]);let isTypedArrayChecked=!1;const checkTypedArray=()=>{if(!isTypedArrayChecked){isTypedArrayChecked=!0;const e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,r="undefined"!=typeof Float16Array&&Float16Array.from;e&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64",BigInt64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array,"int64")),t&&(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64",BigUint64Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array,"uint64")),r?(NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16",Float16Array),NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array,"float16")):NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("float16",Uint16Array)}},calculateSize=e=>{let t=1;for(let r=0;r<e.length;r++){const n=e[r];if("number"!=typeof n||!Number.isSafeInteger(n))throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},tensorReshape=(e,t)=>{switch(e.location){case"cpu":return new Tensor$1(e.type,e.data,t);case"cpu-pinned":return new Tensor$1({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new Tensor$1({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new Tensor$1({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new Tensor$1({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}};let Tensor$1=class{constructor(e,t,r){let n,a;if(checkTypedArray(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,n=e.type,a=e.dims,e.location){case"cpu-pinned":{const t=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(n);if(!t)throw new TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw new TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==n)throw new TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint8"!==n&&"bool"!==n&&"uint4"!==n&&"int4"!==n)throw new TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint64"!==n&&"int8"!==n&&"uint8"!==n&&"bool"!==n)throw new TypeError(`unsupported type "${n}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,i;if("string"==typeof e)if(n=e,i=r,"string"===e){if(!Array.isArray(t))throw new TypeError("A string tensor's data must be a string array.");o=t}else{const r=NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(e);if(void 0===r)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t)){if("float16"===e&&r===Uint16Array||"uint4"===e||"int4"===e)throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${r.name} as data.`);o="uint64"===e||"int64"===e?r.from(t,BigInt):r.from(t)}else if(t instanceof r)o=t;else{if(!(t instanceof Uint8ClampedArray))throw new TypeError(`A ${n} tensor's data must be type of ${r}`);if("uint8"!==e)throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");o=Uint8Array.from(t)}}else if(i=t,Array.isArray(e)){if(0===e.length)throw new TypeError("Tensor type cannot be inferred from an empty array.");const t=typeof e[0];if("string"===t)n="string",o=e;else{if("boolean"!==t)throw new TypeError(`Invalid element type of data array: ${t}.`);n="bool",o=Uint8Array.from(e)}}else if(e instanceof Uint8ClampedArray)n="uint8",o=Uint8Array.from(e);else{const t=NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(e.constructor);if(void 0===t)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=t,o=e}if(void 0===i)i=[o.length];else if(!Array.isArray(i))throw new TypeError("A tensor's dims must be a number array");a=i,this.cpuData=o,this.dataLocation="cpu"}const o=calculateSize(a);if(this.cpuData&&o!==this.cpuData.length&&("uint4"!==n&&"int4"!==n||Math.ceil(o/2)!==this.cpuData.length))throw new Error(`Tensor's size(${o}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=a,this.size=o}static async fromImage(e,t){return tensorFromImage(e,t)}static fromTexture(e,t){return tensorFromTexture(e,t)}static fromGpuBuffer(e,t){return tensorFromGpuBuffer(e,t)}static fromMLTensor(e,t){return tensorFromMLTensor(e,t)}static fromPinnedBuffer(e,t,r){return tensorFromPinnedBuffer(e,t,r)}toDataURL(e){return tensorToDataURL(this,e)}toImageData(e){return tensorToImageData(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;const t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return tensorReshape(this,e)}};const Tensor=Tensor$1,TRACE=(e,t)=>{(void 0===env$1.trace?env$1.wasm.trace:env$1.trace)&&console.timeStamp(`${e}::ORT::${t}`)},TRACE_FUNC=(e,t)=>{const r=(new Error).stack?.split(/\r\n|\r|\n/g)||[];let n=!1;for(let a=0;a<r.length;a++){if(n&&!r[a].includes("TRACE_FUNC")){let n=`FUNC_${e}::${r[a].trim().split(" ")[1]}`;return t&&(n+=`::${t}`),void TRACE("CPU",n)}r[a].includes("TRACE_FUNC")&&(n=!0)}},TRACE_FUNC_BEGIN=e=>{(void 0===env$1.trace?env$1.wasm.trace:env$1.trace)&&TRACE_FUNC("BEGIN",e)},TRACE_FUNC_END=e=>{(void 0===env$1.trace?env$1.wasm.trace:env$1.trace)&&TRACE_FUNC("END",e)};let InferenceSession$1=class e{constructor(e){this.handler=e}async run(e,t,r){TRACE_FUNC_BEGIN();const n={};let a={};if("object"!=typeof e||null===e||e instanceof Tensor||Array.isArray(e))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if("object"==typeof t){if(null===t)throw new TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw new TypeError("'fetches' cannot be an empty array.");o=!1;for(const e of t){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if("object"==typeof r&&null!==r)a=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else{let e=!1;const i=Object.getOwnPropertyNames(t);for(const r of this.outputNames)if(-1!==i.indexOf(r)){const a=t[r];(null===a||a instanceof Tensor)&&(e=!0,o=!1,n[r]=a)}if(e){if("object"==typeof r&&null!==r)a=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else a=t}}else if(void 0!==t)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of this.inputNames)if(void 0===e[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(o)for(const e of this.outputNames)n[e]=null;const i=await this.handler.run(e,n,a),s={};for(const e in i)if(Object.hasOwnProperty.call(i,e)){const t=i[e];s[e]=t instanceof Tensor?t:new Tensor(t.type,t.data,t.dims)}return TRACE_FUNC_END(),s}async release(){return this.handler.dispose()}static async create(t,r,n,a){let o;TRACE_FUNC_BEGIN();let i={};if("string"==typeof t){if(o=t,"object"==typeof r&&null!==r)i=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(o=t,"object"==typeof r&&null!==r)i=r;else if(void 0!==r)throw new TypeError("'options' must be an object.")}else{if(!(t instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer))throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");{const e=t;let s=0,l=t.byteLength;if("object"==typeof r&&null!==r)i=r;else if("number"==typeof r){if(s=r,!Number.isSafeInteger(s))throw new RangeError("'byteOffset' must be an integer.");if(s<0||s>=e.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${e.byteLength}).`);if(l=t.byteLength-s,"number"==typeof n){if(l=n,!Number.isSafeInteger(l))throw new RangeError("'byteLength' must be an integer.");if(l<=0||s+l>e.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${e.byteLength-s}].`);if("object"==typeof a&&null!==a)i=a;else if(void 0!==a)throw new TypeError("'options' must be an object.")}else if(void 0!==n)throw new TypeError("'byteLength' must be a number.")}else if(void 0!==r)throw new TypeError("'options' must be an object.");o=new Uint8Array(e,s,l)}}const[s,l]=await resolveBackendAndExecutionProviders(i),d=await s.createInferenceSessionHandler(o,l);return TRACE_FUNC_END(),new e(d)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}};const InferenceSession=InferenceSession$1,noBackendErrMsg="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.";let TrainingSession$1=class e{constructor(e,t,r){this.handler=e,this.hasOptimizerModel=t,this.hasEvalModel=r}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(t,r){const n=t.evalModel||"",a=t.optimizerModel||"",o=r||{},[i,s]=await resolveBackendAndExecutionProviders(o);if(i.createTrainingSessionHandler){const r=await i.createTrainingSessionHandler(t.checkpointState,t.trainModel,n,a,s);return new e(r,!!t.optimizerModel,!!t.evalModel)}throw new Error(noBackendErrMsg)}typeNarrowingForRunStep(e,t,r,n,a){const o={};let i={};if("object"!=typeof r||null===r||r instanceof Tensor||Array.isArray(r))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if("object"==typeof n){if(null===n)throw new TypeError("Unexpected argument[1]: cannot be null.");if(n instanceof Tensor)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(n)){if(0===n.length)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(const e of n){if("string"!=typeof e)throw new TypeError("'fetches' must be a string array or an object.");if(-1===t.indexOf(e))throw new RangeError(`'fetches' contains invalid output name: ${e}.`);o[e]=null}if("object"==typeof a&&null!==a)i=a;else if(void 0!==a)throw new TypeError("'options' must be an object.")}else{let e=!1;const r=Object.getOwnPropertyNames(n);for(const a of t)if(-1!==r.indexOf(a)){const t=n[a];(null===t||t instanceof Tensor)&&(e=!0,s=!1,o[a]=t)}if(e){if("object"==typeof a&&null!==a)i=a;else if(void 0!==a)throw new TypeError("'options' must be an object.")}else i=n}}else if(void 0!==n)throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(const t of e)if(void 0===r[t])throw new Error(`input '${t}' is missing in 'feeds'.`);if(s)for(const e of t)o[e]=null;return[o,i]}convertHandlerReturnTypeToMapOfTensors(e){const t={};for(const r in e)if(Object.hasOwnProperty.call(e,r)){const n=e[r];t[r]=n instanceof Tensor?n:new Tensor(n.type,n.data,n.dims)}return t}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(e,t,r){const[n,a]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,e,t,r),o=await this.handler.runTrainStep(e,n,a);return this.convertHandlerReturnTypeToMapOfTensors(o)}async runOptimizerStep(e){if(!this.hasOptimizerModel)throw new Error("This TrainingSession has no OptimizerModel loaded.");await this.handler.runOptimizerStep(e||{})}async runEvalStep(e,t,r){if(this.hasEvalModel){const[n,a]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,e,t,r),o=await this.handler.runEvalStep(e,n,a);return this.convertHandlerReturnTypeToMapOfTensors(o)}throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(e=!0){return this.handler.getParametersSize(e)}async loadParametersBuffer(e,t=!0){const r=await this.getParametersSize(t);if(e.length!==4*r)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(e,t)}async getContiguousParameters(e=!0){return this.handler.getContiguousParameters(e)}async release(){return this.handler.dispose()}};const TrainingSession=TrainingSession$1;var __WEBPACK_EXTERNAL_MODULE_onnxruntime_common_82b39e9f__=Object.freeze({__proto__:null,InferenceSession:InferenceSession,TRACE:TRACE,TRACE_FUNC_BEGIN:TRACE_FUNC_BEGIN,TRACE_FUNC_END:TRACE_FUNC_END,Tensor:Tensor,TrainingSession:TrainingSession,env:env,registerBackend:registerBackend}),__webpack_modules__={"onnxruntime-common":
/*!*************************************!*\
  !*** external "onnxruntime-common" ***!
  \*************************************/e=>{e.exports=__WEBPACK_EXTERNAL_MODULE_onnxruntime_common_82b39e9f__},"onnxruntime-web":
/*!**********************************!*\
  !*** external "onnxruntime-web" ***!
  \**********************************/e=>{e.exports=__WEBPACK_EXTERNAL_MODULE_onnxruntime_web_74d14b94__},"?2ce3":
/*!**********************************!*\
  !*** onnxruntime-node (ignored) ***!
  \**********************************/()=>{},"?7a2c":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/()=>{},"?a42a":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/()=>{},"?2b25":
/*!***********************!*\
  !*** sharp (ignored) ***!
  \***********************/()=>{},"?569f":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/()=>{},"?3f59":
/*!**********************!*\
  !*** path (ignored) ***!
  \**********************/()=>{},"?154a":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/()=>{},"./node_modules/@huggingface/jinja/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@huggingface/jinja/dist/index.js ***!
  \*******************************************************/(e,t,r)=>{r.r(t),r.d(t,{Environment:()=>j,Interpreter:()=>$,Template:()=>te,parse:()=>X,tokenize:()=>u});var n=Object.freeze({Text:"Text",NumericLiteral:"NumericLiteral",BooleanLiteral:"BooleanLiteral",NullLiteral:"NullLiteral",StringLiteral:"StringLiteral",Identifier:"Identifier",Equals:"Equals",OpenParen:"OpenParen",CloseParen:"CloseParen",OpenStatement:"OpenStatement",CloseStatement:"CloseStatement",OpenExpression:"OpenExpression",CloseExpression:"CloseExpression",OpenSquareBracket:"OpenSquareBracket",CloseSquareBracket:"CloseSquareBracket",OpenCurlyBracket:"OpenCurlyBracket",CloseCurlyBracket:"CloseCurlyBracket",Comma:"Comma",Dot:"Dot",Colon:"Colon",Pipe:"Pipe",CallOperator:"CallOperator",AdditiveBinaryOperator:"AdditiveBinaryOperator",MultiplicativeBinaryOperator:"MultiplicativeBinaryOperator",ComparisonBinaryOperator:"ComparisonBinaryOperator",UnaryOperator:"UnaryOperator",Set:"Set",If:"If",For:"For",In:"In",Is:"Is",NotIn:"NotIn",Else:"Else",EndIf:"EndIf",ElseIf:"ElseIf",EndFor:"EndFor",And:"And",Or:"Or",Not:"UnaryOperator",Macro:"Macro",EndMacro:"EndMacro"}),a=Object.freeze({set:n.Set,for:n.For,in:n.In,is:n.Is,if:n.If,else:n.Else,endif:n.EndIf,elif:n.ElseIf,endfor:n.EndFor,and:n.And,or:n.Or,not:n.Not,"not in":n.NotIn,macro:n.Macro,endmacro:n.EndMacro,true:n.BooleanLiteral,false:n.BooleanLiteral,none:n.NullLiteral,True:n.BooleanLiteral,False:n.BooleanLiteral,None:n.NullLiteral}),o=class{constructor(e,t){this.value=e,this.type=t}};function i(e){return/\w/.test(e)}function s(e){return/[0-9]/.test(e)}var l=[["{%",n.OpenStatement],["%}",n.CloseStatement],["{{",n.OpenExpression],["}}",n.CloseExpression],["(",n.OpenParen],[")",n.CloseParen],["{",n.OpenCurlyBracket],["}",n.CloseCurlyBracket],["[",n.OpenSquareBracket],["]",n.CloseSquareBracket],[",",n.Comma],[".",n.Dot],[":",n.Colon],["|",n.Pipe],["<=",n.ComparisonBinaryOperator],[">=",n.ComparisonBinaryOperator],["==",n.ComparisonBinaryOperator],["!=",n.ComparisonBinaryOperator],["<",n.ComparisonBinaryOperator],[">",n.ComparisonBinaryOperator],["+",n.AdditiveBinaryOperator],["-",n.AdditiveBinaryOperator],["*",n.MultiplicativeBinaryOperator],["/",n.MultiplicativeBinaryOperator],["%",n.MultiplicativeBinaryOperator],["=",n.Equals]],d=new Map([["n","\n"],["t","\t"],["r","\r"],["b","\b"],["f","\f"],["v","\v"],["'","'"],['"','"'],["\\","\\"]]);function u(e,t={}){const r=[],u=function(e,t={}){return e.endsWith("\n")&&(e=e.slice(0,-1)),e=e.replace(/{#.*?#}/gs,"{##}"),t.lstrip_blocks&&(e=e.replace(/^[ \t]*({[#%])/gm,"$1")),t.trim_blocks&&(e=e.replace(/([#%]})\n/g,"$1")),e.replace(/{##}/g,"").replace(/-%}\s*/g,"%}").replace(/\s*{%-/g,"{%").replace(/-}}\s*/g,"}}").replace(/\s*{{-/g,"{{")}(e,t);let c=0;const p=e=>{let t="";for(;e(u[c]);)if("\\"!==u[c]){if(t+=u[c++],c>=u.length)throw new SyntaxError("Unexpected end of input")}else{if(++c,c>=u.length)throw new SyntaxError("Unexpected end of input");const e=u[c++],r=d.get(e);if(void 0===r)throw new SyntaxError(`Unexpected escaped character: ${e}`);t+=r}return t};e:for(;c<u.length;){const e=r.at(-1)?.type;if(void 0===e||e===n.CloseStatement||e===n.CloseExpression){let e="";for(;c<u.length&&("{"!==u[c]||"%"!==u[c+1]&&"{"!==u[c+1]);)e+=u[c++];if(e.length>0){r.push(new o(e,n.Text));continue}}p((e=>/\s/.test(e)));const t=u[c];if("-"===t||"+"===t){const e=r.at(-1)?.type;if(e===n.Text||void 0===e)throw new SyntaxError(`Unexpected character: ${t}`);switch(e){case n.Identifier:case n.NumericLiteral:case n.BooleanLiteral:case n.NullLiteral:case n.StringLiteral:case n.CloseParen:case n.CloseSquareBracket:break;default:{++c;const e=p(s);r.push(new o(`${t}${e}`,e.length>0?n.NumericLiteral:n.UnaryOperator));continue}}}for(const[e,t]of l){if(u.slice(c,c+e.length)===e){r.push(new o(e,t)),c+=e.length;continue e}}if("'"!==t&&'"'!==t)if(s(t)){const e=p(s);r.push(new o(e,n.NumericLiteral))}else{if(!i(t))throw new SyntaxError(`Unexpected character: ${t}`);{const e=p(i),t=Object.hasOwn(a,e)?a[e]:n.Identifier;t===n.In&&r.at(-1)?.type===n.Not?(r.pop(),r.push(new o("not in",n.NotIn))):r.push(new o(e,t))}}else{++c;const e=p((e=>e!==t));r.push(new o(e,n.StringLiteral)),++c}}return r}var c=class{type="Statement"},p=class extends c{constructor(e){super(),this.body=e}type="Program"},g=class extends c{constructor(e,t,r){super(),this.test=e,this.body=t,this.alternate=r}type="If"},A=class extends c{constructor(e,t,r,n){super(),this.loopvar=e,this.iterable=t,this.body=r,this.defaultBlock=n}type="For"},h=class extends c{constructor(e,t){super(),this.assignee=e,this.value=t}type="Set"},B=class extends c{constructor(e,t,r){super(),this.name=e,this.args=t,this.body=r}type="Macro"},m=class extends c{type="Expression"},C=class extends m{constructor(e,t,r){super(),this.object=e,this.property=t,this.computed=r}type="MemberExpression"},w=class extends m{constructor(e,t){super(),this.callee=e,this.args=t}type="CallExpression"},b=class extends m{constructor(e){super(),this.value=e}type="Identifier"},K=class extends m{constructor(e){super(),this.value=e}type="Literal"},f=class extends K{type="NumericLiteral"},Q=class extends K{type="StringLiteral"},W=class extends K{type="BooleanLiteral"},F=class extends K{type="NullLiteral"},_=class extends K{type="ArrayLiteral"},y=class extends K{type="TupleLiteral"},v=class extends K{type="ObjectLiteral"},E=class extends m{constructor(e,t,r){super(),this.operator=e,this.left=t,this.right=r}type="BinaryExpression"},G=class extends m{constructor(e,t){super(),this.operand=e,this.filter=t}type="FilterExpression"},R=class extends m{constructor(e,t){super(),this.iterable=e,this.test=t}type="SelectExpression"},x=class extends m{constructor(e,t,r){super(),this.operand=e,this.negate=t,this.test=r}type="TestExpression"},S=class extends m{constructor(e,t){super(),this.operator=e,this.argument=t}type="UnaryExpression"},T=class extends m{constructor(e=void 0,t=void 0,r=void 0){super(),this.start=e,this.stop=t,this.step=r}type="SliceExpression"},Z=class extends m{constructor(e,t){super(),this.key=e,this.value=t}type="KeywordArgumentExpression"};function X(e){const t=new p([]);let r=0;function a(t,n){const a=e[r++];if(!a||a.type!==t)throw new Error(`Parser Error: ${n}. ${a.type} !== ${t}.`);return a}function o(){switch(e[r].type){case n.Text:return new Q(a(n.Text,"Expected text token").value);case n.OpenStatement:return function(){let t;switch(a(n.OpenStatement,"Expected opening statement token"),e[r].type){case n.Set:++r,t=l(),a(n.CloseStatement,"Expected closing statement token");break;case n.If:++r,t=d(),a(n.OpenStatement,"Expected {% token"),a(n.EndIf,"Expected endif token"),a(n.CloseStatement,"Expected %} token");break;case n.Macro:++r,t=function(){const e=I();if("Identifier"!==e.type)throw new SyntaxError("Expected identifier following macro statement");const t=M();a(n.CloseStatement,"Expected closing statement token");const r=[];for(;i(n.OpenStatement,n.EndMacro);)r.push(o());return new B(e,t,r)}(),a(n.OpenStatement,"Expected {% token"),a(n.EndMacro,"Expected endmacro token"),a(n.CloseStatement,"Expected %} token");break;case n.For:++r,t=function(){const e=u(!0);if(!(e instanceof b||e instanceof y))throw new SyntaxError(`Expected identifier/tuple for the loop variable, got ${e.type} instead`);a(n.In,"Expected `in` keyword following loop variable");const t=c();a(n.CloseStatement,"Expected closing statement token");const l=[];for(;i(n.OpenStatement,n.EndFor)&&i(n.OpenStatement,n.Else);)l.push(o());const d=[];if(s(n.OpenStatement,n.Else))for(++r,++r,a(n.CloseStatement,"Expected closing statement token");i(n.OpenStatement,n.EndFor);)d.push(o());return new A(e,t,l,d)}(),a(n.OpenStatement,"Expected {% token"),a(n.EndFor,"Expected endfor token"),a(n.CloseStatement,"Expected %} token");break;default:throw new SyntaxError(`Unknown statement type: ${e[r].type}`)}return t}();case n.OpenExpression:return function(){a(n.OpenExpression,"Expected opening expression token");const e=c();return a(n.CloseExpression,"Expected closing expression token"),e}();default:throw new SyntaxError(`Unexpected token type: ${e[r].type}`)}}function i(...t){return r+t.length<=e.length&&t.some(((t,n)=>t!==e[r+n].type))}function s(...t){return r+t.length<=e.length&&t.every(((t,n)=>t===e[r+n].type))}function l(){const e=c();if(s(n.Equals)){++r;const t=l();return new h(e,t)}return e}function d(){const t=c();a(n.CloseStatement,"Expected closing statement token");const i=[],l=[];for(;e[r]?.type!==n.OpenStatement||e[r+1]?.type!==n.ElseIf&&e[r+1]?.type!==n.Else&&e[r+1]?.type!==n.EndIf;)i.push(o());if(e[r]?.type===n.OpenStatement&&e[r+1]?.type!==n.EndIf)if(++r,s(n.ElseIf))a(n.ElseIf,"Expected elseif token"),l.push(d());else for(a(n.Else,"Expected else token"),a(n.CloseStatement,"Expected closing statement token");e[r]?.type!==n.OpenStatement||e[r+1]?.type!==n.EndIf;)l.push(o());return new g(t,i,l)}function u(e=!1){const t=e?I:c,a=[t()],o=s(n.Comma);for(;o&&(++r,a.push(t()),s(n.Comma)););return o?new y(a):a[0]}function c(){return function(){const e=m();if(s(n.If)){++r;const t=m();if(s(n.Else)){++r;const n=m();return new g(t,[e],[n])}return new R(e,t)}return e}()}function m(){let t=K();for(;s(n.Or);){const n=e[r];++r;const a=K();t=new E(n,t,a)}return t}function K(){let t=X();for(;s(n.And);){const n=e[r];++r;const a=X();t=new E(n,t,a)}return t}function X(){let t;for(;s(n.Not);){const n=e[r];++r;const a=X();t=new S(n,a)}return t??function(){let t=V();for(;s(n.ComparisonBinaryOperator)||s(n.In)||s(n.NotIn);){const n=e[r];++r;const a=V();t=new E(n,t,a)}return t}()}function V(){let t=L();for(;s(n.AdditiveBinaryOperator);){const n=e[r];++r;const a=L();t=new E(n,t,a)}return t}function k(e){let t=new w(e,M());return t=Y(t),s(n.OpenParen)&&(t=k(t)),t}function M(){a(n.OpenParen,"Expected opening parenthesis for arguments list");const e=function(){const e=[];for(;!s(n.CloseParen);){let t=c();if(s(n.Equals)){if(++r,!(t instanceof b))throw new SyntaxError("Expected identifier for keyword argument");const e=c();t=new Z(t,e)}e.push(t),s(n.Comma)&&++r}return e}();return a(n.CloseParen,"Expected closing parenthesis for arguments list"),e}function H(){const e=[];let t=!1;for(;!s(n.CloseSquareBracket);)s(n.Colon)?(e.push(void 0),++r,t=!0):(e.push(c()),s(n.Colon)&&(++r,t=!0));if(0===e.length)throw new SyntaxError("Expected at least one argument for member/slice expression");if(t){if(e.length>3)throw new SyntaxError("Expected 0-3 arguments for slice expression");return new T(...e)}return e[0]}function Y(t){for(;s(n.Dot)||s(n.OpenSquareBracket);){const o=e[r];let i;++r;const s=o.type!==n.Dot;if(s)i=H(),a(n.CloseSquareBracket,"Expected closing square bracket");else if(i=I(),"Identifier"!==i.type)throw new SyntaxError("Expected identifier following dot operator");t=new C(t,i,s)}return t}function L(){let t=N();for(;s(n.MultiplicativeBinaryOperator);){const n=e[r];++r;const a=N();t=new E(n,t,a)}return t}function N(){let e=function(){let e=function(){const e=Y(I());return s(n.OpenParen)?k(e):e}();for(;s(n.Pipe);){++r;let t=I();if(!(t instanceof b))throw new SyntaxError("Expected identifier for the filter");s(n.OpenParen)&&(t=k(t)),e=new G(e,t)}return e}();for(;s(n.Is);){++r;const t=s(n.Not);t&&++r;let a=I();if(a instanceof W?a=new b(a.value.toString()):a instanceof F&&(a=new b("none")),!(a instanceof b))throw new SyntaxError("Expected identifier for the test");e=new x(e,t,a)}return e}function I(){const t=e[r];switch(t.type){case n.NumericLiteral:return++r,new f(Number(t.value));case n.StringLiteral:return++r,new Q(t.value);case n.BooleanLiteral:return++r,new W("true"===t.value.toLowerCase());case n.NullLiteral:return++r,new F(null);case n.Identifier:return++r,new b(t.value);case n.OpenParen:{++r;const t=u();if(e[r].type!==n.CloseParen)throw new SyntaxError(`Expected closing parenthesis, got ${e[r].type} instead`);return++r,t}case n.OpenSquareBracket:{++r;const e=[];for(;!s(n.CloseSquareBracket);)e.push(c()),s(n.Comma)&&++r;return++r,new _(e)}case n.OpenCurlyBracket:{++r;const e=new Map;for(;!s(n.CloseCurlyBracket);){const t=c();a(n.Colon,"Expected colon between key and value in object literal");const o=c();e.set(t,o),s(n.Comma)&&++r}return++r,new v(e)}default:throw new SyntaxError(`Unexpected token: ${t.type}`)}}for(;r<e.length;)t.body.push(o());return t}function V(e,t,r=1){void 0===t&&(t=e,e=0);const n=[];for(let a=e;a<t;a+=r)n.push(a);return n}function k(e,t,r,n=1){const a=Math.sign(n);a>=0?(t=(t??=0)<0?Math.max(e.length+t,0):Math.min(t,e.length),r=(r??=e.length)<0?Math.max(e.length+r,0):Math.min(r,e.length)):(t=(t??=e.length-1)<0?Math.max(e.length+t,-1):Math.min(t,e.length-1),r=(r??=-1)<-1?Math.max(e.length+r,-1):Math.min(r,e.length-1));const o=[];for(let i=t;a*i<a*r;i+=n)o.push(e[i]);return o}function M(e){return e.replace(/\b\w/g,(e=>e.toUpperCase()))}var H=class{type="RuntimeValue";value;builtins=new Map;constructor(e=void 0){this.value=e}__bool__(){return new N(!!this.value)}},Y=class extends H{type="NumericValue"},L=class extends H{type="StringValue";builtins=new Map([["upper",new P((()=>new L(this.value.toUpperCase())))],["lower",new P((()=>new L(this.value.toLowerCase())))],["strip",new P((()=>new L(this.value.trim())))],["title",new P((()=>new L(M(this.value))))],["length",new Y(this.value.length)],["rstrip",new P((()=>new L(this.value.trimEnd())))],["lstrip",new P((()=>new L(this.value.trimStart())))],["split",new P((e=>{const t=e[0]??new O;if(!(t instanceof L||t instanceof O))throw new Error("sep argument must be a string or null");const r=e[1]??new Y(-1);if(!(r instanceof Y))throw new Error("maxsplit argument must be a number");let n=[];if(t instanceof O){const e=this.value.trimStart();for(const{0:t,index:a}of e.matchAll(/\S+/g)){if(-1!==r.value&&n.length>=r.value&&void 0!==a){n.push(t+e.slice(a+t.length));break}n.push(t)}}else{if(""===t.value)throw new Error("empty separator");n=this.value.split(t.value),-1!==r.value&&n.length>r.value&&n.push(n.splice(r.value).join(t.value))}return new D(n.map((e=>new L(e))))}))]])},N=class extends H{type="BooleanValue"},I=class extends H{type="ObjectValue";__bool__(){return new N(this.value.size>0)}builtins=new Map([["get",new P((([e,t])=>{if(!(e instanceof L))throw new Error(`Object key must be a string: got ${e.type}`);return this.value.get(e.value)??t??new O}))],["items",new P((()=>new D(Array.from(this.value.entries()).map((([e,t])=>new D([new L(e),t]))))))]])},U=class extends I{type="KeywordArgumentsValue"},D=class extends H{type="ArrayValue";builtins=new Map([["length",new Y(this.value.length)]]);__bool__(){return new N(this.value.length>0)}},J=class extends D{type="TupleValue"},P=class extends H{type="FunctionValue"},O=class extends H{type="NullValue"},z=class extends H{type="UndefinedValue"},j=class{constructor(e){this.parent=e}variables=new Map([["namespace",new P((e=>{if(0===e.length)return new I(new Map);if(1!==e.length||!(e[0]instanceof I))throw new Error("`namespace` expects either zero arguments or a single object argument");return e[0]}))]]);tests=new Map([["boolean",e=>"BooleanValue"===e.type],["callable",e=>e instanceof P],["odd",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "odd" to type: ${e.type}`);return e.value%2!=0}],["even",e=>{if("NumericValue"!==e.type)throw new Error(`Cannot apply test "even" to type: ${e.type}`);return e.value%2==0}],["false",e=>"BooleanValue"===e.type&&!e.value],["true",e=>"BooleanValue"===e.type&&e.value],["none",e=>"NullValue"===e.type],["string",e=>"StringValue"===e.type],["number",e=>"NumericValue"===e.type],["integer",e=>"NumericValue"===e.type&&Number.isInteger(e.value)],["iterable",e=>"ArrayValue"===e.type||"StringValue"===e.type],["mapping",e=>"ObjectValue"===e.type],["lower",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toLowerCase()}],["upper",e=>{const t=e.value;return"StringValue"===e.type&&t===t.toUpperCase()}],["none",e=>"NullValue"===e.type],["defined",e=>"UndefinedValue"!==e.type],["undefined",e=>"UndefinedValue"===e.type],["equalto",(e,t)=>e.value===t.value],["eq",(e,t)=>e.value===t.value]]);set(e,t){return this.declareVariable(e,q(t))}declareVariable(e,t){if(this.variables.has(e))throw new SyntaxError(`Variable already declared: ${e}`);return this.variables.set(e,t),t}setVariable(e,t){return this.variables.set(e,t),t}resolve(e){if(this.variables.has(e))return this;if(this.parent)return this.parent.resolve(e);throw new Error(`Unknown variable: ${e}`)}lookupVariable(e){try{return this.resolve(e).variables.get(e)??new z}catch{return new z}}},$=class{global;constructor(e){this.global=e??new j}run(e){return this.evaluate(e,this.global)}evaluateBinaryExpression(e,t){const r=this.evaluate(e.left,t);switch(e.operator.value){case"and":return r.__bool__().value?this.evaluate(e.right,t):r;case"or":return r.__bool__().value?r:this.evaluate(e.right,t)}const n=this.evaluate(e.right,t);switch(e.operator.value){case"==":return new N(r.value==n.value);case"!=":return new N(r.value!=n.value)}if(r instanceof z||n instanceof z)throw new Error("Cannot perform operation on undefined values");if(r instanceof O||n instanceof O)throw new Error("Cannot perform operation on null values");if(r instanceof Y&&n instanceof Y)switch(e.operator.value){case"+":return new Y(r.value+n.value);case"-":return new Y(r.value-n.value);case"*":return new Y(r.value*n.value);case"/":return new Y(r.value/n.value);case"%":return new Y(r.value%n.value);case"<":return new N(r.value<n.value);case">":return new N(r.value>n.value);case">=":return new N(r.value>=n.value);case"<=":return new N(r.value<=n.value)}else if(r instanceof D&&n instanceof D){if("+"===e.operator.value)return new D(r.value.concat(n.value))}else if(n instanceof D){const t=void 0!==n.value.find((e=>e.value===r.value));switch(e.operator.value){case"in":return new N(t);case"not in":return new N(!t)}}if((r instanceof L||n instanceof L)&&"+"===e.operator.value)return new L(r.value.toString()+n.value.toString());if(r instanceof L&&n instanceof L)switch(e.operator.value){case"in":return new N(n.value.includes(r.value));case"not in":return new N(!n.value.includes(r.value))}if(r instanceof L&&n instanceof I)switch(e.operator.value){case"in":return new N(n.value.has(r.value));case"not in":return new N(!n.value.has(r.value))}throw new SyntaxError(`Unknown operator "${e.operator.value}" between ${r.type} and ${n.type}`)}evaluateArguments(e,t){const r=[],n=new Map;for(const a of e)if("KeywordArgumentExpression"===a.type){const e=a;n.set(e.key.value,this.evaluate(e.value,t))}else{if(n.size>0)throw new Error("Positional arguments must come before keyword arguments");r.push(this.evaluate(a,t))}return[r,n]}evaluateFilterExpression(e,t){const r=this.evaluate(e.operand,t);if("Identifier"===e.filter.type){const t=e.filter;if("tojson"===t.value)return new L(ee(r));if(r instanceof D)switch(t.value){case"list":return r;case"first":return r.value[0];case"last":return r.value[r.value.length-1];case"length":return new Y(r.value.length);case"reverse":return new D(r.value.reverse());case"sort":return new D(r.value.sort(((e,t)=>{if(e.type!==t.type)throw new Error(`Cannot compare different types: ${e.type} and ${t.type}`);switch(e.type){case"NumericValue":return e.value-t.value;case"StringValue":return e.value.localeCompare(t.value);default:throw new Error(`Cannot compare type: ${e.type}`)}})));case"join":return new L(r.value.map((e=>e.value)).join(""));default:throw new Error(`Unknown ArrayValue filter: ${t.value}`)}else if(r instanceof L)switch(t.value){case"length":return new Y(r.value.length);case"upper":return new L(r.value.toUpperCase());case"lower":return new L(r.value.toLowerCase());case"title":return new L(M(r.value));case"capitalize":return new L(r.value.charAt(0).toUpperCase()+r.value.slice(1));case"trim":return new L(r.value.trim());case"indent":return new L(r.value.split("\n").map(((e,t)=>0===t||0===e.length?e:"    "+e)).join("\n"));case"join":case"string":return r;default:throw new Error(`Unknown StringValue filter: ${t.value}`)}else{if(r instanceof Y){if("abs"===t.value)return new Y(Math.abs(r.value));throw new Error(`Unknown NumericValue filter: ${t.value}`)}if(r instanceof I)switch(t.value){case"items":return new D(Array.from(r.value.entries()).map((([e,t])=>new D([new L(e),t]))));case"length":return new Y(r.value.size);default:throw new Error(`Unknown ObjectValue filter: ${t.value}`)}}throw new Error(`Cannot apply filter "${t.value}" to type: ${r.type}`)}if("CallExpression"===e.filter.type){const n=e.filter;if("Identifier"!==n.callee.type)throw new Error(`Unknown filter: ${n.callee.type}`);const a=n.callee.value;if("tojson"===a){const[,e]=this.evaluateArguments(n.args,t),a=e.get("indent")??new O;if(!(a instanceof Y||a instanceof O))throw new Error("If set, indent must be a number");return new L(ee(r,a.value))}if("join"===a){let e;if(r instanceof L)e=Array.from(r.value);else{if(!(r instanceof D))throw new Error(`Cannot apply filter "${a}" to type: ${r.type}`);e=r.value.map((e=>e.value))}const[o,i]=this.evaluateArguments(n.args,t),s=o.at(0)??i.get("separator")??new L("");if(!(s instanceof L))throw new Error("separator must be a string");return new L(e.join(s.value))}if(r instanceof D){switch(a){case"selectattr":case"rejectattr":{const e="selectattr"===a;if(r.value.some((e=>!(e instanceof I))))throw new Error(`\`${a}\` can only be applied to array of objects`);if(n.args.some((e=>"StringLiteral"!==e.type)))throw new Error(`arguments of \`${a}\` must be strings`);const[o,i,s]=n.args.map((e=>this.evaluate(e,t)));let l;if(i){const e=t.tests.get(i.value);if(!e)throw new Error(`Unknown test: ${i.value}`);l=e}else l=(...e)=>e[0].__bool__().value;const d=r.value.filter((t=>{const r=t.value.get(o.value),n=!!r&&l(r,s);return e?n:!n}));return new D(d)}case"map":{const[,e]=this.evaluateArguments(n.args,t);if(e.has("attribute")){const t=e.get("attribute");if(!(t instanceof L))throw new Error("attribute must be a string");const n=e.get("default"),a=r.value.map((e=>{if(!(e instanceof I))throw new Error("items in map must be an object");return e.value.get(t.value)??n??new z}));return new D(a)}throw new Error("`map` expressions without `attribute` set are not currently supported.")}}throw new Error(`Unknown ArrayValue filter: ${a}`)}if(r instanceof L){if("indent"===a){const[e,a]=this.evaluateArguments(n.args,t),o=e.at(0)??a.get("width")??new Y(4);if(!(o instanceof Y))throw new Error("width must be a number");const i=e.at(1)??a.get("first")??new N(!1),s=e.at(2)??a.get("blank")??new N(!1),l=r.value.split("\n"),d=" ".repeat(o.value),u=l.map(((e,t)=>!i.value&&0===t||!s.value&&0===e.length?e:d+e));return new L(u.join("\n"))}throw new Error(`Unknown StringValue filter: ${a}`)}throw new Error(`Cannot apply filter "${a}" to type: ${r.type}`)}throw new Error(`Unknown filter: ${e.filter.type}`)}evaluateTestExpression(e,t){const r=this.evaluate(e.operand,t),n=t.tests.get(e.test.value);if(!n)throw new Error(`Unknown test: ${e.test.value}`);const a=n(r);return new N(e.negate?!a:a)}evaluateUnaryExpression(e,t){const r=this.evaluate(e.argument,t);if("not"===e.operator.value)return new N(!r.value);throw new SyntaxError(`Unknown operator: ${e.operator.value}`)}evalProgram(e,t){return this.evaluateBlock(e.body,t)}evaluateBlock(e,t){let r="";for(const n of e){const e=this.evaluate(n,t);"NullValue"!==e.type&&"UndefinedValue"!==e.type&&(r+=e.value)}return new L(r)}evaluateIdentifier(e,t){return t.lookupVariable(e.value)}evaluateCallExpression(e,t){const[r,n]=this.evaluateArguments(e.args,t);n.size>0&&r.push(new U(n));const a=this.evaluate(e.callee,t);if("FunctionValue"!==a.type)throw new Error(`Cannot call something that is not a function: got ${a.type}`);return a.value(r,t)}evaluateSliceExpression(e,t,r){if(!(e instanceof D||e instanceof L))throw new Error("Slice object must be an array or string");const n=this.evaluate(t.start,r),a=this.evaluate(t.stop,r),o=this.evaluate(t.step,r);if(!(n instanceof Y||n instanceof z))throw new Error("Slice start must be numeric or undefined");if(!(a instanceof Y||a instanceof z))throw new Error("Slice stop must be numeric or undefined");if(!(o instanceof Y||o instanceof z))throw new Error("Slice step must be numeric or undefined");return e instanceof D?new D(k(e.value,n.value,a.value,o.value)):new L(k(Array.from(e.value),n.value,a.value,o.value).join(""))}evaluateMemberExpression(e,t){const r=this.evaluate(e.object,t);let n,a;if(e.computed){if("SliceExpression"===e.property.type)return this.evaluateSliceExpression(r,e.property,t);n=this.evaluate(e.property,t)}else n=new L(e.property.value);if(r instanceof I){if(!(n instanceof L))throw new Error(`Cannot access property with non-string: got ${n.type}`);a=r.value.get(n.value)??r.builtins.get(n.value)}else if(r instanceof D||r instanceof L)if(n instanceof Y)a=r.value.at(n.value),r instanceof L&&(a=new L(r.value.at(n.value)));else{if(!(n instanceof L))throw new Error(`Cannot access property with non-string/non-number: got ${n.type}`);a=r.builtins.get(n.value)}else{if(!(n instanceof L))throw new Error(`Cannot access property with non-string: got ${n.type}`);a=r.builtins.get(n.value)}return a instanceof H?a:new z}evaluateSet(e,t){const r=this.evaluate(e.value,t);if("Identifier"===e.assignee.type){const n=e.assignee.value;t.setVariable(n,r)}else{if("MemberExpression"!==e.assignee.type)throw new Error(`Invalid LHS inside assignment expression: ${JSON.stringify(e.assignee)}`);{const n=e.assignee,a=this.evaluate(n.object,t);if(!(a instanceof I))throw new Error("Cannot assign to member of non-object");if("Identifier"!==n.property.type)throw new Error("Cannot assign to member with non-identifier property");a.value.set(n.property.value,r)}}return new O}evaluateIf(e,t){const r=this.evaluate(e.test,t);return this.evaluateBlock(r.__bool__().value?e.body:e.alternate,t)}evaluateFor(e,t){const r=new j(t);let n,a;if("SelectExpression"===e.iterable.type){const t=e.iterable;a=this.evaluate(t.iterable,r),n=t.test}else a=this.evaluate(e.iterable,r);if(!(a instanceof D))throw new Error(`Expected iterable type in for loop: got ${a.type}`);const o=[],i=[];for(let t=0;t<a.value.length;++t){const s=new j(r),l=a.value[t];let d;if("Identifier"===e.loopvar.type)d=t=>t.setVariable(e.loopvar.value,l);else{if("TupleLiteral"!==e.loopvar.type)throw new Error(`Invalid loop variable(s): ${e.loopvar.type}`);{const t=e.loopvar;if("ArrayValue"!==l.type)throw new Error(`Cannot unpack non-iterable type: ${l.type}`);const r=l;if(t.value.length!==r.value.length)throw new Error(`Too ${t.value.length>r.value.length?"few":"many"} items to unpack`);d=e=>{for(let n=0;n<t.value.length;++n){if("Identifier"!==t.value[n].type)throw new Error(`Cannot unpack non-identifier type: ${t.value[n].type}`);e.setVariable(t.value[n].value,r.value[n])}}}}if(n){d(s);if(!this.evaluate(n,s).__bool__().value)continue}o.push(l),i.push(d)}let s="",l=!0;for(let t=0;t<o.length;++t){const n=new Map([["index",new Y(t+1)],["index0",new Y(t)],["revindex",new Y(o.length-t)],["revindex0",new Y(o.length-t-1)],["first",new N(0===t)],["last",new N(t===o.length-1)],["length",new Y(o.length)],["previtem",t>0?o[t-1]:new z],["nextitem",t<o.length-1?o[t+1]:new z]]);r.setVariable("loop",new I(n)),i[t](r);s+=this.evaluateBlock(e.body,r).value,l=!1}if(l){s+=this.evaluateBlock(e.defaultBlock,r).value}return new L(s)}evaluateMacro(e,t){return t.setVariable(e.name.value,new P(((t,r)=>{const n=new j(r);let a;t=t.slice(),"KeywordArgumentsValue"===t.at(-1)?.type&&(a=t.pop());for(let r=0;r<e.args.length;++r){const o=e.args[r],i=t[r];if("Identifier"===o.type){const e=o;if(!i)throw new Error(`Missing positional argument: ${e.value}`);n.setVariable(e.value,i)}else{if("KeywordArgumentExpression"!==o.type)throw new Error(`Unknown argument type: ${o.type}`);{const e=o,t=i??a?.value.get(e.key.value)??this.evaluate(e.value,n);n.setVariable(e.key.value,t)}}}return this.evaluateBlock(e.body,n)}))),new O}evaluate(e,t){if(void 0===e)return new z;switch(e.type){case"Program":return this.evalProgram(e,t);case"Set":return this.evaluateSet(e,t);case"If":return this.evaluateIf(e,t);case"For":return this.evaluateFor(e,t);case"Macro":return this.evaluateMacro(e,t);case"NumericLiteral":return new Y(Number(e.value));case"StringLiteral":return new L(e.value);case"BooleanLiteral":return new N(e.value);case"NullLiteral":return new O(e.value);case"ArrayLiteral":return new D(e.value.map((e=>this.evaluate(e,t))));case"TupleLiteral":return new J(e.value.map((e=>this.evaluate(e,t))));case"ObjectLiteral":{const r=new Map;for(const[n,a]of e.value){const e=this.evaluate(n,t);if(!(e instanceof L))throw new Error(`Object keys must be strings: got ${e.type}`);r.set(e.value,this.evaluate(a,t))}return new I(r)}case"Identifier":return this.evaluateIdentifier(e,t);case"CallExpression":return this.evaluateCallExpression(e,t);case"MemberExpression":return this.evaluateMemberExpression(e,t);case"UnaryExpression":return this.evaluateUnaryExpression(e,t);case"BinaryExpression":return this.evaluateBinaryExpression(e,t);case"FilterExpression":return this.evaluateFilterExpression(e,t);case"TestExpression":return this.evaluateTestExpression(e,t);default:throw new SyntaxError(`Unknown node type: ${e.type}`)}}};function q(e){switch(typeof e){case"number":return new Y(e);case"string":return new L(e);case"boolean":return new N(e);case"undefined":return new z;case"object":return null===e?new O:Array.isArray(e)?new D(e.map(q)):new I(new Map(Object.entries(e).map((([e,t])=>[e,q(t)]))));case"function":return new P(((t,r)=>q(e(...t.map((e=>e.value)))??null)));default:throw new Error(`Cannot convert to runtime value: ${e}`)}}function ee(e,t,r){const n=r??0;switch(e.type){case"NullValue":case"UndefinedValue":return"null";case"NumericValue":case"StringValue":case"BooleanValue":return JSON.stringify(e.value);case"ArrayValue":case"ObjectValue":{const r=t?" ".repeat(t):"",a="\n"+r.repeat(n),o=a+r;if("ArrayValue"===e.type){const r=e.value.map((e=>ee(e,t,n+1)));return t?`[${o}${r.join(`,${o}`)}${a}]`:`[${r.join(", ")}]`}{const r=Array.from(e.value.entries()).map((([e,r])=>{const a=`"${e}": ${ee(r,t,n+1)}`;return t?`${o}${a}`:a}));return t?`{${r.join(",")}${a}}`:`{${r.join(", ")}}`}}default:throw new Error(`Cannot convert to JSON: ${e.type}`)}}var te=class{parsed;constructor(e){const t=u(e,{lstrip_blocks:!0,trim_blocks:!0});this.parsed=X(t)}render(e){const t=new j;if(t.set("false",!1),t.set("true",!0),t.set("raise_exception",(e=>{throw new Error(e)})),t.set("range",V),e)for(const[r,n]of Object.entries(e))t.set(r,n);return new $(t).run(this.parsed).value}}},"./src/backends/onnx.js":
/*!******************************!*\
  !*** ./src/backends/onnx.js ***!
  \******************************/(e,t,r)=>{var n;r.r(t),r.d(t,{Tensor:()=>s.Tensor,createInferenceSession:()=>B,deviceToExecutionProviders:()=>A,isONNXProxy:()=>w,isONNXTensor:()=>m});var a=r(/*! ../env.js */"./src/env.js"),o=r(/*! onnxruntime-node */"?2ce3"),i=r(/*! onnxruntime-web */"onnxruntime-web"),s=r(/*! onnxruntime-common */"onnxruntime-common");const l=Object.freeze({auto:null,gpu:null,cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:{name:"webnn",deviceType:"cpu"},"webnn-npu":{name:"webnn",deviceType:"npu"},"webnn-gpu":{name:"webnn",deviceType:"gpu"},"webnn-cpu":{name:"webnn",deviceType:"cpu"}}),d=[];let u,c;const p=Symbol.for("onnxruntime");if(p in globalThis)c=globalThis[p];else if(a.apis.IS_NODE_ENV){switch(c=o??(n||(n=r.t(o,2))),process.platform){case"win32":d.push("dml");break;case"linux":"x64"===process.arch&&d.push("cuda")}d.push("cpu"),u=["cpu"]}else c=i,a.apis.IS_WEBNN_AVAILABLE&&d.push("webnn-npu","webnn-gpu","webnn-cpu","webnn"),a.apis.IS_WEBGPU_AVAILABLE&&d.push("webgpu"),d.push("wasm"),u=["wasm"];const g=c.InferenceSession;function A(e=null){if(!e)return u;switch(e){case"auto":return d;case"gpu":return d.filter((e=>["webgpu","cuda","dml","webnn-gpu"].includes(e)))}if(d.includes(e))return[l[e]??e];throw new Error(`Unsupported device: "${e}". Should be one of: ${d.join(", ")}.`)}let h=null;async function B(e,t,r){h&&await h;const n=g.create(e,t);h??=n;const a=await n;return a.config=r,a}function m(e){return e instanceof c.Tensor}const C=c?.env;function w(){return C?.wasm?.proxy}C?.wasm&&("undefined"!=typeof ServiceWorkerGlobalScope&&self instanceof ServiceWorkerGlobalScope||C.wasm.wasmPaths||(C.wasm.wasmPaths=`https://cdn.jsdelivr.net/npm/@huggingface/transformers@${a.env.version}/dist/`),C.wasm.proxy=!1),C?.webgpu&&(C.webgpu.powerPreference="high-performance"),a.env.backends.onnx=C},"./src/base/feature_extraction_utils.js":
/*!**********************************************!*\
  !*** ./src/base/feature_extraction_utils.js ***!
  \**********************************************/(e,t,r)=>{r.r(t),r.d(t,{FeatureExtractor:()=>i,validate_audio_inputs:()=>s});var n=r(/*! ../utils/constants.js */"./src/utils/constants.js"),a=r(/*! ../utils/generic.js */"./src/utils/generic.js"),o=r(/*! ../utils/hub.js */"./src/utils/hub.js");class i extends a.Callable{constructor(e){super(),this.config=e}static async from_pretrained(e,t){return new this(await(0,o.getModelJSON)(e,n.FEATURE_EXTRACTOR_NAME,!0,t))}}function s(e,t){if(!(e instanceof Float32Array||e instanceof Float64Array))throw new Error(`${t} expects input to be a Float32Array or a Float64Array, but got ${e?.constructor?.name??typeof e} instead. If using the feature extractor directly, remember to use \`read_audio(url, sampling_rate)\` to obtain the raw audio data of the file/url.`)}},"./src/base/image_processors_utils.js":
/*!********************************************!*\
  !*** ./src/base/image_processors_utils.js ***!
  \********************************************/(e,t,r)=>{r.r(t),r.d(t,{ImageProcessor:()=>w,center_to_corners_format:()=>c,post_process_instance_segmentation:()=>C,post_process_object_detection:()=>p,post_process_panoptic_segmentation:()=>m,post_process_semantic_segmentation:()=>g});var n=r(/*! ../utils/generic.js */"./src/utils/generic.js"),a=r(/*! ../utils/tensor.js */"./src/utils/tensor.js"),o=r(/*! ../utils/maths.js */"./src/utils/maths.js");r(/*! ../utils/image.js */"./src/utils/image.js");var i=r(/*! ../utils/core.js */"./src/utils/core.js"),s=r(/*! ../utils/hub.js */"./src/utils/hub.js"),l=r(/*! ../utils/constants.js */"./src/utils/constants.js");function d(e,t,r=0,n=null){const a=e/t;let i=(0,o.bankers_round)(a)*t;return null!==n&&i>n&&(i=Math.floor(a)*t),i<r&&(i=Math.ceil(a)*t),i}function u([e,t],r){return[Math.max(Math.floor(e/r),1)*r,Math.max(Math.floor(t/r),1)*r]}function c([e,t,r,n]){return[e-r/2,t-n/2,e+r/2,t+n/2]}function p(e,t=.5,r=null,n=!1){const a=e.logits,i=e.pred_boxes,[s,l,d]=a.dims;if(null!==r&&r.length!==s)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let u=[];for(let e=0;e<s;++e){let s=null!==r?r[e]:null,p={boxes:[],classes:[],scores:[]},g=a[e],A=i[e];for(let e=0;e<l;++e){let r,a=g[e],i=[];if(n){r=a.sigmoid().data;for(let e=0;e<r.length;++e)r[e]>t&&i.push(e)}else{let e=(0,o.max)(a.data)[1];if(e===d-1)continue;if(r=(0,o.softmax)(a.data),r[e]<t)continue;i.push(e)}for(const t of i){let n=A[e].data;n=c(n),null!==s&&(n=n.map(((e,t)=>e*s[(t+1)%2]))),p.boxes.push(n),p.classes.push(t),p.scores.push(r[t])}}u.push(p)}return u}function g(e,t=null){const r=e.logits,n=r.dims[0];if(null!==t&&t.length!==n)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const o=[];for(let e=0;e<n;++e){const n=null!==t?t[e]:null;let i=r[e];null!==n&&(i=(0,a.interpolate)(i,n,"bilinear",!1));const[s,l]=n??i.dims.slice(-2),d=new a.Tensor("int32",new Int32Array(s*l),[s,l]),u=i[0].data,c=d.data;for(let e=1;e<i.dims[0];++e){const t=i[e].data;for(let r=0;r<t.length;++r)t[r]>u[r]&&(u[r]=t[r],c[r]=e)}const p=new Array(i.dims[0]);for(let e=0;e<c.length;++e){const t=c[e];p[t]=t}const g=p.filter((e=>void 0!==e));o.push({segmentation:d,labels:g})}return o}function A(e,t,r,n){const a=[],i=[],s=[];for(let l=0;l<e.dims[0];++l){const d=e[l],u=t[l],c=(0,o.max)(d.data)[1];if(c===n)continue;const p=(0,o.softmax)(d.data)[c];p>r&&(a.push(u),i.push(p),s.push(c))}return[a,i,s]}function h(e,t,r,n=.5,a=.8){const o=[];let i=0,s=0;const l=t[r].data;for(let t=0;t<e.length;++t)e[t]===r&&(o.push(t),++i),l[t]>=n&&++s;let d=i>0&&s>0;if(d){d=i/s>a}return[d,o]}function B(e,t,r,n,o,i=null,s=null){const[l,d]=s??e[0].dims,u=new a.Tensor("int32",new Int32Array(l*d),[l,d]),c=[];if(null!==s)for(let t=0;t<e.length;++t)e[t]=(0,a.interpolate)(e[t],s,"bilinear",!1);const p=new Int32Array(e[0].data.length),g=new Float32Array(e[0].data.length);for(let r=0;r<e.length;++r){let n=t[r];const a=e[r].data;for(let e=0;e<a.length;++e)a[e]*=n,a[e]>g[e]&&(p[e]=r,g[e]=a[e])}let A=0;const B=u.data;for(let a=0;a<r.length;++a){const i=r[a],[s,l]=h(p,e,a,n,o);if(s){++A;for(const e of l)B[e]=A;c.push({id:A,label_id:i,score:t[a]})}}return[u,c]}function m(e,t=.5,r=.5,n=.8,o=null,i=null){null===o&&(console.warn("`label_ids_to_fuse` unset. No instance will be fused."),o=new Set);const s=e.class_queries_logits??e.logits,l=(e.masks_queries_logits??e.pred_masks).sigmoid();let[d,u,c]=s.dims;if(c-=1,null!==i&&i.length!==d)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");let p=[];for(let e=0;e<d;++e){let d=null!==i?i[e]:null,u=s[e],g=l[e],[h,m,C]=A(u,g,t,c);if(0===C.length){let[e,t]=d??g.dims.slice(-2),r=new a.Tensor("int32",new Int32Array(e*t).fill(-1),[e,t]);p.push({segmentation:r,segments_info:[]});continue}let[w,b]=B(h,m,C,r,n,o,d);p.push({segmentation:w,segments_info:b})}return p}function C(e,t=.5,r=null){throw new Error("`post_process_instance_segmentation` is not yet implemented.")}class w extends n.Callable{constructor(e){super(),this.image_mean=e.image_mean??e.mean,this.image_std=e.image_std??e.std,this.resample=e.resample??2,this.do_rescale=e.do_rescale??!0,this.rescale_factor=e.rescale_factor??1/255,this.do_normalize=e.do_normalize,this.do_thumbnail=e.do_thumbnail,this.size=e.size??e.image_size,this.do_resize=e.do_resize??void 0!==this.size,this.size_divisibility=e.size_divisibility??e.size_divisor,this.do_center_crop=e.do_center_crop,this.crop_size=e.crop_size,this.do_convert_rgb=e.do_convert_rgb??!0,this.do_crop_margin=e.do_crop_margin,this.pad_size=e.pad_size,this.do_pad=e.do_pad,this.do_pad&&!this.pad_size&&this.size&&void 0!==this.size.width&&void 0!==this.size.height&&(this.pad_size=this.size),this.do_flip_channel_order=e.do_flip_channel_order??!1,this.config=e}async thumbnail(e,t,r=2){const n=e.height,a=e.width,o=t.height,i=t.width;let s=Math.min(n,o),l=Math.min(a,i);return s===n&&l===a?e:(n>a?l=Math.floor(a*s/n):a>n&&(s=Math.floor(n*l/a)),await e.resize(l,s,{resample:r}))}async crop_margin(e,t=200){const r=e.clone().grayscale(),n=(0,o.min)(r.data)[0],a=(0,o.max)(r.data)[0]-n;if(0===a)return e;const i=t/255;let s=r.width,l=r.height,d=0,u=0;const c=r.data;for(let e=0;e<r.height;++e){const t=e*r.width;for(let o=0;o<r.width;++o)(c[t+o]-n)/a<i&&(s=Math.min(s,o),l=Math.min(l,e),d=Math.max(d,o),u=Math.max(u,e))}return e=await e.crop([s,l,d,u])}pad_image(e,t,r,{mode:n="constant",center:a=!1,constant_values:o=0}={}){const[s,l,d]=t;let u,c;if("number"==typeof r?(u=r,c=r):"square"===r?u=c=Math.max(s,l):(u=r.width,c=r.height),u!==l||c!==s){const r=new Float32Array(u*c*d);if(Array.isArray(o))for(let e=0;e<r.length;++e)r[e]=o[e%d];else 0!==o&&r.fill(o);const[p,g]=a?[Math.floor((u-l)/2),Math.floor((c-s)/2)]:[0,0];for(let t=0;t<s;++t){const n=(t+g)*u,a=t*l;for(let t=0;t<l;++t){const o=(n+t+p)*d,i=(a+t)*d;for(let t=0;t<d;++t)r[o+t]=e[i+t]}}if("symmetric"===n){if(a)throw new Error("`center` padding is not supported when `mode` is set to `symmetric`.");const t=s-1,n=l-1;for(let a=0;a<c;++a){const o=a*u,c=(0,i.calculateReflectOffset)(a,t)*l;for(let t=0;t<u;++t){if(a<s&&t<l)continue;const u=(o+t)*d,p=(c+(0,i.calculateReflectOffset)(t,n))*d;for(let t=0;t<d;++t)r[u+t]=e[p+t]}}}e=r,t=[c,u,d]}return[e,t]}rescale(e){for(let t=0;t<e.length;++t)e[t]=this.rescale_factor*e[t]}get_resize_output_image_size(e,t){const[r,n]=e.size;let a,o;if(this.do_thumbnail){const{height:e,width:r}=t;a=Math.min(e,r)}else Number.isInteger(t)?(a=t,o=this.config.max_size??a):void 0!==t&&(a=t.shortest_edge,o=t.longest_edge);if(void 0!==a||void 0!==o){const e=void 0===a?1:Math.max(a/r,a/n),t=r*e,i=n*e,s=void 0===o?1:Math.min(o/t,o/i);let l=Math.floor(Number((t*s).toFixed(2))),d=Math.floor(Number((i*s).toFixed(2)));return void 0!==this.size_divisibility&&([l,d]=u([l,d],this.size_divisibility)),[l,d]}if(void 0!==t&&void 0!==t.width&&void 0!==t.height){let e=t.width,a=t.height;if(this.config.keep_aspect_ratio&&this.config.ensure_multiple_of){let t=a/n,o=e/r;Math.abs(1-o)<Math.abs(1-t)?t=o:o=t,a=d(t*n,this.config.ensure_multiple_of),e=d(o*r,this.config.ensure_multiple_of)}return[e,a]}if(void 0!==this.size_divisibility)return u([r,n],this.size_divisibility);if(void 0!==t.min_pixels&&void 0!==t.max_pixels){const{min_pixels:e,max_pixels:a}=t;return function(e,t,r=28,n=3136,a=1003520){if(e<r||t<r)throw new Error(`height:${e} or width:${t} must be larger than factor:${r}`);if(Math.max(e,t)/Math.min(e,t)>200)throw new Error("absolute aspect ratio must be smaller than 200, got "+Math.max(e,t)/Math.min(e,t));let o=Math.round(e/r)*r,i=Math.round(t/r)*r;if(o*i>a){const n=Math.sqrt(e*t/a);o=Math.floor(e/n/r)*r,i=Math.floor(t/n/r)*r}else if(o*i<n){const a=Math.sqrt(n/(e*t));o=Math.ceil(e*a/r)*r,i=Math.ceil(t*a/r)*r}return[o,i]}(n,r,this.config.patch_size*this.config.merge_size,e,a)}throw new Error(`Could not resize image due to unsupported \`this.size\` option in config: ${JSON.stringify(t)}`)}async resize(e){const[t,r]=this.get_resize_output_image_size(e,this.size);return await e.resize(t,r,{resample:this.resample})}async preprocess(e,{do_normalize:t=null,do_pad:r=null,do_convert_rgb:n=null,do_convert_grayscale:o=null,do_flip_channel_order:i=null}={}){this.do_crop_margin&&(e=await this.crop_margin(e));const[s,l]=e.size;if(n??this.do_convert_rgb?e=e.rgb():o&&(e=e.grayscale()),this.do_resize&&(e=await this.resize(e)),this.do_thumbnail&&(e=await this.thumbnail(e,this.size,this.resample)),this.do_center_crop){let t,r;Number.isInteger(this.crop_size)?(t=this.crop_size,r=this.crop_size):(t=this.crop_size.width,r=this.crop_size.height),e=await e.center_crop(t,r)}const d=[e.height,e.width];let c=Float32Array.from(e.data),p=[e.height,e.width,e.channels];if(this.do_rescale&&this.rescale(c),t??this.do_normalize){let t=this.image_mean;Array.isArray(this.image_mean)||(t=new Array(e.channels).fill(t));let r=this.image_std;if(Array.isArray(this.image_std)||(r=new Array(e.channels).fill(t)),t.length!==e.channels||r.length!==e.channels)throw new Error(`When set to arrays, the length of \`image_mean\` (${t.length}) and \`image_std\` (${r.length}) must match the number of channels in the image (${e.channels}).`);for(let n=0;n<c.length;n+=e.channels)for(let a=0;a<e.channels;++a)c[n+a]=(c[n+a]-t[a])/r[a]}if(r??this.do_pad)if(this.pad_size){const t=this.pad_image(c,[e.height,e.width,e.channels],this.pad_size);[c,p]=t}else if(this.size_divisibility){const[e,t]=u([p[1],p[0]],this.size_divisibility);[c,p]=this.pad_image(c,p,{width:e,height:t})}if(i??this.do_flip_channel_order){if(3!==p[2])throw new Error("Flipping channel order is only supported for RGB images.");for(let e=0;e<c.length;e+=3){const t=c[e];c[e]=c[e+2],c[e+2]=t}}return{original_size:[l,s],reshaped_input_size:d,pixel_values:new a.Tensor("float32",c,p).permute(2,0,1)}}async _call(e,...t){Array.isArray(e)||(e=[e]);const r=await Promise.all(e.map((e=>this.preprocess(e))));return{pixel_values:(0,a.stack)(r.map((e=>e.pixel_values)),0),original_sizes:r.map((e=>e.original_size)),reshaped_input_sizes:r.map((e=>e.reshaped_input_size))}}static async from_pretrained(e,t){return new this(await(0,s.getModelJSON)(e,l.IMAGE_PROCESSOR_NAME,!0,t))}}},"./src/base/processing_utils.js":
/*!**************************************!*\
  !*** ./src/base/processing_utils.js ***!
  \**************************************/(e,t,r)=>{r.r(t),r.d(t,{Processor:()=>i});var n=r(/*! ../utils/constants.js */"./src/utils/constants.js"),a=r(/*! ../utils/generic.js */"./src/utils/generic.js"),o=r(/*! ../utils/hub.js */"./src/utils/hub.js");class i extends a.Callable{static classes=["image_processor_class","tokenizer_class","feature_extractor_class"];static uses_processor_config=!1;constructor(e,t){super(),this.config=e,this.components=t}get image_processor(){return this.components.image_processor}get tokenizer(){return this.components.tokenizer}get feature_extractor(){return this.components.feature_extractor}apply_chat_template(e,t={}){if(!this.tokenizer)throw new Error("Unable to apply chat template without a tokenizer.");return this.tokenizer.apply_chat_template(e,{tokenize:!1,...t})}batch_decode(...e){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.batch_decode(...e)}decode(...e){if(!this.tokenizer)throw new Error("Unable to decode without a tokenizer.");return this.tokenizer.decode(...e)}async _call(e,...t){for(const r of[this.image_processor,this.feature_extractor,this.tokenizer])if(r)return r(e,...t);throw new Error("No image processor, feature extractor, or tokenizer found.")}static async from_pretrained(e,t){const[r,a]=await Promise.all([this.uses_processor_config?(0,o.getModelJSON)(e,n.PROCESSOR_NAME,!0,t):{},Promise.all(this.classes.filter((e=>e in this)).map((async r=>{const n=await this[r].from_pretrained(e,t);return[r.replace(/_class$/,""),n]}))).then(Object.fromEntries)]);return new this(r,a)}}},"./src/configs.js":
/*!************************!*\
  !*** ./src/configs.js ***!
  \************************/(e,t,r)=>{r.r(t),r.d(t,{AutoConfig:()=>l,PretrainedConfig:()=>s,getKeyValueShapes:()=>i});var n=r(/*! ./utils/core.js */"./src/utils/core.js"),a=r(/*! ./utils/hub.js */"./src/utils/hub.js");function o(e){const t={};let r={};switch(e.model_type){case"llava":case"paligemma":case"florence2":case"llava_onevision":case"idefics3":case"ultravox":case"smolvlm":r=o(e.text_config);break;case"moondream1":r=o(e.phi_config);break;case"musicgen":r=o(e.decoder);break;case"multi_modality":r=o(e.language_config);break;case"gpt2":case"gptj":case"jais":case"codegen":case"gpt_bigcode":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="n_embd";break;case"gpt_neox":case"stablelm":case"opt":case"falcon":t.num_heads="num_attention_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size";break;case"llama":case"olmo":case"olmo2":case"mobilellm":case"granite":case"cohere":case"mistral":case"starcoder2":case"qwen2":case"qwen2_vl":case"phi":case"phi3":case"phi3_v":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.hidden_size="hidden_size",t.num_attention_heads="num_attention_heads";break;case"gemma":case"gemma2":case"glm":case"helium":t.num_heads="num_key_value_heads",t.num_layers="num_hidden_layers",t.dim_kv="head_dim";break;case"openelm":t.num_heads="num_kv_heads",t.num_layers="num_transformer_layers",t.dim_kv="head_dim";break;case"gpt_neo":case"donut-swin":t.num_heads="num_heads",t.num_layers="num_layers",t.hidden_size="hidden_size";break;case"bloom":t.num_heads="n_head",t.num_layers="n_layer",t.hidden_size="hidden_size";break;case"mpt":t.num_heads="n_heads",t.num_layers="n_layers",t.hidden_size="d_model";break;case"exaone":t.num_heads="num_key_value_heads",t.num_layers="num_layers",t.dim_kv="head_dim",t.num_attention_heads="num_attention_heads";break;case"t5":case"mt5":case"longt5":t.num_decoder_layers="num_decoder_layers",t.num_decoder_heads="num_heads",t.decoder_dim_kv="d_kv",t.num_encoder_layers="num_layers",t.num_encoder_heads="num_heads",t.encoder_dim_kv="d_kv";break;case"bart":case"mbart":case"marian":case"whisper":case"lite-whisper":case"m2m_100":case"blenderbot":case"blenderbot-small":case"florence2_language":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="d_model",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="d_model";break;case"speecht5":t.num_decoder_layers="decoder_layers",t.num_decoder_heads="decoder_attention_heads",t.decoder_hidden_size="hidden_size",t.num_encoder_layers="encoder_layers",t.num_encoder_heads="encoder_attention_heads",t.encoder_hidden_size="hidden_size";break;case"trocr":t.num_encoder_layers=t.num_decoder_layers="decoder_layers",t.num_encoder_heads=t.num_decoder_heads="decoder_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="d_model";break;case"musicgen_decoder":t.num_encoder_layers=t.num_decoder_layers="num_hidden_layers",t.num_encoder_heads=t.num_decoder_heads="num_attention_heads",t.encoder_hidden_size=t.decoder_hidden_size="hidden_size";break;case"moonshine":t.num_decoder_layers="decoder_num_hidden_layers",t.num_decoder_heads="decoder_num_key_value_heads",t.num_encoder_layers="encoder_num_hidden_layers",t.num_encoder_heads="encoder_num_key_value_heads",t.encoder_hidden_size=t.decoder_hidden_size="hidden_size";break;case"vision-encoder-decoder":const a=o(e.decoder),i="num_decoder_layers"in a,s=(0,n.pick)(e,["model_type","is_encoder_decoder"]);return i?(s.num_decoder_layers=a.num_decoder_layers,s.num_decoder_heads=a.num_decoder_heads,s.decoder_hidden_size=a.decoder_hidden_size,s.num_encoder_layers=a.num_encoder_layers,s.num_encoder_heads=a.num_encoder_heads,s.encoder_hidden_size=a.encoder_hidden_size):(s.num_layers=a.num_layers,s.num_heads=a.num_heads,s.hidden_size=a.hidden_size),s}const a={...r,...(0,n.pick)(e,["model_type","multi_query","is_encoder_decoder"])};for(const r in t)a[r]=e[t[r]];return a}function i(e,{prefix:t="past_key_values",batch_size:r=1}={}){const n={},a=e.normalized_config;if(a.is_encoder_decoder&&"num_encoder_heads"in a&&"num_decoder_heads"in a){const e=a.encoder_dim_kv??a.encoder_hidden_size/a.num_encoder_heads,o=a.decoder_dim_kv??a.decoder_hidden_size/a.num_decoder_heads,i=[r,a.num_encoder_heads,0,e],s=[r,a.num_decoder_heads,0,o];for(let e=0;e<a.num_decoder_layers;++e)n[`${t}.${e}.encoder.key`]=i,n[`${t}.${e}.encoder.value`]=i,n[`${t}.${e}.decoder.key`]=s,n[`${t}.${e}.decoder.value`]=s}else{const e=a.num_heads,o=a.num_layers,i=a.dim_kv??a.hidden_size/(a.num_attention_heads??e);if("falcon"===a.model_type){const a=[r*e,0,i];for(let e=0;e<o;++e)n[`${t}.${e}.key`]=a,n[`${t}.${e}.value`]=a}else if(a.multi_query){const a=[r*e,0,2*i];for(let e=0;e<o;++e)n[`${t}.${e}.key_value`]=a}else if("bloom"===a.model_type){const a=[r*e,i,0],s=[r*e,0,i];for(let e=0;e<o;++e)n[`${t}.${e}.key`]=a,n[`${t}.${e}.value`]=s}else if("openelm"===a.model_type)for(let a=0;a<o;++a){const o=[r,e[a],0,i];n[`${t}.${a}.key`]=o,n[`${t}.${a}.value`]=o}else{const a=[r,e,0,i];for(let e=0;e<o;++e)n[`${t}.${e}.key`]=a,n[`${t}.${e}.value`]=a}}return n}class s{model_type=null;is_encoder_decoder=!1;max_position_embeddings;"transformers.js_config";constructor(e){Object.assign(this,e),this.normalized_config=o(this)}static async from_pretrained(e,{progress_callback:t=null,config:r=null,cache_dir:n=null,local_files_only:o=!1,revision:i="main"}={}){!r||r instanceof s||(r=new s(r));const l=r??await async function(e,t){return await(0,a.getModelJSON)(e,"config.json",!0,t)}(e,{progress_callback:t,config:r,cache_dir:n,local_files_only:o,revision:i});return new this(l)}}class l{static async from_pretrained(...e){return s.from_pretrained(...e)}}},"./src/env.js":
/*!********************!*\
  !*** ./src/env.js ***!
  \********************/(e,t,r)=>{r.r(t),r.d(t,{apis:()=>h,env:()=>b});var n=r(/*! fs */"?569f"),a=r(/*! path */"?3f59"),o=r(/*! url */"?154a");const i="undefined"!=typeof window&&void 0!==window.document,s="undefined"!=typeof self&&"DedicatedWorkerGlobalScope"===self.constructor?.name,l="undefined"!=typeof self&&"caches"in self,d="undefined"!=typeof navigator&&"gpu"in navigator,u="undefined"!=typeof navigator&&"ml"in navigator,c="undefined"!=typeof process,p=c&&"node"===process?.release?.name,g=!K(n),A=!K(a),h=Object.freeze({IS_BROWSER_ENV:i,IS_WEBWORKER_ENV:s,IS_WEB_CACHE_AVAILABLE:l,IS_WEBGPU_AVAILABLE:d,IS_WEBNN_AVAILABLE:u,IS_PROCESS_AVAILABLE:c,IS_NODE_ENV:p,IS_FS_AVAILABLE:g,IS_PATH_AVAILABLE:A}),B=g&&A;let m="./";if(B){const e=Object(import.meta).url;e?m=a.dirname(a.dirname(o.fileURLToPath(e))):"undefined"!=typeof __dirname&&(m=a.dirname(__dirname))}const C=B?a.join(m,"/.cache/"):null,w="/models/",b={version:"3.4.0",backends:{onnx:{}},allowRemoteModels:!0,remoteHost:"https://huggingface.co/",remotePathTemplate:"{model}/resolve/{revision}/",allowLocalModels:!(i||s),localModelPath:B?a.join(m,w):w,useFS:g,useBrowserCache:l,useFSCache:g,cacheDir:C,useCustomCache:!1,customCache:null};function K(e){return 0===Object.keys(e).length}},"./src/generation/configuration_utils.js":
/*!***********************************************!*\
  !*** ./src/generation/configuration_utils.js ***!
  \***********************************************/(e,t,r)=>{r.r(t),r.d(t,{GenerationConfig:()=>a});var n=r(/*! ../utils/core.js */"./src/utils/core.js");class a{max_length=20;max_new_tokens=null;min_length=0;min_new_tokens=null;early_stopping=!1;max_time=null;do_sample=!1;num_beams=1;num_beam_groups=1;penalty_alpha=null;use_cache=!0;temperature=1;top_k=50;top_p=1;typical_p=1;epsilon_cutoff=0;eta_cutoff=0;diversity_penalty=0;repetition_penalty=1;encoder_repetition_penalty=1;length_penalty=1;no_repeat_ngram_size=0;bad_words_ids=null;force_words_ids=null;renormalize_logits=!1;constraints=null;forced_bos_token_id=null;forced_eos_token_id=null;remove_invalid_values=!1;exponential_decay_length_penalty=null;suppress_tokens=null;streamer=null;begin_suppress_tokens=null;forced_decoder_ids=null;guidance_scale=null;num_return_sequences=1;output_attentions=!1;output_hidden_states=!1;output_scores=!1;return_dict_in_generate=!1;pad_token_id=null;bos_token_id=null;eos_token_id=null;encoder_no_repeat_ngram_size=0;decoder_start_token_id=null;generation_kwargs={};constructor(e){Object.assign(this,(0,n.pick)(e,Object.getOwnPropertyNames(this)))}}},"./src/generation/logits_process.js":
/*!******************************************!*\
  !*** ./src/generation/logits_process.js ***!
  \******************************************/(e,t,r)=>{r.r(t),r.d(t,{ClassifierFreeGuidanceLogitsProcessor:()=>m,ForcedBOSTokenLogitsProcessor:()=>l,ForcedEOSTokenLogitsProcessor:()=>d,LogitsProcessor:()=>o,LogitsProcessorList:()=>s,LogitsWarper:()=>i,MinLengthLogitsProcessor:()=>A,MinNewTokensLengthLogitsProcessor:()=>h,NoBadWordsLogitsProcessor:()=>B,NoRepeatNGramLogitsProcessor:()=>p,RepetitionPenaltyLogitsProcessor:()=>g,SuppressTokensAtBeginLogitsProcessor:()=>u,TemperatureLogitsWarper:()=>C,TopKLogitsWarper:()=>b,TopPLogitsWarper:()=>w,WhisperTimeStampLogitsProcessor:()=>c});var n=r(/*! ../utils/generic.js */"./src/utils/generic.js");r(/*! ../utils/tensor.js */"./src/utils/tensor.js");var a=r(/*! ../utils/maths.js */"./src/utils/maths.js");class o extends n.Callable{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class i extends n.Callable{_call(e,t){throw Error("`_call` should be implemented in a subclass")}}class s extends n.Callable{constructor(){super(),this.processors=[]}push(e){this.processors.push(e)}extend(e){this.processors.push(...e)}_call(e,t){let r=t;for(const t of this.processors)r=t(e,r);return r}[Symbol.iterator](){return this.processors.values()}}class l extends o{constructor(e){super(),this.bos_token_id=e}_call(e,t){for(let r=0;r<e.length;++r)if(1===e[r].length){const e=t[r].data;e.fill(-1/0),e[this.bos_token_id]=0}return t}}class d extends o{constructor(e,t){super(),this.max_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let r=0;r<e.length;++r)if(e[r].length===this.max_length-1){const e=t[r].data;e.fill(-1/0);for(const t of this.eos_token_id)e[t]=0}return t}}class u extends o{constructor(e,t){super(),this.begin_suppress_tokens=e,this.begin_index=t}_call(e,t){for(let r=0;r<e.length;++r)if(e[r].length===this.begin_index){const e=t[r].data;for(const t of this.begin_suppress_tokens)e[t]=-1/0}return t}}class c extends o{constructor(e,t){super(),this.eos_token_id=Array.isArray(e.eos_token_id)?e.eos_token_id[0]:e.eos_token_id,this.no_timestamps_token_id=e.no_timestamps_token_id,this.timestamp_begin=this.no_timestamps_token_id+1,this.begin_index=t.length,t.at(-1)===this.no_timestamps_token_id&&(this.begin_index-=1),this.max_initial_timestamp_index=e.max_initial_timestamp_index}_call(e,t){for(let r=0;r<e.length;++r){const n=t[r].data;if(n[this.no_timestamps_token_id]=-1/0,e[r].length===this.begin_index-1){n.fill(-1/0),n[this.timestamp_begin]=0;continue}const o=e[r].slice(this.begin_index),i=o.length>=1&&o[o.length-1]>=this.timestamp_begin,s=o.length<2||o[o.length-2]>=this.timestamp_begin;if(i&&(s?n.subarray(this.timestamp_begin).fill(-1/0):n.subarray(0,this.eos_token_id).fill(-1/0)),e[r].length===this.begin_index&&null!==this.max_initial_timestamp_index){const e=this.timestamp_begin+this.max_initial_timestamp_index;n.subarray(e+1).fill(-1/0)}const l=(0,a.log_softmax)(n);Math.log(l.subarray(this.timestamp_begin).map(Math.exp).reduce(((e,t)=>e+t)))>(0,a.max)(l.subarray(0,this.timestamp_begin))[0]&&n.subarray(0,this.timestamp_begin).fill(-1/0)}return t}}class p extends o{constructor(e){super(),this.no_repeat_ngram_size=e}getNgrams(e){const t=e.length,r=[];for(let n=0;n<t+1-this.no_repeat_ngram_size;++n){const t=[];for(let r=0;r<this.no_repeat_ngram_size;++r)t.push(e[n+r]);r.push(t.map(Number))}const n=new Map;for(const e of r){const t=e.slice(0,e.length-1),r=JSON.stringify(t),a=n.get(r)??[];a.push(e[e.length-1]),n.set(r,a)}return n}getGeneratedNgrams(e,t){const r=t.slice(t.length+1-this.no_repeat_ngram_size,t.length);return e.get(JSON.stringify(r.map(Number)))??[]}calcBannedNgramTokens(e){const t=[];if(e.length+1<this.no_repeat_ngram_size)return t;{const t=this.getNgrams(e);return this.getGeneratedNgrams(t,e)}}_call(e,t){for(let r=0;r<e.length;++r){const n=t[r].data,a=this.calcBannedNgramTokens(e[r]);for(const e of a)n[e]=-1/0}return t}}class g extends o{constructor(e){super(),this.penalty=e}_call(e,t){for(let r=0;r<e.length;++r){const n=t[r].data;for(const t of new Set(e[r])){const e=Number(t);n[e]<0?n[e]*=this.penalty:n[e]/=this.penalty}}return t}}class A extends o{constructor(e,t){super(),this.min_length=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let r=0;r<e.length;++r)if(e[r].length<this.min_length){const e=t[r].data;for(const t of this.eos_token_id)e[t]=-1/0}return t}}class h extends o{constructor(e,t,r){super(),this.prompt_length_to_skip=e,this.min_new_tokens=t,this.eos_token_id=Array.isArray(r)?r:[r]}_call(e,t){for(let r=0;r<e.length;++r){if(e[r].length-this.prompt_length_to_skip<this.min_new_tokens){const e=t[r].data;for(const t of this.eos_token_id)e[t]=-1/0}}return t}}class B extends o{constructor(e,t){super(),this.bad_words_ids=e,this.eos_token_id=Array.isArray(t)?t:[t]}_call(e,t){for(let r=0;r<e.length;++r){const n=t[r].data,a=e[r];for(const e of this.bad_words_ids){let t=!0;for(let r=1;r<=e.length-1&&e.length<a.length;++r)if(e.at(-r-1)!=a.at(-r)){t=!1;break}t&&(n[e.at(-1)]=-1/0)}}return t}}class m extends o{constructor(e){if(super(),e<=1)throw new Error(`Require guidance scale >1 to use the classifier free guidance processor, got guidance scale ${e}.`);this.guidance_scale=e}_call(e,t){if(t.dims[0]!==2*e.length)throw new Error(`Logits should have twice the batch size of the input ids, the first half of batches corresponding to the conditional inputs, and the second half of batches corresponding to the unconditional inputs. Got batch size ${t.dims[0]} for the logits and ${e.length} for the input ids.`);const r=e.length,n=t.slice([0,r],null),a=t.slice([r,t.dims[0]],null);for(let e=0;e<a.data.length;++e)a.data[e]+=(n.data[e]-a.data[e])*this.guidance_scale;return a}}class C extends i{constructor(e){super(),this.temperature=e}_call(e,t){const r=t.data;for(let e=0;e<r.length;++e)r[e]/=this.temperature;return t}}class w extends i{constructor(e,{filter_value:t=-1/0,min_tokens_to_keep:r=1}={}){if(super(),e<0||e>1)throw new Error(`\`top_p\` must be a float > 0 and < 1, but is ${e}`);if(!Number.isInteger(r)||r<1)throw new Error(`\`min_tokens_to_keep\` must be a positive integer, but is ${r}`);this.top_p=e,this.filter_value=t,this.min_tokens_to_keep=r}}class b extends i{constructor(e,{filter_value:t=-1/0,min_tokens_to_keep:r=1}={}){if(super(),!Number.isInteger(e)||e<0)throw new Error(`\`top_k\` must be a positive integer, but is ${e}`);this.top_k=Math.max(e,r),this.filter_value=t}}},"./src/generation/logits_sampler.js":
/*!******************************************!*\
  !*** ./src/generation/logits_sampler.js ***!
  \******************************************/(e,t,r)=>{r.r(t),r.d(t,{LogitsSampler:()=>i});var n=r(/*! ../utils/generic.js */"./src/utils/generic.js"),a=r(/*! ../utils/tensor.js */"./src/utils/tensor.js"),o=r(/*! ../utils/maths.js */"./src/utils/maths.js");r(/*! ../generation/configuration_utils.js */"./src/generation/configuration_utils.js");class i extends n.Callable{constructor(e){super(),this.generation_config=e}async _call(e){return this.sample(e)}async sample(e){throw Error("sample should be implemented in subclasses.")}getLogits(e,t){let r=e.dims.at(-1),n=e.data;if(-1===t)n=n.slice(-r);else{let e=t*r;n=n.slice(e,e+r)}return n}randomSelect(e){let t=0;for(let r=0;r<e.length;++r)t+=e[r];let r=Math.random()*t;for(let t=0;t<e.length;++t)if(r-=e[t],r<=0)return t;return 0}static getSampler(e){if(e.do_sample)return new l(e);if(e.num_beams>1)return new d(e);if(e.num_return_sequences>1)throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${e.num_return_sequences}.`);return new s(e)}}class s extends i{async sample(e){const t=(0,o.max)(e.data)[1];return[[BigInt(t),0]]}}class l extends i{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[r,n]=await(0,a.topk)(e,t),i=(0,o.softmax)(r.data);return Array.from({length:this.generation_config.num_beams},(()=>{const e=this.randomSelect(i);return[n.data[e],Math.log(i[e])]}))}}class d extends i{async sample(e){let t=e.dims.at(-1);this.generation_config.top_k>0&&(t=Math.min(this.generation_config.top_k,t));const[r,n]=await(0,a.topk)(e,t),i=(0,o.softmax)(r.data);return Array.from({length:this.generation_config.num_beams},((e,t)=>[n.data[t],Math.log(i[t])]))}}},"./src/generation/stopping_criteria.js":
/*!*********************************************!*\
  !*** ./src/generation/stopping_criteria.js ***!
  \*********************************************/(e,t,r)=>{r.r(t),r.d(t,{EosTokenCriteria:()=>s,InterruptableStoppingCriteria:()=>l,MaxLengthCriteria:()=>i,StoppingCriteria:()=>a,StoppingCriteriaList:()=>o});var n=r(/*! ../utils/generic.js */"./src/utils/generic.js");class a extends n.Callable{_call(e,t){throw Error("StoppingCriteria needs to be subclassed")}}class o extends n.Callable{constructor(){super(),this.criteria=[]}push(e){this.criteria.push(e)}extend(e){e instanceof o?e=e.criteria:e instanceof a&&(e=[e]),this.criteria.push(...e)}_call(e,t){const r=new Array(e.length).fill(!1);for(const n of this.criteria){const a=n(e,t);for(let e=0;e<r.length;++e)r[e]||=a[e]}return r}[Symbol.iterator](){return this.criteria.values()}}class i extends a{constructor(e,t=null){super(),this.max_length=e,this.max_position_embeddings=t}_call(e){return e.map((e=>e.length>=this.max_length))}}class s extends a{constructor(e){super(),Array.isArray(e)||(e=[e]),this.eos_token_id=e}_call(e,t){return e.map((e=>{const t=e.at(-1);return this.eos_token_id.some((e=>t==e))}))}}class l extends a{constructor(){super(),this.interrupted=!1}interrupt(){this.interrupted=!0}reset(){this.interrupted=!1}_call(e,t){return new Array(e.length).fill(this.interrupted)}}},"./src/generation/streamers.js":
/*!*************************************!*\
  !*** ./src/generation/streamers.js ***!
  \*************************************/(e,t,r)=>{r.r(t),r.d(t,{BaseStreamer:()=>i,TextStreamer:()=>l,WhisperTextStreamer:()=>d});var n=r(/*! ../utils/core.js */"./src/utils/core.js"),a=r(/*! ../tokenizers.js */"./src/tokenizers.js"),o=r(/*! ../env.js */"./src/env.js");class i{put(e){throw Error("Not implemented")}end(){throw Error("Not implemented")}}const s=o.apis.IS_PROCESS_AVAILABLE?e=>process.stdout.write(e):e=>console.log(e);class l extends i{constructor(e,{skip_prompt:t=!1,callback_function:r=null,token_callback_function:n=null,skip_special_tokens:a=!0,decode_kwargs:o={},...i}={}){super(),this.tokenizer=e,this.skip_prompt=t,this.callback_function=r??s,this.token_callback_function=n,this.decode_kwargs={skip_special_tokens:a,...o,...i},this.token_cache=[],this.print_len=0,this.next_tokens_are_prompt=!0}put(e){if(e.length>1)throw Error("TextStreamer only supports batch size of 1");const t=this.next_tokens_are_prompt;if(t&&(this.next_tokens_are_prompt=!1,this.skip_prompt))return;const r=e[0];this.token_callback_function?.(r),this.token_cache=(0,n.mergeArrays)(this.token_cache,r);const o=this.tokenizer.decode(this.token_cache,this.decode_kwargs);let i;t||o.endsWith("\n")?(i=o.slice(this.print_len),this.token_cache=[],this.print_len=0):o.length>0&&(0,a.is_chinese_char)(o.charCodeAt(o.length-1))?(i=o.slice(this.print_len),this.print_len+=i.length):(i=o.slice(this.print_len,o.lastIndexOf(" ")+1),this.print_len+=i.length),this.on_finalized_text(i,!1)}end(){let e;if(this.token_cache.length>0){e=this.tokenizer.decode(this.token_cache,this.decode_kwargs).slice(this.print_len),this.token_cache=[],this.print_len=0}else e="";this.next_tokens_are_prompt=!0,this.on_finalized_text(e,!0)}on_finalized_text(e,t){e.length>0&&this.callback_function?.(e),t&&this.callback_function===s&&o.apis.IS_PROCESS_AVAILABLE&&this.callback_function?.("\n")}}class d extends l{constructor(e,{skip_prompt:t=!1,callback_function:r=null,token_callback_function:n=null,on_chunk_start:a=null,on_chunk_end:o=null,on_finalize:i=null,time_precision:s=.02,skip_special_tokens:l=!0,decode_kwargs:d={}}={}){super(e,{skip_prompt:t,skip_special_tokens:l,callback_function:r,token_callback_function:n,decode_kwargs:d}),this.timestamp_begin=e.timestamp_begin,this.on_chunk_start=a,this.on_chunk_end=o,this.on_finalize=i,this.time_precision=s,this.waiting_for_timestamp=!1}put(e){if(e.length>1)throw Error("WhisperTextStreamer only supports batch size of 1");const t=e[0];if(1===t.length){const r=Number(t[0])-this.timestamp_begin;if(r>=0){const t=r*this.time_precision;this.waiting_for_timestamp?this.on_chunk_end?.(t):this.on_chunk_start?.(t),this.waiting_for_timestamp=!this.waiting_for_timestamp,e=[[]]}}return super.put(e)}end(){super.end(),this.on_finalize?.()}}},"./src/models.js":
/*!***********************!*\
  !*** ./src/models.js ***!
  \***********************/(e,t,r)=>{r.r(t),r.d(t,{ASTForAudioClassification:()=>Kr,ASTModel:()=>br,ASTPreTrainedModel:()=>wr,AlbertForMaskedLM:()=>Gt,AlbertForQuestionAnswering:()=>Et,AlbertForSequenceClassification:()=>vt,AlbertModel:()=>yt,AlbertPreTrainedModel:()=>_t,AutoModel:()=>Rd,AutoModelForAudioClassification:()=>zd,AutoModelForAudioFrameClassification:()=>$d,AutoModelForAudioTextToText:()=>su,AutoModelForCTC:()=>Od,AutoModelForCausalLM:()=>kd,AutoModelForDepthEstimation:()=>ru,AutoModelForDocumentQuestionAnswering:()=>qd,AutoModelForImageClassification:()=>Ld,AutoModelForImageFeatureExtraction:()=>ou,AutoModelForImageMatting:()=>eu,AutoModelForImageSegmentation:()=>Nd,AutoModelForImageTextToText:()=>iu,AutoModelForImageToImage:()=>tu,AutoModelForMaskGeneration:()=>Pd,AutoModelForMaskedLM:()=>Md,AutoModelForNormalEstimation:()=>nu,AutoModelForObjectDetection:()=>Dd,AutoModelForPoseEstimation:()=>au,AutoModelForQuestionAnswering:()=>Hd,AutoModelForSemanticSegmentation:()=>Id,AutoModelForSeq2SeqLM:()=>Td,AutoModelForSequenceClassification:()=>xd,AutoModelForSpeechSeq2Seq:()=>Zd,AutoModelForTextToSpectrogram:()=>Xd,AutoModelForTextToWaveform:()=>Vd,AutoModelForTokenClassification:()=>Sd,AutoModelForUniversalSegmentation:()=>Ud,AutoModelForVision2Seq:()=>Yd,AutoModelForXVector:()=>jd,AutoModelForZeroShotObjectDetection:()=>Jd,BartForConditionalGeneration:()=>Lt,BartForSequenceClassification:()=>Nt,BartModel:()=>Yt,BartPretrainedModel:()=>Ht,BaseModelOutput:()=>ne,BeitForImageClassification:()=>Bo,BeitModel:()=>ho,BeitPreTrainedModel:()=>Ao,BertForMaskedLM:()=>ie,BertForQuestionAnswering:()=>de,BertForSequenceClassification:()=>se,BertForTokenClassification:()=>le,BertModel:()=>oe,BertPreTrainedModel:()=>ae,BlenderbotForConditionalGeneration:()=>jt,BlenderbotModel:()=>zt,BlenderbotPreTrainedModel:()=>Ot,BlenderbotSmallForConditionalGeneration:()=>er,BlenderbotSmallModel:()=>qt,BlenderbotSmallPreTrainedModel:()=>$t,BloomForCausalLM:()=>Fa,BloomModel:()=>Wa,BloomPreTrainedModel:()=>Qa,CLIPModel:()=>Ir,CLIPPreTrainedModel:()=>Nr,CLIPSegForImageSegmentation:()=>ln,CLIPSegModel:()=>sn,CLIPSegPreTrainedModel:()=>on,CLIPTextModel:()=>Ur,CLIPTextModelWithProjection:()=>Dr,CLIPVisionModel:()=>Jr,CLIPVisionModelWithProjection:()=>Pr,CamembertForMaskedLM:()=>Ve,CamembertForQuestionAnswering:()=>He,CamembertForSequenceClassification:()=>ke,CamembertForTokenClassification:()=>Me,CamembertModel:()=>Xe,CamembertPreTrainedModel:()=>Ze,CausalLMOutput:()=>Au,CausalLMOutputWithPast:()=>hu,ChineseCLIPModel:()=>en,ChineseCLIPPreTrainedModel:()=>qr,ClapAudioModelWithProjection:()=>Ms,ClapModel:()=>Vs,ClapPreTrainedModel:()=>Xs,ClapTextModelWithProjection:()=>ks,CodeGenForCausalLM:()=>En,CodeGenModel:()=>vn,CodeGenPreTrainedModel:()=>yn,CohereForCausalLM:()=>ra,CohereModel:()=>ta,CoherePreTrainedModel:()=>ea,ConvBertForMaskedLM:()=>Fe,ConvBertForQuestionAnswering:()=>ve,ConvBertForSequenceClassification:()=>_e,ConvBertForTokenClassification:()=>ye,ConvBertModel:()=>We,ConvBertPreTrainedModel:()=>Qe,ConvNextForImageClassification:()=>Ai,ConvNextModel:()=>gi,ConvNextPreTrainedModel:()=>pi,ConvNextV2ForImageClassification:()=>mi,ConvNextV2Model:()=>Bi,ConvNextV2PreTrainedModel:()=>hi,DPTForDepthEstimation:()=>Oo,DPTModel:()=>Po,DPTPreTrainedModel:()=>Jo,DacDecoderModel:()=>Il,DacDecoderOutput:()=>Yl,DacEncoderModel:()=>Nl,DacEncoderOutput:()=>Hl,DacModel:()=>Ll,DacPreTrainedModel:()=>Ml,DebertaForMaskedLM:()=>Ne,DebertaForQuestionAnswering:()=>De,DebertaForSequenceClassification:()=>Ie,DebertaForTokenClassification:()=>Ue,DebertaModel:()=>Le,DebertaPreTrainedModel:()=>Ye,DebertaV2ForMaskedLM:()=>Oe,DebertaV2ForQuestionAnswering:()=>$e,DebertaV2ForSequenceClassification:()=>ze,DebertaV2ForTokenClassification:()=>je,DebertaV2Model:()=>Pe,DebertaV2PreTrainedModel:()=>Je,DecisionTransformerModel:()=>wl,DecisionTransformerPreTrainedModel:()=>Cl,DeiTForImageClassification:()=>So,DeiTModel:()=>xo,DeiTPreTrainedModel:()=>Ro,DepthAnythingForDepthEstimation:()=>jo,DepthAnythingPreTrainedModel:()=>zo,DepthProForDepthEstimation:()=>ni,DepthProPreTrainedModel:()=>ri,DetrForObjectDetection:()=>wo,DetrForSegmentation:()=>bo,DetrModel:()=>Co,DetrObjectDetectionOutput:()=>Ko,DetrPreTrainedModel:()=>mo,DetrSegmentationOutput:()=>fo,Dinov2ForImageClassification:()=>bi,Dinov2Model:()=>wi,Dinov2PreTrainedModel:()=>Ci,Dinov2WithRegistersForImageClassification:()=>Qi,Dinov2WithRegistersModel:()=>fi,Dinov2WithRegistersPreTrainedModel:()=>Ki,DistilBertForMaskedLM:()=>at,DistilBertForQuestionAnswering:()=>nt,DistilBertForSequenceClassification:()=>tt,DistilBertForTokenClassification:()=>rt,DistilBertModel:()=>et,DistilBertPreTrainedModel:()=>qe,DonutSwinModel:()=>ci,DonutSwinPreTrainedModel:()=>ui,EfficientNetForImageClassification:()=>js,EfficientNetModel:()=>zs,EfficientNetPreTrainedModel:()=>Os,ElectraForMaskedLM:()=>Re,ElectraForQuestionAnswering:()=>Te,ElectraForSequenceClassification:()=>xe,ElectraForTokenClassification:()=>Se,ElectraModel:()=>Ge,ElectraPreTrainedModel:()=>Ee,EsmForMaskedLM:()=>st,EsmForSequenceClassification:()=>lt,EsmForTokenClassification:()=>dt,EsmModel:()=>it,EsmPreTrainedModel:()=>ot,ExaoneForCausalLM:()=>Yn,ExaoneModel:()=>Hn,ExaonePreTrainedModel:()=>Mn,FalconForCausalLM:()=>Zs,FalconModel:()=>Ts,FalconPreTrainedModel:()=>Ss,FastViTForImageClassification:()=>$a,FastViTModel:()=>ja,FastViTPreTrainedModel:()=>za,Florence2ForConditionalGeneration:()=>Zr,Florence2PreTrainedModel:()=>Tr,GLPNForDepthEstimation:()=>di,GLPNModel:()=>li,GLPNPreTrainedModel:()=>si,GPT2LMHeadModel:()=>cn,GPT2Model:()=>un,GPT2PreTrainedModel:()=>dn,GPTBigCodeForCausalLM:()=>_n,GPTBigCodeModel:()=>Fn,GPTBigCodePreTrainedModel:()=>Wn,GPTJForCausalLM:()=>Qn,GPTJModel:()=>fn,GPTJPreTrainedModel:()=>Kn,GPTNeoForCausalLM:()=>mn,GPTNeoModel:()=>Bn,GPTNeoPreTrainedModel:()=>hn,GPTNeoXForCausalLM:()=>bn,GPTNeoXModel:()=>wn,GPTNeoXPreTrainedModel:()=>Cn,Gemma2ForCausalLM:()=>la,Gemma2Model:()=>sa,Gemma2PreTrainedModel:()=>ia,GemmaForCausalLM:()=>oa,GemmaModel:()=>aa,GemmaPreTrainedModel:()=>na,GlmForCausalLM:()=>kn,GlmModel:()=>Vn,GlmPreTrainedModel:()=>Xn,GraniteForCausalLM:()=>qn,GraniteModel:()=>$n,GranitePreTrainedModel:()=>jn,GroundingDinoForObjectDetection:()=>Fi,GroundingDinoPreTrainedModel:()=>Wi,GroupViTModel:()=>Oa,GroupViTPreTrainedModel:()=>Pa,HeliumForCausalLM:()=>Zn,HeliumModel:()=>Tn,HeliumPreTrainedModel:()=>Sn,HieraForImageClassification:()=>Xo,HieraModel:()=>Zo,HieraPreTrainedModel:()=>To,HubertForCTC:()=>us,HubertForSequenceClassification:()=>cs,HubertModel:()=>ds,HubertPreTrainedModel:()=>ls,IJepaForImageClassification:()=>Va,IJepaModel:()=>Xa,IJepaPreTrainedModel:()=>Za,Idefics3ForConditionalGeneration:()=>Mr,Idefics3PreTrainedModel:()=>kr,ImageMattingOutput:()=>Bu,JAISLMHeadModel:()=>An,JAISModel:()=>gn,JAISPreTrainedModel:()=>pn,JinaCLIPModel:()=>rn,JinaCLIPPreTrainedModel:()=>tn,JinaCLIPTextModel:()=>nn,JinaCLIPVisionModel:()=>an,LiteWhisperForConditionalGeneration:()=>Fr,LlamaForCausalLM:()=>xn,LlamaModel:()=>Rn,LlamaPreTrainedModel:()=>Gn,LlavaForConditionalGeneration:()=>Rr,LlavaOnevisionForConditionalGeneration:()=>xr,LlavaPreTrainedModel:()=>Gr,LongT5ForConditionalGeneration:()=>Xt,LongT5Model:()=>Zt,LongT5PreTrainedModel:()=>Tt,M2M100ForConditionalGeneration:()=>ki,M2M100Model:()=>Vi,M2M100PreTrainedModel:()=>Xi,MBartForCausalLM:()=>Pt,MBartForConditionalGeneration:()=>Dt,MBartForSequenceClassification:()=>Jt,MBartModel:()=>Ut,MBartPreTrainedModel:()=>It,MPNetForMaskedLM:()=>mt,MPNetForQuestionAnswering:()=>bt,MPNetForSequenceClassification:()=>Ct,MPNetForTokenClassification:()=>wt,MPNetModel:()=>Bt,MPNetPreTrainedModel:()=>ht,MT5ForConditionalGeneration:()=>Mt,MT5Model:()=>kt,MT5PreTrainedModel:()=>Vt,MarianMTModel:()=>Zi,MarianModel:()=>Ti,MarianPreTrainedModel:()=>Si,MaskFormerForInstanceSegmentation:()=>ii,MaskFormerModel:()=>oi,MaskFormerPreTrainedModel:()=>ai,MaskedLMOutput:()=>pu,MgpstrForSceneTextRecognition:()=>Wl,MgpstrModelOutput:()=>fl,MgpstrPreTrainedModel:()=>Ql,MimiDecoderModel:()=>kl,MimiDecoderOutput:()=>Zl,MimiEncoderModel:()=>Vl,MimiEncoderOutput:()=>Tl,MimiModel:()=>Xl,MimiPreTrainedModel:()=>Sl,MistralForCausalLM:()=>Es,MistralModel:()=>vs,MistralPreTrainedModel:()=>ys,MobileBertForMaskedLM:()=>pt,MobileBertForQuestionAnswering:()=>At,MobileBertForSequenceClassification:()=>gt,MobileBertModel:()=>ct,MobileBertPreTrainedModel:()=>ut,MobileLLMForCausalLM:()=>In,MobileLLMModel:()=>Nn,MobileLLMPreTrainedModel:()=>Ln,MobileNetV1ForImageClassification:()=>al,MobileNetV1ForSemanticSegmentation:()=>ol,MobileNetV1Model:()=>nl,MobileNetV1PreTrainedModel:()=>rl,MobileNetV2ForImageClassification:()=>ll,MobileNetV2ForSemanticSegmentation:()=>dl,MobileNetV2Model:()=>sl,MobileNetV2PreTrainedModel:()=>il,MobileNetV3ForImageClassification:()=>pl,MobileNetV3ForSemanticSegmentation:()=>gl,MobileNetV3Model:()=>cl,MobileNetV3PreTrainedModel:()=>ul,MobileNetV4ForImageClassification:()=>Bl,MobileNetV4ForSemanticSegmentation:()=>ml,MobileNetV4Model:()=>hl,MobileNetV4PreTrainedModel:()=>Al,MobileViTForImageClassification:()=>no,MobileViTModel:()=>ro,MobileViTPreTrainedModel:()=>to,MobileViTV2ForImageClassification:()=>io,MobileViTV2Model:()=>oo,MobileViTV2PreTrainedModel:()=>ao,ModelOutput:()=>re,ModernBertForMaskedLM:()=>pe,ModernBertForSequenceClassification:()=>ge,ModernBertForTokenClassification:()=>Ae,ModernBertModel:()=>ce,ModernBertPreTrainedModel:()=>ue,Moondream1ForConditionalGeneration:()=>Sr,MoonshineForConditionalGeneration:()=>vr,MoonshineModel:()=>yr,MoonshinePreTrainedModel:()=>_r,MptForCausalLM:()=>va,MptModel:()=>ya,MptPreTrainedModel:()=>_a,MultiModalityCausalLM:()=>Kl,MultiModalityPreTrainedModel:()=>bl,MusicgenForCausalLM:()=>el,MusicgenForConditionalGeneration:()=>tl,MusicgenModel:()=>qs,MusicgenPreTrainedModel:()=>$s,NomicBertModel:()=>Be,NomicBertPreTrainedModel:()=>he,OPTForCausalLM:()=>Ra,OPTModel:()=>Ga,OPTPreTrainedModel:()=>Ea,Olmo2ForCausalLM:()=>zn,Olmo2Model:()=>On,Olmo2PreTrainedModel:()=>Pn,OlmoForCausalLM:()=>Jn,OlmoModel:()=>Dn,OlmoPreTrainedModel:()=>Un,OpenELMForCausalLM:()=>ca,OpenELMModel:()=>ua,OpenELMPreTrainedModel:()=>da,OwlViTForObjectDetection:()=>uo,OwlViTModel:()=>lo,OwlViTPreTrainedModel:()=>so,Owlv2ForObjectDetection:()=>go,Owlv2Model:()=>po,Owlv2PreTrainedModel:()=>co,PaliGemmaForConditionalGeneration:()=>Vr,PaliGemmaPreTrainedModel:()=>Xr,PatchTSMixerForPrediction:()=>Gl,PatchTSMixerModel:()=>El,PatchTSMixerPreTrainedModel:()=>vl,PatchTSTForPrediction:()=>yl,PatchTSTModel:()=>_l,PatchTSTPreTrainedModel:()=>Fl,Phi3ForCausalLM:()=>fa,Phi3Model:()=>Ka,Phi3PreTrainedModel:()=>ba,Phi3VForCausalLM:()=>Lr,Phi3VPreTrainedModel:()=>Yr,PhiForCausalLM:()=>wa,PhiModel:()=>Ca,PhiPreTrainedModel:()=>ma,PreTrainedModel:()=>te,PretrainedMixin:()=>Ul,PvtForImageClassification:()=>La,PvtModel:()=>Ya,PvtPreTrainedModel:()=>Ha,PyAnnoteForAudioFrameClassification:()=>Di,PyAnnoteModel:()=>Ui,PyAnnotePreTrainedModel:()=>Ii,QuestionAnsweringModelOutput:()=>gu,Qwen2ForCausalLM:()=>Aa,Qwen2Model:()=>ga,Qwen2PreTrainedModel:()=>pa,Qwen2VLForConditionalGeneration:()=>Ba,Qwen2VLPreTrainedModel:()=>ha,RTDetrForObjectDetection:()=>Fo,RTDetrModel:()=>Wo,RTDetrObjectDetectionOutput:()=>_o,RTDetrPreTrainedModel:()=>Qo,ResNetForImageClassification:()=>Mo,ResNetModel:()=>ko,ResNetPreTrainedModel:()=>Vo,RoFormerForMaskedLM:()=>we,RoFormerForQuestionAnswering:()=>fe,RoFormerForSequenceClassification:()=>be,RoFormerForTokenClassification:()=>Ke,RoFormerModel:()=>Ce,RoFormerPreTrainedModel:()=>me,RobertaForMaskedLM:()=>nr,RobertaForQuestionAnswering:()=>ir,RobertaForSequenceClassification:()=>ar,RobertaForTokenClassification:()=>or,RobertaModel:()=>rr,RobertaPreTrainedModel:()=>tr,SamImageSegmentationOutput:()=>xi,SamModel:()=>Ri,SamPreTrainedModel:()=>Gi,SapiensForDepthEstimation:()=>ei,SapiensForNormalEstimation:()=>ti,SapiensForSemanticSegmentation:()=>qo,SapiensPreTrainedModel:()=>$o,SegformerForImageClassification:()=>Is,SegformerForSemanticSegmentation:()=>Us,SegformerModel:()=>Ns,SegformerPreTrainedModel:()=>Ls,Seq2SeqLMOutput:()=>lu,SequenceClassifierOutput:()=>du,SiglipModel:()=>zr,SiglipPreTrainedModel:()=>Or,SiglipTextModel:()=>jr,SiglipVisionModel:()=>$r,SmolVLMForConditionalGeneration:()=>Hr,SpeechT5ForSpeechToText:()=>fs,SpeechT5ForTextToSpeech:()=>Qs,SpeechT5HifiGan:()=>Ws,SpeechT5Model:()=>Ks,SpeechT5PreTrainedModel:()=>bs,SqueezeBertForMaskedLM:()=>Qt,SqueezeBertForQuestionAnswering:()=>Ft,SqueezeBertForSequenceClassification:()=>Wt,SqueezeBertModel:()=>ft,SqueezeBertPreTrainedModel:()=>Kt,StableLmForCausalLM:()=>Ps,StableLmModel:()=>Js,StableLmPreTrainedModel:()=>Ds,Starcoder2ForCausalLM:()=>xs,Starcoder2Model:()=>Rs,Starcoder2PreTrainedModel:()=>Gs,StyleTextToSpeech2Model:()=>ws,StyleTextToSpeech2PreTrainedModel:()=>Cs,Swin2SRForImageSuperResolution:()=>Do,Swin2SRModel:()=>Uo,Swin2SRPreTrainedModel:()=>Io,SwinForImageClassification:()=>Lo,SwinForSemanticSegmentation:()=>No,SwinModel:()=>Yo,SwinPreTrainedModel:()=>Ho,T5ForConditionalGeneration:()=>St,T5Model:()=>xt,T5PreTrainedModel:()=>Rt,TableTransformerForObjectDetection:()=>Eo,TableTransformerModel:()=>vo,TableTransformerObjectDetectionOutput:()=>Go,TableTransformerPreTrainedModel:()=>yo,TokenClassifierOutput:()=>cu,TrOCRForCausalLM:()=>_s,TrOCRPreTrainedModel:()=>Fs,UltravoxModel:()=>xl,UltravoxPreTrainedModel:()=>Rl,UniSpeechForCTC:()=>ji,UniSpeechForSequenceClassification:()=>$i,UniSpeechModel:()=>zi,UniSpeechPreTrainedModel:()=>Oi,UniSpeechSatForAudioFrameClassification:()=>ns,UniSpeechSatForCTC:()=>ts,UniSpeechSatForSequenceClassification:()=>rs,UniSpeechSatModel:()=>es,UniSpeechSatPreTrainedModel:()=>qi,ViTForImageClassification:()=>Ta,ViTMAEModel:()=>Ia,ViTMAEPreTrainedModel:()=>Na,ViTMSNForImageClassification:()=>Ja,ViTMSNModel:()=>Da,ViTMSNPreTrainedModel:()=>Ua,ViTModel:()=>Sa,ViTPreTrainedModel:()=>xa,VisionEncoderDecoderModel:()=>Er,VitMatteForImageMatting:()=>eo,VitMattePreTrainedModel:()=>qa,VitPoseForPoseEstimation:()=>Ma,VitPosePreTrainedModel:()=>ka,VitsModel:()=>Ys,VitsModelOutput:()=>mu,VitsPreTrainedModel:()=>Hs,Wav2Vec2BertForCTC:()=>is,Wav2Vec2BertForSequenceClassification:()=>ss,Wav2Vec2BertModel:()=>os,Wav2Vec2BertPreTrainedModel:()=>as,Wav2Vec2ForAudioFrameClassification:()=>Ni,Wav2Vec2ForCTC:()=>Yi,Wav2Vec2ForSequenceClassification:()=>Li,Wav2Vec2Model:()=>Hi,Wav2Vec2PreTrainedModel:()=>Mi,WavLMForAudioFrameClassification:()=>ms,WavLMForCTC:()=>As,WavLMForSequenceClassification:()=>hs,WavLMForXVector:()=>Bs,WavLMModel:()=>gs,WavLMPreTrainedModel:()=>ps,WeSpeakerResNetModel:()=>Pi,WeSpeakerResNetPreTrainedModel:()=>Ji,WhisperForConditionalGeneration:()=>Wr,WhisperModel:()=>Qr,WhisperPreTrainedModel:()=>fr,XLMForQuestionAnswering:()=>pr,XLMForSequenceClassification:()=>ur,XLMForTokenClassification:()=>cr,XLMModel:()=>lr,XLMPreTrainedModel:()=>sr,XLMRobertaForMaskedLM:()=>hr,XLMRobertaForQuestionAnswering:()=>Cr,XLMRobertaForSequenceClassification:()=>Br,XLMRobertaForTokenClassification:()=>mr,XLMRobertaModel:()=>Ar,XLMRobertaPreTrainedModel:()=>gr,XLMWithLMHeadModel:()=>dr,XVectorOutput:()=>uu,YolosForObjectDetection:()=>vi,YolosModel:()=>yi,YolosObjectDetectionOutput:()=>Ei,YolosPreTrainedModel:()=>_i});var n=r(/*! ./configs.js */"./src/configs.js"),a=r(/*! ./backends/onnx.js */"./src/backends/onnx.js"),o=r(/*! ./utils/dtypes.js */"./src/utils/dtypes.js"),i=r(/*! ./utils/generic.js */"./src/utils/generic.js"),s=r(/*! ./utils/core.js */"./src/utils/core.js"),l=r(/*! ./utils/hub.js */"./src/utils/hub.js"),d=r(/*! ./utils/constants.js */"./src/utils/constants.js"),u=r(/*! ./generation/logits_process.js */"./src/generation/logits_process.js"),c=r(/*! ./generation/configuration_utils.js */"./src/generation/configuration_utils.js"),p=r(/*! ./utils/tensor.js */"./src/utils/tensor.js"),g=r(/*! ./utils/image.js */"./src/utils/image.js"),A=r(/*! ./utils/maths.js */"./src/utils/maths.js"),h=r(/*! ./generation/stopping_criteria.js */"./src/generation/stopping_criteria.js"),B=r(/*! ./generation/logits_sampler.js */"./src/generation/logits_sampler.js"),m=r(/*! ./env.js */"./src/env.js"),C=r(/*! ./models/whisper/generation_whisper.js */"./src/models/whisper/generation_whisper.js"),w=r(/*! ./models/whisper/common_whisper.js */"./src/models/whisper/common_whisper.js");const b=0,K=1,f=2,Q=3,W=4,F=5,_=6,y=7,v=8,E=9,G=10,R=11,x=new Map,S=new Map,T=new Map;async function Z(e,t,r){return Object.fromEntries(await Promise.all(Object.keys(t).map((async i=>{const{buffer_or_path:s,session_options:d,session_config:u}=await async function(e,t,r){const i=r.config?.["transformers.js_config"]??{};let s=r.device??i.device;s&&"string"!=typeof s&&(s.hasOwnProperty(t)?s=s[t]:(console.warn(`device not specified for "${t}". Using the default device.`),s=null));const d=s??(m.apis.IS_NODE_ENV?"cpu":"wasm"),u=(0,a.deviceToExecutionProviders)(d);let c=r.dtype??i.dtype;if("string"!=typeof c&&(c&&c.hasOwnProperty(t)?c=c[t]:(c=o.DEFAULT_DEVICE_DTYPE_MAPPING[d]??o.DATA_TYPES.fp32,console.warn(`dtype not specified for "${t}". Using the default dtype (${c}) for this device (${d}).`))),c===o.DATA_TYPES.auto){let e=i.dtype;"string"!=typeof e&&(e=e[t]),c=e&&e!==o.DATA_TYPES.auto&&o.DATA_TYPES.hasOwnProperty(e)?e:o.DEFAULT_DEVICE_DTYPE_MAPPING[d]??o.DATA_TYPES.fp32}const p=c;if(!o.DEFAULT_DTYPE_SUFFIX_MAPPING.hasOwnProperty(p))throw new Error(`Invalid dtype: ${p}. Should be one of: ${Object.keys(o.DATA_TYPES).join(", ")}`);if(p===o.DATA_TYPES.fp16&&"webgpu"===d&&!await(0,o.isWebGpuFp16Supported)())throw new Error(`The device (${d}) does not support fp16.`);const g=i.kv_cache_dtype?"string"==typeof i.kv_cache_dtype?i.kv_cache_dtype:i.kv_cache_dtype[p]??"float32":void 0;if(g&&!["float32","float16"].includes(g))throw new Error(`Invalid kv_cache_dtype: ${g}. Should be one of: float32, float16`);const A={dtype:p,kv_cache_dtype:g},h=`${t}${o.DEFAULT_DTYPE_SUFFIX_MAPPING[p]}.onnx`,B=`${r.subfolder??""}/${h}`,C={...r.session_options};C.executionProviders??=u;const w=i.free_dimension_overrides;w?C.freeDimensionOverrides??=w:d.startsWith("webnn")&&!C.freeDimensionOverrides&&console.warn('WebNN does not currently support dynamic shapes and requires `free_dimension_overrides` to be set in config.json as a field within "transformers.js_config". When `free_dimension_overrides` is not set, you may experience significant performance degradation.');const b=(0,l.getModelFile)(e,B,!0,r,m.apis.IS_NODE_ENV),K=r.use_external_data_format??i.use_external_data_format;let f=[];if(K){let n;n="object"==typeof K?K.hasOwnProperty(h)?K[h]:!!K.hasOwnProperty(t)&&K[t]:K;const a=+n;if(a>l.MAX_EXTERNAL_DATA_CHUNKS)throw new Error(`The number of external data chunks (${a}) exceeds the maximum allowed value (${l.MAX_EXTERNAL_DATA_CHUNKS}).`);for(let t=0;t<a;++t){const n=`${h}_data${0===t?"":"_"+t}`,a=`${r.subfolder??""}/${n}`;f.push(new Promise((async(t,o)=>{const i=await(0,l.getModelFile)(e,a,!0,r,m.apis.IS_NODE_ENV);t(i instanceof Uint8Array?{path:n,data:i}:n)})))}}else void 0!==C.externalData&&(f=C.externalData.map((async t=>{if("string"==typeof t.data){const n=await(0,l.getModelFile)(e,t.data,!0,r);return{...t,data:n}}return t})));if(f.length>0){const e=await Promise.all(f);m.apis.IS_NODE_ENV||(C.externalData=e)}if("webgpu"===d){const e=(0,n.getKeyValueShapes)(r.config,{prefix:"present"});if(Object.keys(e).length>0&&!(0,a.isONNXProxy)()){const t={};for(const r in e)t[r]="gpu-buffer";C.preferredOutputLocation=t}}return{buffer_or_path:await b,session_options:C,session_config:A}}(e,t[i],r);return[i,await(0,a.createInferenceSession)(s,d,u)]}))))}async function X(e,t,r){return Object.fromEntries(await Promise.all(Object.keys(t).map((async n=>[n,await(0,l.getModelJSON)(e,t[n],!1,r)]))))}async function V(e,t){const r=function(e,t){const r=Object.create(null),n=[];for(const o of e.inputNames){const e=t[o];e instanceof p.Tensor?r[o]=(0,a.isONNXProxy)()?e.clone():e:n.push(o)}if(n.length>0)throw new Error(`An error occurred during model execution: "Missing the following inputs: ${n.join(", ")}.`);const o=Object.keys(t).length,i=e.inputNames.length;if(o>i){let r=Object.keys(t).filter((t=>!e.inputNames.includes(t)));console.warn(`WARNING: Too many inputs were provided (${o} > ${i}). The following inputs will be ignored: "${r.join(", ")}".`)}return r}(e,t);try{const t=Object.fromEntries(Object.entries(r).map((([e,t])=>[e,t.ort_tensor])));let n=await e.run(t);return n=k(n),n}catch(e){const t=Object.fromEntries(Object.entries(r).map((([e,{type:t,dims:r,data:n}])=>[e,{type:t,dims:r,data:n}])));throw console.error(`An error occurred during model execution: "${e}".`),console.error("Inputs given to model:",t),e}}function k(e){for(let t in e)(0,a.isONNXTensor)(e[t])?e[t]=new p.Tensor(e[t]):"object"==typeof e[t]&&k(e[t]);return e}function M(e){if(e instanceof p.Tensor)return e;if(0===e.length)throw Error("items must be non-empty");if(Array.isArray(e[0])){if(e.some((t=>t.length!==e[0].length)))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");return new p.Tensor("int64",BigInt64Array.from(e.flat().map((e=>BigInt(e)))),[e.length,e[0].length])}return new p.Tensor("int64",BigInt64Array.from(e.map((e=>BigInt(e)))),[1,e.length])}function H(e){return new p.Tensor("bool",[e],[1])}async function Y(e,t){let{encoder_outputs:r,input_ids:n,decoder_input_ids:a,...o}=t;if(!r){const n=(0,s.pick)(t,e.sessions.model.inputNames);r=(await L(e,n)).last_hidden_state}o.input_ids=a,o.encoder_hidden_states=r,e.sessions.decoder_model_merged.inputNames.includes("encoder_attention_mask")&&(o.encoder_attention_mask=t.attention_mask);return await I(e,o,!0)}async function L(e,t){const r=e.sessions.model,n=(0,s.pick)(t,r.inputNames);if(r.inputNames.includes("inputs_embeds")&&!n.inputs_embeds){if(!t.input_ids)throw new Error("Both `input_ids` and `inputs_embeds` are missing in the model inputs.");n.inputs_embeds=await e.encode_text({input_ids:t.input_ids})}if(r.inputNames.includes("token_type_ids")&&!n.token_type_ids){if(!n.input_ids)throw new Error("Both `input_ids` and `token_type_ids` are missing in the model inputs.");n.token_type_ids=(0,p.zeros_like)(n.input_ids)}if(r.inputNames.includes("pixel_mask")&&!n.pixel_mask){if(!n.pixel_values)throw new Error("Both `pixel_values` and `pixel_mask` are missing in the model inputs.");const e=n.pixel_values.dims;n.pixel_mask=(0,p.ones)([e[0],e[2],e[3]])}return await V(r,n)}async function N(e,t){const r=await e.encode(t);return await e.decode(r)}async function I(e,t,r=!1){const n=e.sessions[r?"decoder_model_merged":"model"],{past_key_values:a,...o}=t;if(n.inputNames.includes("use_cache_branch")&&(o.use_cache_branch=H(!!a)),n.inputNames.includes("position_ids")&&o.attention_mask&&!o.position_ids){const t="paligemma"===e.config.model_type?1:0;o.position_ids=function(e,t=null,r=0){const{input_ids:n,inputs_embeds:a,attention_mask:o}=e,{data:i,dims:s}=z(o,r);let l=new p.Tensor("int64",i,s);if(t){const e=-(n??a).dims.at(1);l=l.slice(null,[e,null])}return l}(o,a,t)}e.addPastKeyValues(o,a);const i=(0,s.pick)(o,n.inputNames);return await V(n,i)}function U({modality_token_id:e,inputs_embeds:t,modality_features:r,input_ids:n,attention_mask:a}){const o=n.tolist().map((t=>t.reduce(((t,r,n)=>(r==e&&t.push(n),t)),[]))),i=o.reduce(((e,t)=>e+t.length),0),s=r.dims[0];if(i!==s)throw new Error(`Number of tokens and features do not match: tokens: ${i}, features ${s}`);let l=0;for(let e=0;e<o.length;++e){const n=o[e],a=t[e];for(let e=0;e<n.length;++e)a[n[e]].data.set(r[l++].data)}return{inputs_embeds:t,attention_mask:a}}function D({image_token_id:e,inputs_embeds:t,image_features:r,input_ids:n,attention_mask:a}){return U({modality_token_id:e,inputs_embeds:t,modality_features:r,input_ids:n,attention_mask:a})}async function J(e,{encode_function:t,merge_function:r,modality_input_name:n,modality_output_name:a,input_ids:o=null,attention_mask:i=null,position_ids:s=null,inputs_embeds:l=null,past_key_values:d=null,generation_config:u=null,logits_processor:c=null,...g}){const A=g[n];if(!l)if(l=await e.encode_text({input_ids:o,...g}),A&&1!==o.dims[1]){const e=await t({[n]:A,...g});({inputs_embeds:l,attention_mask:i}=r({[a]:e,inputs_embeds:l,input_ids:o,attention_mask:i}))}else if(d&&A&&1===o.dims[1]){const e=o.dims[1],t=Object.values(d)[0].dims.at(-2);i=(0,p.cat)([(0,p.ones)([o.dims[0],t]),i.slice(null,[i.dims[1]-e,i.dims[1]])],1)}if(!s&&"qwen2_vl"===e.config.model_type){const{image_grid_thw:t,video_grid_thw:r}=g;[s]=e.get_rope_index(o,t,r,i)}return await I(e,{inputs_embeds:l,past_key_values:d,attention_mask:i,position_ids:s,generation_config:u,logits_processor:c},!0)}async function P(e,t){return await J(e,{...t,modality_input_name:"audio_values",modality_output_name:"audio_features",encode_function:e.encode_audio.bind(e),merge_function:e._merge_input_ids_with_audio_features.bind(e)})}async function O(e,t){return await J(e,{...t,modality_input_name:"pixel_values",modality_output_name:"image_features",encode_function:e.encode_image.bind(e),merge_function:e._merge_input_ids_with_image_features.bind(e)})}function z(e,t=0){const[r,n]=e.dims,a=e.data,o=new BigInt64Array(a.length);for(let e=0;e<r;++e){const r=e*n;let i=BigInt(t);for(let e=0;e<n;++e){const t=r+e;0n===a[t]?o[t]=BigInt(1):(o[t]=i,i+=a[t])}}return{data:o,dims:e.dims}}function j(e,t,r,n){if(r.past_key_values){const t=Object.values(r.past_key_values)[0].dims.at(-2),{input_ids:n,attention_mask:a}=r;if(a&&a.dims[1]>n.dims[1]);else if(t<n.dims[1])r.input_ids=n.slice(null,[t,null]);else if(null!=e.config.image_token_index&&n.data.some((t=>t==e.config.image_token_index))){const a=e.config.num_image_tokens;if(!a)throw new Error("`num_image_tokens` is missing in the model configuration.");const o=n.dims[1]-(t-a);r.input_ids=n.slice(null,[-o,null]),r.attention_mask=(0,p.ones)([1,t+o])}}return r}function $(e,t,r,n){return r.past_key_values&&(t=t.map((e=>[e.at(-1)]))),{...r,decoder_input_ids:M(t)}}function q(e,...t){return e.config.is_encoder_decoder?$(e,...t):j(e,...t)}function ee(e,t,r,n){const a=!!r.past_key_values;if(null!==n.guidance_scale&&n.guidance_scale>1&&(a?r.input_ids=(0,p.cat)([r.input_ids,r.input_ids],0):(r.input_ids=(0,p.cat)([r.input_ids,(0,p.full_like)(r.input_ids,BigInt(n.pad_token_id))],0),r.attention_mask=(0,p.cat)([r.attention_mask,(0,p.full_like)(r.attention_mask,0n)],0))),!a&&r.pixel_values||(r.pixel_values=(0,p.full)([0,0,3,384,384],1)),a){const e=0,t=1,n=1;r.images_seq_mask=new p.Tensor("bool",new Array(e+t).fill(!0).fill(!1,0,t),[n,e+t]),r.images_emb_mask=new p.Tensor("bool",new Array(e).fill(!1),[n,1,e])}return r}class te extends i.Callable{main_input_name="input_ids";forward_params=["input_ids","attention_mask"];constructor(e,t,r){super(),this.config=e,this.sessions=t,this.configs=r;const n=T.get(this.constructor),a=x.get(n);switch(this.can_generate=!1,this._forward=null,this._prepare_inputs_for_generation=null,a){case W:this.can_generate=!0,this._forward=I,this._prepare_inputs_for_generation=j;break;case f:case Q:case y:this.can_generate=!0,this._forward=Y,this._prepare_inputs_for_generation=$;break;case K:this._forward=Y;break;case _:this.can_generate=!0,this._forward=O,this._prepare_inputs_for_generation=q;break;case G:this.can_generate=!0,this._forward=P,this._prepare_inputs_for_generation=q;break;case E:this.can_generate=!0,this._prepare_inputs_for_generation=q;break;case v:this.can_generate=!0,this._prepare_inputs_for_generation=ee;break;case R:this._forward=N;break;default:this._forward=L}this.can_generate&&this.forward_params.push("past_key_values"),this.custom_config=this.config["transformers.js_config"]??{}}async dispose(){const e=[];for(const t of Object.values(this.sessions))t?.handler?.dispose&&e.push(t.handler.dispose());return await Promise.all(e)}static async from_pretrained(e,{progress_callback:t=null,config:r=null,cache_dir:a=null,local_files_only:o=!1,revision:i="main",model_file_name:s=null,subfolder:l="onnx",device:u=null,dtype:c=null,use_external_data_format:p=null,session_options:g={}}={}){let A={progress_callback:t,config:r,cache_dir:a,local_files_only:o,revision:i,model_file_name:s,subfolder:l,device:u,dtype:c,use_external_data_format:p,session_options:g};const h=T.get(this),B=x.get(h);let m;if(r=A.config=await n.AutoConfig.from_pretrained(e,A),B===W)m=await Promise.all([Z(e,{model:A.model_file_name??"model"},A),X(e,{generation_config:"generation_config.json"},A)]);else if(B===f||B===Q)m=await Promise.all([Z(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},A),X(e,{generation_config:"generation_config.json"},A)]);else if(B===F)m=await Promise.all([Z(e,{model:"vision_encoder",prompt_encoder_mask_decoder:"prompt_encoder_mask_decoder"},A)]);else if(B===K)m=await Promise.all([Z(e,{model:"encoder_model",decoder_model_merged:"decoder_model_merged"},A)]);else if(B===_){const t={embed_tokens:"embed_tokens",vision_encoder:"vision_encoder",decoder_model_merged:"decoder_model_merged"};r.is_encoder_decoder&&(t.model="encoder_model"),m=await Promise.all([Z(e,t,A),X(e,{generation_config:"generation_config.json"},A)])}else if(B===G){const t={embed_tokens:"embed_tokens",audio_encoder:"audio_encoder",decoder_model_merged:"decoder_model_merged"};m=await Promise.all([Z(e,t,A),X(e,{generation_config:"generation_config.json"},A)])}else if(B===y)m=await Promise.all([Z(e,{model:"text_encoder",decoder_model_merged:"decoder_model_merged",encodec_decode:"encodec_decode"},A),X(e,{generation_config:"generation_config.json"},A)]);else if(B===v)m=await Promise.all([Z(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"language_model",lm_head:"lm_head",gen_head:"gen_head",gen_img_embeds:"gen_img_embeds",image_decode:"image_decode"},A),X(e,{generation_config:"generation_config.json"},A)]);else if(B===E)m=await Promise.all([Z(e,{prepare_inputs_embeds:"prepare_inputs_embeds",model:"model",vision_encoder:"vision_encoder"},A),X(e,{generation_config:"generation_config.json"},A)]);else if(B===R)m=await Promise.all([Z(e,{encoder_model:"encoder_model",decoder_model:"decoder_model"},A)]);else{if(B!==b){const e=h??r?.model_type;"custom"!==e&&console.warn(`Model type for '${e}' not found, assuming encoder-only architecture. Please report this at ${d.GITHUB_ISSUE_URL}.`)}m=await Promise.all([Z(e,{model:A.model_file_name??"model"},A)])}return new this(r,...m)}async _call(e){return await this.forward(e)}async forward(e){return await this._forward(this,e)}get generation_config(){return this.configs?.generation_config??null}_get_logits_warper(e){const t=new u.LogitsProcessorList;return null!==e.temperature&&1!==e.temperature&&t.push(new u.TemperatureLogitsWarper(e.temperature)),null!==e.top_k&&0!==e.top_k&&t.push(new u.TopKLogitsWarper(e.top_k)),null!==e.top_p&&e.top_p<1&&t.push(new u.TopPLogitsWarper(e.top_p)),t}_get_logits_processor(e,t,r=null){const n=new u.LogitsProcessorList;if(null!==e.repetition_penalty&&1!==e.repetition_penalty&&n.push(new u.RepetitionPenaltyLogitsProcessor(e.repetition_penalty)),null!==e.no_repeat_ngram_size&&e.no_repeat_ngram_size>0&&n.push(new u.NoRepeatNGramLogitsProcessor(e.no_repeat_ngram_size)),null!==e.bad_words_ids&&n.push(new u.NoBadWordsLogitsProcessor(e.bad_words_ids,e.eos_token_id)),null!==e.min_length&&null!==e.eos_token_id&&e.min_length>0&&n.push(new u.MinLengthLogitsProcessor(e.min_length,e.eos_token_id)),null!==e.min_new_tokens&&null!==e.eos_token_id&&e.min_new_tokens>0&&n.push(new u.MinNewTokensLengthLogitsProcessor(t,e.min_new_tokens,e.eos_token_id)),null!==e.forced_bos_token_id&&n.push(new u.ForcedBOSTokenLogitsProcessor(e.forced_bos_token_id)),null!==e.forced_eos_token_id&&n.push(new u.ForcedEOSTokenLogitsProcessor(e.max_length,e.forced_eos_token_id)),null!==e.begin_suppress_tokens){const r=t>1||null===e.forced_bos_token_id?t:t+1;n.push(new u.SuppressTokensAtBeginLogitsProcessor(e.begin_suppress_tokens,r))}return null!==e.guidance_scale&&e.guidance_scale>1&&n.push(new u.ClassifierFreeGuidanceLogitsProcessor(e.guidance_scale)),null!==r&&n.extend(r),n}_prepare_generation_config(e,t,r=c.GenerationConfig){const n={...this.config};for(const e of["decoder","generator","text_config"])e in n&&Object.assign(n,n[e]);const a=new r(n);return Object.assign(a,this.generation_config??{}),e&&Object.assign(a,e),t&&Object.assign(a,(0,s.pick)(t,Object.getOwnPropertyNames(a))),a}_get_stopping_criteria(e,t=null){const r=new h.StoppingCriteriaList;return null!==e.max_length&&r.push(new h.MaxLengthCriteria(e.max_length,this.config.max_position_embeddings??null)),null!==e.eos_token_id&&r.push(new h.EosTokenCriteria(e.eos_token_id)),t&&r.extend(t),r}_validate_model_class(){if(!this.can_generate){const e=[rd,id,td,zl],t=T.get(this.constructor),r=new Set,n=this.config.model_type;for(const t of e){const e=t.get(n);e&&r.add(e[0])}let a=`The current model class (${t}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;throw r.size>0&&(a+=` Please use the following class instead: ${[...r].join(", ")}`),Error(a)}}prepare_inputs_for_generation(...e){return this._prepare_inputs_for_generation(this,...e)}_update_model_kwargs_for_generation({generated_input_ids:e,outputs:t,model_inputs:r,is_encoder_decoder:n}){return r.past_key_values=this.getPastKeyValues(t,r.past_key_values),r.input_ids=new p.Tensor("int64",e.flat(),[e.length,1]),n||(r.attention_mask=(0,p.cat)([r.attention_mask,(0,p.ones)([r.attention_mask.dims[0],1])],1)),r.position_ids=null,r}_prepare_model_inputs({inputs:e,bos_token_id:t,model_kwargs:r}){const n=(0,s.pick)(r,this.forward_params),a=this.main_input_name;if(a in n){if(e)throw new Error("`inputs`: {inputs}` were passed alongside {input_name} which is not allowed. Make sure to either pass {inputs} or {input_name}=...")}else n[a]=e;return{inputs_tensor:n[a],model_inputs:n,model_input_name:a}}async _prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:e,model_inputs:t,model_input_name:r,generation_config:n}){if(this.sessions.model.inputNames.includes("inputs_embeds")&&!t.inputs_embeds&&"_prepare_inputs_embeds"in this){const{input_ids:e,pixel_values:r,attention_mask:n,...a}=t,o=await this._prepare_inputs_embeds(t);t={...a,...(0,s.pick)(o,["inputs_embeds","attention_mask"])}}let{last_hidden_state:a}=await L(this,t);if(null!==n.guidance_scale&&n.guidance_scale>1)a=(0,p.cat)([a,(0,p.full_like)(a,0)],0),"attention_mask"in t&&(t.attention_mask=(0,p.cat)([t.attention_mask,(0,p.zeros_like)(t.attention_mask)],0));else if(t.decoder_input_ids){const e=M(t.decoder_input_ids).dims[0];if(e!==a.dims[0]){if(1!==a.dims[0])throw new Error(`The encoder outputs have a different batch size (${a.dims[0]}) than the decoder inputs (${e}).`);a=(0,p.cat)(Array.from({length:e},(()=>a)),0)}}return t.encoder_outputs=a,t}_prepare_decoder_input_ids_for_generation({batch_size:e,model_input_name:t,model_kwargs:r,decoder_start_token_id:n,bos_token_id:a,generation_config:o}){let{decoder_input_ids:i,...s}=r;if(!(i instanceof p.Tensor)){if(i)Array.isArray(i[0])||(i=Array.from({length:e},(()=>i)));else if(n??=a,"musicgen"===this.config.model_type)i=Array.from({length:e*this.config.decoder.num_codebooks},(()=>[n]));else if(Array.isArray(n)){if(n.length!==e)throw new Error(`\`decoder_start_token_id\` expcted to have length ${e} but got ${n.length}`);i=n}else i=Array.from({length:e},(()=>[n]));i=M(i)}return r.decoder_attention_mask=(0,p.ones_like)(i),{input_ids:i,model_inputs:s}}async generate({inputs:e=null,generation_config:t=null,logits_processor:r=null,stopping_criteria:n=null,streamer:a=null,...o}){this._validate_model_class(),t=this._prepare_generation_config(t,o);let{inputs_tensor:i,model_inputs:s,model_input_name:l}=this._prepare_model_inputs({inputs:e,model_kwargs:o});const d=this.config.is_encoder_decoder;let u;d&&("encoder_outputs"in s||(s=await this._prepare_encoder_decoder_kwargs_for_generation({inputs_tensor:i,model_inputs:s,model_input_name:l,generation_config:t}))),d?({input_ids:u,model_inputs:s}=this._prepare_decoder_input_ids_for_generation({batch_size:s[l].dims.at(0),model_input_name:l,model_kwargs:s,decoder_start_token_id:t.decoder_start_token_id,bos_token_id:t.bos_token_id,generation_config:t})):u=s[l];let c=u.dims.at(-1);null!==t.max_new_tokens&&(t.max_length=c+t.max_new_tokens);const g=this._get_logits_processor(t,c,r),A=this._get_stopping_criteria(t,n),h=s[l].dims.at(0),m=B.LogitsSampler.getSampler(t),C=new Array(h).fill(0),w=u.tolist();let b;a&&a.put(w);let K={};for(;;){if(s=this.prepare_inputs_for_generation(w,s,t),b=await this.forward(s),t.output_attentions&&t.return_dict_in_generate){const e=this.getAttentions(b);for(const t in e)t in K||(K[t]=[]),K[t].push(e[t])}const e=g(w,b.logits.slice(null,-1,null)),r=[];for(let t=0;t<e.dims.at(0);++t){const n=e[t],a=await m(n);for(const[e,n]of a){const a=BigInt(e);C[t]+=n,w[t].push(a),r.push([a]);break}}a&&a.put(r);if(A(w).every((e=>e)))break;s=this._update_model_kwargs_for_generation({generated_input_ids:r,outputs:b,model_inputs:s,is_encoder_decoder:d})}a&&a.end();const f=this.getPastKeyValues(b,s.past_key_values,!0),Q=new p.Tensor("int64",w.flat(),[w.length,w[0].length]);if(t.return_dict_in_generate)return{sequences:Q,past_key_values:f,...K};for(const e of Object.values(b))"gpu-buffer"===e.location&&e.dispose();return Q}getPastKeyValues(e,t,r=!1){const n=Object.create(null);for(const a in e)if(a.startsWith("present")){const o=a.replace("present","past_key_values"),i=a.includes("encoder");if(n[o]=i&&t?t[o]:e[a],t&&(!i||r)){const e=t[o];"gpu-buffer"===e.location&&e.dispose()}}return n}getAttentions(e){const t={};for(const r of["cross_attentions","encoder_attentions","decoder_attentions"])for(const n in e)n.startsWith(r)&&(r in t||(t[r]=[]),t[r].push(e[n]));return t}addPastKeyValues(e,t){if(t)Object.assign(e,t);else{const t=this.sessions.decoder_model_merged??this.sessions.model,r=t?.config?.kv_cache_dtype??"float32",a="float16"===r?new p.DataTypeMap.float16:[],o=(e[this.main_input_name]??e.attention_mask)?.dims?.[0]??1,i=(0,n.getKeyValueShapes)(this.config,{batch_size:o});for(const t in i)e[t]=new p.Tensor(r,a,i[t])}}async encode_image({pixel_values:e}){const t=(await V(this.sessions.vision_encoder,{pixel_values:e})).image_features;return this.config.num_image_tokens||(console.warn(`The number of image tokens was not set in the model configuration. Setting it to the number of features detected by the vision encoder (${t.dims[1]}).`),this.config.num_image_tokens=t.dims[1]),t}async encode_text({input_ids:e}){return(await V(this.sessions.embed_tokens,{input_ids:e})).inputs_embeds}async encode_audio({audio_values:e}){return(await V(this.sessions.audio_encoder,{audio_values:e})).audio_features}}class re{}class ne extends re{constructor({last_hidden_state:e,hidden_states:t=null,attentions:r=null}){super(),this.last_hidden_state=e,this.hidden_states=t,this.attentions=r}}class ae extends te{}class oe extends ae{}class ie extends ae{async _call(e){return new pu(await super._call(e))}}class se extends ae{async _call(e){return new du(await super._call(e))}}class le extends ae{async _call(e){return new cu(await super._call(e))}}class de extends ae{async _call(e){return new gu(await super._call(e))}}class ue extends te{}class ce extends ue{}class pe extends ue{async _call(e){return new pu(await super._call(e))}}class ge extends ue{async _call(e){return new du(await super._call(e))}}class Ae extends ue{async _call(e){return new cu(await super._call(e))}}class he extends te{}class Be extends he{}class me extends te{}class Ce extends me{}class we extends me{async _call(e){return new pu(await super._call(e))}}class be extends me{async _call(e){return new du(await super._call(e))}}class Ke extends me{async _call(e){return new cu(await super._call(e))}}class fe extends me{async _call(e){return new gu(await super._call(e))}}class Qe extends te{}class We extends Qe{}class Fe extends Qe{async _call(e){return new pu(await super._call(e))}}class _e extends Qe{async _call(e){return new du(await super._call(e))}}class ye extends Qe{async _call(e){return new cu(await super._call(e))}}class ve extends Qe{async _call(e){return new gu(await super._call(e))}}class Ee extends te{}class Ge extends Ee{}class Re extends Ee{async _call(e){return new pu(await super._call(e))}}class xe extends Ee{async _call(e){return new du(await super._call(e))}}class Se extends Ee{async _call(e){return new cu(await super._call(e))}}class Te extends Ee{async _call(e){return new gu(await super._call(e))}}class Ze extends te{}class Xe extends Ze{}class Ve extends Ze{async _call(e){return new pu(await super._call(e))}}class ke extends Ze{async _call(e){return new du(await super._call(e))}}class Me extends Ze{async _call(e){return new cu(await super._call(e))}}class He extends Ze{async _call(e){return new gu(await super._call(e))}}class Ye extends te{}class Le extends Ye{}class Ne extends Ye{async _call(e){return new pu(await super._call(e))}}class Ie extends Ye{async _call(e){return new du(await super._call(e))}}class Ue extends Ye{async _call(e){return new cu(await super._call(e))}}class De extends Ye{async _call(e){return new gu(await super._call(e))}}class Je extends te{}class Pe extends Je{}class Oe extends Je{async _call(e){return new pu(await super._call(e))}}class ze extends Je{async _call(e){return new du(await super._call(e))}}class je extends Je{async _call(e){return new cu(await super._call(e))}}class $e extends Je{async _call(e){return new gu(await super._call(e))}}class qe extends te{}class et extends qe{}class tt extends qe{async _call(e){return new du(await super._call(e))}}class rt extends qe{async _call(e){return new cu(await super._call(e))}}class nt extends qe{async _call(e){return new gu(await super._call(e))}}class at extends qe{async _call(e){return new pu(await super._call(e))}}class ot extends te{}class it extends ot{}class st extends ot{async _call(e){return new pu(await super._call(e))}}class lt extends ot{async _call(e){return new du(await super._call(e))}}class dt extends ot{async _call(e){return new cu(await super._call(e))}}class ut extends te{}class ct extends ut{}class pt extends ut{async _call(e){return new pu(await super._call(e))}}class gt extends ut{async _call(e){return new du(await super._call(e))}}class At extends ut{async _call(e){return new gu(await super._call(e))}}class ht extends te{}class Bt extends ht{}class mt extends ht{async _call(e){return new pu(await super._call(e))}}class Ct extends ht{async _call(e){return new du(await super._call(e))}}class wt extends ht{async _call(e){return new cu(await super._call(e))}}class bt extends ht{async _call(e){return new gu(await super._call(e))}}class Kt extends te{}class ft extends Kt{}class Qt extends Kt{async _call(e){return new pu(await super._call(e))}}class Wt extends Kt{async _call(e){return new du(await super._call(e))}}class Ft extends Kt{async _call(e){return new gu(await super._call(e))}}class _t extends te{}class yt extends _t{}class vt extends _t{async _call(e){return new du(await super._call(e))}}class Et extends _t{async _call(e){return new gu(await super._call(e))}}class Gt extends _t{async _call(e){return new pu(await super._call(e))}}class Rt extends te{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"]}class xt extends Rt{}class St extends Rt{}class Tt extends te{}class Zt extends Tt{}class Xt extends Tt{}class Vt extends te{}class kt extends Vt{}class Mt extends Vt{}class Ht extends te{}class Yt extends Ht{}class Lt extends Ht{}class Nt extends Ht{async _call(e){return new du(await super._call(e))}}class It extends te{}class Ut extends It{}class Dt extends It{}class Jt extends It{async _call(e){return new du(await super._call(e))}}class Pt extends It{}class Ot extends te{}class zt extends Ot{}class jt extends Ot{}class $t extends te{}class qt extends $t{}class er extends $t{}class tr extends te{}class rr extends tr{}class nr extends tr{async _call(e){return new pu(await super._call(e))}}class ar extends tr{async _call(e){return new du(await super._call(e))}}class or extends tr{async _call(e){return new cu(await super._call(e))}}class ir extends tr{async _call(e){return new gu(await super._call(e))}}class sr extends te{}class lr extends sr{}class dr extends sr{async _call(e){return new pu(await super._call(e))}}class ur extends sr{async _call(e){return new du(await super._call(e))}}class cr extends sr{async _call(e){return new cu(await super._call(e))}}class pr extends sr{async _call(e){return new gu(await super._call(e))}}class gr extends te{}class Ar extends gr{}class hr extends gr{async _call(e){return new pu(await super._call(e))}}class Br extends gr{async _call(e){return new du(await super._call(e))}}class mr extends gr{async _call(e){return new cu(await super._call(e))}}class Cr extends gr{async _call(e){return new gu(await super._call(e))}}class wr extends te{}class br extends wr{}class Kr extends wr{}class fr extends te{requires_attention_mask=!1;main_input_name="input_features";forward_params=["input_features","attention_mask","decoder_input_ids","decoder_attention_mask","past_key_values"]}class Qr extends fr{}class Wr extends fr{_prepare_generation_config(e,t){return super._prepare_generation_config(e,t,C.WhisperGenerationConfig)}_retrieve_init_tokens(e){const t=[e.decoder_start_token_id];let r=e.language;const n=e.task;if(e.is_multilingual){r||(console.warn("No language specified - defaulting to English (en)."),r="en");const a=`<|${(0,w.whisper_language_to_code)(r)}|>`;t.push(e.lang_to_id[a]),t.push(e.task_to_id[n??"transcribe"])}else if(r||n)throw new Error("Cannot specify `task` or `language` for an English-only model. If the model is intended to be multilingual, pass `is_multilingual=true` to generate, or update the generation config.");return!e.return_timestamps&&e.no_timestamps_token_id&&t.at(-1)!==e.no_timestamps_token_id?t.push(e.no_timestamps_token_id):e.return_timestamps&&t.at(-1)===e.no_timestamps_token_id&&(console.warn("<|notimestamps|> prompt token is removed from generation_config since `return_timestamps` is set to `true`."),t.pop()),t.filter((e=>null!=e))}async generate({inputs:e=null,generation_config:t=null,logits_processor:r=null,stopping_criteria:n=null,...a}){t=this._prepare_generation_config(t,a);const o=a.decoder_input_ids??this._retrieve_init_tokens(t);if(t.return_timestamps&&(r??=new u.LogitsProcessorList,r.push(new u.WhisperTimeStampLogitsProcessor(t,o))),t.begin_suppress_tokens&&(r??=new u.LogitsProcessorList,r.push(new u.SuppressTokensAtBeginLogitsProcessor(t.begin_suppress_tokens,o.length))),t.return_token_timestamps){if(!t.alignment_heads)throw new Error("Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config.");"translate"===t.task&&console.warn("Token-level timestamps may not be reliable for task 'translate'."),t.output_attentions=!0,t.return_dict_in_generate=!0}const i=await super.generate({inputs:e,generation_config:t,logits_processor:r,decoder_input_ids:o,...a});return t.return_token_timestamps&&(i.token_timestamps=this._extract_token_timestamps(i,t.alignment_heads,t.num_frames)),i}_extract_token_timestamps(e,t,r=null,n=.02){if(!e.cross_attentions)throw new Error("Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`.");null==r&&console.warn("`num_frames` has not been set, meaning the entire audio will be analyzed. This may lead to inaccurate token-level timestamps for short audios (< 30 seconds).");let a=this.config.median_filter_width;void 0===a&&(console.warn("Model config has no `median_filter_width`, using default value of 7."),a=7);const o=e.cross_attentions,i=Array.from({length:this.config.decoder_layers},((e,t)=>(0,p.cat)(o.map((e=>e[t])),2))),l=(0,p.stack)(t.map((([e,t])=>{if(e>=i.length)throw new Error(`Layer index ${e} is out of bounds for cross attentions (length ${i.length}).`);return r?i[e].slice(null,t,null,[0,r]):i[e].slice(null,t)}))).transpose(1,0,2,3),[d,u]=(0,p.std_mean)(l,-2,0,!0),c=l.clone();for(let e=0;e<c.dims[0];++e){const t=c[e];for(let r=0;r<t.dims[0];++r){const n=t[r],o=d[e][r][0].data,i=u[e][r][0].data;for(let e=0;e<n.dims[0];++e){let t=n[e].data;for(let e=0;e<t.length;++e)t[e]=(t[e]-i[e])/o[e];t.set((0,A.medianFilter)(t,a))}}}const g=[(0,p.mean)(c,1)],h=e.sequences.dims,B=new p.Tensor("float32",new Float32Array(h[0]*h[1]),h);for(let e=0;e<h[0];++e){const t=g[e].neg().squeeze_(0),[r,a]=(0,A.dynamic_time_warping)(t.tolist()),o=Array.from({length:r.length-1},((e,t)=>r[t+1]-r[t])),i=(0,s.mergeArrays)([1],o).map((e=>!!e)),l=[];for(let e=0;e<i.length;++e)i[e]&&l.push(a[e]*n);B[e].data.set(l,1)}return B}}class Fr extends Wr{}class _r extends te{requires_attention_mask=!1;main_input_name="input_values";forward_params=["input_values","decoder_input_ids","past_key_values"]}class yr extends _r{}class vr extends _r{}class Er extends te{main_input_name="pixel_values";forward_params=["pixel_values","decoder_input_ids","encoder_hidden_states","past_key_values"]}class Gr extends te{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Rr extends Gr{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:r,attention_mask:n}){const a=this.config.image_token_index,o=r.tolist().map((e=>e.findIndex((e=>e==a)))),i=o.every((e=>-1===e)),s=o.every((e=>-1!==e));if(!i&&!s)throw new Error("Every input should contain either 0 or 1 image token.");if(i)return{inputs_embeds:e,attention_mask:n};const l=[],d=[];for(let r=0;r<o.length;++r){const a=o[r],i=e[r],s=t[r],u=n[r];l.push((0,p.cat)([i.slice([0,a]),s,i.slice([a+1,i.dims[0]])],0)),d.push((0,p.cat)([u.slice([0,a]),(0,p.ones)([s.dims[0]]),u.slice([a+1,u.dims[0]])],0))}return{inputs_embeds:(0,p.stack)(l,0),attention_mask:(0,p.stack)(d,0)}}}class xr extends Rr{}class Sr extends Rr{}class Tr extends te{forward_params=["input_ids","inputs_embeds","attention_mask","pixel_values","encoder_outputs","decoder_input_ids","decoder_inputs_embeds","decoder_attention_mask","past_key_values"];main_input_name="inputs_embeds"}class Zr extends Tr{_merge_input_ids_with_image_features({inputs_embeds:e,image_features:t,input_ids:r,attention_mask:n}){return{inputs_embeds:(0,p.cat)([t,e],1),attention_mask:(0,p.cat)([(0,p.ones)(t.dims.slice(0,2)),n],1)}}async _prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:r,attention_mask:n}){if(!e&&!t)throw new Error("Either `input_ids` or `pixel_values` should be provided.");let a,o;return e&&(a=await this.encode_text({input_ids:e})),t&&(o=await this.encode_image({pixel_values:t})),a&&o?({inputs_embeds:r,attention_mask:n}=this._merge_input_ids_with_image_features({inputs_embeds:a,image_features:o,input_ids:e,attention_mask:n})):r=a||o,{inputs_embeds:r,attention_mask:n}}async forward({input_ids:e,pixel_values:t,attention_mask:r,decoder_input_ids:n,decoder_attention_mask:a,encoder_outputs:o,past_key_values:i,inputs_embeds:s,decoder_inputs_embeds:l}){if(s||({inputs_embeds:s,attention_mask:r}=await this._prepare_inputs_embeds({input_ids:e,pixel_values:t,inputs_embeds:s,attention_mask:r})),!o){let{last_hidden_state:e}=await L(this,{inputs_embeds:s,attention_mask:r});o=e}if(!l){if(!n)throw new Error("Either `decoder_input_ids` or `decoder_inputs_embeds` should be provided.");l=await this.encode_text({input_ids:n})}const d={inputs_embeds:l,attention_mask:a,encoder_attention_mask:r,encoder_hidden_states:o,past_key_values:i};return await I(this,d,!0)}}class Xr extends te{forward_params=["input_ids","attention_mask","pixel_values","position_ids","past_key_values"]}class Vr extends Xr{_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),r=e.image_features.view(-1,t);return D({image_token_id:this.config.image_token_index,...e,image_features:r})}}class kr extends te{forward_params=["input_ids","attention_mask","pixel_values","pixel_attention_mask","position_ids","past_key_values"]}class Mr extends kr{async encode_image({pixel_values:e,pixel_attention_mask:t}){return(await V(this.sessions.vision_encoder,{pixel_values:e,pixel_attention_mask:t})).image_features}_merge_input_ids_with_image_features(e){const t=e.image_features.dims.at(-1),r=e.image_features.view(-1,t);return D({image_token_id:this.config.image_token_id,...e,image_features:r})}}class Hr extends Mr{}class Yr extends te{forward_params=["input_ids","inputs_embeds","attention_mask","position_ids","pixel_values","image_sizes","past_key_values"]}class Lr extends Yr{async forward({input_ids:e=null,attention_mask:t=null,pixel_values:r=null,image_sizes:n=null,position_ids:a=null,inputs_embeds:o=null,past_key_values:i=null,generation_config:s=null,logits_processor:l=null,...d}){if(!o){let t;if(r&&1!==e.dims[1]){if(!n)throw new Error("`image_sizes` must be provided when `pixel_values` is provided.");({image_features:t}=await V(this.sessions.vision_encoder,{pixel_values:r,image_sizes:n}))}else{const e=this.config.normalized_config.hidden_size;t=new p.Tensor("float32",[],[0,e])}({inputs_embeds:o}=await V(this.sessions.prepare_inputs_embeds,{input_ids:e,image_features:t}))}return await I(this,{inputs_embeds:o,past_key_values:i,attention_mask:t,position_ids:a,generation_config:s,logits_processor:l},!1)}}class Nr extends te{}class Ir extends Nr{}class Ur extends Nr{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class Dr extends Nr{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class Jr extends Nr{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class Pr extends Nr{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class Or extends te{}class zr extends Or{}class jr extends Or{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class $r extends Nr{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class qr extends te{}class en extends qr{}class tn extends te{}class rn extends tn{async forward(e){const t=!e.input_ids,r=!e.pixel_values;if(t&&r)throw new Error("Either `input_ids` or `pixel_values` should be provided.");if(t&&(e.input_ids=(0,p.ones)([e.pixel_values.dims[0],1])),r){const{image_size:t}=this.config.vision_config;e.pixel_values=(0,p.full)([0,3,t,t],0)}const{text_embeddings:n,image_embeddings:a,l2norm_text_embeddings:o,l2norm_image_embeddings:i}=await super.forward(e),s={};return t||(s.text_embeddings=n,s.l2norm_text_embeddings=o),r||(s.image_embeddings=a,s.l2norm_image_embeddings=i),s}}class nn extends tn{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class an extends tn{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"vision_model"})}}class on extends te{}class sn extends on{}class ln extends on{}class dn extends te{}class un extends dn{}class cn extends dn{}class pn extends te{}class gn extends pn{}class An extends pn{}class hn extends te{}class Bn extends hn{}class mn extends hn{}class Cn extends te{}class wn extends Cn{}class bn extends Cn{}class Kn extends te{}class fn extends Kn{}class Qn extends Kn{}class Wn extends te{}class Fn extends Wn{}class _n extends Wn{}class yn extends te{}class vn extends yn{}class En extends yn{}class Gn extends te{}class Rn extends Gn{}class xn extends Gn{}class Sn extends te{}class Tn extends Sn{}class Zn extends Sn{}class Xn extends te{}class Vn extends Xn{}class kn extends Xn{}class Mn extends te{}class Hn extends Mn{}class Yn extends Mn{}class Ln extends te{}class Nn extends Ln{}class In extends Ln{}class Un extends te{}class Dn extends Un{}class Jn extends Un{}class Pn extends te{}class On extends Pn{}class zn extends Pn{}class jn extends te{}class $n extends jn{}class qn extends jn{}class ea extends te{}class ta extends ea{}class ra extends ea{}class na extends te{}class aa extends na{}class oa extends na{}class ia extends te{}class sa extends ia{}class la extends ia{}class da extends te{}class ua extends da{}class ca extends da{}class pa extends te{}class ga extends pa{}class Aa extends pa{}class ha extends te{forward_params=["input_ids","attention_mask","position_ids","past_key_values","pixel_values","image_grid_thw"]}class Ba extends ha{get_rope_index(e,t,r,n){const{vision_config:a,image_token_id:o,video_token_id:i,vision_start_token_id:s}=this.config,l=a.spatial_merge_size??2,d=[];if(t||r){let a=e.tolist();n||(n=(0,p.ones_like)(e));const u=n.tolist(),c=Array.from({length:3},(t=>Array.from({length:e.dims[0]},(t=>Array.from({length:e.dims[1]},(e=>1)))))),g=t?t.tolist():[],h=r?r.tolist():[];let B=0,m=0;for(let e=0;e<a.length;++e){const t=a[e].filter(((t,r)=>1==u[e][r])),r=t.reduce(((e,t,r)=>(t==s&&e.push(r),e)),[]).map((e=>t[e+1])),n=r.filter((e=>e==o)).length,p=r.filter((e=>e==i)).length;let C=[],w=0,b=n,K=p;for(let e=0;e<r.length;++e){const e=t.findIndex(((e,t)=>t>w&&e==o)),r=t.findIndex(((e,t)=>t>w&&e==i)),n=b>0&&-1!==e?e:t.length+1,a=K>0&&-1!==r?r:t.length+1;let s,d,u,c;n<a?([d,u,c]=g[B],++B,--b,s=n):([d,u,c]=h[m],++m,--K,s=a);const[p,f,Q]=[Number(d),Math.floor(Number(u)/l),Math.floor(Number(c)/l)],W=s-w,F=C.length>0?(0,A.max)(C.at(-1))[0]+1:0;C.push(Array.from({length:3*W},((e,t)=>F+t%W)));const _=W+F,y=p*f*Q,v=Array.from({length:y},((e,t)=>_+Math.floor(t/(f*Q)))),E=Array.from({length:y},((e,t)=>_+Math.floor(t/Q)%f)),G=Array.from({length:y},((e,t)=>_+t%Q));C.push([v,E,G].flat()),w=s+y}if(w<t.length){const e=C.length>0?(0,A.max)(C.at(-1))[0]+1:0,r=t.length-w;C.push(Array.from({length:3*r},((t,n)=>e+n%r)))}const f=C.reduce(((e,t)=>e+t.length),0),Q=new Array(f);let W=0;for(let e=0;e<3;++e)for(let t=0;t<C.length;++t){const r=C[t],n=r.length/3;for(let t=e*n;t<(e+1)*n;++t)Q[W++]=r[t]}let F=0;const _=u[e];for(let t=0;t<_.length;++t)if(1==_[t]){for(let r=0;r<3;++r)c[r][e][t]=Q[r*f/3+F];++F}const y=(0,A.max)(Q)[0];d.push(y+1-a[e].length)}return[new p.Tensor("int64",c.flat(1/0),[3,e.dims[0],e.dims[1]]),new p.Tensor("int64",d,[d.length,1])]}if(n){const{data:e,dims:t}=z(n),r=BigInt64Array.from({length:3*e.length},((t,r)=>e[r%e.length])),a=Array.from({length:t[0]},((r,n)=>(0,A.max)(e.subarray(t[1]*n,t[1]*(n+1)))[0]+1n+BigInt(t[1])));return[new p.Tensor("int64",r,[3,...t]),new p.Tensor("int64",a,[a.length,1])]}{const[t,r]=e.dims,n=BigInt64Array.from({length:3*t*r},((e,n)=>BigInt(Math.floor(n%r/t))));return[new p.Tensor("int64",n,[3,...e.dims]),(0,p.zeros)([t,1])]}}async encode_image({pixel_values:e,image_grid_thw:t}){return(await V(this.sessions.vision_encoder,{pixel_values:e,grid_thw:t})).image_features}_merge_input_ids_with_image_features(e){return D({image_token_id:this.config.image_token_id,...e})}prepare_inputs_for_generation(e,t,r){if(t.attention_mask&&!t.position_ids)if(t.past_key_values){t.pixel_values=null;const e=BigInt(Object.values(t.past_key_values)[0].dims.at(-2)),r=t.rope_deltas.map((t=>e+t));t.position_ids=(0,p.stack)([r,r,r],0)}else[t.position_ids,t.rope_deltas]=this.get_rope_index(t.input_ids,t.image_grid_thw,t.video_grid_thw,t.attention_mask);return t}}class ma extends te{}class Ca extends ma{}class wa extends ma{}class ba extends te{}class Ka extends ba{}class fa extends ba{}class Qa extends te{}class Wa extends Qa{}class Fa extends Qa{}class _a extends te{}class ya extends _a{}class va extends _a{}class Ea extends te{}class Ga extends Ea{}class Ra extends Ea{}class xa extends te{}class Sa extends xa{}class Ta extends xa{async _call(e){return new du(await super._call(e))}}class Za extends te{}class Xa extends Za{}class Va extends Za{async _call(e){return new du(await super._call(e))}}class ka extends te{}class Ma extends ka{}class Ha extends te{}class Ya extends Ha{}class La extends Ha{async _call(e){return new du(await super._call(e))}}class Na extends te{}class Ia extends Na{}class Ua extends te{}class Da extends Ua{}class Ja extends Ua{async _call(e){return new du(await super._call(e))}}class Pa extends te{}class Oa extends Pa{}class za extends te{}class ja extends za{}class $a extends za{async _call(e){return new du(await super._call(e))}}class qa extends te{}class eo extends qa{async _call(e){return new Bu(await super._call(e))}}class to extends te{}class ro extends to{}class no extends to{async _call(e){return new du(await super._call(e))}}class ao extends te{}class oo extends ao{}class io extends ao{async _call(e){return new du(await super._call(e))}}class so extends te{}class lo extends so{}class uo extends so{}class co extends te{}class po extends co{}class go extends co{}class Ao extends te{}class ho extends Ao{}class Bo extends Ao{async _call(e){return new du(await super._call(e))}}class mo extends te{}class Co extends mo{}class wo extends mo{async _call(e){return new Ko(await super._call(e))}}class bo extends mo{async _call(e){return new fo(await super._call(e))}}class Ko extends re{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class fo extends re{constructor({logits:e,pred_boxes:t,pred_masks:r}){super(),this.logits=e,this.pred_boxes=t,this.pred_masks=r}}class Qo extends te{}class Wo extends Qo{}class Fo extends Qo{async _call(e){return new _o(await super._call(e))}}class _o extends re{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class yo extends te{}class vo extends yo{}class Eo extends yo{async _call(e){return new Go(await super._call(e))}}class Go extends Ko{}class Ro extends te{}class xo extends Ro{}class So extends Ro{async _call(e){return new du(await super._call(e))}}class To extends te{}class Zo extends To{}class Xo extends To{async _call(e){return new du(await super._call(e))}}class Vo extends te{}class ko extends Vo{}class Mo extends Vo{async _call(e){return new du(await super._call(e))}}class Ho extends te{}class Yo extends Ho{}class Lo extends Ho{async _call(e){return new du(await super._call(e))}}class No extends Ho{}class Io extends te{}class Uo extends Io{}class Do extends Io{}class Jo extends te{}class Po extends Jo{}class Oo extends Jo{}class zo extends te{}class jo extends zo{}class $o extends te{}class qo extends $o{}class ei extends $o{}class ti extends $o{}class ri extends te{}class ni extends ri{}class ai extends te{}class oi extends ai{}class ii extends ai{}class si extends te{}class li extends si{}class di extends si{}class ui extends te{}class ci extends ui{}class pi extends te{}class gi extends pi{}class Ai extends pi{async _call(e){return new du(await super._call(e))}}class hi extends te{}class Bi extends hi{}class mi extends hi{async _call(e){return new du(await super._call(e))}}class Ci extends te{}class wi extends Ci{}class bi extends Ci{async _call(e){return new du(await super._call(e))}}class Ki extends te{}class fi extends Ki{}class Qi extends Ki{async _call(e){return new du(await super._call(e))}}class Wi extends te{}class Fi extends Wi{}class _i extends te{}class yi extends _i{}class vi extends _i{async _call(e){return new Ei(await super._call(e))}}class Ei extends re{constructor({logits:e,pred_boxes:t}){super(),this.logits=e,this.pred_boxes=t}}class Gi extends te{}class Ri extends Gi{async get_image_embeddings({pixel_values:e}){return await L(this,{pixel_values:e})}async forward(e){if(e.image_embeddings&&e.image_positional_embeddings||(e={...e,...await this.get_image_embeddings(e)}),!e.input_labels&&e.input_points){const t=e.input_points.dims.slice(0,-1),r=t.reduce(((e,t)=>e*t),1);e.input_labels=new p.Tensor("int64",new BigInt64Array(r).fill(1n),t)}const t={image_embeddings:e.image_embeddings,image_positional_embeddings:e.image_positional_embeddings};return e.input_points&&(t.input_points=e.input_points),e.input_labels&&(t.input_labels=e.input_labels),e.input_boxes&&(t.input_boxes=e.input_boxes),await V(this.sessions.prompt_encoder_mask_decoder,t)}async _call(e){return new xi(await super._call(e))}}class xi extends re{constructor({iou_scores:e,pred_masks:t}){super(),this.iou_scores=e,this.pred_masks=t}}class Si extends te{}class Ti extends Si{}class Zi extends Si{}class Xi extends te{}class Vi extends Xi{}class ki extends Xi{}class Mi extends te{}class Hi extends Mi{}class Yi extends Mi{async _call(e){return new Au(await super._call(e))}}class Li extends Mi{async _call(e){return new du(await super._call(e))}}class Ni extends Mi{async _call(e){return new cu(await super._call(e))}}class Ii extends te{}class Ui extends Ii{}class Di extends Ii{async _call(e){return new cu(await super._call(e))}}class Ji extends te{}class Pi extends Ji{}class Oi extends te{}class zi extends Oi{}class ji extends Oi{async _call(e){return new Au(await super._call(e))}}class $i extends Oi{async _call(e){return new du(await super._call(e))}}class qi extends te{}class es extends qi{}class ts extends qi{async _call(e){return new Au(await super._call(e))}}class rs extends qi{async _call(e){return new du(await super._call(e))}}class ns extends qi{async _call(e){return new cu(await super._call(e))}}class as extends te{}class os extends as{}class is extends as{async _call(e){return new Au(await super._call(e))}}class ss extends as{async _call(e){return new du(await super._call(e))}}class ls extends te{}class ds extends Mi{}class us extends Mi{async _call(e){return new Au(await super._call(e))}}class cs extends Mi{async _call(e){return new du(await super._call(e))}}class ps extends te{}class gs extends ps{}class As extends ps{async _call(e){return new Au(await super._call(e))}}class hs extends ps{async _call(e){return new du(await super._call(e))}}class Bs extends ps{async _call(e){return new uu(await super._call(e))}}class ms extends ps{async _call(e){return new cu(await super._call(e))}}class Cs extends te{}class ws extends Cs{}class bs extends te{}class Ks extends bs{}class fs extends bs{}class Qs extends bs{async generate_speech(e,t,{threshold:r=.5,minlenratio:n=0,maxlenratio:a=20,vocoder:o=null}={}){const i={input_ids:e},{encoder_outputs:s,encoder_attention_mask:l}=await L(this,i),d=s.dims[1]/this.config.reduction_factor,u=Math.floor(d*a),c=Math.floor(d*n),g=this.config.num_mel_bins;let A=[],h=null,B=null,m=0;for(;;){++m;const e=H(!!B);let n;n=B?B.output_sequence_out:new p.Tensor("float32",new Float32Array(g),[1,1,g]);let a={use_cache_branch:e,output_sequence:n,encoder_attention_mask:l,speaker_embeddings:t,encoder_hidden_states:s};this.addPastKeyValues(a,h),B=await V(this.sessions.decoder_model_merged,a),h=this.getPastKeyValues(B,h);const{prob:o,spectrum:i}=B;if(A.push(i),m>=c&&(Array.from(o.data).filter((e=>e>=r)).length>0||m>=u))break}const C=(0,p.cat)(A),{waveform:w}=await V(o.sessions.model,{spectrogram:C});return{spectrogram:C,waveform:w}}}class Ws extends te{main_input_name="spectrogram"}class Fs extends te{}class _s extends Fs{}class ys extends te{}class vs extends ys{}class Es extends ys{}class Gs extends te{}class Rs extends Gs{}class xs extends Gs{}class Ss extends te{}class Ts extends Ss{}class Zs extends Ss{}class Xs extends te{}class Vs extends Xs{}class ks extends Xs{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"text_model"})}}class Ms extends Xs{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"audio_model"})}}class Hs extends te{}class Ys extends Hs{async _call(e){return new mu(await super._call(e))}}class Ls extends te{}class Ns extends Ls{}class Is extends Ls{}class Us extends Ls{}class Ds extends te{}class Js extends Ds{}class Ps extends Ds{}class Os extends te{}class zs extends Os{}class js extends Os{async _call(e){return new du(await super._call(e))}}class $s extends te{}class qs extends $s{}class el extends $s{}class tl extends te{forward_params=["input_ids","attention_mask","encoder_outputs","decoder_input_ids","decoder_attention_mask","past_key_values"];_apply_and_filter_by_delay_pattern_mask(e){const[t,r]=e.dims,n=this.config.decoder.num_codebooks,a=r-n;let o=0;for(let t=0;t<e.size;++t){if(e.data[t]===this.config.decoder.pad_token_id)continue;const i=t%r-Math.floor(t/r)%n;i>0&&i<=a&&(e.data[o++]=e.data[t])}const i=Math.floor(t/n),s=o/(i*n);return new p.Tensor(e.type,e.data.slice(0,o),[i,n,s])}prepare_inputs_for_generation(e,t,r){let n=structuredClone(e);for(let e=0;e<n.length;++e)for(let t=0;t<n[e].length;++t)e%this.config.decoder.num_codebooks>=t&&(n[e][t]=BigInt(this.config.decoder.pad_token_id));null!==r.guidance_scale&&r.guidance_scale>1&&(n=n.concat(n));return super.prepare_inputs_for_generation(n,t,r)}async generate(e){const t=await super.generate(e),r=this._apply_and_filter_by_delay_pattern_mask(t).unsqueeze_(0),{audio_values:n}=await V(this.sessions.encodec_decode,{audio_codes:r});return n}}class rl extends te{}class nl extends rl{}class al extends rl{async _call(e){return new du(await super._call(e))}}class ol extends rl{}class il extends te{}class sl extends il{}class ll extends il{async _call(e){return new du(await super._call(e))}}class dl extends il{}class ul extends te{}class cl extends ul{}class pl extends ul{async _call(e){return new du(await super._call(e))}}class gl extends ul{}class Al extends te{}class hl extends Al{}class Bl extends Al{async _call(e){return new du(await super._call(e))}}class ml extends Al{}class Cl extends te{}class wl extends Cl{}class bl extends te{}class Kl extends bl{forward_params=["input_ids","pixel_values","images_seq_mask","images_emb_mask","attention_mask","position_ids","past_key_values"];constructor(...e){super(...e),this._generation_mode="text"}async forward(e){const t=this._generation_mode??"text";let r;if("text"!==t&&e.past_key_values){const t=this.sessions.gen_img_embeds,n=(0,s.pick)({image_ids:e.input_ids},t.inputNames);r=await V(t,n)}else{const t=this.sessions.prepare_inputs_embeds,n=(0,s.pick)(e,t.inputNames);r=await V(t,n)}const n={...e,...r},a=await I(this,n),o=this.sessions["text"===t?"lm_head":"gen_head"];if(!o)throw new Error(`Unable to find "${o}" generation head`);const i=await V(o,(0,s.pick)(a,o.inputNames));return{...r,...a,...i}}async generate(e){return this._generation_mode="text",super.generate(e)}async generate_images(e){this._generation_mode="image";const t=(e.inputs??e[this.main_input_name]).dims[1],r=(await super.generate(e)).slice(null,[t,null]),n=this.sessions.image_decode,{decoded_image:a}=await V(n,{generated_tokens:r}),o=a.add_(1).mul_(127.5).clamp_(0,255).to("uint8"),i=[];for(const e of o){const t=g.RawImage.fromTensor(e);i.push(t)}return i}}class fl extends re{constructor({char_logits:e,bpe_logits:t,wp_logits:r}){super(),this.char_logits=e,this.bpe_logits=t,this.wp_logits=r}get logits(){return[this.char_logits,this.bpe_logits,this.wp_logits]}}class Ql extends te{}class Wl extends Ql{async _call(e){return new fl(await super._call(e))}}class Fl extends te{}class _l extends Fl{}class yl extends Fl{}class vl extends te{}class El extends vl{}class Gl extends vl{}class Rl extends te{forward_params=["input_ids","attention_mask","position_ids","audio_values","past_key_values"]}class xl extends Rl{_merge_input_ids_with_audio_features(e){const t=e.audio_features.dims.at(-1),r=e.audio_features.view(-1,t);return function({audio_token_id:e,inputs_embeds:t,audio_features:r,input_ids:n,attention_mask:a}){return U({modality_token_id:e,inputs_embeds:t,modality_features:r,input_ids:n,attention_mask:a})}({audio_token_id:this.config.ignore_index,...e,audio_features:r})}}class Sl extends te{main_input_name="input_values";forward_params=["input_values"]}class Tl extends re{constructor({audio_codes:e}){super(),this.audio_codes=e}}class Zl extends re{constructor({audio_values:e}){super(),this.audio_values=e}}class Xl extends Sl{async encode(e){return new Tl(await V(this.sessions.encoder_model,e))}async decode(e){return new Zl(await V(this.sessions.decoder_model,e))}}class Vl extends Sl{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"encoder_model"})}}class kl extends Sl{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"decoder_model"})}}class Ml extends te{main_input_name="input_values";forward_params=["input_values"]}class Hl extends re{constructor({audio_codes:e}){super(),this.audio_codes=e}}class Yl extends re{constructor({audio_values:e}){super(),this.audio_values=e}}class Ll extends Ml{async encode(e){return new Hl(await V(this.sessions.encoder_model,e))}async decode(e){return new Yl(await V(this.sessions.decoder_model,e))}}class Nl extends Ml{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"encoder_model"})}}class Il extends Ml{static async from_pretrained(e,t={}){return super.from_pretrained(e,{...t,model_file_name:t.model_file_name??"decoder_model"})}}class Ul{static MODEL_CLASS_MAPPINGS=null;static BASE_IF_FAIL=!1;static async from_pretrained(e,{progress_callback:t=null,config:r=null,cache_dir:a=null,local_files_only:o=!1,revision:i="main",model_file_name:s=null,subfolder:l="onnx",device:d=null,dtype:u=null,use_external_data_format:c=null,session_options:p={}}={}){const g={progress_callback:t,config:r,cache_dir:a,local_files_only:o,revision:i,model_file_name:s,subfolder:l,device:d,dtype:u,use_external_data_format:c,session_options:p};if(g.config=await n.AutoConfig.from_pretrained(e,g),!this.MODEL_CLASS_MAPPINGS)throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: "+this.name);const A=g.config.model_type;for(const t of this.MODEL_CLASS_MAPPINGS){let r=t.get(A);if(!r){for(const e of t.values())if(e[0]===A){r=e;break}if(!r)continue}return await r[1].from_pretrained(e,g)}if(this.BASE_IF_FAIL)return Gd.has(A)||console.warn(`Unknown model class "${A}", attempting to construct from base class.`),await te.from_pretrained(e,g);throw Error(`Unsupported model type: ${A}`)}}const Dl=new Map([["bert",["BertModel",oe]],["modernbert",["ModernBertModel",ce]],["nomic_bert",["NomicBertModel",Be]],["roformer",["RoFormerModel",Ce]],["electra",["ElectraModel",Ge]],["esm",["EsmModel",it]],["convbert",["ConvBertModel",We]],["camembert",["CamembertModel",Xe]],["deberta",["DebertaModel",Le]],["deberta-v2",["DebertaV2Model",Pe]],["mpnet",["MPNetModel",Bt]],["albert",["AlbertModel",yt]],["distilbert",["DistilBertModel",et]],["roberta",["RobertaModel",rr]],["xlm",["XLMModel",lr]],["xlm-roberta",["XLMRobertaModel",Ar]],["clap",["ClapModel",Vs]],["clip",["CLIPModel",Ir]],["clipseg",["CLIPSegModel",sn]],["chinese_clip",["ChineseCLIPModel",en]],["siglip",["SiglipModel",zr]],["jina_clip",["JinaCLIPModel",rn]],["mobilebert",["MobileBertModel",ct]],["squeezebert",["SqueezeBertModel",ft]],["wav2vec2",["Wav2Vec2Model",Hi]],["wav2vec2-bert",["Wav2Vec2BertModel",os]],["unispeech",["UniSpeechModel",zi]],["unispeech-sat",["UniSpeechSatModel",es]],["hubert",["HubertModel",ds]],["wavlm",["WavLMModel",gs]],["audio-spectrogram-transformer",["ASTModel",br]],["vits",["VitsModel",Ys]],["pyannote",["PyAnnoteModel",Ui]],["wespeaker-resnet",["WeSpeakerResNetModel",Pi]],["detr",["DetrModel",Co]],["rt_detr",["RTDetrModel",Wo]],["table-transformer",["TableTransformerModel",vo]],["vit",["ViTModel",Sa]],["ijepa",["IJepaModel",Xa]],["pvt",["PvtModel",Ya]],["vit_msn",["ViTMSNModel",Da]],["vit_mae",["ViTMAEModel",Ia]],["groupvit",["GroupViTModel",Oa]],["fastvit",["FastViTModel",ja]],["mobilevit",["MobileViTModel",ro]],["mobilevitv2",["MobileViTV2Model",oo]],["owlvit",["OwlViTModel",lo]],["owlv2",["Owlv2Model",po]],["beit",["BeitModel",ho]],["deit",["DeiTModel",xo]],["hiera",["HieraModel",Zo]],["convnext",["ConvNextModel",gi]],["convnextv2",["ConvNextV2Model",Bi]],["dinov2",["Dinov2Model",wi]],["dinov2_with_registers",["Dinov2WithRegistersModel",fi]],["resnet",["ResNetModel",ko]],["swin",["SwinModel",Yo]],["swin2sr",["Swin2SRModel",Uo]],["donut-swin",["DonutSwinModel",ci]],["yolos",["YolosModel",yi]],["dpt",["DPTModel",Po]],["glpn",["GLPNModel",li]],["hifigan",["SpeechT5HifiGan",Ws]],["efficientnet",["EfficientNetModel",zs]],["decision_transformer",["DecisionTransformerModel",wl]],["patchtst",["PatchTSTForPrediction",_l]],["patchtsmixer",["PatchTSMixerForPrediction",El]],["mobilenet_v1",["MobileNetV1Model",nl]],["mobilenet_v2",["MobileNetV2Model",sl]],["mobilenet_v3",["MobileNetV3Model",cl]],["mobilenet_v4",["MobileNetV4Model",hl]],["maskformer",["MaskFormerModel",oi]],["mgp-str",["MgpstrForSceneTextRecognition",Wl]],["style_text_to_speech_2",["StyleTextToSpeech2Model",ws]]]),Jl=new Map([["t5",["T5Model",xt]],["longt5",["LongT5Model",Zt]],["mt5",["MT5Model",kt]],["bart",["BartModel",Yt]],["mbart",["MBartModel",Ut]],["marian",["MarianModel",Ti]],["whisper",["WhisperModel",Qr]],["m2m_100",["M2M100Model",Vi]],["blenderbot",["BlenderbotModel",zt]],["blenderbot-small",["BlenderbotSmallModel",qt]]]),Pl=new Map([["mimi",["MimiModel",Xl]],["dac",["DacModel",Ll]]]),Ol=new Map([["bloom",["BloomModel",Wa]],["jais",["JAISModel",gn]],["gpt2",["GPT2Model",un]],["gptj",["GPTJModel",fn]],["gpt_bigcode",["GPTBigCodeModel",Fn]],["gpt_neo",["GPTNeoModel",Bn]],["gpt_neox",["GPTNeoXModel",wn]],["codegen",["CodeGenModel",vn]],["llama",["LlamaModel",Rn]],["exaone",["ExaoneModel",Hn]],["olmo",["OlmoModel",Dn]],["olmo2",["Olmo2Model",On]],["mobilellm",["MobileLLMModel",Nn]],["granite",["GraniteModel",$n]],["cohere",["CohereModel",ta]],["gemma",["GemmaModel",aa]],["gemma2",["Gemma2Model",sa]],["helium",["HeliumModel",Tn]],["glm",["GlmModel",Vn]],["openelm",["OpenELMModel",ua]],["qwen2",["Qwen2Model",ga]],["phi",["PhiModel",Ca]],["phi3",["Phi3Model",Ka]],["mpt",["MptModel",ya]],["opt",["OPTModel",Ga]],["mistral",["MistralModel",vs]],["starcoder2",["Starcoder2Model",Rs]],["falcon",["FalconModel",Ts]],["stablelm",["StableLmModel",Js]]]),zl=new Map([["speecht5",["SpeechT5ForSpeechToText",fs]],["whisper",["WhisperForConditionalGeneration",Wr]],["lite-whisper",["LiteWhisperForConditionalGeneration",Fr]],["moonshine",["MoonshineForConditionalGeneration",vr]]]),jl=new Map([["speecht5",["SpeechT5ForTextToSpeech",Qs]]]),$l=new Map([["vits",["VitsModel",Ys]],["musicgen",["MusicgenForConditionalGeneration",tl]]]),ql=new Map([["bert",["BertForSequenceClassification",se]],["modernbert",["ModernBertForSequenceClassification",ge]],["roformer",["RoFormerForSequenceClassification",be]],["electra",["ElectraForSequenceClassification",xe]],["esm",["EsmForSequenceClassification",lt]],["convbert",["ConvBertForSequenceClassification",_e]],["camembert",["CamembertForSequenceClassification",ke]],["deberta",["DebertaForSequenceClassification",Ie]],["deberta-v2",["DebertaV2ForSequenceClassification",ze]],["mpnet",["MPNetForSequenceClassification",Ct]],["albert",["AlbertForSequenceClassification",vt]],["distilbert",["DistilBertForSequenceClassification",tt]],["roberta",["RobertaForSequenceClassification",ar]],["xlm",["XLMForSequenceClassification",ur]],["xlm-roberta",["XLMRobertaForSequenceClassification",Br]],["bart",["BartForSequenceClassification",Nt]],["mbart",["MBartForSequenceClassification",Jt]],["mobilebert",["MobileBertForSequenceClassification",gt]],["squeezebert",["SqueezeBertForSequenceClassification",Wt]]]),ed=new Map([["bert",["BertForTokenClassification",le]],["modernbert",["ModernBertForTokenClassification",Ae]],["roformer",["RoFormerForTokenClassification",Ke]],["electra",["ElectraForTokenClassification",Se]],["esm",["EsmForTokenClassification",dt]],["convbert",["ConvBertForTokenClassification",ye]],["camembert",["CamembertForTokenClassification",Me]],["deberta",["DebertaForTokenClassification",Ue]],["deberta-v2",["DebertaV2ForTokenClassification",je]],["mpnet",["MPNetForTokenClassification",wt]],["distilbert",["DistilBertForTokenClassification",rt]],["roberta",["RobertaForTokenClassification",or]],["xlm",["XLMForTokenClassification",cr]],["xlm-roberta",["XLMRobertaForTokenClassification",mr]]]),td=new Map([["t5",["T5ForConditionalGeneration",St]],["longt5",["LongT5ForConditionalGeneration",Xt]],["mt5",["MT5ForConditionalGeneration",Mt]],["bart",["BartForConditionalGeneration",Lt]],["mbart",["MBartForConditionalGeneration",Dt]],["marian",["MarianMTModel",Zi]],["m2m_100",["M2M100ForConditionalGeneration",ki]],["blenderbot",["BlenderbotForConditionalGeneration",jt]],["blenderbot-small",["BlenderbotSmallForConditionalGeneration",er]]]),rd=new Map([["bloom",["BloomForCausalLM",Fa]],["gpt2",["GPT2LMHeadModel",cn]],["jais",["JAISLMHeadModel",An]],["gptj",["GPTJForCausalLM",Qn]],["gpt_bigcode",["GPTBigCodeForCausalLM",_n]],["gpt_neo",["GPTNeoForCausalLM",mn]],["gpt_neox",["GPTNeoXForCausalLM",bn]],["codegen",["CodeGenForCausalLM",En]],["llama",["LlamaForCausalLM",xn]],["exaone",["ExaoneForCausalLM",Yn]],["olmo",["OlmoForCausalLM",Jn]],["olmo2",["Olmo2ForCausalLM",zn]],["mobilellm",["MobileLLMForCausalLM",In]],["granite",["GraniteForCausalLM",qn]],["cohere",["CohereForCausalLM",ra]],["gemma",["GemmaForCausalLM",oa]],["gemma2",["Gemma2ForCausalLM",la]],["helium",["HeliumForCausalLM",Zn]],["glm",["GlmForCausalLM",kn]],["openelm",["OpenELMForCausalLM",ca]],["qwen2",["Qwen2ForCausalLM",Aa]],["phi",["PhiForCausalLM",wa]],["phi3",["Phi3ForCausalLM",fa]],["mpt",["MptForCausalLM",va]],["opt",["OPTForCausalLM",Ra]],["mbart",["MBartForCausalLM",Pt]],["mistral",["MistralForCausalLM",Es]],["starcoder2",["Starcoder2ForCausalLM",xs]],["falcon",["FalconForCausalLM",Zs]],["trocr",["TrOCRForCausalLM",_s]],["stablelm",["StableLmForCausalLM",Ps]],["phi3_v",["Phi3VForCausalLM",Lr]]]),nd=new Map([["multi_modality",["MultiModalityCausalLM",Kl]]]),ad=new Map([["bert",["BertForMaskedLM",ie]],["modernbert",["ModernBertForMaskedLM",pe]],["roformer",["RoFormerForMaskedLM",we]],["electra",["ElectraForMaskedLM",Re]],["esm",["EsmForMaskedLM",st]],["convbert",["ConvBertForMaskedLM",Fe]],["camembert",["CamembertForMaskedLM",Ve]],["deberta",["DebertaForMaskedLM",Ne]],["deberta-v2",["DebertaV2ForMaskedLM",Oe]],["mpnet",["MPNetForMaskedLM",mt]],["albert",["AlbertForMaskedLM",Gt]],["distilbert",["DistilBertForMaskedLM",at]],["roberta",["RobertaForMaskedLM",nr]],["xlm",["XLMWithLMHeadModel",dr]],["xlm-roberta",["XLMRobertaForMaskedLM",hr]],["mobilebert",["MobileBertForMaskedLM",pt]],["squeezebert",["SqueezeBertForMaskedLM",Qt]]]),od=new Map([["bert",["BertForQuestionAnswering",de]],["roformer",["RoFormerForQuestionAnswering",fe]],["electra",["ElectraForQuestionAnswering",Te]],["convbert",["ConvBertForQuestionAnswering",ve]],["camembert",["CamembertForQuestionAnswering",He]],["deberta",["DebertaForQuestionAnswering",De]],["deberta-v2",["DebertaV2ForQuestionAnswering",$e]],["mpnet",["MPNetForQuestionAnswering",bt]],["albert",["AlbertForQuestionAnswering",Et]],["distilbert",["DistilBertForQuestionAnswering",nt]],["roberta",["RobertaForQuestionAnswering",ir]],["xlm",["XLMForQuestionAnswering",pr]],["xlm-roberta",["XLMRobertaForQuestionAnswering",Cr]],["mobilebert",["MobileBertForQuestionAnswering",At]],["squeezebert",["SqueezeBertForQuestionAnswering",Ft]]]),id=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Er]],["idefics3",["Idefics3ForConditionalGeneration",Mr]],["smolvlm",["SmolVLMForConditionalGeneration",Hr]]]),sd=new Map([["llava",["LlavaForConditionalGeneration",Rr]],["llava_onevision",["LlavaOnevisionForConditionalGeneration",xr]],["moondream1",["Moondream1ForConditionalGeneration",Sr]],["florence2",["Florence2ForConditionalGeneration",Zr]],["qwen2-vl",["Qwen2VLForConditionalGeneration",Ba]],["idefics3",["Idefics3ForConditionalGeneration",Mr]],["smolvlm",["SmolVLMForConditionalGeneration",Hr]],["paligemma",["PaliGemmaForConditionalGeneration",Vr]]]),ld=new Map([["ultravox",["UltravoxModel",xl]]]),dd=new Map([["vision-encoder-decoder",["VisionEncoderDecoderModel",Er]]]),ud=new Map([["vit",["ViTForImageClassification",Ta]],["ijepa",["IJepaForImageClassification",Va]],["pvt",["PvtForImageClassification",La]],["vit_msn",["ViTMSNForImageClassification",Ja]],["fastvit",["FastViTForImageClassification",$a]],["mobilevit",["MobileViTForImageClassification",no]],["mobilevitv2",["MobileViTV2ForImageClassification",io]],["beit",["BeitForImageClassification",Bo]],["deit",["DeiTForImageClassification",So]],["hiera",["HieraForImageClassification",Xo]],["convnext",["ConvNextForImageClassification",Ai]],["convnextv2",["ConvNextV2ForImageClassification",mi]],["dinov2",["Dinov2ForImageClassification",bi]],["dinov2_with_registers",["Dinov2WithRegistersForImageClassification",Qi]],["resnet",["ResNetForImageClassification",Mo]],["swin",["SwinForImageClassification",Lo]],["segformer",["SegformerForImageClassification",Is]],["efficientnet",["EfficientNetForImageClassification",js]],["mobilenet_v1",["MobileNetV1ForImageClassification",al]],["mobilenet_v2",["MobileNetV2ForImageClassification",ll]],["mobilenet_v3",["MobileNetV3ForImageClassification",pl]],["mobilenet_v4",["MobileNetV4ForImageClassification",Bl]]]),cd=new Map([["detr",["DetrForObjectDetection",wo]],["rt_detr",["RTDetrForObjectDetection",Fo]],["table-transformer",["TableTransformerForObjectDetection",Eo]],["yolos",["YolosForObjectDetection",vi]]]),pd=new Map([["owlvit",["OwlViTForObjectDetection",uo]],["owlv2",["Owlv2ForObjectDetection",go]],["grounding-dino",["GroundingDinoForObjectDetection",Fi]]]),gd=new Map([["detr",["DetrForSegmentation",bo]],["clipseg",["CLIPSegForImageSegmentation",ln]]]),Ad=new Map([["segformer",["SegformerForSemanticSegmentation",Us]],["sapiens",["SapiensForSemanticSegmentation",qo]],["swin",["SwinForSemanticSegmentation",No]],["mobilenet_v1",["MobileNetV1ForSemanticSegmentation",ol]],["mobilenet_v2",["MobileNetV2ForSemanticSegmentation",dl]],["mobilenet_v3",["MobileNetV3ForSemanticSegmentation",gl]],["mobilenet_v4",["MobileNetV4ForSemanticSegmentation",ml]]]),hd=new Map([["detr",["DetrForSegmentation",bo]],["maskformer",["MaskFormerForInstanceSegmentation",ii]]]),Bd=new Map([["sam",["SamModel",Ri]]]),md=new Map([["wav2vec2",["Wav2Vec2ForCTC",Yi]],["wav2vec2-bert",["Wav2Vec2BertForCTC",is]],["unispeech",["UniSpeechForCTC",ji]],["unispeech-sat",["UniSpeechSatForCTC",ts]],["wavlm",["WavLMForCTC",As]],["hubert",["HubertForCTC",us]]]),Cd=new Map([["wav2vec2",["Wav2Vec2ForSequenceClassification",Li]],["wav2vec2-bert",["Wav2Vec2BertForSequenceClassification",ss]],["unispeech",["UniSpeechForSequenceClassification",$i]],["unispeech-sat",["UniSpeechSatForSequenceClassification",rs]],["wavlm",["WavLMForSequenceClassification",hs]],["hubert",["HubertForSequenceClassification",cs]],["audio-spectrogram-transformer",["ASTForAudioClassification",Kr]]]),wd=new Map([["wavlm",["WavLMForXVector",Bs]]]),bd=new Map([["unispeech-sat",["UniSpeechSatForAudioFrameClassification",ns]],["wavlm",["WavLMForAudioFrameClassification",ms]],["wav2vec2",["Wav2Vec2ForAudioFrameClassification",Ni]],["pyannote",["PyAnnoteForAudioFrameClassification",Di]]]),Kd=new Map([["vitmatte",["VitMatteForImageMatting",eo]]]),fd=new Map([["patchtst",["PatchTSTForPrediction",yl]],["patchtsmixer",["PatchTSMixerForPrediction",Gl]]]),Qd=new Map([["swin2sr",["Swin2SRForImageSuperResolution",Do]]]),Wd=new Map([["dpt",["DPTForDepthEstimation",Oo]],["depth_anything",["DepthAnythingForDepthEstimation",jo]],["glpn",["GLPNForDepthEstimation",di]],["sapiens",["SapiensForDepthEstimation",ei]],["depth_pro",["DepthProForDepthEstimation",ni]]]),Fd=new Map([["sapiens",["SapiensForNormalEstimation",ti]]]),_d=new Map([["vitpose",["VitPoseForPoseEstimation",Ma]]]),yd=new Map([["clip",["CLIPVisionModelWithProjection",Pr]],["siglip",["SiglipVisionModel",$r]],["jina_clip",["JinaCLIPVisionModel",an]]]),vd=[[Dl,b],[Jl,K],[Ol,W],[Pl,R],[ql,b],[ed,b],[td,f],[zl,f],[rd,W],[nd,v],[ad,b],[od,b],[id,Q],[sd,_],[ld,G],[ud,b],[gd,b],[hd,b],[Ad,b],[Kd,b],[fd,b],[Qd,b],[Wd,b],[Fd,b],[_d,b],[cd,b],[pd,b],[Bd,F],[md,b],[Cd,b],[jl,f],[$l,b],[wd,b],[bd,b],[yd,b]];for(const[e,t]of vd)for(const[r,n]of e.values())x.set(r,t),T.set(n,r),S.set(r,n);const Ed=[["MusicgenForConditionalGeneration",tl,y],["Phi3VForCausalLM",Lr,E],["CLIPTextModelWithProjection",Dr,b],["SiglipTextModel",jr,b],["JinaCLIPTextModel",nn,b],["ClapTextModelWithProjection",ks,b],["ClapAudioModelWithProjection",Ms,b],["DacEncoderModel",Nl,b],["DacDecoderModel",Il,b],["MimiEncoderModel",Vl,b],["MimiDecoderModel",kl,b]];for(const[e,t,r]of Ed)x.set(e,r),T.set(t,e),S.set(e,t);const Gd=new Map([["modnet",gd],["birefnet",gd],["isnet",gd],["ben",gd]]);for(const[e,t]of Gd.entries())t.set(e,["PreTrainedModel",te]),x.set(e,b),T.set(te,e),S.set(e,te);class Rd extends Ul{static MODEL_CLASS_MAPPINGS=vd.map((e=>e[0]));static BASE_IF_FAIL=!0}class xd extends Ul{static MODEL_CLASS_MAPPINGS=[ql]}class Sd extends Ul{static MODEL_CLASS_MAPPINGS=[ed]}class Td extends Ul{static MODEL_CLASS_MAPPINGS=[td]}class Zd extends Ul{static MODEL_CLASS_MAPPINGS=[zl]}class Xd extends Ul{static MODEL_CLASS_MAPPINGS=[jl]}class Vd extends Ul{static MODEL_CLASS_MAPPINGS=[$l]}class kd extends Ul{static MODEL_CLASS_MAPPINGS=[rd]}class Md extends Ul{static MODEL_CLASS_MAPPINGS=[ad]}class Hd extends Ul{static MODEL_CLASS_MAPPINGS=[od]}class Yd extends Ul{static MODEL_CLASS_MAPPINGS=[id]}class Ld extends Ul{static MODEL_CLASS_MAPPINGS=[ud]}class Nd extends Ul{static MODEL_CLASS_MAPPINGS=[gd]}class Id extends Ul{static MODEL_CLASS_MAPPINGS=[Ad]}class Ud extends Ul{static MODEL_CLASS_MAPPINGS=[hd]}class Dd extends Ul{static MODEL_CLASS_MAPPINGS=[cd]}class Jd extends Ul{static MODEL_CLASS_MAPPINGS=[pd]}class Pd extends Ul{static MODEL_CLASS_MAPPINGS=[Bd]}class Od extends Ul{static MODEL_CLASS_MAPPINGS=[md]}class zd extends Ul{static MODEL_CLASS_MAPPINGS=[Cd]}class jd extends Ul{static MODEL_CLASS_MAPPINGS=[wd]}class $d extends Ul{static MODEL_CLASS_MAPPINGS=[bd]}class qd extends Ul{static MODEL_CLASS_MAPPINGS=[dd]}class eu extends Ul{static MODEL_CLASS_MAPPINGS=[Kd]}class tu extends Ul{static MODEL_CLASS_MAPPINGS=[Qd]}class ru extends Ul{static MODEL_CLASS_MAPPINGS=[Wd]}class nu extends Ul{static MODEL_CLASS_MAPPINGS=[Fd]}class au extends Ul{static MODEL_CLASS_MAPPINGS=[_d]}class ou extends Ul{static MODEL_CLASS_MAPPINGS=[yd]}class iu extends Ul{static MODEL_CLASS_MAPPINGS=[sd]}class su extends Ul{static MODEL_CLASS_MAPPINGS=[ld]}class lu extends re{constructor({logits:e,past_key_values:t,encoder_outputs:r,decoder_attentions:n=null,cross_attentions:a=null}){super(),this.logits=e,this.past_key_values=t,this.encoder_outputs=r,this.decoder_attentions=n,this.cross_attentions=a}}class du extends re{constructor({logits:e,...t}){super(),this.logits=e;const r=Object.values(t);r.length>0&&(this.attentions=r)}}class uu extends re{constructor({logits:e,embeddings:t}){super(),this.logits=e,this.embeddings=t}}class cu extends re{constructor({logits:e}){super(),this.logits=e}}class pu extends re{constructor({logits:e}){super(),this.logits=e}}class gu extends re{constructor({start_logits:e,end_logits:t}){super(),this.start_logits=e,this.end_logits=t}}class Au extends re{constructor({logits:e}){super(),this.logits=e}}class hu extends re{constructor({logits:e,past_key_values:t}){super(),this.logits=e,this.past_key_values=t}}class Bu extends re{constructor({alphas:e}){super(),this.alphas=e}}class mu extends re{constructor({waveform:e,spectrogram:t}){super(),this.waveform=e,this.spectrogram=t}}},"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js":
/*!******************************************************************************************************!*\
  !*** ./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js ***!
  \******************************************************************************************************/(e,t,r)=>{r.r(t),r.d(t,{ASTFeatureExtractor:()=>o});var n=r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js");r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");var a=r(/*! ../../utils/audio.js */"./src/utils/audio.js");class o extends n.FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,r=(0,a.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<r.length;++e)r[e].push(0);this.mel_filters=r,this.window=(0,a.window_function)(400,"hann",{periodic:!1}),this.mean=this.config.mean,this.std=this.config.std}async _extract_fbank_features(e,t){return(0,a.spectrogram)(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e){(0,n.validate_audio_inputs)(e,"ASTFeatureExtractor");const t=await this._extract_fbank_features(e,this.config.max_length);if(this.config.do_normalize){const e=2*this.std,r=t.data;for(let t=0;t<r.length;++t)r[t]=(r[t]-this.mean)/e}return{input_values:t.unsqueeze_(0)}}}},"./src/models/auto/feature_extraction_auto.js":
/*!****************************************************!*\
  !*** ./src/models/auto/feature_extraction_auto.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{AutoFeatureExtractor:()=>i});var n=r(/*! ../../utils/constants.js */"./src/utils/constants.js"),a=r(/*! ../../utils/hub.js */"./src/utils/hub.js");r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js");var o=r(/*! ../feature_extractors.js */"./src/models/feature_extractors.js");class i{static async from_pretrained(e,t={}){const r=await(0,a.getModelJSON)(e,n.FEATURE_EXTRACTOR_NAME,!0,t),i=r.feature_extractor_type,s=o[i];if(!s)throw new Error(`Unknown feature_extractor_type: '${i}'. Please report this at ${n.GITHUB_ISSUE_URL}.`);return new s(r)}}},"./src/models/auto/image_processing_auto.js":
/*!**************************************************!*\
  !*** ./src/models/auto/image_processing_auto.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{AutoImageProcessor:()=>s});var n=r(/*! ../../utils/constants.js */"./src/utils/constants.js"),a=r(/*! ../../utils/hub.js */"./src/utils/hub.js"),o=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js"),i=r(/*! ../image_processors.js */"./src/models/image_processors.js");class s{static async from_pretrained(e,t={}){const r=await(0,a.getModelJSON)(e,n.IMAGE_PROCESSOR_NAME,!0,t),s=r.image_processor_type??r.feature_extractor_type;let l=i[s];return l||(void 0!==s&&console.warn(`Image processor type '${s}' not found, assuming base ImageProcessor. Please report this at ${n.GITHUB_ISSUE_URL}.`),l=o.ImageProcessor),new l(r)}}},"./src/models/auto/processing_auto.js":
/*!********************************************!*\
  !*** ./src/models/auto/processing_auto.js ***!
  \********************************************/(e,t,r)=>{r.r(t),r.d(t,{AutoProcessor:()=>d});var n=r(/*! ../../utils/constants.js */"./src/utils/constants.js"),a=r(/*! ../../utils/hub.js */"./src/utils/hub.js"),o=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),i=r(/*! ../processors.js */"./src/models/processors.js"),s=r(/*! ../image_processors.js */"./src/models/image_processors.js"),l=r(/*! ../feature_extractors.js */"./src/models/feature_extractors.js");class d{static async from_pretrained(e,t={}){const r=await(0,a.getModelJSON)(e,n.IMAGE_PROCESSOR_NAME,!0,t),{image_processor_type:d,feature_extractor_type:u,processor_class:c}=r;if(c&&i[c])return i[c].from_pretrained(e,t);if(!d&&!u)throw new Error("No `image_processor_type` or `feature_extractor_type` found in the config.");const p={};if(d){const e=s[d];if(!e)throw new Error(`Unknown image_processor_type: '${d}'.`);p.image_processor=new e(r)}if(u){const e=s[u];if(e)p.image_processor=new e(r);else{const e=l[u];if(!e)throw new Error(`Unknown feature_extractor_type: '${u}'.`);p.feature_extractor=new e(r)}}return new o.Processor({},p)}}},"./src/models/beit/image_processing_beit.js":
/*!**************************************************!*\
  !*** ./src/models/beit/image_processing_beit.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{BeitFeatureExtractor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}},"./src/models/bit/image_processing_bit.js":
/*!************************************************!*\
  !*** ./src/models/bit/image_processing_bit.js ***!
  \************************************************/(e,t,r)=>{r.r(t),r.d(t,{BitImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}},"./src/models/chinese_clip/image_processing_chinese_clip.js":
/*!******************************************************************!*\
  !*** ./src/models/chinese_clip/image_processing_chinese_clip.js ***!
  \******************************************************************/(e,t,r)=>{r.r(t),r.d(t,{ChineseCLIPFeatureExtractor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}},"./src/models/clap/feature_extraction_clap.js":
/*!****************************************************!*\
  !*** ./src/models/clap/feature_extraction_clap.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{ClapFeatureExtractor:()=>o});var n=r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js");r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");var a=r(/*! ../../utils/audio.js */"./src/utils/audio.js");class o extends n.FeatureExtractor{constructor(e){super(e),this.mel_filters=(0,a.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,null,"htk"),this.mel_filters_slaney=(0,a.mel_filter_bank)(this.config.nb_frequency_bins,this.config.feature_size,this.config.frequency_min,this.config.frequency_max,this.config.sampling_rate,"slaney","slaney"),this.window=(0,a.window_function)(this.config.fft_window_size,"hann")}async _get_input_mel(e,t,r,n){let a;const o=e.length-t;if(o>0){if("rand_trunc"!==r)throw new Error(`Truncation strategy "${r}" not implemented`);{const r=Math.floor(Math.random()*(o+1));e=e.subarray(r,r+t),a=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}}else{if(o<0){let r=new Float64Array(t);if(r.set(e),"repeat"===n)for(let n=e.length;n<t;n+=e.length)r.set(e.subarray(0,Math.min(e.length,t-n)),n);else if("repeatpad"===n)for(let t=e.length;t<-o;t+=e.length)r.set(e,t);e=r}if("fusion"===r)throw new Error(`Truncation strategy "${r}" not implemented`);a=await this._extract_fbank_features(e,this.mel_filters_slaney,this.config.nb_max_samples)}return a.unsqueeze_(0)}async _extract_fbank_features(e,t,r=null){return(0,a.spectrogram)(e,this.window,this.config.fft_window_size,this.config.hop_length,{power:2,mel_filters:t,log_mel:"dB",max_num_frames:r,do_pad:!1,transpose:!0})}async _call(e,{max_length:t=null}={}){(0,n.validate_audio_inputs)(e,"ClapFeatureExtractor");return{input_features:(await this._get_input_mel(e,t??this.config.nb_max_samples,this.config.truncation,this.config.padding)).unsqueeze_(0)}}}},"./src/models/clip/image_processing_clip.js":
/*!**************************************************!*\
  !*** ./src/models/clip/image_processing_clip.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{CLIPFeatureExtractor:()=>o,CLIPImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}class o extends a{}},"./src/models/convnext/image_processing_convnext.js":
/*!**********************************************************!*\
  !*** ./src/models/convnext/image_processing_convnext.js ***!
  \**********************************************************/(e,t,r)=>{r.r(t),r.d(t,{ConvNextFeatureExtractor:()=>o,ConvNextImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{constructor(e){super(e),this.crop_pct=this.config.crop_pct??.875}async resize(e){const t=this.size?.shortest_edge;if(void 0===t)throw new Error("Size dictionary must contain 'shortest_edge' key.");if(t<384){const r=Math.floor(t/this.crop_pct),[n,a]=this.get_resize_output_image_size(e,{shortest_edge:r});e=await e.resize(n,a,{resample:this.resample}),e=await e.center_crop(t,t)}else e=await e.resize(t,t,{resample:this.resample});return e}}class o extends a{}},"./src/models/dac/feature_extraction_dac.js":
/*!**************************************************!*\
  !*** ./src/models/dac/feature_extraction_dac.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{DacFeatureExtractor:()=>a});var n=r(/*! ../encodec/feature_extraction_encodec.js */"./src/models/encodec/feature_extraction_encodec.js");class a extends n.EncodecFeatureExtractor{}},"./src/models/deit/image_processing_deit.js":
/*!**************************************************!*\
  !*** ./src/models/deit/image_processing_deit.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{DeiTFeatureExtractor:()=>o,DeiTImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}class o extends a{}},"./src/models/detr/image_processing_detr.js":
/*!**************************************************!*\
  !*** ./src/models/detr/image_processing_detr.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{DetrFeatureExtractor:()=>i,DetrImageProcessor:()=>o});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");class o extends n.ImageProcessor{async _call(e){const t=await super._call(e),r=[t.pixel_values.dims[0],64,64],n=(0,a.full)(r,1n);return{...t,pixel_mask:n}}post_process_object_detection(...e){return(0,n.post_process_object_detection)(...e)}post_process_panoptic_segmentation(...e){return(0,n.post_process_panoptic_segmentation)(...e)}post_process_instance_segmentation(...e){return(0,n.post_process_instance_segmentation)(...e)}}class i extends o{}},"./src/models/donut/image_processing_donut.js":
/*!****************************************************!*\
  !*** ./src/models/donut/image_processing_donut.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{DonutFeatureExtractor:()=>o,DonutImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{pad_image(e,t,r,n={}){const[a,o,i]=t;let s=this.image_mean;Array.isArray(this.image_mean)||(s=new Array(i).fill(s));let l=this.image_std;Array.isArray(l)||(l=new Array(i).fill(s));const d=s.map(((e,t)=>-e/l[t]));return super.pad_image(e,t,r,{center:!0,constant_values:d,...n})}}class o extends a{}},"./src/models/dpt/image_processing_dpt.js":
/*!************************************************!*\
  !*** ./src/models/dpt/image_processing_dpt.js ***!
  \************************************************/(e,t,r)=>{r.r(t),r.d(t,{DPTFeatureExtractor:()=>o,DPTImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}class o extends a{}},"./src/models/efficientnet/image_processing_efficientnet.js":
/*!******************************************************************!*\
  !*** ./src/models/efficientnet/image_processing_efficientnet.js ***!
  \******************************************************************/(e,t,r)=>{r.r(t),r.d(t,{EfficientNetImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{constructor(e){super(e),this.include_top=this.config.include_top??!0,this.include_top&&(this.image_std=this.image_std.map((e=>e*e)))}}},"./src/models/encodec/feature_extraction_encodec.js":
/*!**********************************************************!*\
  !*** ./src/models/encodec/feature_extraction_encodec.js ***!
  \**********************************************************/(e,t,r)=>{r.r(t),r.d(t,{EncodecFeatureExtractor:()=>o});var n=r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");class o extends n.FeatureExtractor{async _call(e){(0,n.validate_audio_inputs)(e,"EncodecFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=this.config.feature_size;if(e.length%t!=0)throw new Error(`The length of the audio data must be a multiple of the number of channels (${t}).`);const r=[1,t,e.length/t];return{input_values:new a.Tensor("float32",e,r)}}}},"./src/models/feature_extractors.js":
/*!******************************************!*\
  !*** ./src/models/feature_extractors.js ***!
  \******************************************/(e,t,r)=>{r.r(t),r.d(t,{ASTFeatureExtractor:()=>n.ASTFeatureExtractor,ClapFeatureExtractor:()=>o.ClapFeatureExtractor,DacFeatureExtractor:()=>i.DacFeatureExtractor,EncodecFeatureExtractor:()=>a.EncodecFeatureExtractor,ImageFeatureExtractor:()=>A.ImageProcessor,MoonshineFeatureExtractor:()=>s.MoonshineFeatureExtractor,PyAnnoteFeatureExtractor:()=>l.PyAnnoteFeatureExtractor,SeamlessM4TFeatureExtractor:()=>d.SeamlessM4TFeatureExtractor,SpeechT5FeatureExtractor:()=>u.SpeechT5FeatureExtractor,Wav2Vec2FeatureExtractor:()=>c.Wav2Vec2FeatureExtractor,WeSpeakerFeatureExtractor:()=>p.WeSpeakerFeatureExtractor,WhisperFeatureExtractor:()=>g.WhisperFeatureExtractor});var n=r(/*! ./audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js */"./src/models/audio_spectrogram_transformer/feature_extraction_audio_spectrogram_transformer.js"),a=r(/*! ./encodec/feature_extraction_encodec.js */"./src/models/encodec/feature_extraction_encodec.js"),o=r(/*! ./clap/feature_extraction_clap.js */"./src/models/clap/feature_extraction_clap.js"),i=r(/*! ./dac/feature_extraction_dac.js */"./src/models/dac/feature_extraction_dac.js"),s=r(/*! ./moonshine/feature_extraction_moonshine.js */"./src/models/moonshine/feature_extraction_moonshine.js"),l=r(/*! ./pyannote/feature_extraction_pyannote.js */"./src/models/pyannote/feature_extraction_pyannote.js"),d=r(/*! ./seamless_m4t/feature_extraction_seamless_m4t.js */"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js"),u=r(/*! ./speecht5/feature_extraction_speecht5.js */"./src/models/speecht5/feature_extraction_speecht5.js"),c=r(/*! ./wav2vec2/feature_extraction_wav2vec2.js */"./src/models/wav2vec2/feature_extraction_wav2vec2.js"),p=r(/*! ./wespeaker/feature_extraction_wespeaker.js */"./src/models/wespeaker/feature_extraction_wespeaker.js"),g=r(/*! ./whisper/feature_extraction_whisper.js */"./src/models/whisper/feature_extraction_whisper.js"),A=r(/*! ../base/image_processors_utils.js */"./src/base/image_processors_utils.js")},"./src/models/florence2/processing_florence2.js":
/*!******************************************************!*\
  !*** ./src/models/florence2/processing_florence2.js ***!
  \******************************************************/(e,t,r)=>{r.r(t),r.d(t,{Florence2Processor:()=>i});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),o=r(/*! ../../tokenizers.js */"./src/tokenizers.js");class i extends n.Processor{static tokenizer_class=o.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;constructor(e,t){super(e,t);const{tasks_answer_post_processing_type:r,task_prompts_without_inputs:n,task_prompts_with_input:a}=this.image_processor.config;this.tasks_answer_post_processing_type=new Map(Object.entries(r??{})),this.task_prompts_without_inputs=new Map(Object.entries(n??{})),this.task_prompts_with_input=new Map(Object.entries(a??{})),this.regexes={quad_boxes:/(.+?)<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm,bboxes:/([^<]+)?<loc_(\d+)><loc_(\d+)><loc_(\d+)><loc_(\d+)>/gm},this.size_per_bin=1e3}construct_prompts(e){"string"==typeof e&&(e=[e]);const t=[];for(const r of e)if(this.task_prompts_without_inputs.has(r))t.push(this.task_prompts_without_inputs.get(r));else{for(const[e,n]of this.task_prompts_with_input)if(r.includes(e)){t.push(n.replaceAll("{input}",r).replaceAll(e,""));break}t.length!==e.length&&t.push(r)}return t}post_process_generation(e,t,r){const n=this.tasks_answer_post_processing_type.get(t)??"pure_text";let a;switch(e=e.replaceAll("<s>","").replaceAll("</s>",""),n){case"pure_text":a=e;break;case"description_with_bboxes":case"bboxes":case"phrase_grounding":case"ocr":const o="ocr"===n?"quad_boxes":"bboxes",i=e.matchAll(this.regexes[o]),s=[],l=[];for(const[e,t,...n]of i)s.push(t?t.trim():s.at(-1)??""),l.push(n.map(((e,t)=>(Number(e)+.5)/this.size_per_bin*r[t%2])));a={labels:s,[o]:l};break;default:throw new Error(`Task "${t}" (of type "${n}") not yet implemented.`)}return{[t]:a}}async _call(e,t=null,r={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...await this.image_processor(e,r),...t?this.tokenizer(t,r):{}}}}},"./src/models/glpn/image_processing_glpn.js":
/*!**************************************************!*\
  !*** ./src/models/glpn/image_processing_glpn.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{GLPNFeatureExtractor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}},"./src/models/grounding_dino/image_processing_grounding_dino.js":
/*!**********************************************************************!*\
  !*** ./src/models/grounding_dino/image_processing_grounding_dino.js ***!
  \**********************************************************************/(e,t,r)=>{r.r(t),r.d(t,{GroundingDinoImageProcessor:()=>o});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");class o extends n.ImageProcessor{async _call(e){const t=await super._call(e),r=t.pixel_values.dims,n=(0,a.ones)([r[0],r[2],r[3]]);return{...t,pixel_mask:n}}}},"./src/models/grounding_dino/processing_grounding_dino.js":
/*!****************************************************************!*\
  !*** ./src/models/grounding_dino/processing_grounding_dino.js ***!
  \****************************************************************/(e,t,r)=>{r.r(t),r.d(t,{GroundingDinoProcessor:()=>l});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),o=r(/*! ../../tokenizers.js */"./src/tokenizers.js"),i=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");function s(e,t){const r=e.dims.at(-1)-1,n=e.tolist();n.fill(!1,0,1),n.fill(!1,r);const a=t.tolist();return n.map(((e,t)=>e?t:null)).filter((e=>null!==e)).map((e=>a[e]))}class l extends n.Processor{static tokenizer_class=o.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;async _call(e,t,r={}){const n=e?await this.image_processor(e,r):{};return{...t?this.tokenizer(t,r):{},...n}}post_process_grounded_object_detection(e,t,{box_threshold:r=.25,text_threshold:n=.25,target_sizes:a=null}={}){const{logits:o,pred_boxes:l}=e,d=o.dims[0];if(null!==a&&a.length!==d)throw Error("Make sure that you pass in as many target sizes as the batch dimension of the logits");const u=o.dims.at(1),c=o.sigmoid(),p=c.max(-1).tolist(),g=l.tolist().map((e=>e.map((e=>(0,i.center_to_corners_format)(e))))),A=[];for(let e=0;e<d;++e){const o=null!==a?a[e]:null;null!==o&&(g[e]=g[e].map((e=>e.map(((e,t)=>e*o[(t+1)%2])))));const i=p[e],l=[],d=[],h=[];for(let a=0;a<u;++a){const o=i[a];if(o<=r)continue;const u=g[e][a],p=c[e][a];l.push(o),h.push(u);const A=s(p.gt(n),t[e]);d.push(A)}A.push({scores:l,boxes:h,labels:this.batch_decode(d)})}return A}}},"./src/models/idefics3/image_processing_idefics3.js":
/*!**********************************************************!*\
  !*** ./src/models/idefics3/image_processing_idefics3.js ***!
  \**********************************************************/(e,t,r)=>{r.r(t),r.d(t,{Idefics3ImageProcessor:()=>o});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");class o extends n.ImageProcessor{constructor(e){super(e),this.do_image_splitting=e.do_image_splitting??!0,this.max_image_size=e.max_image_size}get_resize_for_vision_encoder(e,t){let[r,n]=e.dims.slice(-2);const a=n/r;return n>=r?(n=Math.ceil(n/t)*t,r=Math.floor(n/a),r=Math.ceil(r/t)*t):(r=Math.ceil(r/t)*t,n=Math.floor(r*a),n=Math.ceil(n/t)*t),{height:r,width:n}}async _call(e,{do_image_splitting:t=null,return_row_col_info:r=!1}={}){let n;if(Array.isArray(e)){if(0===e.length||!e[0])throw new Error("No images provided.");n=Array.isArray(e[0])?e:[e]}else n=[[e]];let o=[],i=[],s=[];const l=[],d=[];for(const e of n){let r=await Promise.all(e.map((e=>this.preprocess(e))));l.push(...r.map((e=>e.original_size))),d.push(...r.map((e=>e.reshaped_input_size))),r.forEach((e=>e.pixel_values.unsqueeze_(0)));const{longest_edge:n}=this.max_image_size;let u;if(t??this.do_image_splitting){let e=new Array(r.length),t=new Array(r.length);u=await Promise.all(r.map((async(r,o)=>{const i=this.get_resize_for_vision_encoder(r.pixel_values,n),s=await(0,a.interpolate_4d)(r.pixel_values,{size:[i.height,i.width]}),{frames:l,num_splits_h:d,num_splits_w:u}=await this.split_image(s,this.max_image_size);return e[o]=d,t[o]=u,(0,a.cat)(l,0)}))),i.push(e),s.push(t)}else{const e=[n,n];u=await Promise.all(r.map((t=>(0,a.interpolate_4d)(t.pixel_values,{size:e})))),i.push(new Array(r.length).fill(0)),s.push(new Array(r.length).fill(0))}o.push((0,a.cat)(u,0))}const u=o.length,[c,p,g,A]=o[0].dims;let h,B;if(1===u)h=o[0].unsqueeze_(0),B=(0,a.full)([u,c,g,A],!0);else{const e=Math.max(...o.map((e=>e.dims.at(0))));B=(0,a.full)([u,e,g,A],!0);const t=B.data,r=e*g*A;for(let n=0;n<u;++n){const i=o[n].dims[0];if(i<e){o[n]=(0,a.cat)([o[n],(0,a.full)([e-i,p,g,A],0)],0);const s=n*r+i*g*A,l=(n+1)*r;t.fill(!1,s,l)}}h=(0,a.stack)(o,0)}return{pixel_values:h,pixel_attention_mask:B,original_sizes:l,reshaped_input_sizes:d,...r?{rows:i,cols:s}:{}}}async split_image(e,{longest_edge:t}){const r=t,n=t,o=[],[i,s]=e.dims.slice(-2);let l=0,d=0;if(i>r||s>n){l=Math.ceil(i/r),d=Math.ceil(s/n);const t=Math.ceil(i/l),u=Math.ceil(s/d);for(let r=0;r<l;++r)for(let n=0;n<d;++n){let c,p,g,A;r===l-1?(p=i-t,A=i):(p=r*t,A=(r+1)*t),n===d-1?(c=s-u,g=s):(c=n*u,g=(n+1)*u);const h=[p,c],B=[A,g],m=await(0,a.slice)(e,h,B,[2,3]);o.push(m)}const c=r,p=n;i===c&&s===p||(e=await(0,a.interpolate_4d)(e,{size:[c,p]}))}return o.push(e),{frames:o,num_splits_h:l,num_splits_w:d}}}},"./src/models/idefics3/processing_idefics3.js":
/*!****************************************************!*\
  !*** ./src/models/idefics3/processing_idefics3.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{Idefics3Processor:()=>l});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),o=r(/*! ../../tokenizers.js */"./src/tokenizers.js");r(/*! ../../utils/image.js */"./src/utils/image.js");var i=r(/*! ../../utils/core.js */"./src/utils/core.js");function s(e,t,r,n,a,o){return 0===e&&0===t?function(e,t,r,n){return`${t}${n}`+r.repeat(e)+`${t}`}(r,n,a,o):function(e,t,r,n,a,o){let i="";for(let o=0;o<t;++o){for(let t=0;t<r;++t)i+=n+`<row_${o+1}_col_${t+1}>`+a.repeat(e);i+="\n"}return i+=`\n${n}${o}`+a.repeat(e)+`${n}`,i}(r,e,t,n,a,o)}class l extends n.Processor{static image_processor_class=a.AutoImageProcessor;static tokenizer_class=o.AutoTokenizer;static uses_processor_config=!0;fake_image_token="<fake_token_around_image>";image_token="<image>";global_img_token="<global-img>";async _call(e,t=null,r={}){let n;r.return_row_col_info??=!0,t&&(n=await this.image_processor(t,r)),Array.isArray(e)||(e=[e]);const a=n.rows??[new Array(e.length).fill(0)],o=n.cols??[new Array(e.length).fill(0)],l=this.config.image_seq_len,d=[],u=[];for(let t=0;t<e.length;++t){const r=e[t],n=a[t],c=o[t];d.push((0,i.count)(r,this.image_token));const p=n.map(((e,t)=>s(e,c[t],l,this.fake_image_token,this.image_token,this.global_img_token))),g=r.split(this.image_token);if(0===g.length)throw new Error("The image token should be present in the text.");let A=g[0];for(let e=0;e<p.length;++e)A+=p[e]+g[e+1];u.push(A)}return{...this.tokenizer(u),...n}}}},"./src/models/image_processors.js":
/*!****************************************!*\
  !*** ./src/models/image_processors.js ***!
  \****************************************/(e,t,r)=>{r.r(t),r.d(t,{BeitFeatureExtractor:()=>n.BeitFeatureExtractor,BitImageProcessor:()=>a.BitImageProcessor,CLIPFeatureExtractor:()=>i.CLIPFeatureExtractor,CLIPImageProcessor:()=>i.CLIPImageProcessor,ChineseCLIPFeatureExtractor:()=>o.ChineseCLIPFeatureExtractor,ConvNextFeatureExtractor:()=>s.ConvNextFeatureExtractor,ConvNextImageProcessor:()=>s.ConvNextImageProcessor,DPTFeatureExtractor:()=>c.DPTFeatureExtractor,DPTImageProcessor:()=>c.DPTImageProcessor,DeiTFeatureExtractor:()=>l.DeiTFeatureExtractor,DeiTImageProcessor:()=>l.DeiTImageProcessor,DetrFeatureExtractor:()=>d.DetrFeatureExtractor,DetrImageProcessor:()=>d.DetrImageProcessor,DonutFeatureExtractor:()=>u.DonutFeatureExtractor,DonutImageProcessor:()=>u.DonutImageProcessor,EfficientNetImageProcessor:()=>p.EfficientNetImageProcessor,GLPNFeatureExtractor:()=>g.GLPNFeatureExtractor,GroundingDinoImageProcessor:()=>A.GroundingDinoImageProcessor,Idefics3ImageProcessor:()=>h.Idefics3ImageProcessor,JinaCLIPImageProcessor:()=>m.JinaCLIPImageProcessor,LlavaOnevisionImageProcessor:()=>C.LlavaOnevisionImageProcessor,Mask2FormerImageProcessor:()=>w.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>b.MaskFormerFeatureExtractor,MaskFormerImageProcessor:()=>b.MaskFormerImageProcessor,MobileNetV1FeatureExtractor:()=>K.MobileNetV1FeatureExtractor,MobileNetV1ImageProcessor:()=>K.MobileNetV1ImageProcessor,MobileNetV2FeatureExtractor:()=>f.MobileNetV2FeatureExtractor,MobileNetV2ImageProcessor:()=>f.MobileNetV2ImageProcessor,MobileNetV3FeatureExtractor:()=>Q.MobileNetV3FeatureExtractor,MobileNetV3ImageProcessor:()=>Q.MobileNetV3ImageProcessor,MobileNetV4FeatureExtractor:()=>W.MobileNetV4FeatureExtractor,MobileNetV4ImageProcessor:()=>W.MobileNetV4ImageProcessor,MobileViTFeatureExtractor:()=>F.MobileViTFeatureExtractor,MobileViTImageProcessor:()=>F.MobileViTImageProcessor,NougatImageProcessor:()=>_.NougatImageProcessor,OwlViTFeatureExtractor:()=>v.OwlViTFeatureExtractor,OwlViTImageProcessor:()=>v.OwlViTImageProcessor,Owlv2ImageProcessor:()=>y.Owlv2ImageProcessor,Phi3VImageProcessor:()=>E.Phi3VImageProcessor,PvtImageProcessor:()=>G.PvtImageProcessor,Qwen2VLImageProcessor:()=>R.Qwen2VLImageProcessor,RTDetrImageProcessor:()=>x.RTDetrImageProcessor,SamImageProcessor:()=>S.SamImageProcessor,SegformerFeatureExtractor:()=>T.SegformerFeatureExtractor,SegformerImageProcessor:()=>T.SegformerImageProcessor,SiglipImageProcessor:()=>Z.SiglipImageProcessor,SmolVLMImageProcessor:()=>X.SmolVLMImageProcessor,Swin2SRImageProcessor:()=>V.Swin2SRImageProcessor,VLMImageProcessor:()=>B.VLMImageProcessor,ViTFeatureExtractor:()=>k.ViTFeatureExtractor,ViTImageProcessor:()=>k.ViTImageProcessor,VitMatteImageProcessor:()=>M.VitMatteImageProcessor,VitPoseImageProcessor:()=>H.VitPoseImageProcessor,YolosFeatureExtractor:()=>Y.YolosFeatureExtractor,YolosImageProcessor:()=>Y.YolosImageProcessor});var n=r(/*! ./beit/image_processing_beit.js */"./src/models/beit/image_processing_beit.js"),a=r(/*! ./bit/image_processing_bit.js */"./src/models/bit/image_processing_bit.js"),o=r(/*! ./chinese_clip/image_processing_chinese_clip.js */"./src/models/chinese_clip/image_processing_chinese_clip.js"),i=r(/*! ./clip/image_processing_clip.js */"./src/models/clip/image_processing_clip.js"),s=r(/*! ./convnext/image_processing_convnext.js */"./src/models/convnext/image_processing_convnext.js"),l=r(/*! ./deit/image_processing_deit.js */"./src/models/deit/image_processing_deit.js"),d=r(/*! ./detr/image_processing_detr.js */"./src/models/detr/image_processing_detr.js"),u=r(/*! ./donut/image_processing_donut.js */"./src/models/donut/image_processing_donut.js"),c=r(/*! ./dpt/image_processing_dpt.js */"./src/models/dpt/image_processing_dpt.js"),p=r(/*! ./efficientnet/image_processing_efficientnet.js */"./src/models/efficientnet/image_processing_efficientnet.js"),g=r(/*! ./glpn/image_processing_glpn.js */"./src/models/glpn/image_processing_glpn.js"),A=r(/*! ./grounding_dino/image_processing_grounding_dino.js */"./src/models/grounding_dino/image_processing_grounding_dino.js"),h=r(/*! ./idefics3/image_processing_idefics3.js */"./src/models/idefics3/image_processing_idefics3.js"),B=r(/*! ./janus/image_processing_janus.js */"./src/models/janus/image_processing_janus.js"),m=r(/*! ./jina_clip/image_processing_jina_clip.js */"./src/models/jina_clip/image_processing_jina_clip.js"),C=r(/*! ./llava_onevision/image_processing_llava_onevision.js */"./src/models/llava_onevision/image_processing_llava_onevision.js"),w=r(/*! ./mask2former/image_processing_mask2former.js */"./src/models/mask2former/image_processing_mask2former.js"),b=r(/*! ./maskformer/image_processing_maskformer.js */"./src/models/maskformer/image_processing_maskformer.js"),K=r(/*! ./mobilenet_v1/image_processing_mobilenet_v1.js */"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js"),f=r(/*! ./mobilenet_v2/image_processing_mobilenet_v2.js */"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js"),Q=r(/*! ./mobilenet_v3/image_processing_mobilenet_v3.js */"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js"),W=r(/*! ./mobilenet_v4/image_processing_mobilenet_v4.js */"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js"),F=r(/*! ./mobilevit/image_processing_mobilevit.js */"./src/models/mobilevit/image_processing_mobilevit.js"),_=r(/*! ./nougat/image_processing_nougat.js */"./src/models/nougat/image_processing_nougat.js"),y=r(/*! ./owlv2/image_processing_owlv2.js */"./src/models/owlv2/image_processing_owlv2.js"),v=r(/*! ./owlvit/image_processing_owlvit.js */"./src/models/owlvit/image_processing_owlvit.js"),E=r(/*! ./phi3_v/image_processing_phi3_v.js */"./src/models/phi3_v/image_processing_phi3_v.js"),G=r(/*! ./pvt/image_processing_pvt.js */"./src/models/pvt/image_processing_pvt.js"),R=r(/*! ./qwen2_vl/image_processing_qwen2_vl.js */"./src/models/qwen2_vl/image_processing_qwen2_vl.js"),x=r(/*! ./rt_detr/image_processing_rt_detr.js */"./src/models/rt_detr/image_processing_rt_detr.js"),S=r(/*! ./sam/image_processing_sam.js */"./src/models/sam/image_processing_sam.js"),T=r(/*! ./segformer/image_processing_segformer.js */"./src/models/segformer/image_processing_segformer.js"),Z=r(/*! ./siglip/image_processing_siglip.js */"./src/models/siglip/image_processing_siglip.js"),X=r(/*! ./smolvlm/image_processing_smolvlm.js */"./src/models/smolvlm/image_processing_smolvlm.js"),V=r(/*! ./swin2sr/image_processing_swin2sr.js */"./src/models/swin2sr/image_processing_swin2sr.js"),k=r(/*! ./vit/image_processing_vit.js */"./src/models/vit/image_processing_vit.js"),M=r(/*! ./vitmatte/image_processing_vitmatte.js */"./src/models/vitmatte/image_processing_vitmatte.js"),H=r(/*! ./vitpose/image_processing_vitpose.js */"./src/models/vitpose/image_processing_vitpose.js"),Y=r(/*! ./yolos/image_processing_yolos.js */"./src/models/yolos/image_processing_yolos.js")},"./src/models/janus/image_processing_janus.js":
/*!****************************************************!*\
  !*** ./src/models/janus/image_processing_janus.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{VLMImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{constructor(e){super({do_pad:!0,pad_size:{width:e.image_size,height:e.image_size},...e}),this.constant_values=this.config.background_color.map((e=>e*this.rescale_factor))}pad_image(e,t,r,n){return super.pad_image(e,t,r,{constant_values:this.constant_values,center:!0,...n})}}},"./src/models/janus/processing_janus.js":
/*!**********************************************!*\
  !*** ./src/models/janus/processing_janus.js ***!
  \**********************************************/(e,t,r)=>{r.r(t),r.d(t,{VLChatProcessor:()=>d});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),o=r(/*! ../../tokenizers.js */"./src/tokenizers.js"),i=r(/*! ../../utils/core.js */"./src/utils/core.js"),s=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js"),l=r(/*! ../../utils/image.js */"./src/utils/image.js");class d extends n.Processor{static image_processor_class=a.AutoImageProcessor;static tokenizer_class=o.AutoTokenizer;static uses_processor_config=!0;constructor(e,t){super(e,t),this.image_tag=this.config.image_tag,this.image_start_tag=this.config.image_start_tag,this.image_end_tag=this.config.image_end_tag,this.num_image_tokens=this.config.num_image_tokens}async _call(e,{images:t=null,chat_template:r="default"}={}){t?Array.isArray(t)||(t=[t]):t=await Promise.all(e.filter((e=>e.images)).flatMap((e=>e.images)).map((e=>l.RawImage.read(e))));const n=this.tokenizer,a=e=>n.encode(e,{add_special_tokens:!1}),o=n.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0,chat_template:r}).split(this.image_tag),d=o.length-1;if(t.length!==d)throw new Error(`Number of images provided (${t.length}) does not match number of "${this.image_tag}" image tags (${d})`);const[u,c,p]=n.model.convert_tokens_to_ids([this.image_tag,this.image_start_tag,this.image_end_tag]);let g=a(o[0]),A=new Array(g.length).fill(!1);for(let e=1;e<o.length;++e){const t=new Array(this.num_image_tokens).fill(u),r=a(o[e]);g=(0,i.mergeArrays)(g,[c],t,[p],r);const n=new Array(this.num_image_tokens).fill(!0);A=(0,i.mergeArrays)(A,[!1],n,[!1],new Array(r.length).fill(!1))}const h=[1,g.length],B={input_ids:new s.Tensor("int64",g,h),attention_mask:new s.Tensor("int64",new Array(g.length).fill(1),h),images_seq_mask:new s.Tensor("bool",A,h),images_emb_mask:new s.Tensor("bool",new Array(d*this.num_image_tokens).fill(!0),[1,d,this.num_image_tokens])};if(t&&t.length>0){const e=await this.image_processor(t);return e.pixel_values.unsqueeze_(0),{...B,...e}}return B}}},"./src/models/jina_clip/image_processing_jina_clip.js":
/*!************************************************************!*\
  !*** ./src/models/jina_clip/image_processing_jina_clip.js ***!
  \************************************************************/(e,t,r)=>{r.r(t),r.d(t,{JinaCLIPImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{constructor(e){const{resize_mode:t,fill_color:r,interpolation:n,size:a,...o}=e;super({...o,size:"squash"===t?{width:a,height:a}:"shortest"===t?{shortest_edge:a}:{longest_edge:a},resample:"bicubic"===n?3:2,do_center_crop:!0,crop_size:a,do_normalize:!0})}}},"./src/models/jina_clip/processing_jina_clip.js":
/*!******************************************************!*\
  !*** ./src/models/jina_clip/processing_jina_clip.js ***!
  \******************************************************/(e,t,r)=>{r.r(t),r.d(t,{JinaCLIPProcessor:()=>i});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),o=r(/*! ../../tokenizers.js */"./src/tokenizers.js");class i extends n.Processor{static tokenizer_class=o.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;async _call(e=null,t=null,r={}){if(!e&&!t)throw new Error("Either text or images must be provided");return{...e?this.tokenizer(e,r):{},...t?await this.image_processor(t,r):{}}}}},"./src/models/llava_onevision/image_processing_llava_onevision.js":
/*!************************************************************************!*\
  !*** ./src/models/llava_onevision/image_processing_llava_onevision.js ***!
  \************************************************************************/(e,t,r)=>{r.r(t),r.d(t,{LlavaOnevisionImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}},"./src/models/mask2former/image_processing_mask2former.js":
/*!****************************************************************!*\
  !*** ./src/models/mask2former/image_processing_mask2former.js ***!
  \****************************************************************/(e,t,r)=>{r.r(t),r.d(t,{Mask2FormerImageProcessor:()=>a});var n=r(/*! ../maskformer/image_processing_maskformer.js */"./src/models/maskformer/image_processing_maskformer.js");class a extends n.MaskFormerImageProcessor{}},"./src/models/maskformer/image_processing_maskformer.js":
/*!**************************************************************!*\
  !*** ./src/models/maskformer/image_processing_maskformer.js ***!
  \**************************************************************/(e,t,r)=>{r.r(t),r.d(t,{MaskFormerFeatureExtractor:()=>o,MaskFormerImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{post_process_panoptic_segmentation(...e){return(0,n.post_process_panoptic_segmentation)(...e)}post_process_instance_segmentation(...e){return(0,n.post_process_instance_segmentation)(...e)}}class o extends a{}},"./src/models/mgp_str/processing_mgp_str.js":
/*!**************************************************!*\
  !*** ./src/models/mgp_str/processing_mgp_str.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{MgpstrProcessor:()=>l});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),o=r(/*! ../../tokenizers.js */"./src/tokenizers.js"),i=r(/*! ../../utils/maths.js */"./src/utils/maths.js");const s={char:["char_decode",1],bpe:["bpe_decode",2],wp:["wp_decode",102]};class l extends n.Processor{static tokenizer_class=o.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;get char_tokenizer(){return this.components.char_tokenizer}get bpe_tokenizer(){return this.components.bpe_tokenizer}get wp_tokenizer(){return this.components.wp_tokenizer}_decode_helper(e,t){if(!s.hasOwnProperty(t))throw new Error(`Format ${t} is not supported.`);const[r,n]=s[t],a=this[r].bind(this),[o,l]=e.dims,d=[],u=[],c=e.tolist();for(let e=0;e<o;++e){const t=c[e],r=[],a=[];for(let e=1;e<l;++e){const[o,s]=(0,i.max)((0,i.softmax)(t[e]));if(a.push(o),s==n)break;r.push(s)}const o=a.length>0?a.reduce(((e,t)=>e*t),1):0;u.push(r),d.push(o)}return[a(u),d]}char_decode(e){return this.char_tokenizer.batch_decode(e).map((e=>e.replaceAll(" ","")))}bpe_decode(e){return this.bpe_tokenizer.batch_decode(e)}wp_decode(e){return this.wp_tokenizer.batch_decode(e).map((e=>e.replaceAll(" ","")))}batch_decode([e,t,r]){const[n,a]=this._decode_helper(e,"char"),[o,s]=this._decode_helper(t,"bpe"),[l,d]=this._decode_helper(r,"wp"),u=[],c=[];for(let e=0;e<n.length;++e){const[t,r]=(0,i.max)([a[e],s[e],d[e]]);u.push([n[e],o[e],l[e]][r]),c.push(t)}return{generated_text:u,scores:c,char_preds:n,bpe_preds:o,wp_preds:l}}static async from_pretrained(...e){const t=await super.from_pretrained(...e),r=await o.AutoTokenizer.from_pretrained("Xenova/gpt2"),n=await o.AutoTokenizer.from_pretrained("Xenova/bert-base-uncased");return t.components={image_processor:t.image_processor,char_tokenizer:t.tokenizer,bpe_tokenizer:r,wp_tokenizer:n},t}async _call(e,t=null){const r=await this.image_processor(e);return t&&(r.labels=this.tokenizer(t).input_ids),r}}},"./src/models/mobilenet_v1/image_processing_mobilenet_v1.js":
/*!******************************************************************!*\
  !*** ./src/models/mobilenet_v1/image_processing_mobilenet_v1.js ***!
  \******************************************************************/(e,t,r)=>{r.r(t),r.d(t,{MobileNetV1FeatureExtractor:()=>o,MobileNetV1ImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}class o extends a{}},"./src/models/mobilenet_v2/image_processing_mobilenet_v2.js":
/*!******************************************************************!*\
  !*** ./src/models/mobilenet_v2/image_processing_mobilenet_v2.js ***!
  \******************************************************************/(e,t,r)=>{r.r(t),r.d(t,{MobileNetV2FeatureExtractor:()=>o,MobileNetV2ImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}class o extends a{}},"./src/models/mobilenet_v3/image_processing_mobilenet_v3.js":
/*!******************************************************************!*\
  !*** ./src/models/mobilenet_v3/image_processing_mobilenet_v3.js ***!
  \******************************************************************/(e,t,r)=>{r.r(t),r.d(t,{MobileNetV3FeatureExtractor:()=>o,MobileNetV3ImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}class o extends a{}},"./src/models/mobilenet_v4/image_processing_mobilenet_v4.js":
/*!******************************************************************!*\
  !*** ./src/models/mobilenet_v4/image_processing_mobilenet_v4.js ***!
  \******************************************************************/(e,t,r)=>{r.r(t),r.d(t,{MobileNetV4FeatureExtractor:()=>o,MobileNetV4ImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}class o extends a{}},"./src/models/mobilevit/image_processing_mobilevit.js":
/*!************************************************************!*\
  !*** ./src/models/mobilevit/image_processing_mobilevit.js ***!
  \************************************************************/(e,t,r)=>{r.r(t),r.d(t,{MobileViTFeatureExtractor:()=>o,MobileViTImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}class o extends a{}},"./src/models/moonshine/feature_extraction_moonshine.js":
/*!**************************************************************!*\
  !*** ./src/models/moonshine/feature_extraction_moonshine.js ***!
  \**************************************************************/(e,t,r)=>{r.r(t),r.d(t,{MoonshineFeatureExtractor:()=>o});var n=r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");class o extends n.FeatureExtractor{async _call(e){(0,n.validate_audio_inputs)(e,"MoonshineFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,e.length];return{input_values:new a.Tensor("float32",e,t)}}}},"./src/models/moonshine/processing_moonshine.js":
/*!******************************************************!*\
  !*** ./src/models/moonshine/processing_moonshine.js ***!
  \******************************************************/(e,t,r)=>{r.r(t),r.d(t,{MoonshineProcessor:()=>i});var n=r(/*! ../auto/feature_extraction_auto.js */"./src/models/auto/feature_extraction_auto.js"),a=r(/*! ../../tokenizers.js */"./src/tokenizers.js"),o=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js");class i extends o.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=n.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/nougat/image_processing_nougat.js":
/*!******************************************************!*\
  !*** ./src/models/nougat/image_processing_nougat.js ***!
  \******************************************************/(e,t,r)=>{r.r(t),r.d(t,{NougatImageProcessor:()=>a});var n=r(/*! ../donut/image_processing_donut.js */"./src/models/donut/image_processing_donut.js");class a extends n.DonutImageProcessor{}},"./src/models/owlv2/image_processing_owlv2.js":
/*!****************************************************!*\
  !*** ./src/models/owlv2/image_processing_owlv2.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{Owlv2ImageProcessor:()=>a});var n=r(/*! ../owlvit/image_processing_owlvit.js */"./src/models/owlvit/image_processing_owlvit.js");class a extends n.OwlViTImageProcessor{}},"./src/models/owlvit/image_processing_owlvit.js":
/*!******************************************************!*\
  !*** ./src/models/owlvit/image_processing_owlvit.js ***!
  \******************************************************/(e,t,r)=>{r.r(t),r.d(t,{OwlViTFeatureExtractor:()=>o,OwlViTImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{post_process_object_detection(...e){return(0,n.post_process_object_detection)(...e)}}class o extends a{}},"./src/models/owlvit/processing_owlvit.js":
/*!************************************************!*\
  !*** ./src/models/owlvit/processing_owlvit.js ***!
  \************************************************/(e,t,r)=>{r.r(t),r.d(t,{OwlViTProcessor:()=>i});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),o=r(/*! ../../tokenizers.js */"./src/tokenizers.js");class i extends n.Processor{static tokenizer_class=o.AutoTokenizer;static image_processor_class=a.AutoImageProcessor}},"./src/models/paligemma/processing_paligemma.js":
/*!******************************************************!*\
  !*** ./src/models/paligemma/processing_paligemma.js ***!
  \******************************************************/(e,t,r)=>{r.r(t),r.d(t,{PaliGemmaProcessor:()=>s});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),o=r(/*! ../../tokenizers.js */"./src/tokenizers.js");const i="<image>";class s extends n.Processor{static tokenizer_class=o.AutoTokenizer;static image_processor_class=a.AutoImageProcessor;static uses_processor_config=!1;async _call(e,t=null,r={}){t||(console.warn("You are using PaliGemma without a text prefix. It will perform as a picture-captioning model."),t=""),Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const n=this.tokenizer.bos_token,a=this.image_processor.config.image_seq_length;let o;t.some((e=>e.includes(i)))?o=t.map((e=>{const t=e.replaceAll(i,i.repeat(a)),r=t.lastIndexOf(i),o=-1===r?0:r+7;return t.slice(0,o)+n+t.slice(o)+"\n"})):(console.warn("You are passing both `text` and `images` to `PaliGemmaProcessor`. The processor expects special image tokens in the text, as many tokens as there are images per each text. It is recommended to add `<image>` tokens in the very beginning of your text. For this call, we will infer how many images each text has and add special tokens."),o=t.map((t=>function(e,t,r,n,a){return`${n.repeat(r*a)}${t}${e}\n`}(t,n,a,i,e.length))));const s=this.tokenizer(o,r);return{...await this.image_processor(e,r),...s}}}},"./src/models/phi3_v/image_processing_phi3_v.js":
/*!******************************************************!*\
  !*** ./src/models/phi3_v/image_processing_phi3_v.js ***!
  \******************************************************/(e,t,r)=>{r.r(t),r.d(t,{Phi3VImageProcessor:()=>u});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");const o=336,i=[2,3],{ceil:s,floor:l,sqrt:d}=Math;class u extends n.ImageProcessor{constructor(e){super({...e,do_normalize:!0,do_pad:!0,pad_size:"custom",do_convert_rgb:!0,do_resize:!0}),this._num_crops=e.num_crops}calc_num_image_tokens_from_image_size(e,t){const{num_img_tokens:r}=this.config;return l((l(t/o)*l(e/o)+1)*r+1+(l(t/o)+1)*d(r))}get_resize_output_image_size(e,t){const r=this._num_crops,[n,a]=e.size;let o=n/a,i=1;for(;i*Math.ceil(i/o)<=r;)i+=1;i-=1;const s=Math.floor(336*i);return[s,Math.floor(s/o)]}pad_image(e,t,r,n={}){const[a,i]=t,l=o*s(a/o),d=o*s(i/o),u=[1,1,1].map(((e,t)=>(e-this.image_mean[t])/this.image_std[t]));return super.pad_image(e,t,{width:d,height:l},{center:!0,constant_values:u,...n})}async _call(e,{num_crops:t=null}={}){if(this._num_crops=t??=this.config.num_crops,t<4||d(t)%1!=0)throw new Error("num_crops must be a square number >= 4");Array.isArray(e)||(e=[e]);const r=e.length,n=await Promise.all(e.map((e=>this.preprocess(e)))),u=n.map((e=>e.original_size)),c=n.map((e=>e.reshaped_input_size)),p=[];for(const{pixel_values:e}of n){e.unsqueeze_(0);const[r,n]=e.dims.slice(-2),s=await(0,a.interpolate_4d)(e,{size:[o,o],mode:"bicubic"});if(t>0){const u=[],c=d(t),g=l(n/c),A=l(r/c);for(let t=0;t<c;++t)for(let o=0;o<c;++o){let s,l,d,p;t===c-1?(l=r-A,p=r):(l=t*A,p=(t+1)*A),o===c-1?(s=n-g,d=n):(s=o*g,d=(o+1)*g);const h=[l,s],B=[p,d],m=await(0,a.slice)(e,h,B,i);u.push(m)}const h=await(0,a.interpolate_4d)((0,a.cat)(u,0),{size:[o,o],mode:"bicubic"});p.push((0,a.cat)([s,h],0))}else p.push(s)}const g=(0,a.stack)(p,0),A=c.map((e=>e.map((e=>o*s(e/o)))));return{pixel_values:g,original_sizes:u,reshaped_input_sizes:c,image_sizes:new a.Tensor("int64",A.flat(),[r,2]),num_img_tokens:A.map((([e,t])=>this.calc_num_image_tokens_from_image_size(t,e)))}}}},"./src/models/phi3_v/processing_phi3_v.js":
/*!************************************************!*\
  !*** ./src/models/phi3_v/processing_phi3_v.js ***!
  \************************************************/(e,t,r)=>{r.r(t),r.d(t,{Phi3VProcessor:()=>l});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),o=r(/*! ../../tokenizers.js */"./src/tokenizers.js");r(/*! ../../utils/image.js */"./src/utils/image.js");const i="<|image|>",s=/<\|image_\d+\|>/g;class l extends n.Processor{static image_processor_class=a.AutoImageProcessor;static tokenizer_class=o.AutoTokenizer;async _call(e,t=null,{padding:r=!0,truncation:n=!0,num_crops:a=null}={}){let o,l;if(Array.isArray(e)||(e=[e]),t){l=await this.image_processor(t,{num_crops:a});const{num_img_tokens:d}=l,u=e.map(((e,t)=>e.split(s).join(i.repeat(d[t]))));o=this.tokenizer(u,{padding:r,truncation:n});const c=this.tokenizer.model.convert_tokens_to_ids([i])[0];o.input_ids.map_((e=>e==c?-e:e))}else o=this.tokenizer(e);return{...o,...l}}}},"./src/models/processors.js":
/*!**********************************!*\
  !*** ./src/models/processors.js ***!
  \**********************************/(e,t,r)=>{r.r(t),r.d(t,{Florence2Processor:()=>n.Florence2Processor,GroundingDinoProcessor:()=>a.GroundingDinoProcessor,Idefics3Processor:()=>o.Idefics3Processor,JinaCLIPProcessor:()=>s.JinaCLIPProcessor,MgpstrProcessor:()=>l.MgpstrProcessor,MoonshineProcessor:()=>d.MoonshineProcessor,OwlViTProcessor:()=>u.OwlViTProcessor,PaliGemmaProcessor:()=>p.PaliGemmaProcessor,Phi3VProcessor:()=>c.Phi3VProcessor,PyAnnoteProcessor:()=>g.PyAnnoteProcessor,Qwen2VLProcessor:()=>A.Qwen2VLProcessor,SamProcessor:()=>h.SamProcessor,SmolVLMProcessor:()=>B.SmolVLMProcessor,SpeechT5Processor:()=>m.SpeechT5Processor,UltravoxProcessor:()=>C.UltravoxProcessor,VLChatProcessor:()=>i.VLChatProcessor,Wav2Vec2Processor:()=>w.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>b.Wav2Vec2ProcessorWithLM,WhisperProcessor:()=>K.WhisperProcessor});var n=r(/*! ./florence2/processing_florence2.js */"./src/models/florence2/processing_florence2.js"),a=r(/*! ./grounding_dino/processing_grounding_dino.js */"./src/models/grounding_dino/processing_grounding_dino.js"),o=r(/*! ./idefics3/processing_idefics3.js */"./src/models/idefics3/processing_idefics3.js"),i=r(/*! ./janus/processing_janus.js */"./src/models/janus/processing_janus.js"),s=r(/*! ./jina_clip/processing_jina_clip.js */"./src/models/jina_clip/processing_jina_clip.js"),l=r(/*! ./mgp_str/processing_mgp_str.js */"./src/models/mgp_str/processing_mgp_str.js"),d=r(/*! ./moonshine/processing_moonshine.js */"./src/models/moonshine/processing_moonshine.js"),u=r(/*! ./owlvit/processing_owlvit.js */"./src/models/owlvit/processing_owlvit.js"),c=r(/*! ./phi3_v/processing_phi3_v.js */"./src/models/phi3_v/processing_phi3_v.js"),p=r(/*! ./paligemma/processing_paligemma.js */"./src/models/paligemma/processing_paligemma.js"),g=r(/*! ./pyannote/processing_pyannote.js */"./src/models/pyannote/processing_pyannote.js"),A=r(/*! ./qwen2_vl/processing_qwen2_vl.js */"./src/models/qwen2_vl/processing_qwen2_vl.js"),h=r(/*! ./sam/processing_sam.js */"./src/models/sam/processing_sam.js"),B=r(/*! ./smolvlm/processing_smolvlm.js */"./src/models/smolvlm/processing_smolvlm.js"),m=r(/*! ./speecht5/processing_speecht5.js */"./src/models/speecht5/processing_speecht5.js"),C=r(/*! ./ultravox/processing_ultravox.js */"./src/models/ultravox/processing_ultravox.js"),w=r(/*! ./wav2vec2/processing_wav2vec2.js */"./src/models/wav2vec2/processing_wav2vec2.js"),b=r(/*! ./wav2vec2_with_lm/processing_wav2vec2_with_lm.js */"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js"),K=r(/*! ./whisper/processing_whisper.js */"./src/models/whisper/processing_whisper.js")},"./src/models/pvt/image_processing_pvt.js":
/*!************************************************!*\
  !*** ./src/models/pvt/image_processing_pvt.js ***!
  \************************************************/(e,t,r)=>{r.r(t),r.d(t,{PvtImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}},"./src/models/pyannote/feature_extraction_pyannote.js":
/*!************************************************************!*\
  !*** ./src/models/pyannote/feature_extraction_pyannote.js ***!
  \************************************************************/(e,t,r)=>{r.r(t),r.d(t,{PyAnnoteFeatureExtractor:()=>i});var n=r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js"),o=r(/*! ../../utils/maths.js */"./src/utils/maths.js");class i extends n.FeatureExtractor{async _call(e){(0,n.validate_audio_inputs)(e,"PyAnnoteFeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));const t=[1,1,e.length];return{input_values:new a.Tensor("float32",e,t)}}samples_to_frames(e){return(e-this.config.offset)/this.config.step}post_process_speaker_diarization(e,t){const r=t/this.samples_to_frames(t)/this.config.sampling_rate,n=[];for(const t of e.tolist()){const e=[];let a=-1;for(let r=0;r<t.length;++r){const n=(0,o.softmax)(t[r]),[i,s]=(0,o.max)(n),[l,d]=[r,r+1];s!==a?(a=s,e.push({id:s,start:l,end:d,score:i})):(e.at(-1).end=d,e.at(-1).score+=i)}n.push(e.map((({id:e,start:t,end:n,score:a})=>({id:e,start:t*r,end:n*r,confidence:a/(n-t)}))))}return n}}},"./src/models/pyannote/processing_pyannote.js":
/*!****************************************************!*\
  !*** ./src/models/pyannote/processing_pyannote.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{PyAnnoteProcessor:()=>o});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ./feature_extraction_pyannote.js */"./src/models/pyannote/feature_extraction_pyannote.js");class o extends n.Processor{static feature_extractor_class=a.PyAnnoteFeatureExtractor;async _call(e){return await this.feature_extractor(e)}post_process_speaker_diarization(...e){return this.feature_extractor.post_process_speaker_diarization(...e)}get sampling_rate(){return this.feature_extractor.config.sampling_rate}}},"./src/models/qwen2_vl/image_processing_qwen2_vl.js":
/*!**********************************************************!*\
  !*** ./src/models/qwen2_vl/image_processing_qwen2_vl.js ***!
  \**********************************************************/(e,t,r)=>{r.r(t),r.d(t,{Qwen2VLImageProcessor:()=>o});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");class o extends n.ImageProcessor{async _call(e,...t){const{pixel_values:r,original_sizes:n,reshaped_input_sizes:o}=await super._call(e,...t);let i=r;const{temporal_patch_size:s,merge_size:l,patch_size:d}=this.config;1===i.dims[0]&&(i=(0,a.cat)(Array.from({length:s},(()=>i)),0));const u=i.dims[0]/s,c=i.dims[1],p=Math.floor(i.dims[2]/d),g=Math.floor(i.dims[3]/d);return{pixel_values:i.view(u,s,c,Math.floor(p/l),l,d,Math.floor(g/l),l,d).permute(0,3,6,4,7,2,1,5,8).view(u*p*g,c*s*d*d),image_grid_thw:new a.Tensor("int64",[u,p,g],[1,3]),original_sizes:n,reshaped_input_sizes:o}}}},"./src/models/qwen2_vl/processing_qwen2_vl.js":
/*!****************************************************!*\
  !*** ./src/models/qwen2_vl/processing_qwen2_vl.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{Qwen2VLProcessor:()=>i});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),o=r(/*! ../../tokenizers.js */"./src/tokenizers.js");r(/*! ../../utils/image.js */"./src/utils/image.js");class i extends n.Processor{static image_processor_class=a.AutoImageProcessor;static tokenizer_class=o.AutoTokenizer;async _call(e,t=null,...r){let n,a;if(Array.isArray(e)||(e=[e]),t&&(n=await this.image_processor(t),a=n.image_grid_thw),a){let t=this.image_processor.config.merge_size**2,r=0;const n=a.tolist();e=e.map((e=>{for(;e.includes("<|image_pad|>");){const a=Number(n[r++].reduce(((e,t)=>e*t),1n));e=e.replace("<|image_pad|>","<|placeholder|>".repeat(Math.floor(a/t)))}return e.replaceAll("<|placeholder|>","<|image_pad|>")}))}return{...this.tokenizer(e),...n}}}},"./src/models/rt_detr/image_processing_rt_detr.js":
/*!********************************************************!*\
  !*** ./src/models/rt_detr/image_processing_rt_detr.js ***!
  \********************************************************/(e,t,r)=>{r.r(t),r.d(t,{RTDetrImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{post_process_object_detection(...e){return(0,n.post_process_object_detection)(...e)}}},"./src/models/sam/image_processing_sam.js":
/*!************************************************!*\
  !*** ./src/models/sam/image_processing_sam.js ***!
  \************************************************/(e,t,r)=>{r.r(t),r.d(t,{SamImageProcessor:()=>i});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js"),a=r(/*! ../../utils/core.js */"./src/utils/core.js"),o=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");class i extends n.ImageProcessor{reshape_input_points(e,t,r,n=!1){e=structuredClone(e);let i=(0,a.calculateDimensions)(e);if(3===i.length)n||(i=[1,...i]),e=[e];else if(4!==i.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");for(let n=0;n<e.length;++n){let a=t[n],o=r[n],i=[o[0]/a[0],o[1]/a[1]];for(let t=0;t<e[n].length;++t)for(let r=0;r<e[n][t].length;++r)for(let a=0;a<e[n][t][r].length;++a)e[n][t][r][a]*=i[a%2]}return new o.Tensor("float32",Float32Array.from(e.flat(1/0)),i)}add_input_labels(e,t){let r=(0,a.calculateDimensions)(e);if(2===r.length)r=[1,...r],e=[e];else if(3!==r.length)throw Error("The input_points must be a 4D tensor of shape `batch_size`, `point_batch_size`, `nb_points_per_image`, `2`.");if(r.some(((e,r)=>e!==t.dims[r])))throw Error(`The first ${r.length} dimensions of 'input_points' and 'input_labels' must be the same.`);return new o.Tensor("int64",e.flat(1/0).map(BigInt),r)}async _call(e,{input_points:t=null,input_labels:r=null,input_boxes:n=null}={}){const a=await super._call(e);if(t&&(a.input_points=this.reshape_input_points(t,a.original_sizes,a.reshaped_input_sizes)),r){if(!a.input_points)throw Error("`input_points` must be provided if `input_labels` are provided.");a.input_labels=this.add_input_labels(r,a.input_points)}return n&&(a.input_boxes=this.reshape_input_points(n,a.original_sizes,a.reshaped_input_sizes,!0)),a}async post_process_masks(e,t,r,{mask_threshold:n=0,binarize:a=!0,pad_size:i=null}={}){const s=[],l=[(i=i??this.pad_size).height,i.width];for(let i=0;i<t.length;++i){const d=t[i],u=r[i];let c=await(0,o.interpolate_4d)(e[i],{mode:"bilinear",size:l});if(c=c.slice(null,null,[0,u[0]],[0,u[1]]),c=await(0,o.interpolate_4d)(c,{mode:"bilinear",size:d}),a){const e=c.data,t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)e[r]>n&&(t[r]=1);c=new o.Tensor("bool",t,c.dims)}s.push(c)}return s}generate_crop_boxes(e,t,{crop_n_layers:r=0,overlap_ratio:n=512/1500,points_per_crop:a=32,crop_n_points_downscale_factor:o=1}={}){}}},"./src/models/sam/processing_sam.js":
/*!******************************************!*\
  !*** ./src/models/sam/processing_sam.js ***!
  \******************************************/(e,t,r)=>{r.r(t),r.d(t,{SamProcessor:()=>o});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js");class o extends n.Processor{static image_processor_class=a.AutoImageProcessor;async _call(...e){return await this.image_processor(...e)}post_process_masks(...e){return this.image_processor.post_process_masks(...e)}reshape_input_points(...e){return this.image_processor.reshape_input_points(...e)}}},"./src/models/seamless_m4t/feature_extraction_seamless_m4t.js":
/*!********************************************************************!*\
  !*** ./src/models/seamless_m4t/feature_extraction_seamless_m4t.js ***!
  \********************************************************************/(e,t,r)=>{r.r(t),r.d(t,{SeamlessM4TFeatureExtractor:()=>i});var n=r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js"),o=r(/*! ../../utils/audio.js */"./src/utils/audio.js");class i extends n.FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,r=(0,o.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<r.length;++e)r[e].push(0);this.mel_filters=r,this.window=(0,o.window_function)(400,"povey",{periodic:!1})}async _extract_fbank_features(e,t){return e=e.map((e=>32768*e)),(0,o.spectrogram)(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,max_num_frames:t,transpose:!0})}async _call(e,{padding:t=!0,pad_to_multiple_of:r=2,do_normalize_per_mel_bins:o=!0,return_attention_mask:i=!0}={}){(0,n.validate_audio_inputs)(e,"SeamlessM4TFeatureExtractor");let s,l=await this._extract_fbank_features(e,this.config.max_length);if(o){const[e,t]=l.dims,r=l.data;for(let n=0;n<t;++n){let a=0;for(let o=0;o<e;++o)a+=r[o*t+n];const o=a/e;let i=0;for(let a=0;a<e;++a)i+=(r[a*t+n]-o)**2;i/=e-1;const s=Math.sqrt(i+1e-7);for(let a=0;a<e;++a){const e=a*t+n;r[e]=(r[e]-o)/s}}}if(t){const[e,t]=l.dims,n=l.data,o=e%r;if(o>0){const r=new Float32Array(t*(e+o));r.set(n),r.fill(this.config.padding_value,n.length);const d=e+o;l=new a.Tensor(l.type,r,[d,t]),i&&(s=new a.Tensor("int64",new BigInt64Array(d),[1,d]),s.data.fill(1n,0,e))}}const[d,u]=l.dims,c=this.config.stride;if(0!==d%c)throw new Error(`The number of frames (${d}) must be a multiple of the stride (${c}).`);const p=l.view(1,Math.floor(d/c),u*c),g={input_features:p};if(i){const e=p.dims[1],t=new BigInt64Array(e);if(s){const e=s.data;for(let r=1,n=0;r<d;r+=c,++n)t[n]=e[r]}else t.fill(1n);g.attention_mask=new a.Tensor("int64",t,[1,e])}return g}}},"./src/models/segformer/image_processing_segformer.js":
/*!************************************************************!*\
  !*** ./src/models/segformer/image_processing_segformer.js ***!
  \************************************************************/(e,t,r)=>{r.r(t),r.d(t,{SegformerFeatureExtractor:()=>o,SegformerImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{post_process_semantic_segmentation(...e){return(0,n.post_process_semantic_segmentation)(...e)}}class o extends a{}},"./src/models/siglip/image_processing_siglip.js":
/*!******************************************************!*\
  !*** ./src/models/siglip/image_processing_siglip.js ***!
  \******************************************************/(e,t,r)=>{r.r(t),r.d(t,{SiglipImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}},"./src/models/smolvlm/image_processing_smolvlm.js":
/*!********************************************************!*\
  !*** ./src/models/smolvlm/image_processing_smolvlm.js ***!
  \********************************************************/(e,t,r)=>{r.r(t),r.d(t,{SmolVLMImageProcessor:()=>n.Idefics3ImageProcessor});var n=r(/*! ../idefics3/image_processing_idefics3.js */"./src/models/idefics3/image_processing_idefics3.js")},"./src/models/smolvlm/processing_smolvlm.js":
/*!**************************************************!*\
  !*** ./src/models/smolvlm/processing_smolvlm.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{SmolVLMProcessor:()=>n.Idefics3Processor});var n=r(/*! ../idefics3/processing_idefics3.js */"./src/models/idefics3/processing_idefics3.js")},"./src/models/speecht5/feature_extraction_speecht5.js":
/*!************************************************************!*\
  !*** ./src/models/speecht5/feature_extraction_speecht5.js ***!
  \************************************************************/(e,t,r)=>{r.r(t),r.d(t,{SpeechT5FeatureExtractor:()=>a});var n=r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js");class a extends n.FeatureExtractor{}},"./src/models/speecht5/processing_speecht5.js":
/*!****************************************************!*\
  !*** ./src/models/speecht5/processing_speecht5.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{SpeechT5Processor:()=>i});var n=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js"),a=r(/*! ../../tokenizers.js */"./src/tokenizers.js"),o=r(/*! ../auto/feature_extraction_auto.js */"./src/models/auto/feature_extraction_auto.js");class i extends n.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=o.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/swin2sr/image_processing_swin2sr.js":
/*!********************************************************!*\
  !*** ./src/models/swin2sr/image_processing_swin2sr.js ***!
  \********************************************************/(e,t,r)=>{r.r(t),r.d(t,{Swin2SRImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{pad_image(e,t,r,n={}){const[a,o,i]=t;return super.pad_image(e,t,{width:o+(r-o%r)%r,height:a+(r-a%r)%r},{mode:"symmetric",center:!1,constant_values:-1,...n})}}},"./src/models/ultravox/processing_ultravox.js":
/*!****************************************************!*\
  !*** ./src/models/ultravox/processing_ultravox.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{UltravoxProcessor:()=>i});var n=r(/*! ../auto/feature_extraction_auto.js */"./src/models/auto/feature_extraction_auto.js"),a=r(/*! ../../tokenizers.js */"./src/tokenizers.js"),o=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js");class i extends o.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=n.AutoFeatureExtractor;static uses_processor_config=!0;async _call(e,t=null,r={}){if(Array.isArray(e))throw new Error("Batched inputs are not supported yet.");let n={};if(t){const a=t.length,{input_features:o}=await this.feature_extractor(t,{...r,max_length:a}),i=Math.round(a/this.config.encoder_ds_factor+1e-4),s=1+Math.ceil(i/this.config.stack_factor);n.audio_token_len=[s],n.audio_values=o;const l=this.config.audio_placeholder;if(!e.includes(l))throw new Error(`The input text does not contain the image token ${l}.`);e=e.replaceAll(l,l.repeat(s))}return{...this.tokenizer(e,{add_special_tokens:!1,...r}),...n}}}},"./src/models/vit/image_processing_vit.js":
/*!************************************************!*\
  !*** ./src/models/vit/image_processing_vit.js ***!
  \************************************************/(e,t,r)=>{r.r(t),r.d(t,{ViTFeatureExtractor:()=>o,ViTImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{}class o extends a{}},"./src/models/vitmatte/image_processing_vitmatte.js":
/*!**********************************************************!*\
  !*** ./src/models/vitmatte/image_processing_vitmatte.js ***!
  \**********************************************************/(e,t,r)=>{r.r(t),r.d(t,{VitMatteImageProcessor:()=>o});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");class o extends n.ImageProcessor{async _call(e,t){Array.isArray(e)||(e=[e]),Array.isArray(t)||(t=[t]);const r=await Promise.all(e.map((e=>this.preprocess(e)))),n=await Promise.all(t.map((e=>this.preprocess(e,{do_normalize:!1,do_convert_rgb:!1,do_convert_grayscale:!0}))));return{pixel_values:(0,a.stack)(r.map(((e,t)=>(0,a.cat)([e.pixel_values,n[t].pixel_values],0))),0),original_sizes:r.map((e=>e.original_size)),reshaped_input_sizes:r.map((e=>e.reshaped_input_size))}}}},"./src/models/vitpose/image_processing_vitpose.js":
/*!********************************************************!*\
  !*** ./src/models/vitpose/image_processing_vitpose.js ***!
  \********************************************************/(e,t,r)=>{r.r(t),r.d(t,{VitPoseImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{post_process_pose_estimation(e,t,{threshold:r=null}={}){const n=e.tolist(),[a,o,i,s]=e.dims,l=[];for(let e=0;e<a;++e){const a=n[e],o=t[e],d=[];for(let e=0;e<o.length;++e){const t=o[e],n=[],l=[],u=[],c=t.at(-2)/s,p=t.at(-1)/i;for(let e=0;e<a.length;++e){let[t,o]=[0,0],i=0,s=-1/0;const d=a[e];for(let e=0;e<d.length;++e){const r=d[e];for(let n=0;n<r.length;++n){const a=r[n];i+=a,s=Math.max(s,a),t+=(n+.5)*a,o+=e*a}}if(null!=r&&s<r)continue;const g=[c*t/i,p*o/i];n.push(g),u.push(e),l.push(s)}d.push({bbox:t,scores:l,labels:u,keypoints:n})}l.push(d)}return l}}},"./src/models/wav2vec2/feature_extraction_wav2vec2.js":
/*!************************************************************!*\
  !*** ./src/models/wav2vec2/feature_extraction_wav2vec2.js ***!
  \************************************************************/(e,t,r)=>{r.r(t),r.d(t,{Wav2Vec2FeatureExtractor:()=>o});var n=r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js"),a=r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");class o extends n.FeatureExtractor{_zero_mean_unit_var_norm(e){const t=e.reduce(((e,t)=>e+t),0)/e.length,r=e.reduce(((e,r)=>e+(r-t)**2),0)/e.length;return e.map((e=>(e-t)/Math.sqrt(r+1e-7)))}async _call(e){(0,n.validate_audio_inputs)(e,"Wav2Vec2FeatureExtractor"),e instanceof Float64Array&&(e=new Float32Array(e));let t=e;this.config.do_normalize&&(t=this._zero_mean_unit_var_norm(t));const r=[1,t.length];return{input_values:new a.Tensor("float32",t,r),attention_mask:new a.Tensor("int64",new BigInt64Array(t.length).fill(1n),r)}}}},"./src/models/wav2vec2/processing_wav2vec2.js":
/*!****************************************************!*\
  !*** ./src/models/wav2vec2/processing_wav2vec2.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{Wav2Vec2Processor:()=>i});var n=r(/*! ../../tokenizers.js */"./src/tokenizers.js"),a=r(/*! ../auto/feature_extraction_auto.js */"./src/models/auto/feature_extraction_auto.js"),o=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js");class i extends o.Processor{static tokenizer_class=n.AutoTokenizer;static feature_extractor_class=a.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js":
/*!********************************************************************!*\
  !*** ./src/models/wav2vec2_with_lm/processing_wav2vec2_with_lm.js ***!
  \********************************************************************/(e,t,r)=>{r.r(t),r.d(t,{Wav2Vec2ProcessorWithLM:()=>i});var n=r(/*! ../../tokenizers.js */"./src/tokenizers.js"),a=r(/*! ../auto/feature_extraction_auto.js */"./src/models/auto/feature_extraction_auto.js"),o=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js");class i extends o.Processor{static tokenizer_class=n.AutoTokenizer;static feature_extractor_class=a.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/wespeaker/feature_extraction_wespeaker.js":
/*!**************************************************************!*\
  !*** ./src/models/wespeaker/feature_extraction_wespeaker.js ***!
  \**************************************************************/(e,t,r)=>{r.r(t),r.d(t,{WeSpeakerFeatureExtractor:()=>o});var n=r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js");r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");var a=r(/*! ../../utils/audio.js */"./src/utils/audio.js");class o extends n.FeatureExtractor{constructor(e){super(e);const t=this.config.sampling_rate,r=(0,a.mel_filter_bank)(256,this.config.num_mel_bins,20,Math.floor(t/2),t,null,"kaldi",!0);for(let e=0;e<r.length;++e)r[e].push(0);this.mel_filters=r,this.window=(0,a.window_function)(400,"hamming",{periodic:!1}),this.min_num_frames=this.config.min_num_frames}async _extract_fbank_features(e){return e=e.map((e=>32768*e)),(0,a.spectrogram)(e,this.window,400,160,{fft_length:512,power:2,center:!1,preemphasis:.97,mel_filters:this.mel_filters,log_mel:"log",mel_floor:1.192092955078125e-7,remove_dc_offset:!0,transpose:!0,min_num_frames:this.min_num_frames})}async _call(e){(0,n.validate_audio_inputs)(e,"WeSpeakerFeatureExtractor");const t=(await this._extract_fbank_features(e)).unsqueeze_(0);if(null===this.config.fbank_centering_span){const e=t.mean(1).data,r=t.data,[n,a,o]=t.dims;for(let t=0;t<n;++t){const n=t*a*o,i=t*o;for(let t=0;t<a;++t){const a=n+t*o;for(let t=0;t<o;++t)r[a+t]-=e[i+t]}}}return{input_features:t}}}},"./src/models/whisper/common_whisper.js":
/*!**********************************************!*\
  !*** ./src/models/whisper/common_whisper.js ***!
  \**********************************************/(e,t,r)=>{r.r(t),r.d(t,{WHISPER_LANGUAGE_MAPPING:()=>a,WHISPER_TO_LANGUAGE_CODE_MAPPING:()=>o,whisper_language_to_code:()=>i});const n=[["en","english"],["zh","chinese"],["de","german"],["es","spanish"],["ru","russian"],["ko","korean"],["fr","french"],["ja","japanese"],["pt","portuguese"],["tr","turkish"],["pl","polish"],["ca","catalan"],["nl","dutch"],["ar","arabic"],["sv","swedish"],["it","italian"],["id","indonesian"],["hi","hindi"],["fi","finnish"],["vi","vietnamese"],["he","hebrew"],["uk","ukrainian"],["el","greek"],["ms","malay"],["cs","czech"],["ro","romanian"],["da","danish"],["hu","hungarian"],["ta","tamil"],["no","norwegian"],["th","thai"],["ur","urdu"],["hr","croatian"],["bg","bulgarian"],["lt","lithuanian"],["la","latin"],["mi","maori"],["ml","malayalam"],["cy","welsh"],["sk","slovak"],["te","telugu"],["fa","persian"],["lv","latvian"],["bn","bengali"],["sr","serbian"],["az","azerbaijani"],["sl","slovenian"],["kn","kannada"],["et","estonian"],["mk","macedonian"],["br","breton"],["eu","basque"],["is","icelandic"],["hy","armenian"],["ne","nepali"],["mn","mongolian"],["bs","bosnian"],["kk","kazakh"],["sq","albanian"],["sw","swahili"],["gl","galician"],["mr","marathi"],["pa","punjabi"],["si","sinhala"],["km","khmer"],["sn","shona"],["yo","yoruba"],["so","somali"],["af","afrikaans"],["oc","occitan"],["ka","georgian"],["be","belarusian"],["tg","tajik"],["sd","sindhi"],["gu","gujarati"],["am","amharic"],["yi","yiddish"],["lo","lao"],["uz","uzbek"],["fo","faroese"],["ht","haitian creole"],["ps","pashto"],["tk","turkmen"],["nn","nynorsk"],["mt","maltese"],["sa","sanskrit"],["lb","luxembourgish"],["my","myanmar"],["bo","tibetan"],["tl","tagalog"],["mg","malagasy"],["as","assamese"],["tt","tatar"],["haw","hawaiian"],["ln","lingala"],["ha","hausa"],["ba","bashkir"],["jw","javanese"],["su","sundanese"]],a=new Map(n),o=new Map([...n.map((([e,t])=>[t,e])),["burmese","my"],["valencian","ca"],["flemish","nl"],["haitian","ht"],["letzeburgesch","lb"],["pushto","ps"],["panjabi","pa"],["moldavian","ro"],["moldovan","ro"],["sinhalese","si"],["castilian","es"]]);function i(e){e=e.toLowerCase();let t=o.get(e);if(void 0===t){const r=e.match(/^<\|([a-z]{2})\|>$/);if(r&&(e=r[1]),!a.has(e)){const t=2===e.length?a.keys():a.values();throw new Error(`Language "${e}" is not supported. Must be one of: ${JSON.stringify(Array.from(t))}`)}t=e}return t}},"./src/models/whisper/feature_extraction_whisper.js":
/*!**********************************************************!*\
  !*** ./src/models/whisper/feature_extraction_whisper.js ***!
  \**********************************************************/(e,t,r)=>{r.r(t),r.d(t,{WhisperFeatureExtractor:()=>i});var n=r(/*! ../../base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js");r(/*! ../../utils/tensor.js */"./src/utils/tensor.js");var a=r(/*! ../../utils/audio.js */"./src/utils/audio.js"),o=r(/*! ../../utils/maths.js */"./src/utils/maths.js");class i extends n.FeatureExtractor{constructor(e){super(e),this.config.mel_filters??=(0,a.mel_filter_bank)(Math.floor(1+this.config.n_fft/2),this.config.feature_size,0,8e3,this.config.sampling_rate,"slaney","slaney"),this.window=(0,a.window_function)(this.config.n_fft,"hann")}async _extract_fbank_features(e){const t=await(0,a.spectrogram)(e,this.window,this.config.n_fft,this.config.hop_length,{power:2,mel_filters:this.config.mel_filters,log_mel:"log10",max_num_frames:Math.min(Math.floor(e.length/this.config.hop_length),this.config.nb_max_frames)}),r=t.data,n=(0,o.max)(r)[0];for(let e=0;e<r.length;++e)r[e]=(Math.max(r[e],n-8)+4)/4;return t}async _call(e,{max_length:t=null}={}){let r;(0,n.validate_audio_inputs)(e,"WhisperFeatureExtractor");const a=t??this.config.n_samples;e.length>a?(e.length>this.config.n_samples&&console.warn("Attempting to extract features for audio longer than 30 seconds. If using a pipeline to extract transcript from a long audio clip, remember to specify `chunk_length_s` and/or `stride_length_s`."),r=e.slice(0,a)):(r=new Float32Array(a),r.set(e));return{input_features:(await this._extract_fbank_features(r)).unsqueeze_(0)}}}},"./src/models/whisper/generation_whisper.js":
/*!**************************************************!*\
  !*** ./src/models/whisper/generation_whisper.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{WhisperGenerationConfig:()=>a});var n=r(/*! ../../generation/configuration_utils.js */"./src/generation/configuration_utils.js");class a extends n.GenerationConfig{return_timestamps=null;return_token_timestamps=null;num_frames=null;alignment_heads=null;task=null;language=null;no_timestamps_token_id=null;prompt_ids=null;is_multilingual=null;lang_to_id=null;task_to_id=null;max_initial_timestamp_index=1}},"./src/models/whisper/processing_whisper.js":
/*!**************************************************!*\
  !*** ./src/models/whisper/processing_whisper.js ***!
  \**************************************************/(e,t,r)=>{r.r(t),r.d(t,{WhisperProcessor:()=>i});var n=r(/*! ../auto/feature_extraction_auto.js */"./src/models/auto/feature_extraction_auto.js"),a=r(/*! ../../tokenizers.js */"./src/tokenizers.js"),o=r(/*! ../../base/processing_utils.js */"./src/base/processing_utils.js");class i extends o.Processor{static tokenizer_class=a.AutoTokenizer;static feature_extractor_class=n.AutoFeatureExtractor;async _call(e){return await this.feature_extractor(e)}}},"./src/models/yolos/image_processing_yolos.js":
/*!****************************************************!*\
  !*** ./src/models/yolos/image_processing_yolos.js ***!
  \****************************************************/(e,t,r)=>{r.r(t),r.d(t,{YolosFeatureExtractor:()=>o,YolosImageProcessor:()=>a});var n=r(/*! ../../base/image_processors_utils.js */"./src/base/image_processors_utils.js");class a extends n.ImageProcessor{post_process_object_detection(...e){return(0,n.post_process_object_detection)(...e)}}class o extends a{}},"./src/ops/registry.js":
/*!*****************************!*\
  !*** ./src/ops/registry.js ***!
  \*****************************/(e,t,r)=>{r.r(t),r.d(t,{TensorOpRegistry:()=>l});var n=r(/*! ../backends/onnx.js */"./src/backends/onnx.js"),a=r(/*! ../utils/tensor.js */"./src/utils/tensor.js"),o=r(/*! ../env.js */"./src/env.js");const i=o.apis.IS_BROWSER_ENV||o.apis.IS_WEBWORKER_ENV,s=async(e,t,r)=>{const o=await(0,n.createInferenceSession)(new Uint8Array(e),t);let s=Promise.resolve();return async e=>{const t=(0,n.isONNXProxy)(),l=Object.fromEntries(Object.entries(e).map((([e,r])=>[e,(t?r.clone():r).ort_tensor]))),d=await(s=i?s.then((()=>o.run(l))):o.run(l));return Array.isArray(r)?r.map((e=>new a.Tensor(d[e]))):new a.Tensor(d[r])}};class l{static session_options={};static get nearest_interpolate_4d(){return this._nearest_interpolate_4d||(this._nearest_interpolate_4d=s([8,10,18,0,58,129,1,10,41,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,18,10,4,109,111,100,101,34,7,110,101,97,114,101,115,116,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,21],this.session_options,"y")),this._nearest_interpolate_4d}static get bilinear_interpolate_4d(){return this._bilinear_interpolate_4d||(this._bilinear_interpolate_4d=s([8,9,18,0,58,128,1,10,40,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,17,10,4,109,111,100,101,34,6,108,105,110,101,97,114,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bilinear_interpolate_4d}static get bicubic_interpolate_4d(){return this._bicubic_interpolate_4d||(this._bicubic_interpolate_4d=s([8,9,18,0,58,127,10,39,10,1,120,10,0,10,0,10,1,115,18,1,121,34,6,82,101,115,105,122,101,42,16,10,4,109,111,100,101,34,5,99,117,98,105,99,160,1,3,18,1,114,90,31,10,1,120,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,90,15,10,1,115,18,10,10,8,8,7,18,4,10,2,8,4,98,31,10,1,121,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,99,10,3,18,1,104,10,3,18,1,119,66,2,16,20],this.session_options,"y")),this._bicubic_interpolate_4d}static get matmul(){return this._matmul||(this._matmul=s([8,9,18,0,58,55,10,17,10,1,97,10,1,98,18,1,99,34,6,77,97,116,77,117,108,18,1,114,90,9,10,1,97,18,4,10,2,8,1,90,9,10,1,98,18,4,10,2,8,1,98,9,10,1,99,18,4,10,2,8,1,66,2,16,20],this.session_options,"c")),this._matmul}static get stft(){return this._stft||(this._stft=s([8,7,18,0,58,148,1,10,38,10,1,115,10,1,106,10,1,119,10,1,108,18,1,111,34,4,83,84,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,115,90,26,10,1,115,18,21,10,19,8,1,18,15,10,3,18,1,98,10,3,18,1,115,10,3,18,1,99,90,11,10,1,106,18,6,10,4,8,7,18,0,90,16,10,1,119,18,11,10,9,8,1,18,5,10,3,18,1,119,90,11,10,1,108,18,6,10,4,8,7,18,0,98,31,10,1,111,18,26,10,24,8,1,18,20,10,3,18,1,98,10,3,18,1,102,10,3,18,1,100,10,3,18,1,99,66,2,16,17],this.session_options,"o")),this._stft}static get rfft(){return this._rfft||(this._rfft=s([8,9,18,0,58,97,10,33,10,1,120,10,0,10,1,97,18,1,121,34,3,68,70,84,42,15,10,8,111,110,101,115,105,100,101,100,24,1,160,1,2,18,1,100,90,21,10,1,120,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,90,11,10,1,97,18,6,10,4,8,7,18,0,98,21,10,1,121,18,16,10,14,8,1,18,10,10,3,18,1,115,10,3,18,1,99,66,2,16,20],this.session_options,"y")),this._rfft}static get top_k(){return this._top_k||(this._top_k=s([8,10,18,0,58,73,10,18,10,1,120,10,1,107,18,1,118,18,1,105,34,4,84,111,112,75,18,1,116,90,9,10,1,120,18,4,10,2,8,1,90,15,10,1,107,18,10,10,8,8,7,18,4,10,2,8,1,98,9,10,1,118,18,4,10,2,8,1,98,9,10,1,105,18,4,10,2,8,7,66,2,16,21],this.session_options,["v","i"])),this._top_k}static get slice(){return this._slice||(this._slice=s([8,7,18,0,58,96,10,25,10,1,120,10,1,115,10,1,101,10,1,97,10,1,116,18,1,121,34,5,83,108,105,99,101,18,1,114,90,9,10,1,120,18,4,10,2,8,1,90,9,10,1,115,18,4,10,2,8,7,90,9,10,1,101,18,4,10,2,8,7,90,9,10,1,97,18,4,10,2,8,7,90,9,10,1,116,18,4,10,2,8,7,98,9,10,1,121,18,4,10,2,8,1,66,2,16,13],this.session_options,"y")),this._slice}}},"./src/pipelines.js":
/*!**************************!*\
  !*** ./src/pipelines.js ***!
  \**************************/(e,t,r)=>{r.r(t),r.d(t,{AudioClassificationPipeline:()=>v,AutomaticSpeechRecognitionPipeline:()=>G,BackgroundRemovalPipeline:()=>T,DepthEstimationPipeline:()=>Y,DocumentQuestionAnsweringPipeline:()=>k,FeatureExtractionPipeline:()=>_,FillMaskPipeline:()=>w,ImageClassificationPipeline:()=>x,ImageFeatureExtractionPipeline:()=>y,ImageSegmentationPipeline:()=>S,ImageToImagePipeline:()=>H,ImageToTextPipeline:()=>R,ObjectDetectionPipeline:()=>X,Pipeline:()=>h,QuestionAnsweringPipeline:()=>C,SummarizationPipeline:()=>K,Text2TextGenerationPipeline:()=>b,TextClassificationPipeline:()=>B,TextGenerationPipeline:()=>W,TextToAudioPipeline:()=>M,TokenClassificationPipeline:()=>m,TranslationPipeline:()=>f,ZeroShotAudioClassificationPipeline:()=>E,ZeroShotClassificationPipeline:()=>F,ZeroShotImageClassificationPipeline:()=>Z,ZeroShotObjectDetectionPipeline:()=>V,pipeline:()=>I});var n=r(/*! ./tokenizers.js */"./src/tokenizers.js"),a=r(/*! ./models.js */"./src/models.js"),o=r(/*! ./models/auto/processing_auto.js */"./src/models/auto/processing_auto.js");r(/*! ./base/processing_utils.js */"./src/base/processing_utils.js");var i=r(/*! ./utils/generic.js */"./src/utils/generic.js"),s=r(/*! ./utils/core.js */"./src/utils/core.js"),l=r(/*! ./utils/maths.js */"./src/utils/maths.js"),d=r(/*! ./utils/audio.js */"./src/utils/audio.js"),u=r(/*! ./utils/tensor.js */"./src/utils/tensor.js"),c=r(/*! ./utils/image.js */"./src/utils/image.js");async function p(e){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>c.RawImage.read(e))))}async function g(e,t){return Array.isArray(e)||(e=[e]),await Promise.all(e.map((e=>"string"==typeof e||e instanceof URL?(0,d.read_audio)(e,t):e instanceof Float64Array?new Float32Array(e):e)))}function A(e,t){t&&(e=e.map((e=>0|e)));const[r,n,a,o]=e;return{xmin:r,ymin:n,xmax:a,ymax:o}}class h extends i.Callable{constructor({task:e,model:t,tokenizer:r=null,processor:n=null}){super(),this.task=e,this.model=t,this.tokenizer=r,this.processor=n}async dispose(){await this.model.dispose()}}class B extends h{constructor(e){super(e)}async _call(e,{top_k:t=1}={}){const r=this.tokenizer(e,{padding:!0,truncation:!0}),n=await this.model(r),a="multi_label_classification"===this.model.config.problem_type?e=>e.sigmoid():e=>new u.Tensor("float32",(0,l.softmax)(e.data),e.dims),o=this.model.config.id2label,i=[];for(const e of n.logits){const r=a(e),n=await(0,u.topk)(r,t),s=n[0].tolist(),l=n[1].tolist().map(((e,t)=>({label:o?o[e]:`LABEL_${e}`,score:s[t]})));1===t?i.push(...l):i.push(l)}return Array.isArray(e)||1===t?i:i[0]}}class m extends h{constructor(e){super(e)}async _call(e,{ignore_labels:t=["O"]}={}){const r=Array.isArray(e),n=this.tokenizer(r?e:[e],{padding:!0,truncation:!0}),a=(await this.model(n)).logits,o=this.model.config.id2label,i=[];for(let e=0;e<a.dims[0];++e){const r=n.input_ids[e],s=a[e],d=[];for(let e=0;e<s.dims[0];++e){const n=s[e],a=(0,l.max)(n.data)[1],i=o?o[a]:`LABEL_${a}`;if(t.includes(i))continue;const u=this.tokenizer.decode([r[e].item()],{skip_special_tokens:!0});if(""===u)continue;const c=(0,l.softmax)(n.data);d.push({entity:i,score:c[a],index:e,word:u})}i.push(d)}return r?i:i[0]}}class C extends h{constructor(e){super(e)}async _call(e,t,{top_k:r=1}={}){const n=this.tokenizer(e,{text_pair:t,padding:!0,truncation:!0}),{start_logits:a,end_logits:o}=await this.model(n),i=n.input_ids.tolist(),d=n.attention_mask.tolist(),u=this.tokenizer.all_special_ids,c=[];for(let e=0;e<a.dims[0];++e){const t=i[e],n=t.findIndex((e=>e==this.tokenizer.sep_token_id));d[e].map(((e,r)=>1==e&&(0===r||r>n&&-1===u.findIndex((e=>e==t[r])))));const p=a[e].tolist(),g=o[e].tolist();for(let r=1;r<p.length;++r)(0==d[e]||r<=n||-1!==u.findIndex((e=>e==t[r])))&&(p[r]=-1/0,g[r]=-1/0);const A=(0,l.softmax)(p).map(((e,t)=>[e,t])),h=(0,l.softmax)(g).map(((e,t)=>[e,t]));A[0][0]=0,h[0][0]=0;const B=(0,s.product)(A,h).filter((e=>e[0][1]<=e[1][1])).map((e=>[e[0][1],e[1][1],e[0][0]*e[1][0]])).sort(((e,t)=>t[2]-e[2]));for(let e=0;e<Math.min(B.length,r);++e){const[r,n,a]=B[e],o=t.slice(r,n+1),i=this.tokenizer.decode(o,{skip_special_tokens:!0});c.push({answer:i,score:a})}}return 1===r?c[0]:c}}class w extends h{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const r=this.tokenizer(e,{padding:!0,truncation:!0}),{logits:n}=await this.model(r),a=[],o=r.input_ids.tolist();for(let e=0;e<o.length;++e){const r=o[e],i=r.findIndex((e=>e==this.tokenizer.mask_token_id));if(-1===i)throw Error(`Mask token (${this.tokenizer.mask_token}) not found in text.`);const s=n[e][i],d=await(0,u.topk)(new u.Tensor("float32",(0,l.softmax)(s.data),s.dims),t),c=d[0].tolist(),p=d[1].tolist();a.push(p.map(((e,t)=>{const n=r.slice();return n[i]=e,{score:c[t],token:Number(e),token_str:this.tokenizer.decode([e]),sequence:this.tokenizer.decode(n,{skip_special_tokens:!0})}})))}return Array.isArray(e)?a:a[0]}}class b extends h{_key="generated_text";constructor(e){super(e)}async _call(e,t={}){Array.isArray(e)||(e=[e]),this.model.config.prefix&&(e=e.map((e=>this.model.config.prefix+e)));const r=this.model.config.task_specific_params;r&&r[this.task]&&r[this.task].prefix&&(e=e.map((e=>r[this.task].prefix+e)));const n=this.tokenizer,a={padding:!0,truncation:!0};let o;o=this instanceof f&&"_build_translation_inputs"in n?n._build_translation_inputs(e,a,t):n(e,a);const i=await this.model.generate({...o,...t});return n.batch_decode(i,{skip_special_tokens:!0}).map((e=>({[this._key]:e})))}}class K extends b{_key="summary_text";constructor(e){super(e)}}class f extends b{_key="translation_text";constructor(e){super(e)}}function Q(e){return Array.isArray(e)&&e.every((e=>"role"in e&&"content"in e))}class W extends h{constructor(e){super(e)}async _call(e,t={}){let r,n=!1,a=!1;if("string"==typeof e)r=e=[e];else if(Array.isArray(e)&&e.every((e=>"string"==typeof e)))n=!0,r=e;else{if(Q(e))e=[e];else{if(!Array.isArray(e)||!e.every(Q))throw new Error("Input must be a string, an array of strings, a Chat, or an array of Chats");n=!0}a=!0,r=e.map((e=>this.tokenizer.apply_chat_template(e,{tokenize:!1,add_generation_prompt:!0})))}const o=t.add_special_tokens??!1,i=!a&&(t.return_full_text??!0);this.tokenizer.padding_side="left";const s=this.tokenizer(r,{add_special_tokens:o,padding:!0,truncation:!0}),l=await this.model.generate({...s,...t}),d=this.tokenizer.batch_decode(l,{skip_special_tokens:!0});let u;!i&&s.input_ids.dims.at(-1)>0&&(u=this.tokenizer.batch_decode(s.input_ids,{skip_special_tokens:!0}).map((e=>e.length)));const c=Array.from({length:e.length},(e=>[]));for(let t=0;t<d.length;++t){const r=Math.floor(t/l.dims[0]*e.length);u&&(d[t]=d[t].slice(u[r])),c[r].push({generated_text:a?[...e[r],{role:"assistant",content:d[t]}]:d[t]})}return n||1!==c.length?c:c[0]}}class F extends h{constructor(e){super(e),this.label2id=Object.fromEntries(Object.entries(this.model.config.label2id).map((([e,t])=>[e.toLowerCase(),t]))),this.entailment_id=this.label2id.entailment,void 0===this.entailment_id&&(console.warn("Could not find 'entailment' in label2id mapping. Using 2 as entailment_id."),this.entailment_id=2),this.contradiction_id=this.label2id.contradiction??this.label2id.not_entailment,void 0===this.contradiction_id&&(console.warn("Could not find 'contradiction' in label2id mapping. Using 0 as contradiction_id."),this.contradiction_id=0)}async _call(e,t,{hypothesis_template:r="This example is {}.",multi_label:n=!1}={}){const a=Array.isArray(e);a||(e=[e]),Array.isArray(t)||(t=[t]);const o=t.map((e=>r.replace("{}",e))),i=n||1===t.length,s=[];for(const r of e){const e=[];for(const t of o){const n=this.tokenizer(r,{text_pair:t,padding:!0,truncation:!0}),a=await this.model(n);i?e.push([a.logits.data[this.contradiction_id],a.logits.data[this.entailment_id]]):e.push(a.logits.data[this.entailment_id])}const n=(i?e.map((e=>(0,l.softmax)(e)[1])):(0,l.softmax)(e)).map(((e,t)=>[e,t])).sort(((e,t)=>t[0]-e[0]));s.push({sequence:r,labels:n.map((e=>t[e[1]])),scores:n.map((e=>e[0]))})}return a?s:s[0]}}class _ extends h{constructor(e){super(e)}async _call(e,{pooling:t="none",normalize:r=!1,quantize:n=!1,precision:a="binary"}={}){const o=this.tokenizer(e,{padding:!0,truncation:!0}),i=await this.model(o);let s=i.last_hidden_state??i.logits??i.token_embeddings;if("none"===t);else if("mean"===t)s=(0,u.mean_pooling)(s,o.attention_mask);else{if("cls"!==t)throw Error(`Pooling method '${t}' not supported.`);s=s.slice(null,0)}return r&&(s=s.normalize(2,-1)),n&&(s=(0,u.quantize_embeddings)(s,a)),s}}class y extends h{constructor(e){super(e)}async _call(e,{pool:t=null}={}){const r=await p(e),{pixel_values:n}=await this.processor(r),a=await this.model({pixel_values:n});let o;if(t){if(!("pooler_output"in a))throw Error("No pooled output was returned. Make sure the model has a 'pooler' layer when using the 'pool' option.");o=a.pooler_output}else o=a.last_hidden_state??a.logits??a.image_embeds;return o}}class v extends h{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const r=this.processor.feature_extractor.config.sampling_rate,n=await g(e,r),a=this.model.config.id2label,o=[];for(const e of n){const r=await this.processor(e),n=(await this.model(r)).logits[0],i=await(0,u.topk)(new u.Tensor("float32",(0,l.softmax)(n.data),n.dims),t),s=i[0].tolist(),d=i[1].tolist().map(((e,t)=>({label:a?a[e]:`LABEL_${e}`,score:s[t]})));o.push(d)}return Array.isArray(e)?o:o[0]}}class E extends h{constructor(e){super(e)}async _call(e,t,{hypothesis_template:r="This is a sound of {}."}={}){const n=!Array.isArray(e);n&&(e=[e]);const a=t.map((e=>r.replace("{}",e))),o=this.tokenizer(a,{padding:!0,truncation:!0}),i=this.processor.feature_extractor.config.sampling_rate,s=await g(e,i),d=[];for(const e of s){const r=await this.processor(e),n=await this.model({...o,...r}),a=(0,l.softmax)(n.logits_per_audio.data);d.push([...a].map(((e,r)=>({score:e,label:t[r]}))))}return n?d[0]:d}}class G extends h{constructor(e){super(e)}async _call(e,t={}){switch(this.model.config.model_type){case"whisper":case"lite-whisper":return this._call_whisper(e,t);case"wav2vec2":case"wav2vec2-bert":case"unispeech":case"unispeech-sat":case"hubert":return this._call_wav2vec2(e,t);case"moonshine":return this._call_moonshine(e,t);default:throw new Error(`AutomaticSpeechRecognitionPipeline does not support model type '${this.model.config.model_type}'.`)}}async _call_wav2vec2(e,t){t.language&&console.warn('`language` parameter is not yet supported for `wav2vec2` models, defaulting to "English".'),t.task&&console.warn('`task` parameter is not yet supported for `wav2vec2` models, defaulting to "transcribe".');const r=!Array.isArray(e);r&&(e=[e]);const n=this.processor.feature_extractor.config.sampling_rate,a=await g(e,n),o=[];for(const e of a){const t=await this.processor(e),r=(await this.model(t)).logits[0],n=[];for(const e of r)n.push((0,l.max)(e.data)[1]);const a=this.tokenizer.decode(n);o.push({text:a})}return r?o[0]:o}async _call_whisper(e,t){const r=t.return_timestamps??!1,n=t.chunk_length_s??0,a=t.force_full_sequences??!1;let o=t.stride_length_s??null;const i={...t};"word"===r&&(i.return_token_timestamps=!0,i.return_timestamps=!1);const s=!Array.isArray(e);s&&(e=[e]);const d=this.processor.feature_extractor.config.chunk_length/this.model.config.max_source_positions,u=this.processor.feature_extractor.config.hop_length,c=this.processor.feature_extractor.config.sampling_rate,p=await g(e,c),A=[];for(const e of p){let t=[];if(n>0){if(null===o)o=n/6;else if(n<=o)throw Error("`chunk_length_s` must be larger than `stride_length_s`.");const r=c*n,a=c*o,i=r-2*a;let s=0;for(;;){const n=s+r,o=e.subarray(s,n),l=await this.processor(o),d=0===s,u=n>=e.length;if(t.push({stride:[o.length,d?0:a,u?0:a],input_features:l.input_features,is_last:u}),u)break;s+=i}}else t=[{stride:[e.length,0,0],input_features:(await this.processor(e)).input_features,is_last:!0}];for(const e of t){i.num_frames=Math.floor(e.stride[0]/u);const t=await this.model.generate({inputs:e.input_features,...i});"word"===r?(e.tokens=t.sequences.tolist()[0],e.token_timestamps=t.token_timestamps.tolist()[0].map((e=>(0,l.round)(e,2)))):e.tokens=t[0].tolist(),e.stride=e.stride.map((e=>e/c))}const[s,p]=this.tokenizer._decode_asr(t,{time_precision:d,return_timestamps:r,force_full_sequences:a});A.push({text:s,...p})}return s?A[0]:A}async _call_moonshine(e,t){const r=!Array.isArray(e);r&&(e=[e]);const n=this.processor.feature_extractor.config.sampling_rate,a=await g(e,n),o=[];for(const e of a){const r=await this.processor(e),a=6*Math.floor(e.length/n),i=await this.model.generate({max_new_tokens:a,...t,...r}),s=this.processor.batch_decode(i,{skip_special_tokens:!0})[0];o.push({text:s})}return r?o[0]:o}}class R extends h{constructor(e){super(e)}async _call(e,t={}){const r=Array.isArray(e),n=await p(e),{pixel_values:a}=await this.processor(n),o=[];for(const e of a){e.dims=[1,...e.dims];const r=await this.model.generate({inputs:e,...t}),n=this.tokenizer.batch_decode(r,{skip_special_tokens:!0}).map((e=>({generated_text:e.trim()})));o.push(n)}return r?o:o[0]}}class x extends h{constructor(e){super(e)}async _call(e,{top_k:t=5}={}){const r=await p(e),{pixel_values:n}=await this.processor(r),a=await this.model({pixel_values:n}),o=this.model.config.id2label,i=[];for(const e of a.logits){const r=await(0,u.topk)(new u.Tensor("float32",(0,l.softmax)(e.data),e.dims),t),n=r[0].tolist(),a=r[1].tolist().map(((e,t)=>({label:o?o[e]:`LABEL_${e}`,score:n[t]})));i.push(a)}return Array.isArray(e)?i:i[0]}}class S extends h{constructor(e){super(e),this.subtasks_mapping={panoptic:"post_process_panoptic_segmentation",instance:"post_process_instance_segmentation",semantic:"post_process_semantic_segmentation"}}async _call(e,{threshold:t=.5,mask_threshold:r=.5,overlap_mask_area_threshold:n=.8,label_ids_to_fuse:a=null,target_sizes:o=null,subtask:i=null}={}){if(Array.isArray(e)&&1!==e.length)throw Error("Image segmentation pipeline currently only supports a batch size of 1.");const s=await p(e),l=s.map((e=>[e.height,e.width])),d=await this.processor(s),{inputNames:u,outputNames:g}=this.model.sessions.model;if(!u.includes("pixel_values")){if(1!==u.length)throw Error(`Expected a single input name, but got ${u.length} inputs: ${u}.`);const e=u[0];if(e in d)throw Error(`Input name ${e} already exists in the inputs.`);d[e]=d.pixel_values}const A=await this.model(d);let h=null;if(null!==i)h=this.subtasks_mapping[i];else if(this.processor.image_processor)for(const[e,t]of Object.entries(this.subtasks_mapping))if(t in this.processor.image_processor){h=this.processor.image_processor[t].bind(this.processor.image_processor),i=e;break}const B=this.model.config.id2label,m=[];if(i)if("panoptic"===i||"instance"===i){const e=h(A,t,r,n,a,o??l)[0],i=e.segmentation;for(const t of e.segments_info){const e=new Uint8ClampedArray(i.data.length);for(let r=0;r<i.data.length;++r)i.data[r]===t.id&&(e[r]=255);const r=new c.RawImage(e,i.dims[1],i.dims[0],1);m.push({score:t.score,label:B[t.label_id],mask:r})}}else{if("semantic"!==i)throw Error(`Subtask ${i} not supported.`);{const{segmentation:e,labels:t}=h(A,o??l)[0];for(const r of t){const t=new Uint8ClampedArray(e.data.length);for(let n=0;n<e.data.length;++n)e.data[n]===r&&(t[n]=255);const n=new c.RawImage(t,e.dims[1],e.dims[0],1);m.push({score:null,label:B[r],mask:n})}}}else{const e=A[g[0]];for(let t=0;t<l.length;++t){const r=l[t],n=e[t];n.data.some((e=>e<0||e>1))&&n.sigmoid_();const a=await c.RawImage.fromTensor(n.mul_(255).to("uint8")).resize(r[1],r[0]);m.push({label:null,score:null,mask:a})}}return m}}class T extends S{constructor(e){super(e)}async _call(e,t={}){if(Array.isArray(e)&&1!==e.length)throw Error("Background removal pipeline currently only supports a batch size of 1.");const r=await p(e),n=await super._call(e,t);return r.map(((e,t)=>{const r=e.clone();return r.putAlpha(n[t].mask),r}))}}class Z extends h{constructor(e){super(e)}async _call(e,t,{hypothesis_template:r="This is a photo of {}"}={}){const n=Array.isArray(e),a=await p(e),o=t.map((e=>r.replace("{}",e))),i=this.tokenizer(o,{padding:"siglip"!==this.model.config.model_type||"max_length",truncation:!0}),{pixel_values:s}=await this.processor(a),d=await this.model({...i,pixel_values:s}),u="siglip"===this.model.config.model_type?e=>e.sigmoid().data:e=>(0,l.softmax)(e.data),c=[];for(const e of d.logits_per_image){const r=[...u(e)].map(((e,r)=>({score:e,label:t[r]})));r.sort(((e,t)=>t.score-e.score)),c.push(r)}return n?c:c[0]}}class X extends h{constructor(e){super(e)}async _call(e,{threshold:t=.9,percentage:r=!1}={}){const n=Array.isArray(e);if(n&&1!==e.length)throw Error("Object detection pipeline currently only supports a batch size of 1.");const a=await p(e),o=r?null:a.map((e=>[e.height,e.width])),{pixel_values:i,pixel_mask:s}=await this.processor(a),l=await this.model({pixel_values:i,pixel_mask:s}),d=this.processor.image_processor.post_process_object_detection(l,t,o),u=this.model.config.id2label,c=d.map((e=>e.boxes.map(((t,n)=>({score:e.scores[n],label:u[e.classes[n]],box:A(t,!r)})))));return n?c:c[0]}}class V extends h{constructor(e){super(e)}async _call(e,t,{threshold:r=.1,top_k:n=null,percentage:a=!1}={}){const o=Array.isArray(e),i=await p(e),s=this.tokenizer(t,{padding:!0,truncation:!0}),l=await this.processor(i),d=[];for(let e=0;e<i.length;++e){const o=i[e],u=a?null:[[o.height,o.width]],c=l.pixel_values[e].unsqueeze_(0),p=await this.model({...s,pixel_values:c});let g;if("post_process_grounded_object_detection"in this.processor){const e=this.processor.post_process_grounded_object_detection(p,s.input_ids,{box_threshold:r,text_threshold:r,target_sizes:u})[0];g=e.boxes.map(((t,r)=>({score:e.scores[r],label:e.labels[r],box:A(t,!a)})))}else{const e=this.processor.image_processor.post_process_object_detection(p,r,u,!0)[0];g=e.boxes.map(((r,n)=>({score:e.scores[n],label:t[e.classes[n]],box:A(r,!a)})))}g.sort(((e,t)=>t.score-e.score)),null!==n&&(g=g.slice(0,n)),d.push(g)}return o?d:d[0]}}class k extends h{constructor(e){super(e)}async _call(e,t,r={}){const n=(await p(e))[0],{pixel_values:a}=await this.processor(n),o=`<s_docvqa><s_question>${t}</s_question><s_answer>`,i=this.tokenizer(o,{add_special_tokens:!1,padding:!0,truncation:!0}).input_ids,s=await this.model.generate({inputs:a,max_length:this.model.config.decoder.max_position_embeddings,decoder_input_ids:i,...r}),l=this.tokenizer.batch_decode(s)[0].match(/<s_answer>(.*?)<\/s_answer>/);let d=null;return l&&l.length>=2&&(d=l[1].trim()),[{answer:d}]}}class M extends h{DEFAULT_VOCODER_ID="Xenova/speecht5_hifigan";constructor(e){super(e),this.vocoder=e.vocoder??null}async _call(e,{speaker_embeddings:t=null}={}){return this.processor?this._call_text_to_spectrogram(e,{speaker_embeddings:t}):this._call_text_to_waveform(e)}async _call_text_to_waveform(e){const t=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:r}=await this.model(t),n=this.model.config.sampling_rate;return new d.RawAudio(r.data,n)}async _call_text_to_spectrogram(e,{speaker_embeddings:t}){if(this.vocoder||(console.log("No vocoder specified, using default HifiGan vocoder."),this.vocoder=await a.AutoModel.from_pretrained(this.DEFAULT_VOCODER_ID,{dtype:"fp32"})),("string"==typeof t||t instanceof URL)&&(t=new Float32Array(await(await fetch(t)).arrayBuffer())),t instanceof Float32Array)t=new u.Tensor("float32",t,[1,t.length]);else if(!(t instanceof u.Tensor))throw new Error("Speaker embeddings must be a `Tensor`, `Float32Array`, `string`, or `URL`.");const{input_ids:r}=this.tokenizer(e,{padding:!0,truncation:!0}),{waveform:n}=await this.model.generate_speech(r,t,{vocoder:this.vocoder}),o=this.processor.feature_extractor.config.sampling_rate;return new d.RawAudio(n.data,o)}}class H extends h{constructor(e){super(e)}async _call(e){const t=await p(e),r=await this.processor(t),n=await this.model(r),a=[];for(const e of n.reconstruction){const t=e.squeeze().clamp_(0,1).mul_(255).round_().to("uint8");a.push(c.RawImage.fromTensor(t))}return a.length>1?a:a[0]}}class Y extends h{constructor(e){super(e)}async _call(e){const t=await p(e),r=await this.processor(t),{predicted_depth:n}=await this.model(r),a=[];for(let e=0;e<t.length;++e){const r=n[e],[o,i]=r.dims.slice(-2),[s,l]=t[e].size,d=(await(0,u.interpolate_4d)(r.view(1,1,o,i),{size:[l,s],mode:"bilinear"})).view(l,s),p=d.min().item(),g=d.max().item(),A=d.sub(p).div_(g-p).mul_(255).to("uint8").unsqueeze(0),h=c.RawImage.fromTensor(A);a.push({predicted_depth:d,depth:h})}return a.length>1?a:a[0]}}const L=Object.freeze({"text-classification":{tokenizer:n.AutoTokenizer,pipeline:B,model:a.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-finetuned-sst-2-english"},type:"text"},"token-classification":{tokenizer:n.AutoTokenizer,pipeline:m,model:a.AutoModelForTokenClassification,default:{model:"Xenova/bert-base-multilingual-cased-ner-hrl"},type:"text"},"question-answering":{tokenizer:n.AutoTokenizer,pipeline:C,model:a.AutoModelForQuestionAnswering,default:{model:"Xenova/distilbert-base-cased-distilled-squad"},type:"text"},"fill-mask":{tokenizer:n.AutoTokenizer,pipeline:w,model:a.AutoModelForMaskedLM,default:{model:"Xenova/bert-base-uncased"},type:"text"},summarization:{tokenizer:n.AutoTokenizer,pipeline:K,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/distilbart-cnn-6-6"},type:"text"},translation:{tokenizer:n.AutoTokenizer,pipeline:f,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/t5-small"},type:"text"},"text2text-generation":{tokenizer:n.AutoTokenizer,pipeline:b,model:a.AutoModelForSeq2SeqLM,default:{model:"Xenova/flan-t5-small"},type:"text"},"text-generation":{tokenizer:n.AutoTokenizer,pipeline:W,model:a.AutoModelForCausalLM,default:{model:"Xenova/gpt2"},type:"text"},"zero-shot-classification":{tokenizer:n.AutoTokenizer,pipeline:F,model:a.AutoModelForSequenceClassification,default:{model:"Xenova/distilbert-base-uncased-mnli"},type:"text"},"audio-classification":{pipeline:v,model:a.AutoModelForAudioClassification,processor:o.AutoProcessor,default:{model:"Xenova/wav2vec2-base-superb-ks"},type:"audio"},"zero-shot-audio-classification":{tokenizer:n.AutoTokenizer,pipeline:E,model:a.AutoModel,processor:o.AutoProcessor,default:{model:"Xenova/clap-htsat-unfused"},type:"multimodal"},"automatic-speech-recognition":{tokenizer:n.AutoTokenizer,pipeline:G,model:[a.AutoModelForSpeechSeq2Seq,a.AutoModelForCTC],processor:o.AutoProcessor,default:{model:"Xenova/whisper-tiny.en"},type:"multimodal"},"text-to-audio":{tokenizer:n.AutoTokenizer,pipeline:M,model:[a.AutoModelForTextToWaveform,a.AutoModelForTextToSpectrogram],processor:[o.AutoProcessor,null],default:{model:"Xenova/speecht5_tts"},type:"text"},"image-to-text":{tokenizer:n.AutoTokenizer,pipeline:R,model:a.AutoModelForVision2Seq,processor:o.AutoProcessor,default:{model:"Xenova/vit-gpt2-image-captioning"},type:"multimodal"},"image-classification":{pipeline:x,model:a.AutoModelForImageClassification,processor:o.AutoProcessor,default:{model:"Xenova/vit-base-patch16-224"},type:"multimodal"},"image-segmentation":{pipeline:S,model:[a.AutoModelForImageSegmentation,a.AutoModelForSemanticSegmentation,a.AutoModelForUniversalSegmentation],processor:o.AutoProcessor,default:{model:"Xenova/detr-resnet-50-panoptic"},type:"multimodal"},"background-removal":{pipeline:T,model:[a.AutoModelForImageSegmentation,a.AutoModelForSemanticSegmentation,a.AutoModelForUniversalSegmentation],processor:o.AutoProcessor,default:{model:"Xenova/modnet"},type:"image"},"zero-shot-image-classification":{tokenizer:n.AutoTokenizer,pipeline:Z,model:a.AutoModel,processor:o.AutoProcessor,default:{model:"Xenova/clip-vit-base-patch32"},type:"multimodal"},"object-detection":{pipeline:X,model:a.AutoModelForObjectDetection,processor:o.AutoProcessor,default:{model:"Xenova/detr-resnet-50"},type:"multimodal"},"zero-shot-object-detection":{tokenizer:n.AutoTokenizer,pipeline:V,model:a.AutoModelForZeroShotObjectDetection,processor:o.AutoProcessor,default:{model:"Xenova/owlvit-base-patch32"},type:"multimodal"},"document-question-answering":{tokenizer:n.AutoTokenizer,pipeline:k,model:a.AutoModelForDocumentQuestionAnswering,processor:o.AutoProcessor,default:{model:"Xenova/donut-base-finetuned-docvqa"},type:"multimodal"},"image-to-image":{pipeline:H,model:a.AutoModelForImageToImage,processor:o.AutoProcessor,default:{model:"Xenova/swin2SR-classical-sr-x2-64"},type:"image"},"depth-estimation":{pipeline:Y,model:a.AutoModelForDepthEstimation,processor:o.AutoProcessor,default:{model:"Xenova/dpt-large"},type:"image"},"feature-extraction":{tokenizer:n.AutoTokenizer,pipeline:_,model:a.AutoModel,default:{model:"Xenova/all-MiniLM-L6-v2"},type:"text"},"image-feature-extraction":{processor:o.AutoProcessor,pipeline:y,model:[a.AutoModelForImageFeatureExtraction,a.AutoModel],default:{model:"Xenova/vit-base-patch16-224-in21k"},type:"image"}}),N=Object.freeze({"sentiment-analysis":"text-classification",ner:"token-classification",asr:"automatic-speech-recognition","text-to-speech":"text-to-audio",embeddings:"feature-extraction"});async function I(e,t=null,{progress_callback:r=null,config:n=null,cache_dir:a=null,local_files_only:o=!1,revision:i="main",device:l=null,dtype:d=null,subfolder:u="onnx",use_external_data_format:c=null,model_file_name:p=null,session_options:g={}}={}){e=N[e]??e;const A=L[e.split("_",1)[0]];if(!A)throw Error(`Unsupported pipeline: ${e}. Must be one of [${Object.keys(L)}]`);t||(t=A.default.model,console.log(`No model specified. Using default model: "${t}".`));const h={progress_callback:r,config:n,cache_dir:a,local_files_only:o,revision:i,device:l,dtype:d,subfolder:u,use_external_data_format:c,model_file_name:p,session_options:g},B=new Map([["tokenizer",A.tokenizer],["model",A.model],["processor",A.processor]]),m=await async function(e,t,r){const n=Object.create(null),a=[];for(const[o,i]of e.entries()){if(!i)continue;let e;e=Array.isArray(i)?new Promise((async(e,n)=>{let a;for(const o of i){if(null===o)return void e(null);try{return void e(await o.from_pretrained(t,r))}catch(e){if(e.message?.includes("Unsupported model type"))a=e;else{if(!e.message?.includes("Could not locate file"))return void n(e);a=e}}}n(a)})):i.from_pretrained(t,r),n[o]=e,a.push(e)}await Promise.all(a);for(const[e,t]of Object.entries(n))n[e]=await t;return n}(B,t,h);m.task=e,(0,s.dispatchCallback)(r,{status:"ready",task:e,model:t});return new(0,A.pipeline)(m)}},"./src/tokenizers.js":
/*!***************************!*\
  !*** ./src/tokenizers.js ***!
  \***************************/(e,t,r)=>{r.r(t),r.d(t,{AlbertTokenizer:()=>We,AutoTokenizer:()=>Bt,BartTokenizer:()=>ke,BertTokenizer:()=>Qe,BlenderbotSmallTokenizer:()=>ut,BlenderbotTokenizer:()=>dt,BloomTokenizer:()=>Le,CLIPTokenizer:()=>ot,CamembertTokenizer:()=>Se,CodeGenTokenizer:()=>at,CodeLlamaTokenizer:()=>Ue,CohereTokenizer:()=>At,ConvBertTokenizer:()=>Ge,DebertaTokenizer:()=>ye,DebertaV2Tokenizer:()=>ve,DistilBertTokenizer:()=>xe,ElectraTokenizer:()=>Ze,EsmTokenizer:()=>ze,FalconTokenizer:()=>Pe,GPT2Tokenizer:()=>Ve,GPTNeoXTokenizer:()=>Oe,GemmaTokenizer:()=>$e,Grok1Tokenizer:()=>qe,HerbertTokenizer:()=>Ee,LlamaTokenizer:()=>Ie,M2M100Tokenizer:()=>rt,MBart50Tokenizer:()=>He,MBartTokenizer:()=>Me,MPNetTokenizer:()=>Je,MarianTokenizer:()=>st,MgpstrTokenizer:()=>ht,MobileBertTokenizer:()=>Fe,NllbTokenizer:()=>tt,NougatTokenizer:()=>pt,PreTrainedTokenizer:()=>fe,Qwen2Tokenizer:()=>je,RoFormerTokenizer:()=>Re,RobertaTokenizer:()=>Ye,SiglipTokenizer:()=>it,SpeechT5Tokenizer:()=>ct,SqueezeBertTokenizer:()=>_e,T5Tokenizer:()=>Xe,TokenizerModel:()=>Q,VitsTokenizer:()=>gt,Wav2Vec2CTCTokenizer:()=>lt,WhisperTokenizer:()=>nt,XLMRobertaTokenizer:()=>De,XLMTokenizer:()=>Te,is_chinese_char:()=>m});var n=r(/*! ./utils/generic.js */"./src/utils/generic.js"),a=r(/*! ./utils/core.js */"./src/utils/core.js"),o=r(/*! ./utils/hub.js */"./src/utils/hub.js"),i=r(/*! ./utils/maths.js */"./src/utils/maths.js"),s=r(/*! ./utils/tensor.js */"./src/utils/tensor.js"),l=r(/*! ./utils/data-structures.js */"./src/utils/data-structures.js"),d=r(/*! @huggingface/jinja */"./node_modules/@huggingface/jinja/dist/index.js"),u=r(/*! ./models/whisper/common_whisper.js */"./src/models/whisper/common_whisper.js");async function c(e,t){const r=await Promise.all([(0,o.getModelJSON)(e,"tokenizer.json",!0,t),(0,o.getModelJSON)(e,"tokenizer_config.json",!0,t)]);return null!==t.legacy&&(r[1].legacy=t.legacy),r}function p(e,t=!0){if(void 0!==e.Regex){let t=e.Regex.replace(/\\([#&~])/g,"$1");for(const[e,r]of K)t=t.replaceAll(e,r);return new RegExp(t,"gu")}if(void 0!==e.String){const r=(0,a.escapeRegExp)(e.String);return new RegExp(t?r:`(${r})`,"gu")}return console.warn("Unknown pattern type:",e),null}function g(e){return new Map(Object.entries(e))}function A(e){const t=e.dims;switch(t.length){case 1:return e.tolist();case 2:if(1!==t[0])throw new Error("Unable to decode tensor with `batch size !== 1`. Use `tokenizer.batch_decode(...)` for batched inputs.");return e.tolist()[0];default:throw new Error(`Expected tensor to have 1-2 dimensions, got ${t.length}.`)}}function h(e){return e.replace(/ \./g,".").replace(/ \?/g,"?").replace(/ \!/g,"!").replace(/ ,/g,",").replace(/ \' /g,"'").replace(/ n\'t/g,"n't").replace(/ \'m/g,"'m").replace(/ \'s/g,"'s").replace(/ \'ve/g,"'ve").replace(/ \'re/g,"'re")}function B(e){return e.replace(/\p{M}/gu,"")}function m(e){return e>=19968&&e<=40959||e>=13312&&e<=19903||e>=131072&&e<=173791||e>=173824&&e<=177983||e>=177984&&e<=178207||e>=178208&&e<=183983||e>=63744&&e<=64255||e>=194560&&e<=195103}const C="\\p{P}\\u0021-\\u002F\\u003A-\\u0040\\u005B-\\u0060\\u007B-\\u007E",w=new RegExp(`^[${C}]+$`,"gu"),b=".,!?…。，、।۔،",K=new Map([["(?i:'s|'t|'re|'ve|'m|'ll|'d)","(?:'([sS]|[tT]|[rR][eE]|[vV][eE]|[mM]|[lL][lL]|[dD]))"],[` ?[^(\\s|[${b}])]+`,` ?[^\\s${b}]+`]]);class f{constructor(e){this.content=e.content,this.id=e.id,this.single_word=e.single_word??!1,this.lstrip=e.lstrip??!1,this.rstrip=e.rstrip??!1,this.special=e.special??!1,this.normalized=e.normalized??null}}class Q extends n.Callable{constructor(e){super(),this.config=e,this.vocab=[],this.tokens_to_ids=new Map,this.unk_token_id=void 0,this.unk_token=void 0,this.end_of_word_suffix=void 0,this.fuse_unk=this.config.fuse_unk??!1}static fromConfig(e,...t){switch(e.type){case"WordPiece":return new W(e);case"Unigram":return new F(e,...t);case"BPE":return new v(e);default:if(e.vocab)return Array.isArray(e.vocab)?new F(e,...t):"object"==typeof e.vocab&&e.continuing_subword_prefix&&e.unk_token?new W(e):new E(e,...t);throw new Error(`Unknown TokenizerModel type: ${e.type}`)}}_call(e){return e=this.encode(e),this.fuse_unk&&(e=function(e,t,r){const n=[];let a=0;for(;a<e.length;)if(n.push(e[a]),(t.get(e[a])??r)===r)for(;++a<e.length&&(t.get(e[a])??r)===r;)t.get(n.at(-1))!==r&&(n[n.length-1]+=e[a]);else++a;return n}(e,this.tokens_to_ids,this.unk_token_id)),e}encode(e){throw Error("encode should be implemented in subclass.")}convert_tokens_to_ids(e){return e.map((e=>this.tokens_to_ids.get(e)??this.unk_token_id))}convert_ids_to_tokens(e){return e.map((e=>this.vocab[e]??this.unk_token))}}class W extends Q{constructor(e){super(e),this.tokens_to_ids=g(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.max_input_chars_per_word=e.max_input_chars_per_word??100,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){const t=[];for(const r of e){const e=[...r];if(e.length>this.max_input_chars_per_word){t.push(this.unk_token);continue}let n=!1,a=0;const o=[];for(;a<e.length;){let t=e.length,r=null;for(;a<t;){let n=e.slice(a,t).join("");if(a>0&&(n=this.config.continuing_subword_prefix+n),this.tokens_to_ids.has(n)){r=n;break}--t}if(null===r){n=!0;break}o.push(r),a=t}n?t.push(this.unk_token):t.push(...o)}return t}}class F extends Q{constructor(e,t){super(e);const r=e.vocab.length;this.vocab=new Array(r),this.scores=new Array(r);for(let t=0;t<r;++t)[this.vocab[t],this.scores[t]]=e.vocab[t];this.unk_token_id=e.unk_id,this.unk_token=this.vocab[e.unk_id],this.tokens_to_ids=new Map(this.vocab.map(((e,t)=>[e,t]))),this.bos_token=" ",this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.unk_token=this.vocab[this.unk_token_id],this.minScore=(0,i.min)(this.scores)[0],this.unk_score=this.minScore-10,this.scores[this.unk_token_id]=this.unk_score,this.trie=new l.CharTrie,this.trie.extend(this.vocab),this.fuse_unk=!0}populateNodes(e){const t=e.chars;let r=0;for(;r<t.length;){let n=!1;const o=t.slice(r).join(""),i=this.trie.commonPrefixSearch(o);for(const t of i){const o=this.tokens_to_ids.get(t),i=this.scores[o],s=(0,a.len)(t);e.insert(r,s,i,o),n||1!==s||(n=!0)}n||e.insert(r,1,this.unk_score,this.unk_token_id),r+=1}}tokenize(e){const t=new l.TokenLattice(e,this.bos_token_id,this.eos_token_id);return this.populateNodes(t),t.tokens()}encode(e){const t=[];for(const r of e){const e=this.tokenize(r);t.push(...e)}return t}}const _=(()=>{const e=[...Array.from({length:"~".charCodeAt(0)-"!".charCodeAt(0)+1},((e,t)=>t+"!".charCodeAt(0))),...Array.from({length:"¬".charCodeAt(0)-"¡".charCodeAt(0)+1},((e,t)=>t+"¡".charCodeAt(0))),...Array.from({length:"ÿ".charCodeAt(0)-"®".charCodeAt(0)+1},((e,t)=>t+"®".charCodeAt(0)))],t=e.slice();let r=0;for(let n=0;n<256;++n)e.includes(n)||(e.push(n),t.push(256+r),r+=1);const n=t.map((e=>String.fromCharCode(e)));return Object.fromEntries(e.map(((e,t)=>[e,n[t]])))})(),y=(0,a.reverseDictionary)(_);class v extends Q{constructor(e){super(e),this.tokens_to_ids=g(e.vocab),this.unk_token_id=this.tokens_to_ids.get(e.unk_token),this.unk_token=e.unk_token,this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e;const t=Array.isArray(e.merges[0]);this.merges=t?e.merges:e.merges.map((e=>e.split(" ",2))),this.bpe_ranks=new Map(this.merges.map(((e,t)=>[JSON.stringify(e),t]))),this.end_of_word_suffix=e.end_of_word_suffix,this.continuing_subword_suffix=e.continuing_subword_suffix??null,this.byte_fallback=this.config.byte_fallback??!1,this.byte_fallback&&(this.text_encoder=new TextEncoder),this.ignore_merges=this.config.ignore_merges??!1,this.cache=new Map}bpe(e){if(0===e.length)return[];const t=this.cache.get(e);if(void 0!==t)return t;const r=Array.from(e);this.end_of_word_suffix&&(r[r.length-1]+=this.end_of_word_suffix);let n=[];if(r.length>1){const e=new l.PriorityQueue(((e,t)=>e.score<t.score));let t={token:r[0],bias:0,prev:null,next:null},a=t;for(let t=1;t<r.length;++t){const n={bias:t/r.length,token:r[t],prev:a,next:null};a.next=n,this._add_node(e,a),a=n}for(;!e.isEmpty();){const r=e.pop();if(r.deleted||!r.next||r.next.deleted)continue;if(r.deleted=!0,r.next.deleted=!0,r.prev){const e={...r.prev};r.prev.deleted=!0,r.prev=e,e.prev?e.prev.next=e:t=e}const n={token:r.token+r.next.token,bias:r.bias,prev:r.prev,next:r.next.next};n.prev?(n.prev.next=n,this._add_node(e,n.prev)):t=n,n.next&&(n.next.prev=n,this._add_node(e,n))}for(let e=t;null!==e;e=e.next)n.push(e.token)}else n=r;if(this.continuing_subword_suffix)for(let e=0;e<n.length-1;++e)n[e]+=this.continuing_subword_suffix;return this.cache.set(e,n),n}_add_node(e,t){const r=this.bpe_ranks.get(JSON.stringify([t.token,t.next.token]));void 0!==r&&(t.score=r+t.bias,e.push(t))}encode(e){const t=[];for(const r of e){if(this.ignore_merges&&this.tokens_to_ids.has(r)){t.push(r);continue}const e=this.bpe(r);for(const r of e)if(this.tokens_to_ids.has(r))t.push(r);else if(this.byte_fallback){const e=Array.from(this.text_encoder.encode(r)).map((e=>`<0x${e.toString(16).toUpperCase().padStart(2,"0")}>`));e.every((e=>this.tokens_to_ids.has(e)))?t.push(...e):t.push(this.unk_token)}else t.push(this.unk_token)}return t}}class E extends Q{constructor(e,t){super(e),this.tokens_to_ids=g(t.target_lang?e.vocab[t.target_lang]:e.vocab),this.bos_token=t.bos_token,this.bos_token_id=this.tokens_to_ids.get(this.bos_token),this.eos_token=t.eos_token,this.eos_token_id=this.tokens_to_ids.get(this.eos_token),this.pad_token=t.pad_token,this.pad_token_id=this.tokens_to_ids.get(this.pad_token),this.unk_token=t.unk_token,this.unk_token_id=this.tokens_to_ids.get(this.unk_token),this.vocab=new Array(this.tokens_to_ids.size);for(const[e,t]of this.tokens_to_ids)this.vocab[t]=e}encode(e){return e}}class G extends n.Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"BertNormalizer":return new L(e);case"Precompiled":return new Ae(e);case"Sequence":return new Y(e);case"Replace":return new R(e);case"NFC":return new S(e);case"NFD":return new T(e);case"NFKC":return new Z(e);case"NFKD":return new X(e);case"Strip":return new V(e);case"StripAccents":return new k(e);case"Lowercase":return new M(e);case"Prepend":return new H(e);default:throw new Error(`Unknown Normalizer type: ${e.type}`)}}normalize(e){throw Error("normalize should be implemented in subclass.")}_call(e){return this.normalize(e)}}class R extends G{normalize(e){const t=p(this.config.pattern);return null===t?e:e.replaceAll(t,this.config.content)}}class x extends G{form=void 0;normalize(e){return e=e.normalize(this.form)}}class S extends x{form="NFC"}class T extends x{form="NFD"}class Z extends x{form="NFKC"}class X extends x{form="NFKD"}class V extends G{normalize(e){return this.config.strip_left&&this.config.strip_right?e=e.trim():(this.config.strip_left&&(e=e.trimStart()),this.config.strip_right&&(e=e.trimEnd())),e}}class k extends G{normalize(e){return e=B(e)}}class M extends G{normalize(e){return e=e.toLowerCase()}}class H extends G{normalize(e){return e=this.config.prepend+e}}class Y extends G{constructor(e){super(e),this.normalizers=e.normalizers.map((e=>G.fromConfig(e)))}normalize(e){return this.normalizers.reduce(((e,t)=>t.normalize(e)),e)}}class L extends G{_tokenize_chinese_chars(e){const t=[];for(let r=0;r<e.length;++r){const n=e[r];m(n.charCodeAt(0))?(t.push(" "),t.push(n),t.push(" ")):t.push(n)}return t.join("")}stripAccents(e){return e.normalize("NFD").replace(/\p{Mn}/gu,"")}_is_control(e){switch(e){case"\t":case"\n":case"\r":return!1;default:return/^\p{Cc}|\p{Cf}|\p{Co}|\p{Cs}$/u.test(e)}}_clean_text(e){const t=[];for(const r of e){const e=r.charCodeAt(0);0===e||65533===e||this._is_control(r)||(/^\s$/.test(r)?t.push(" "):t.push(r))}return t.join("")}normalize(e){return this.config.clean_text&&(e=this._clean_text(e)),this.config.handle_chinese_chars&&(e=this._tokenize_chinese_chars(e)),this.config.lowercase?(e=e.toLowerCase(),!1!==this.config.strip_accents&&(e=this.stripAccents(e))):this.config.strip_accents&&(e=this.stripAccents(e)),e}}class N extends n.Callable{static fromConfig(e){if(null===e)return null;switch(e.type){case"BertPreTokenizer":return new I(e);case"Sequence":return new he(e);case"Whitespace":return new Be(e);case"WhitespaceSplit":return new me(e);case"Metaspace":return new pe(e);case"ByteLevel":return new U(e);case"Split":return new D(e);case"Punctuation":return new J(e);case"Digits":return new P(e);case"Replace":return new Ce(e);default:throw new Error(`Unknown PreTokenizer type: ${e.type}`)}}pre_tokenize_text(e,t){throw Error("pre_tokenize_text should be implemented in subclass.")}pre_tokenize(e,t){return(Array.isArray(e)?e.map((e=>this.pre_tokenize_text(e,t))):this.pre_tokenize_text(e,t)).flat()}_call(e,t){return this.pre_tokenize(e,t)}}class I extends N{constructor(e){super(),this.pattern=new RegExp(`[^\\s${C}]+|[${C}]`,"gu")}pre_tokenize_text(e,t){return e.trim().match(this.pattern)||[]}}class U extends N{constructor(e){super(),this.config=e,this.add_prefix_space=this.config.add_prefix_space,this.trim_offsets=this.config.trim_offsets,this.use_regex=this.config.use_regex??!0,this.pattern=/'s|'t|'re|'ve|'m|'ll|'d| ?\p{L}+| ?\p{N}+| ?[^\s\p{L}\p{N}]+|\s+(?!\S)|\s+/gu,this.byte_encoder=_,this.text_encoder=new TextEncoder}pre_tokenize_text(e,t){this.add_prefix_space&&!e.startsWith(" ")&&(e=" "+e);return(this.use_regex?e.match(this.pattern)||[]:[e]).map((e=>Array.from(this.text_encoder.encode(e),(e=>this.byte_encoder[e])).join("")))}}class D extends N{constructor(e){super(),this.config=e,this.pattern=p(this.config.pattern,this.config.invert)}pre_tokenize_text(e,t){return null===this.pattern?[]:this.config.invert?e.match(this.pattern)||[]:"removed"===this.config.behavior?.toLowerCase()?e.split(this.pattern).filter((e=>e)):function(e,t){const r=[];let n=0;for(const a of e.matchAll(t)){const t=a[0];n<a.index&&r.push(e.slice(n,a.index)),t.length>0&&r.push(t),n=a.index+t.length}return n<e.length&&r.push(e.slice(n)),r}(e,this.pattern)}}class J extends N{constructor(e){super(),this.config=e,this.pattern=new RegExp(`[^${C}]+|[${C}]+`,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class P extends N{constructor(e){super(),this.config=e;const t="[^\\d]+|\\d"+(this.config.individual_digits?"":"+");this.pattern=new RegExp(t,"gu")}pre_tokenize_text(e,t){return e.match(this.pattern)||[]}}class O extends n.Callable{constructor(e){super(),this.config=e}static fromConfig(e){if(null===e)return null;switch(e.type){case"TemplateProcessing":return new $(e);case"ByteLevel":return new q(e);case"RobertaProcessing":return new j(e);case"BertProcessing":return new z(e);case"Sequence":return new ee(e);default:throw new Error(`Unknown PostProcessor type: ${e.type}`)}}post_process(e,...t){throw Error("post_process should be implemented in subclass.")}_call(e,...t){return this.post_process(e,...t)}}class z extends O{constructor(e){super(e),this.cls=e.cls[0],this.sep=e.sep[0]}post_process(e,t=null,{add_special_tokens:r=!0}={}){r&&(e=(0,a.mergeArrays)([this.cls],e,[this.sep]));let n=new Array(e.length).fill(0);if(null!==t){const o=r&&this instanceof j?[this.sep]:[],i=r?[this.sep]:[];e=(0,a.mergeArrays)(e,o,t,i),n=(0,a.mergeArrays)(n,new Array(t.length+o.length+i.length).fill(1))}return{tokens:e,token_type_ids:n}}}class j extends z{}class $ extends O{constructor(e){super(e),this.single=e.single,this.pair=e.pair}post_process(e,t=null,{add_special_tokens:r=!0}={}){const n=null===t?this.single:this.pair;let o=[],i=[];for(const s of n)"SpecialToken"in s?r&&(o.push(s.SpecialToken.id),i.push(s.SpecialToken.type_id)):"Sequence"in s&&("A"===s.Sequence.id?(o=(0,a.mergeArrays)(o,e),i=(0,a.mergeArrays)(i,new Array(e.length).fill(s.Sequence.type_id))):"B"===s.Sequence.id&&(o=(0,a.mergeArrays)(o,t),i=(0,a.mergeArrays)(i,new Array(t.length).fill(s.Sequence.type_id))));return{tokens:o,token_type_ids:i}}}class q extends O{post_process(e,t=null){return t&&(e=(0,a.mergeArrays)(e,t)),{tokens:e}}}class ee extends O{constructor(e){super(e),this.processors=e.processors.map((e=>O.fromConfig(e)))}post_process(e,t=null,r={}){let n;for(const a of this.processors)if(a instanceof q){if(e=a.post_process(e).tokens,t){t=a.post_process(t).tokens}}else{const o=a.post_process(e,t,r);e=o.tokens,n=o.token_type_ids}return{tokens:e,token_type_ids:n}}}class te extends n.Callable{constructor(e){super(),this.config=e,this.added_tokens=[],this.end_of_word_suffix=null,this.trim_offsets=e.trim_offsets}static fromConfig(e){if(null===e)return null;switch(e.type){case"WordPiece":return new ie(e);case"Metaspace":return new ge(e);case"ByteLevel":return new se(e);case"Replace":return new re(e);case"ByteFallback":return new ne(e);case"Fuse":return new ae(e);case"Strip":return new oe(e);case"Sequence":return new de(e);case"CTC":return new le(e);case"BPEDecoder":return new ue(e);default:throw new Error(`Unknown Decoder type: ${e.type}`)}}_call(e){return this.decode(e)}decode(e){return this.decode_chain(e).join("")}decode_chain(e){throw Error("`decode_chain` should be implemented in subclass.")}}class re extends te{decode_chain(e){const t=p(this.config.pattern);return null===t?e:e.map((e=>e.replaceAll(t,this.config.content)))}}class ne extends te{constructor(e){super(e),this.text_decoder=new TextDecoder}decode_chain(e){const t=[];let r=[];for(const n of e){let e=null;if(6===n.length&&n.startsWith("<0x")&&n.endsWith(">")){const t=parseInt(n.slice(3,5),16);isNaN(t)||(e=t)}if(null!==e)r.push(e);else{if(r.length>0){const e=this.text_decoder.decode(Uint8Array.from(r));t.push(e),r=[]}t.push(n)}}if(r.length>0){const e=this.text_decoder.decode(Uint8Array.from(r));t.push(e),r=[]}return t}}class ae extends te{decode_chain(e){return[e.join("")]}}class oe extends te{constructor(e){super(e),this.content=this.config.content,this.start=this.config.start,this.stop=this.config.stop}decode_chain(e){return e.map((e=>{let t=0;for(let r=0;r<this.start&&e[r]===this.content;++r)t=r+1;let r=e.length;for(let t=0;t<this.stop;++t){const n=e.length-t-1;if(e[n]!==this.content)break;r=n}return e.slice(t,r)}))}}class ie extends te{constructor(e){super(e),this.cleanup=e.cleanup}decode_chain(e){return e.map(((e,t)=>(0!==t&&(e=e.startsWith(this.config.prefix)?e.replace(this.config.prefix,""):" "+e),this.cleanup&&(e=h(e)),e)))}}class se extends te{constructor(e){super(e),this.byte_decoder=y,this.text_decoder=new TextDecoder("utf-8",{fatal:!1,ignoreBOM:!0}),this.end_of_word_suffix=null}convert_tokens_to_string(e){const t=e.join(""),r=new Uint8Array([...t].map((e=>this.byte_decoder[e])));return this.text_decoder.decode(r)}decode_chain(e){const t=[];let r=[];for(const n of e)void 0!==this.added_tokens.find((e=>e.content===n))?(r.length>0&&(t.push(this.convert_tokens_to_string(r)),r=[]),t.push(n)):r.push(n);return r.length>0&&t.push(this.convert_tokens_to_string(r)),t}}class le extends te{constructor(e){super(e),this.pad_token=this.config.pad_token,this.word_delimiter_token=this.config.word_delimiter_token,this.cleanup=this.config.cleanup}convert_tokens_to_string(e){if(0===e.length)return"";const t=[e[0]];for(let r=1;r<e.length;++r)e[r]!==t.at(-1)&&t.push(e[r]);let r=t.filter((e=>e!==this.pad_token)).join("");return this.cleanup&&(r=h(r).replaceAll(this.word_delimiter_token," ").trim()),r}decode_chain(e){return[this.convert_tokens_to_string(e)]}}class de extends te{constructor(e){super(e),this.decoders=e.decoders.map((e=>te.fromConfig(e)))}decode_chain(e){return this.decoders.reduce(((e,t)=>t.decode_chain(e)),e)}}class ue extends te{constructor(e){super(e),this.suffix=this.config.suffix}decode_chain(e){return e.map(((t,r)=>t.replaceAll(this.suffix,r===e.length-1?"":" ")))}}class ce extends te{decode_chain(e){let t="";for(let r=1;r<e.length;r+=2)t+=e[r];return[t]}}class pe extends N{constructor(e){super(),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement,this.strRep=e.str_rep||this.replacement,this.prepend_scheme=e.prepend_scheme??"always"}pre_tokenize_text(e,{section_index:t}={}){let r=e.replaceAll(" ",this.strRep);return this.addPrefixSpace&&!r.startsWith(this.replacement)&&("always"===this.prepend_scheme||"first"===this.prepend_scheme&&0===t)&&(r=this.strRep+r),[r]}}class ge extends te{constructor(e){super(e),this.addPrefixSpace=e.add_prefix_space,this.replacement=e.replacement}decode_chain(e){const t=[];for(let r=0;r<e.length;++r){let n=e[r].replaceAll(this.replacement," ");this.addPrefixSpace&&0==r&&n.startsWith(" ")&&(n=n.substring(1)),t.push(n)}return t}}class Ae extends G{constructor(e){super(e),this.charsmap=e.precompiled_charsmap}normalize(e){if((e=(e=e.replace(/[\u0001-\u0008\u000B\u000E-\u001F\u007F\u008F\u009F]/gm,"")).replace(/[\u0009\u000A\u000C\u000D\u00A0\u1680\u2000-\u200F\u2028\u2029\u202F\u205F\u2581\u3000\uFEFF\uFFFD]/gm," ")).includes("～")){const t=e.split("～");e=t.map((e=>e.normalize("NFKC"))).join("～")}else e=e.normalize("NFKC");return e}}class he extends N{constructor(e){super(),this.tokenizers=e.pretokenizers.map((e=>N.fromConfig(e)))}pre_tokenize_text(e,t){return this.tokenizers.reduce(((e,r)=>r.pre_tokenize(e,t)),[e])}}class Be extends N{constructor(e){super()}pre_tokenize_text(e,t){return e.match(/\w+|[^\w\s]+/g)||[]}}class me extends N{constructor(e){super()}pre_tokenize_text(e,t){return function(e){return e.match(/\S+/g)||[]}(e)}}class Ce extends N{constructor(e){super(),this.config=e,this.pattern=p(this.config.pattern),this.content=this.config.content}pre_tokenize_text(e,t){return null===this.pattern?[e]:[e.replaceAll(this.pattern,this.config.content)]}}const we=["bos_token","eos_token","unk_token","sep_token","pad_token","cls_token","mask_token"];function be(e,t,r,n){for(const o of Object.keys(e)){const i=t-e[o].length,s=r(o),l=new Array(i).fill(s);e[o]="right"===n?(0,a.mergeArrays)(e[o],l):(0,a.mergeArrays)(l,e[o])}}function Ke(e,t){for(const r of Object.keys(e))e[r].length=t}class fe extends n.Callable{return_token_type_ids=!1;padding_side="right";constructor(e,t){super(),this._tokenizer_config=t,this.normalizer=G.fromConfig(e.normalizer),this.pre_tokenizer=N.fromConfig(e.pre_tokenizer),this.model=Q.fromConfig(e.model,t),this.post_processor=O.fromConfig(e.post_processor),this.decoder=te.fromConfig(e.decoder),this.special_tokens=[],this.all_special_ids=[],this.added_tokens=[];for(const t of e.added_tokens){const e=new f(t);this.added_tokens.push(e),this.model.tokens_to_ids.set(e.content,e.id),this.model.vocab[e.id]=e.content,e.special&&(this.special_tokens.push(e.content),this.all_special_ids.push(e.id))}if(this.additional_special_tokens=t.additional_special_tokens??[],this.special_tokens.push(...this.additional_special_tokens),this.special_tokens=[...new Set(this.special_tokens)],this.decoder&&(this.decoder.added_tokens=this.added_tokens,this.decoder.end_of_word_suffix=this.model.end_of_word_suffix),this.added_tokens_regex=this.added_tokens.length>0?new RegExp(this.added_tokens.slice().sort(((e,t)=>t.content.length-e.content.length)).map((e=>`${e.lstrip?"\\s*":""}(${(0,a.escapeRegExp)(e.content)})${e.rstrip?"\\s*":""}`)).join("|")):null,this.mask_token=this.getToken("mask_token"),this.mask_token_id=this.model.tokens_to_ids.get(this.mask_token),this.pad_token=this.getToken("pad_token","eos_token"),this.pad_token_id=this.model.tokens_to_ids.get(this.pad_token),this.sep_token=this.getToken("sep_token"),this.sep_token_id=this.model.tokens_to_ids.get(this.sep_token),this.unk_token=this.getToken("unk_token"),this.unk_token_id=this.model.tokens_to_ids.get(this.unk_token),this.bos_token=this.getToken("bos_token"),this.bos_token_id=this.model.tokens_to_ids.get(this.bos_token),this.eos_token=this.getToken("eos_token"),this.eos_token_id=this.model.tokens_to_ids.get(this.eos_token),this.model_max_length=t.model_max_length,this.remove_space=t.remove_space,this.clean_up_tokenization_spaces=t.clean_up_tokenization_spaces??!0,this.do_lowercase_and_remove_accent=t.do_lowercase_and_remove_accent??!1,t.padding_side&&(this.padding_side=t.padding_side),this.legacy=!1,this.chat_template=t.chat_template??null,Array.isArray(this.chat_template)){const e=Object.create(null);for(const{name:t,template:r}of this.chat_template){if("string"!=typeof t||"string"!=typeof r)throw new Error('Chat template must be a list of objects with "name" and "template" properties');e[t]=r}this.chat_template=e}this._compiled_template_cache=new Map}getToken(...e){for(const t of e){const e=this._tokenizer_config[t];if(e){if("object"==typeof e){if("AddedToken"===e.__type)return e.content;throw Error(`Unknown token: ${e}`)}return e}}return null}static async from_pretrained(e,{progress_callback:t=null,config:r=null,cache_dir:n=null,local_files_only:a=!1,revision:o="main",legacy:i=null}={}){return new this(...await c(e,{progress_callback:t,config:r,cache_dir:n,local_files_only:a,revision:o,legacy:i}))}_call(e,{text_pair:t=null,add_special_tokens:r=!0,padding:n=!1,truncation:a=null,max_length:o=null,return_tensor:l=!0,return_token_type_ids:d=null}={}){const u=Array.isArray(e);let c;if(u){if(0===e.length)throw Error("text array must be non-empty");if(null!==t){if(!Array.isArray(t))throw Error("text_pair must also be an array");if(e.length!==t.length)throw Error("text and text_pair must have the same length");c=e.map(((e,n)=>this._encode_plus(e,{text_pair:t[n],add_special_tokens:r,return_token_type_ids:d})))}else c=e.map((e=>this._encode_plus(e,{add_special_tokens:r,return_token_type_ids:d})))}else{if(null==e)throw Error("text may not be null or undefined");if(Array.isArray(t))throw Error("When specifying `text_pair`, since `text` is a string, `text_pair` must also be a string (i.e., not an array).");c=[this._encode_plus(e,{text_pair:t,add_special_tokens:r,return_token_type_ids:d})]}if(null===o?o="max_length"===n?this.model_max_length:(0,i.max)(c.map((e=>e.input_ids.length)))[0]:a||console.warn("Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=true` to explicitly truncate examples to max length."),o=Math.min(o,this.model_max_length??1/0),n||a)for(let e=0;e<c.length;++e)c[e].input_ids.length!==o&&(c[e].input_ids.length>o?a&&Ke(c[e],o):n&&be(c[e],o,(e=>"input_ids"===e?this.pad_token_id:0),this.padding_side));const p={};if(l){if((!n||!a)&&c.some((e=>{for(const t of Object.keys(e))if(e[t].length!==c[0][t]?.length)return!0;return!1})))throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=true' and 'truncation=true' to have batched tensors with the same length.");const e=[c.length,c[0].input_ids.length];for(const t of Object.keys(c[0]))p[t]=new s.Tensor("int64",BigInt64Array.from(c.flatMap((e=>e[t])).map(BigInt)),e)}else{for(const e of Object.keys(c[0]))p[e]=c.map((t=>t[e]));if(!u)for(const e of Object.keys(p))p[e]=p[e][0]}return p}_encode_text(e){if(null===e)return null;const t=(this.added_tokens_regex?e.split(this.added_tokens_regex).filter((e=>e)):[e]).map(((e,t)=>{if(void 0!==this.added_tokens.find((t=>t.content===e)))return e;{if(!0===this.remove_space&&(e=e.trim().split(/\s+/).join(" ")),this.do_lowercase_and_remove_accent&&(e=function(e){return B(e.toLowerCase())}(e)),null!==this.normalizer&&(e=this.normalizer(e)),0===e.length)return[];const r=null!==this.pre_tokenizer?this.pre_tokenizer(e,{section_index:t}):[e];return this.model(r)}})).flat();return t}_encode_plus(e,{text_pair:t=null,add_special_tokens:r=!0,return_token_type_ids:n=null}={}){const{tokens:a,token_type_ids:o}=this._tokenize_helper(e,{pair:t,add_special_tokens:r}),i=this.model.convert_tokens_to_ids(a),s={input_ids:i,attention_mask:new Array(i.length).fill(1)};return(n??this.return_token_type_ids)&&o&&(s.token_type_ids=o),s}_tokenize_helper(e,{pair:t=null,add_special_tokens:r=!1}={}){const n=this._encode_text(e),o=this._encode_text(t);return this.post_processor?this.post_processor(n,o,{add_special_tokens:r}):{tokens:(0,a.mergeArrays)(n??[],o??[])}}tokenize(e,{pair:t=null,add_special_tokens:r=!1}={}){return this._tokenize_helper(e,{pair:t,add_special_tokens:r}).tokens}encode(e,{text_pair:t=null,add_special_tokens:r=!0,return_token_type_ids:n=null}={}){return this._encode_plus(e,{text_pair:t,add_special_tokens:r,return_token_type_ids:n}).input_ids}batch_decode(e,t={}){return e instanceof s.Tensor&&(e=e.tolist()),e.map((e=>this.decode(e,t)))}decode(e,t={}){if(e instanceof s.Tensor&&(e=A(e)),!Array.isArray(e)||0===e.length||!(0,a.isIntegralNumber)(e[0]))throw Error("token_ids must be a non-empty array of integers.");return this.decode_single(e,t)}decode_single(e,{skip_special_tokens:t=!1,clean_up_tokenization_spaces:r=null}){let n=this.model.convert_ids_to_tokens(e);t&&(n=n.filter((e=>!this.special_tokens.includes(e))));let a=this.decoder?this.decoder(n):n.join(" ");return this.decoder&&this.decoder.end_of_word_suffix&&(a=a.replaceAll(this.decoder.end_of_word_suffix," "),t&&(a=a.trim())),(r??this.clean_up_tokenization_spaces)&&(a=h(a)),a}get_chat_template({chat_template:e=null,tools:t=null}={}){if(this.chat_template&&"object"==typeof this.chat_template){const r=this.chat_template;if(null!==e&&Object.hasOwn(r,e))e=r[e];else if(null===e)if(null!==t&&"tool_use"in r)e=r.tool_use;else{if(!("default"in r))throw Error(`This model has multiple chat templates with no default specified! Please either pass a chat template or the name of the template you wish to use to the 'chat_template' argument. Available template names are ${Object.keys(r).sort()}.`);e=r.default}}else if(null===e){if(!this.chat_template)throw Error("Cannot use apply_chat_template() because tokenizer.chat_template is not set and no template argument was passed! For information about writing templates and setting the tokenizer.chat_template attribute, please see the documentation at https://huggingface.co/docs/transformers/main/en/chat_templating");e=this.chat_template}return e}apply_chat_template(e,{tools:t=null,documents:r=null,chat_template:n=null,add_generation_prompt:a=!1,tokenize:o=!0,padding:i=!1,truncation:s=!1,max_length:l=null,return_tensor:u=!0,return_dict:c=!1,tokenizer_kwargs:p={},...g}={}){if("string"!=typeof(n=this.get_chat_template({chat_template:n,tools:t})))throw Error("chat_template must be a string, but got "+typeof n);let A=this._compiled_template_cache.get(n);void 0===A&&(A=new d.Template(n),this._compiled_template_cache.set(n,A));const h=Object.create(null);for(const e of we){const t=this.getToken(e);t&&(h[e]=t)}const B=A.render({messages:e,add_generation_prompt:a,tools:t,documents:r,...h,...g});if(o){const e=this._call(B,{add_special_tokens:!1,padding:i,truncation:s,max_length:l,return_tensor:u,...p});return c?e:e.input_ids}return B}}class Qe extends fe{return_token_type_ids=!0}class We extends fe{return_token_type_ids=!0}class Fe extends fe{return_token_type_ids=!0}class _e extends fe{return_token_type_ids=!0}class ye extends fe{return_token_type_ids=!0}class ve extends fe{return_token_type_ids=!0}class Ee extends fe{return_token_type_ids=!0}class Ge extends fe{return_token_type_ids=!0}class Re extends fe{return_token_type_ids=!0}class xe extends fe{}class Se extends fe{}class Te extends fe{return_token_type_ids=!0;constructor(e,t){super(e,t),console.warn('WARNING: `XLMTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}}class Ze extends fe{return_token_type_ids=!0}class Xe extends fe{}class Ve extends fe{}class ke extends fe{}class Me extends fe{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{2}_[A-Z]{2}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,r){return et(this,e,t,r)}}class He extends Me{}class Ye extends fe{}class Le extends fe{}const Ne="▁";class Ie extends fe{padding_side="left";constructor(e,t){super(e,t),this.legacy=t.legacy??!0,this.legacy||(this.normalizer=null,this.pre_tokenizer=new pe({replacement:Ne,add_prefix_space:!0,prepend_scheme:"first"}))}_encode_text(e){if(null===e)return null;if(this.legacy||0===e.length)return super._encode_text(e);let t=super._encode_text(Ne+e.replaceAll(Ne," "));return t.length>1&&t[0]===Ne&&this.special_tokens.includes(t[1])&&(t=t.slice(1)),t}}class Ue extends fe{}class De extends fe{}class Je extends fe{}class Pe extends fe{}class Oe extends fe{}class ze extends fe{}class je extends fe{}class $e extends fe{}class qe extends fe{}function et(e,t,r,n){if(!("language_codes"in e)||!Array.isArray(e.language_codes))throw new Error("Tokenizer must have `language_codes` attribute set and it should be an array of language ids.");if(!("languageRegex"in e&&e.languageRegex instanceof RegExp))throw new Error("Tokenizer must have `languageRegex` attribute set and it should be a regular expression.");if(!("lang_to_token"in e)||"function"!=typeof e.lang_to_token)throw new Error("Tokenizer must have `lang_to_token` attribute set and it should be a function.");const a=n.src_lang,o=n.tgt_lang;if(!e.language_codes.includes(o))throw new Error(`Target language code "${o}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);if(void 0!==a){if(!e.language_codes.includes(a))throw new Error(`Source language code "${a}" is not valid. Must be one of: {${e.language_codes.join(", ")}}`);for(const t of e.post_processor.config.single)if("SpecialToken"in t&&e.languageRegex.test(t.SpecialToken.id)){t.SpecialToken.id=e.lang_to_token(a);break}}return n.forced_bos_token_id=e.model.convert_tokens_to_ids([e.lang_to_token(o)])[0],e._call(t,r)}class tt extends fe{constructor(e,t){super(e,t),this.languageRegex=/^[a-z]{3}_[A-Z][a-z]{3}$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))),this.lang_to_token=e=>e}_build_translation_inputs(e,t,r){return et(this,e,t,r)}}class rt extends fe{constructor(e,t){super(e,t),this.languageRegex=/^__[a-z]{2,3}__$/,this.language_codes=this.special_tokens.filter((e=>this.languageRegex.test(e))).map((e=>e.slice(2,-2))),this.lang_to_token=e=>`__${e}__`}_build_translation_inputs(e,t,r){return et(this,e,t,r)}}class nt extends fe{get timestamp_begin(){return this.model.convert_tokens_to_ids(["<|notimestamps|>"])[0]+1}_decode_asr(e,{return_timestamps:t=!1,return_language:r=!1,time_precision:n=null,force_full_sequences:a=!0}={}){if(null===n)throw Error("Must specify time_precision");let o=null;const s="word"===t;function l(){return{language:o,timestamp:[null,null],text:""}}const d=[];let c=l(),p=0;const g=this.timestamp_begin,A=g+1500;let h=[],B=[],m=!1,C=null;const b=new Set(this.all_special_ids);for(const r of e){const e=r.tokens,a=s?r.token_timestamps:null;let K=null,f=g;if("stride"in r){const[t,a,o]=r.stride;if(p-=a,C=t-o,a&&(f=a/n+g),o)for(let t=e.length-1;t>=0;--t){const r=Number(e[t]);if(r>=g){if(null!==K&&(r-g)*n<C)break;K=r}}}let Q=[],W=[];for(let r=0;r<e.length;++r){const C=Number(e[r]);if(b.has(C)){const e=this.decode([C]),r=u.WHISPER_LANGUAGE_MAPPING.get(e.slice(2,-2));if(void 0!==r){if(null!==o&&r!==o&&!t){h.push(Q);const e=this.findLongestCommonSequence(h)[0],t=this.decode(e);c.text=t,d.push(c),h=[],Q=[],c=l()}o=c.language=r}}else if(C>=g&&C<=A){const e=(C-g)*n+p,t=(0,i.round)(e,2);if(null!==K&&C>=K)m=!0;else if(m||h.length>0&&C<f)m=!1;else if(null===c.timestamp[0])c.timestamp[0]=t;else if(t===c.timestamp[0]);else{c.timestamp[1]=t,h.push(Q),s&&B.push(W);const[e,r]=this.findLongestCommonSequence(h,B),n=this.decode(e);c.text=n,s&&(c.words=this.collateWordTimestamps(e,r,o)),d.push(c),h=[],Q=[],B=[],W=[],c=l()}}else if(Q.push(C),s){let e,t=(0,i.round)(a[r]+p,2);if(r+1<a.length){e=(0,i.round)(a[r+1]+p,2);const o=this.decode([C]);w.test(o)&&(e=(0,i.round)(Math.min(t+n,e),2))}else e=null;W.push([t,e])}}if("stride"in r){const[e,t,n]=r.stride;p+=e-n}Q.length>0?(h.push(Q),s&&B.push(W)):h.every((e=>0===e.length))&&(c=l(),h=[],Q=[],B=[],W=[])}if(h.length>0){if(a&&t)throw new Error("Whisper did not predict an ending timestamp, which can happen if audio is cut off in the middle of a word. Also make sure WhisperTimeStampLogitsProcessor was used during generation.");const[e,r]=this.findLongestCommonSequence(h,B),n=this.decode(e);c.text=n,s&&(c.words=this.collateWordTimestamps(e,r,o)),d.push(c)}let K=Object.create(null);const f=d.map((e=>e.text)).join("");if(t||r){for(let e=0;e<d.length;++e){const n=d[e];t||delete n.timestamp,r||delete n.language}if(s){const e=[];for(const t of d)for(const r of t.words)e.push(r);K={chunks:e}}else K={chunks:d}}return[f,K]}findLongestCommonSequence(e,t=null){let r=e[0],n=r.length,a=[];const o=Array.isArray(t)&&t.length>0;let i=o?[]:null,s=o?t[0]:null;for(let l=1;l<e.length;++l){const d=e[l];let u=0,c=[n,n,0,0];const p=d.length;for(let e=1;e<n+p;++e){const a=Math.max(0,n-e),i=Math.min(n,n+p-e),g=r.slice(a,i),A=Math.max(0,e-n),h=Math.min(p,e),B=d.slice(A,h);if(g.length!==B.length)throw new Error("There is a bug within whisper `decode_asr` function, please report it. Dropping to prevent bad inference.");let m;m=o?g.filter(((e,r)=>e===B[r]&&s[a+r]<=t[l][A+r])).length:g.filter(((e,t)=>e===B[t])).length;const C=m/e+e/1e4;m>1&&C>u&&(u=C,c=[a,i,A,h])}const[g,A,h,B]=c,m=Math.floor((A+g)/2),C=Math.floor((B+h)/2);a.push(...r.slice(0,m)),r=d.slice(C),n=r.length,o&&(i.push(...s.slice(0,m)),s=t[l].slice(C))}return a.push(...r),o?(i.push(...s),[a,i]):[a,[]]}collateWordTimestamps(e,t,r){const[n,a,o]=this.combineTokensIntoWords(e,r),i=[];for(let e=0;e<n.length;++e){const r=o[e];i.push({text:n[e],timestamp:[t[r.at(0)][0],t[r.at(-1)][1]]})}return i}combineTokensIntoWords(e,t,r="\"'“¡¿([{-",n="\"'.。,，!！?？:：”)]}、"){let a,o,i;return["chinese","japanese","thai","lao","myanmar"].includes(t=t??"english")?[a,o,i]=this.splitTokensOnUnicode(e):[a,o,i]=this.splitTokensOnSpaces(e),this.mergePunctuations(a,o,i,r,n)}decode(e,t){let r;return t?.decode_with_timestamps?(e instanceof s.Tensor&&(e=A(e)),r=this.decodeWithTimestamps(e,t)):r=super.decode(e,t),r}decodeWithTimestamps(e,t){const r=t?.time_precision??.02,n=Array.from(this.all_special_ids).at(-1)+1;let a=[[]];for(let t of e)if(t=Number(t),t>=n){const e=((t-n)*r).toFixed(2);a.push(`<|${e}|>`),a.push([])}else a[a.length-1].push(t);return a=a.map((e=>"string"==typeof e?e:super.decode(e,t))),a.join("")}splitTokensOnUnicode(e){const t=this.decode(e,{decode_with_timestamps:!0}),r=[],n=[],a=[];let o=[],i=[],s=0;for(let l=0;l<e.length;++l){const d=e[l];o.push(d),i.push(l);const u=this.decode(o,{decode_with_timestamps:!0});u.includes("�")&&"�"!==t[s+u.indexOf("�")]||(r.push(u),n.push(o),a.push(i),o=[],i=[],s+=u.length)}return[r,n,a]}splitTokensOnSpaces(e){const[t,r,n]=this.splitTokensOnUnicode(e),a=[],o=[],i=[],s=new RegExp(`^[${C}]$`,"gu");for(let e=0;e<t.length;++e){const l=t[e],d=r[e],u=n[e],c=d[0]>=this.model.tokens_to_ids.get("<|endoftext|>"),p=l.startsWith(" "),g=l.trim(),A=s.test(g);if(c||p||A||0===a.length)a.push(l),o.push(d),i.push(u);else{const e=a.length-1;a[e]+=l,o[e].push(...d),i[e].push(...u)}}return[a,o,i]}mergePunctuations(e,t,r,n,o){const i=structuredClone(e),s=structuredClone(t),l=structuredClone(r);let d=i.length-2,u=i.length-1;for(;d>=0;)i[d].startsWith(" ")&&n.includes(i[d].trim())?(i[u]=i[d]+i[u],s[u]=(0,a.mergeArrays)(s[d],s[u]),l[u]=(0,a.mergeArrays)(l[d],l[u]),i[d]="",s[d]=[],l[d]=[]):u=d,--d;for(d=0,u=1;u<i.length;)!i[d].endsWith(" ")&&o.includes(i[u])?(i[d]+=i[u],s[d]=(0,a.mergeArrays)(s[d],s[u]),l[d]=(0,a.mergeArrays)(l[d],l[u]),i[u]="",s[u]=[],l[u]=[]):d=u,++u;return[i.filter((e=>e)),s.filter((e=>e.length>0)),l.filter((e=>e.length>0))]}}class at extends fe{}class ot extends fe{}class it extends fe{}class st extends fe{constructor(e,t){super(e,t),this.languageRegex=/^(>>\w+<<)\s*/g,this.supported_language_codes=this.model.vocab.filter((e=>this.languageRegex.test(e))),console.warn('WARNING: `MarianTokenizer` is not yet supported by Hugging Face\'s "fast" tokenizers library. Therefore, you may experience slightly inaccurate results.')}_encode_text(e){if(null===e)return null;const[t,...r]=e.trim().split(this.languageRegex);if(0===r.length)return super._encode_text(t);if(2===r.length){const[e,t]=r;return this.supported_language_codes.includes(e)||console.warn(`Unsupported language code "${e}" detected, which may lead to unexpected behavior. Should be one of: ${JSON.stringify(this.supported_language_codes)}`),(0,a.mergeArrays)([e],super._encode_text(t))}}}class lt extends fe{}class dt extends fe{}class ut extends fe{}class ct extends fe{}class pt extends fe{}class gt extends fe{constructor(e,t){super(e,t),this.decoder=new ce({})}}class At extends fe{}class ht extends fe{}class Bt{static TOKENIZER_CLASS_MAPPING={T5Tokenizer:Xe,DistilBertTokenizer:xe,CamembertTokenizer:Se,DebertaTokenizer:ye,DebertaV2Tokenizer:ve,BertTokenizer:Qe,HerbertTokenizer:Ee,ConvBertTokenizer:Ge,RoFormerTokenizer:Re,XLMTokenizer:Te,ElectraTokenizer:Ze,MobileBertTokenizer:Fe,SqueezeBertTokenizer:_e,AlbertTokenizer:We,GPT2Tokenizer:Ve,BartTokenizer:ke,MBartTokenizer:Me,MBart50Tokenizer:He,RobertaTokenizer:Ye,WhisperTokenizer:nt,CodeGenTokenizer:at,CLIPTokenizer:ot,SiglipTokenizer:it,MarianTokenizer:st,BloomTokenizer:Le,NllbTokenizer:tt,M2M100Tokenizer:rt,LlamaTokenizer:Ie,CodeLlamaTokenizer:Ue,XLMRobertaTokenizer:De,MPNetTokenizer:Je,FalconTokenizer:Pe,GPTNeoXTokenizer:Oe,EsmTokenizer:ze,Wav2Vec2CTCTokenizer:lt,BlenderbotTokenizer:dt,BlenderbotSmallTokenizer:ut,SpeechT5Tokenizer:ct,NougatTokenizer:pt,VitsTokenizer:gt,Qwen2Tokenizer:je,GemmaTokenizer:$e,Grok1Tokenizer:qe,CohereTokenizer:At,MgpstrTokenizer:ht,PreTrainedTokenizer:fe};static async from_pretrained(e,{progress_callback:t=null,config:r=null,cache_dir:n=null,local_files_only:a=!1,revision:o="main",legacy:i=null}={}){const[s,l]=await c(e,{progress_callback:t,config:r,cache_dir:n,local_files_only:a,revision:o,legacy:i}),d=l.tokenizer_class?.replace(/Fast$/,"")??"PreTrainedTokenizer";let u=this.TOKENIZER_CLASS_MAPPING[d];return u||(console.warn(`Unknown tokenizer class "${d}", attempting to construct from base class.`),u=fe),new u(s,l)}}},"./src/utils/audio.js":
/*!****************************!*\
  !*** ./src/utils/audio.js ***!
  \****************************/(e,t,r)=>{r.r(t),r.d(t,{RawAudio:()=>f,hamming:()=>p,hanning:()=>c,mel_filter_bank:()=>m,read_audio:()=>d,spectrogram:()=>w,window_function:()=>b});var n=r(/*! ./hub.js */"./src/utils/hub.js"),a=r(/*! ./maths.js */"./src/utils/maths.js"),o=r(/*! ./core.js */"./src/utils/core.js"),i=r(/*! ../env.js */"./src/env.js"),s=r(/*! fs */"?7a2c"),l=r(/*! ./tensor.js */"./src/utils/tensor.js");async function d(e,t){if("undefined"==typeof AudioContext)throw Error("Unable to load audio from path/URL since `AudioContext` is not available in your environment. Instead, audio data should be passed directly to the pipeline/processor. For more information and some example code, see https://huggingface.co/docs/transformers.js/guides/node-audio-processing.");const r=await(await(0,n.getFile)(e)).arrayBuffer(),a=new AudioContext({sampleRate:t});void 0===t&&console.warn(`No sampling rate provided, using default of ${a.sampleRate}Hz.`);const o=await a.decodeAudioData(r);let i;if(2===o.numberOfChannels){const e=Math.sqrt(2),t=o.getChannelData(0),r=o.getChannelData(1);i=new Float32Array(t.length);for(let n=0;n<o.length;++n)i[n]=e*(t[n]+r[n])/2}else i=o.getChannelData(0);return i}function u(e,t){if(e<1)return new Float64Array;if(1===e)return new Float64Array([1]);const r=1-t,n=2*Math.PI/(e-1),a=new Float64Array(e);for(let o=0;o<e;++o)a[o]=t-r*Math.cos(o*n);return a}function c(e){return u(e,.5)}function p(e){return u(e,.54)}const g={htk:e=>2595*Math.log10(1+e/700),kaldi:e=>1127*Math.log(1+e/700),slaney:(e,t=1e3,r=15,n=27/Math.log(6.4))=>e>=t?r+Math.log(e/t)*n:3*e/200};function A(e,t="htk"){const r=g[t];if(!r)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return"number"==typeof e?r(e):e.map((e=>r(e)))}const h={htk:e=>700*(10**(e/2595)-1),kaldi:e=>700*(Math.exp(e/1127)-1),slaney:(e,t=1e3,r=15,n=Math.log(6.4)/27)=>e>=r?t*Math.exp(n*(e-r)):200*e/3};function B(e,t,r){const n=(t-e)/(r-1);return Float64Array.from({length:r},((t,r)=>e+n*r))}function m(e,t,r,n,a,o=null,i="htk",s=!1){if(null!==o&&"slaney"!==o)throw new Error('norm must be one of null or "slaney"');const l=B(A(r,i),A(n,i),t+2);let d,u=function(e,t="htk"){const r=h[t];if(!r)throw new Error('mel_scale should be one of "htk", "slaney" or "kaldi".');return"number"==typeof e?r(e):e.map((e=>r(e)))}(l,i);if(s){const t=a/(2*e);d=A(Float64Array.from({length:e},((e,r)=>r*t)),i),u=l}else d=B(0,Math.floor(a/2),e);const c=function(e,t){const r=Float64Array.from({length:t.length-1},((e,r)=>t[r+1]-t[r])),n=Array.from({length:e.length},(()=>new Array(t.length)));for(let r=0;r<e.length;++r){const a=n[r];for(let n=0;n<t.length;++n)a[n]=t[n]-e[r]}const a=t.length-2,o=Array.from({length:a},(()=>new Array(e.length)));for(let t=0;t<e.length;++t){const e=n[t];for(let n=0;n<a;++n){const a=-e[n]/r[n],i=e[n+2]/r[n+1];o[n][t]=Math.max(0,Math.min(a,i))}}return o}(d,u);if(null!==o&&"slaney"===o)for(let r=0;r<t;++r){const t=c[r],n=2/(u[r+2]-u[r]);for(let r=0;r<e;++r)t[r]*=n}return c}function C(e,t,r,n,o){if(r<=0)throw new Error("reference must be greater than zero");if(n<=0)throw new Error("min_value must be greater than zero");r=Math.max(n,r);const i=Math.log10(r);for(let r=0;r<e.length;++r)e[r]=t*Math.log10(Math.max(n,e[r])-i);if(null!==o){if(o<=0)throw new Error("db_range must be greater than zero");const t=(0,a.max)(e)[0]-o;for(let r=0;r<e.length;++r)e[r]=Math.max(e[r],t)}return e}async function w(e,t,r,n,{fft_length:i=null,power:s=1,center:d=!0,pad_mode:u="reflect",onesided:c=!0,preemphasis:p=null,mel_filters:g=null,mel_floor:A=1e-10,log_mel:h=null,reference:B=1,min_value:m=1e-10,db_range:w=null,remove_dc_offset:b=null,min_num_frames:K=null,max_num_frames:f=null,do_pad:Q=!0,transpose:W=!1}={}){const F=t.length;if(null===i&&(i=r),r>i)throw Error(`frame_length (${r}) may not be larger than fft_length (${i})`);if(F!==r)throw new Error(`Length of the window (${F}) must equal frame_length (${r})`);if(n<=0)throw new Error("hop_length must be greater than zero");if(null===s&&null!==g)throw new Error("You have provided `mel_filters` but `power` is `None`. Mel spectrogram computation is not yet supported for complex-valued spectrogram. Specify `power` to fix this issue.");if(d){if("reflect"!==u)throw new Error(`pad_mode="${u}" not implemented yet.`);const t=Math.floor((i-1)/2)+1;e=function(e,t,r){const n=new e.constructor(e.length+t+r),a=e.length-1;for(let r=0;r<e.length;++r)n[t+r]=e[r];for(let r=1;r<=t;++r)n[t-r]=e[(0,o.calculateReflectOffset)(r,a)];for(let i=1;i<=r;++i)n[a+t+i]=e[(0,o.calculateReflectOffset)(a-i,a)];return n}(e,t,t)}let _=Math.floor(1+Math.floor((e.length-r)/n));null!==K&&_<K&&(_=K);const y=c?Math.floor(i/2)+1:i;let v=_,E=_;null!==f&&(f>_?Q&&(E=f):E=v=f);const G=new a.FFT(i),R=new Float64Array(i),x=new Float64Array(G.outputBufferSize),S=new Float32Array(y*E);for(let a=0;a<v;++a){const o=a*n,i=Math.min(e.length-o,r);i!==r&&R.fill(0,0,r);for(let t=0;t<i;++t)R[t]=e[o+t];if(b){let e=0;for(let t=0;t<i;++t)e+=R[t];const t=e/i;for(let e=0;e<i;++e)R[e]-=t}if(null!==p){for(let e=i-1;e>=1;--e)R[e]-=p*R[e-1];R[0]*=1-p}for(let e=0;e<t.length;++e)R[e]*=t[e];G.realTransform(x,R);for(let e=0;e<y;++e){const t=e<<1;S[e*E+a]=x[t]**2+x[t+1]**2}}if(null!==s&&2!==s){const e=2/s;for(let t=0;t<S.length;++t)S[t]**=e}const T=g.length;let Z=await(0,l.matmul)(new l.Tensor("float32",g.flat(),[T,y]),new l.Tensor("float32",S,[y,E]));W&&(Z=Z.transpose(1,0));const X=Z.data;for(let e=0;e<X.length;++e)X[e]=Math.max(A,X[e]);if(null!==s&&null!==h){const e=Math.min(X.length,v*T);switch(h){case"log":for(let t=0;t<e;++t)X[t]=Math.log(X[t]);break;case"log10":for(let t=0;t<e;++t)X[t]=Math.log10(X[t]);break;case"dB":if(1===s)!function(e,t=1,r=1e-5,n=null){C(e,20,t,r,n)}(X,B,m,w);else{if(2!==s)throw new Error(`Cannot use log_mel option '${h}' with power ${s}`);!function(e,t=1,r=1e-10,n=null){C(e,10,t,r,n)}(X,B,m,w)}break;default:throw new Error(`log_mel must be one of null, 'log', 'log10' or 'dB'. Got '${h}'`)}}return Z}function b(e,t,{periodic:r=!0,frame_length:n=null,center:a=!0}={}){const o=r?e+1:e;let i;switch(t){case"boxcar":i=new Float64Array(o).fill(1);break;case"hann":case"hann_window":i=c(o);break;case"hamming":i=p(o);break;case"povey":i=c(o).map((e=>Math.pow(e,.85)));break;default:throw new Error(`Unknown window type ${t}.`)}if(r&&(i=i.subarray(0,e)),null===n)return i;if(e>n)throw new Error(`Length of the window (${e}) may not be larger than frame_length (${n})`);return i}function K(e,t,r){for(let n=0;n<r.length;++n)e.setUint8(t+n,r.charCodeAt(n))}class f{constructor(e,t){this.audio=e,this.sampling_rate=t}toWav(){return function(e,t){let r=44;const n=new ArrayBuffer(r+4*e.length),a=new DataView(n);K(a,0,"RIFF"),a.setUint32(4,36+4*e.length,!0),K(a,8,"WAVE"),K(a,12,"fmt "),a.setUint32(16,16,!0),a.setUint16(20,3,!0),a.setUint16(22,1,!0),a.setUint32(24,t,!0),a.setUint32(28,4*t,!0),a.setUint16(32,4,!0),a.setUint16(34,32,!0),K(a,36,"data"),a.setUint32(40,4*e.length,!0);for(let t=0;t<e.length;++t,r+=4)a.setFloat32(r,e[t],!0);return n}(this.audio,this.sampling_rate)}toBlob(){const e=this.toWav();return new Blob([e],{type:"audio/wav"})}async save(e){let t;if(i.apis.IS_BROWSER_ENV){if(i.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save a file from a Web Worker.");t=o.saveBlob}else{if(!i.apis.IS_FS_AVAILABLE)throw new Error("Unable to save because filesystem is disabled in this environment.");t=async(e,t)=>{let r=await t.arrayBuffer();s.writeFileSync(e,Buffer.from(r))}}await t(e,this.toBlob())}}},"./src/utils/constants.js":
/*!********************************!*\
  !*** ./src/utils/constants.js ***!
  \********************************/(e,t,r)=>{r.r(t),r.d(t,{CHAT_TEMPLATE_NAME:()=>l,CONFIG_NAME:()=>a,FEATURE_EXTRACTOR_NAME:()=>o,GENERATION_CONFIG_NAME:()=>d,GITHUB_ISSUE_URL:()=>n,IMAGE_PROCESSOR_NAME:()=>i,PROCESSOR_NAME:()=>s});const n="https://github.com/huggingface/transformers.js/issues/new/choose",a="config.json",o="preprocessor_config.json",i=o,s="processor_config.json",l="chat_template.json",d="generation_config.json"},"./src/utils/core.js":
/*!***************************!*\
  !*** ./src/utils/core.js ***!
  \***************************/(e,t,r)=>{function n(e,t){e&&e(t)}function a(e){return Object.fromEntries(Object.entries(e).map((([e,t])=>[t,e])))}function o(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function i(e){return"TypedArray"===e?.prototype?.__proto__?.constructor?.name}function s(e){return Number.isInteger(e)||"bigint"==typeof e}function l(e){return null==e||-1===e}function d(e){const t=[];let r=e;for(;Array.isArray(r);)t.push(r.length),r=r[0];return t}function u(e,t,r=void 0){const n=e[t];if(void 0!==n)return delete e[t],n;if(void 0===r)throw Error(`Key ${t} does not exist in object.`);return r}function c(...e){return Array.prototype.concat.apply([],e)}function p(...e){return e.reduce(((e,t)=>e.flatMap((e=>t.map((t=>[e,t]))))))}function g(e,t){return Math.abs((e+t)%(2*t)-t)}function A(e,t){const r=URL.createObjectURL(t),n=document.createElement("a");n.href=r,n.download=e,n.click(),n.remove(),URL.revokeObjectURL(r)}function h(e,t){return Object.assign({},...t.map((t=>{if(void 0!==e[t])return{[t]:e[t]}})))}function B(e){let t=0;for(const r of e)++t;return t}function m(e,t){let r=0;for(const n of e)n===t&&++r;return r}r.r(t),r.d(t,{calculateDimensions:()=>d,calculateReflectOffset:()=>g,count:()=>m,dispatchCallback:()=>n,escapeRegExp:()=>o,isIntegralNumber:()=>s,isNullishDimension:()=>l,isTypedArray:()=>i,len:()=>B,mergeArrays:()=>c,pick:()=>h,pop:()=>u,product:()=>p,reverseDictionary:()=>a,saveBlob:()=>A})},"./src/utils/data-structures.js":
/*!**************************************!*\
  !*** ./src/utils/data-structures.js ***!
  \**************************************/(e,t,r)=>{r.r(t),r.d(t,{CharTrie:()=>a,PriorityQueue:()=>n,TokenLattice:()=>i});class n{constructor(e=(e,t)=>e>t,t=1/0){this._heap=[],this._comparator=e,this._maxSize=t}get size(){return this._heap.length}isEmpty(){return 0===this.size}peek(){return this._heap[0]}push(...e){return this.extend(e)}extend(e){for(const t of e)if(this.size<this._maxSize)this._heap.push(t),this._siftUp();else{const e=this._smallest();this._comparator(t,this._heap[e])&&(this._heap[e]=t,this._siftUpFrom(e))}return this.size}pop(){const e=this.peek(),t=this.size-1;return t>0&&this._swap(0,t),this._heap.pop(),this._siftDown(),e}replace(e){const t=this.peek();return this._heap[0]=e,this._siftDown(),t}_parent(e){return(e+1>>>1)-1}_left(e){return 1+(e<<1)}_right(e){return e+1<<1}_greater(e,t){return this._comparator(this._heap[e],this._heap[t])}_swap(e,t){const r=this._heap[e];this._heap[e]=this._heap[t],this._heap[t]=r}_siftUp(){this._siftUpFrom(this.size-1)}_siftUpFrom(e){for(;e>0&&this._greater(e,this._parent(e));)this._swap(e,this._parent(e)),e=this._parent(e)}_siftDown(){let e=0;for(;this._left(e)<this.size&&this._greater(this._left(e),e)||this._right(e)<this.size&&this._greater(this._right(e),e);){const t=this._right(e)<this.size&&this._greater(this._right(e),this._left(e))?this._right(e):this._left(e);this._swap(e,t),e=t}}_smallest(){return 2**Math.floor(Math.log2(this.size))-1}}class a{constructor(){this.root=o.default()}extend(e){for(const t of e)this.push(t)}push(e){let t=this.root;for(const r of e){let e=t.children.get(r);void 0===e&&(e=o.default(),t.children.set(r,e)),t=e}t.isLeaf=!0}*commonPrefixSearch(e){let t=this.root;if(void 0===t)return;let r="";for(const n of e){if(r+=n,t=t.children.get(n),void 0===t)return;t.isLeaf&&(yield r)}}}class o{constructor(e,t){this.isLeaf=e,this.children=t}static default(){return new o(!1,new Map)}}class i{constructor(e,t,r){this.chars=Array.from(e),this.len=this.chars.length,this.bosTokenId=t,this.eosTokenId=r,this.nodes=[],this.beginNodes=Array.from({length:this.len+1},(()=>[])),this.endNodes=Array.from({length:this.len+1},(()=>[]));const n=new s(this.bosTokenId,0,0,0,0),a=new s(this.eosTokenId,1,this.len,0,0);this.nodes.push(n.clone()),this.nodes.push(a.clone()),this.beginNodes[this.len].push(a),this.endNodes[0].push(n)}insert(e,t,r,n){const a=this.nodes.length,o=new s(n,a,e,t,r);this.beginNodes[e].push(o),this.endNodes[e+t].push(o),this.nodes.push(o)}viterbi(){const e=this.len;let t=0;for(;t<=e;){if(0==this.beginNodes[t].length)return[];for(let e of this.beginNodes[t]){e.prev=null;let r=0,n=null;for(let a of this.endNodes[t]){const t=a.backtraceScore+e.score;(null===n||t>r)&&(n=a.clone(),r=t)}if(null===n)return[];e.prev=n,e.backtraceScore=r}++t}const r=[],n=this.beginNodes[e][0].prev;if(null===n)return[];let a=n.clone();for(;null!==a.prev;){r.push(a.clone());const e=a.clone();a=e.prev.clone()}return r.reverse(),r}piece(e){return this.chars.slice(e.pos,e.pos+e.length).join("")}tokens(){return this.viterbi().map((e=>this.piece(e)))}tokenIds(){return this.viterbi().map((e=>e.tokenId))}}class s{constructor(e,t,r,n,a){this.tokenId=e,this.nodeId=t,this.pos=r,this.length=n,this.score=a,this.prev=null,this.backtraceScore=0}clone(){const e=new s(this.tokenId,this.nodeId,this.pos,this.length,this.score);return e.prev=this.prev,e.backtraceScore=this.backtraceScore,e}}},"./src/utils/devices.js":
/*!******************************!*\
  !*** ./src/utils/devices.js ***!
  \******************************/(e,t,r)=>{r.r(t),r.d(t,{DEVICE_TYPES:()=>n});const n=Object.freeze({auto:"auto",gpu:"gpu",cpu:"cpu",wasm:"wasm",webgpu:"webgpu",cuda:"cuda",dml:"dml",webnn:"webnn","webnn-npu":"webnn-npu","webnn-gpu":"webnn-gpu","webnn-cpu":"webnn-cpu"})},"./src/utils/dtypes.js":
/*!*****************************!*\
  !*** ./src/utils/dtypes.js ***!
  \*****************************/(e,t,r)=>{r.r(t),r.d(t,{DATA_TYPES:()=>i,DEFAULT_DEVICE_DTYPE_MAPPING:()=>s,DEFAULT_DTYPE_SUFFIX_MAPPING:()=>l,isWebGpuFp16Supported:()=>o});var n=r(/*! ../env.js */"./src/env.js"),a=r(/*! ./devices.js */"./src/utils/devices.js");const o=function(){let e;return async function(){if(void 0===e)if(n.apis.IS_WEBGPU_AVAILABLE)try{const t=await navigator.gpu.requestAdapter();e=t.features.has("shader-f16")}catch(t){e=!1}else e=!1;return e}}(),i=Object.freeze({auto:"auto",fp32:"fp32",fp16:"fp16",q8:"q8",int8:"int8",uint8:"uint8",q4:"q4",bnb4:"bnb4",q4f16:"q4f16"}),s=Object.freeze({[a.DEVICE_TYPES.wasm]:i.q8}),l=Object.freeze({[i.fp32]:"",[i.fp16]:"_fp16",[i.int8]:"_int8",[i.uint8]:"_uint8",[i.q8]:"_quantized",[i.q4]:"_q4",[i.q4f16]:"_q4f16",[i.bnb4]:"_bnb4"})},"./src/utils/generic.js":
/*!******************************!*\
  !*** ./src/utils/generic.js ***!
  \******************************/(e,t,r)=>{r.r(t),r.d(t,{Callable:()=>n});const n=class{constructor(){let e=function(...t){return e._call(...t)};return Object.setPrototypeOf(e,new.target.prototype)}_call(...e){throw Error("Must implement _call method in subclass")}}},"./src/utils/hub.js":
/*!**************************!*\
  !*** ./src/utils/hub.js ***!
  \**************************/(e,t,r)=>{r.r(t),r.d(t,{MAX_EXTERNAL_DATA_CHUNKS:()=>s,getFile:()=>c,getModelFile:()=>A,getModelJSON:()=>h});var n=r(/*! fs */"?7a2c"),a=r(/*! path */"?a42a"),o=r(/*! ../env.js */"./src/env.js"),i=r(/*! ./core.js */"./src/utils/core.js");const s=100,l={txt:"text/plain",html:"text/html",css:"text/css",js:"text/javascript",json:"application/json",png:"image/png",jpg:"image/jpeg",jpeg:"image/jpeg",gif:"image/gif"};class d{constructor(e){if(this.filePath=e,this.headers=new Headers,this.exists=n.existsSync(e),this.exists){this.status=200,this.statusText="OK";let t=n.statSync(e);this.headers.set("content-length",t.size.toString()),this.updateContentType();const r=n.createReadStream(e);this.body=new ReadableStream({start(e){r.on("data",(t=>e.enqueue(t))),r.on("end",(()=>e.close())),r.on("error",(t=>e.error(t)))},cancel(){r.destroy()}})}else this.status=404,this.statusText="Not Found",this.body=null}updateContentType(){const e=this.filePath.toString().split(".").pop().toLowerCase();this.headers.set("content-type",l[e]??"application/octet-stream")}clone(){let e=new d(this.filePath);return e.exists=this.exists,e.status=this.status,e.statusText=this.statusText,e.headers=new Headers(this.headers),e}async arrayBuffer(){return(await n.promises.readFile(this.filePath)).buffer}async blob(){const e=await n.promises.readFile(this.filePath);return new Blob([e],{type:this.headers.get("content-type")})}async text(){return await n.promises.readFile(this.filePath,"utf8")}async json(){return JSON.parse(await this.text())}}function u(e,t=null,r=null){let n;try{n=new URL(e)}catch(e){return!1}return!(t&&!t.includes(n.protocol))&&!(r&&!r.includes(n.hostname))}async function c(e){if(o.env.useFS&&!u(e,["http:","https:","blob:"]))return new d(e.toString());if("undefined"!=typeof process&&"node"===process?.release?.name){const t=!!process.env?.TESTING_REMOTELY,r=o.env.version,n=new Headers;n.set("User-Agent",`transformers.js/${r}; is_ci/${t};`);if(u(e,["http:","https:"],["huggingface.co","hf.co"])){const e=process.env?.HF_TOKEN??process.env?.HF_ACCESS_TOKEN;e&&n.set("Authorization",`Bearer ${e}`)}return fetch(e,{headers:n})}return fetch(e)}const p={400:"Bad request error occurred while trying to load file",401:"Unauthorized access to file",403:"Forbidden access to file",404:"Could not locate file",408:"Request timeout error occurred while trying to load file",500:"Internal server error error occurred while trying to load file",502:"Bad gateway error occurred while trying to load file",503:"Service unavailable error occurred while trying to load file",504:"Gateway timeout error occurred while trying to load file"};class g{constructor(e){this.path=e}async match(e){let t=a.join(this.path,e),r=new d(t);return r.exists?r:void 0}async put(e,t,r=void 0){let o=a.join(this.path,e);try{const e=t.headers.get("Content-Length"),i=parseInt(e??"0");let s=0;await n.promises.mkdir(a.dirname(o),{recursive:!0});const l=n.createWriteStream(o),d=t.body.getReader();for(;;){const{done:e,value:t}=await d.read();if(e)break;await new Promise(((e,r)=>{l.write(t,(t=>{t?r(t):e()}))})),s+=t.length;const n=i?s/i*100:0;r?.({progress:n,loaded:s,total:i})}l.close()}catch(e){try{await n.promises.unlink(o)}catch{}throw e}}}async function A(e,t,r=!0,n={},a=!1){if(!o.env.allowLocalModels){if(n.local_files_only)throw Error("Invalid configuration detected: local models are disabled (`env.allowLocalModels=false`) but you have requested to only use local models (`local_files_only=true`).");if(!o.env.allowRemoteModels)throw Error("Invalid configuration detected: both local and remote models are disabled. Fix by setting `env.allowLocalModels` or `env.allowRemoteModels` to `true`.")}let s;if((0,i.dispatchCallback)(n.progress_callback,{status:"initiate",name:e,file:t}),!s&&o.env.useBrowserCache){if("undefined"==typeof caches)throw Error("Browser cache is not available in this environment.");try{s=await caches.open("transformers-cache")}catch(e){console.warn("An error occurred while opening the browser cache:",e)}}if(!s&&o.env.useFSCache&&(s=new g(n.cache_dir??o.env.cacheDir)),!s&&o.env.useCustomCache){if(!o.env.customCache)throw Error("`env.useCustomCache=true`, but `env.customCache` is not defined.");if(!o.env.customCache.match||!o.env.customCache.put)throw new Error("`env.customCache` must be an object which implements the `match` and `put` functions of the Web Cache API. For more information, see https://developer.mozilla.org/en-US/docs/Web/API/Cache");s=o.env.customCache}const l=n.revision??"main";let A,h,m=B(e,t),C=B(o.env.localModelPath,m),w=m,b=B(o.env.remoteHost,o.env.remotePathTemplate.replaceAll("{model}",e).replaceAll("{revision}",encodeURIComponent(l)),t),K="main"===l?m:B(e,l,t),f=s instanceof g?K:b,Q=!1;s&&(h=await async function(e,...t){for(let r of t)try{let t=await e.match(r);if(t)return t}catch(e){continue}}(s,C,f));const W=void 0!==h;if(void 0===h){if(o.env.allowLocalModels){if(u(m,["http:","https:"])){if(n.local_files_only)throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${w}.`);if(!o.env.allowRemoteModels)throw new Error(`\`env.allowRemoteModels=false\`, but attempted to load a remote file from: ${w}.`)}else try{h=await c(w),A=w}catch(e){console.warn(`Unable to load from local path "${w}": "${e}"`)}}if(void 0===h||404===h.status){if(n.local_files_only||!o.env.allowRemoteModels){if(r)throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${w}".`);return null}if(h=await c(b),200!==h.status)return function(e,t,r){if(!r)return null;const n=p[e]??`Error (${e}) occurred while trying to load file`;throw Error(`${n}: "${t}".`)}(h.status,b,r);A=f}Q=s&&"undefined"!=typeof Response&&h instanceof Response&&200===h.status}let F;if((0,i.dispatchCallback)(n.progress_callback,{status:"download",name:e,file:t}),!o.apis.IS_NODE_ENV||!a){let r;n.progress_callback?W&&"undefined"!=typeof navigator&&/firefox/i.test(navigator.userAgent)?(r=new Uint8Array(await h.arrayBuffer()),(0,i.dispatchCallback)(n.progress_callback,{status:"progress",name:e,file:t,progress:100,loaded:r.length,total:r.length})):r=await async function(e,t){const r=e.headers.get("Content-Length");null===r&&console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");let n=parseInt(r??"0"),a=new Uint8Array(n),o=0;const i=e.body.getReader();async function s(){const{done:e,value:r}=await i.read();if(e)return;const l=o+r.length;if(l>n){n=l;const e=new Uint8Array(n);e.set(a),a=e}a.set(r,o),o=l;return t({progress:o/n*100,loaded:o,total:n}),s()}return await s(),a}(h,(r=>{(0,i.dispatchCallback)(n.progress_callback,{status:"progress",name:e,file:t,...r})})):r=new Uint8Array(await h.arrayBuffer()),F=r}if(Q&&A&&void 0===await s.match(A)&&(F?await s.put(A,new Response(F,{headers:h.headers})).catch((e=>{console.warn(`Unable to add response to browser cache: ${e}.`)})):await s.put(A,h,n.progress_callback)),(0,i.dispatchCallback)(n.progress_callback,{status:"done",name:e,file:t}),F){if(a)throw new Error("Cannot return path in a browser environment.");return F}if(h instanceof d)return h.filePath;const _=await s.match(A);if(_ instanceof d)return _.filePath;throw new Error("Unable to return path for response.")}async function h(e,t,r=!0,n={}){const a=await A(e,t,r,n,!1);if(null===a)return{};const o=new TextDecoder("utf-8").decode(a);return JSON.parse(o)}function B(...e){return(e=e.map(((t,r)=>(r&&(t=t.replace(new RegExp("^/"),"")),r!==e.length-1&&(t=t.replace(new RegExp("/$"),"")),t)))).join("/")}},"./src/utils/image.js":
/*!****************************!*\
  !*** ./src/utils/image.js ***!
  \****************************/(e,t,r)=>{r.r(t),r.d(t,{RawImage:()=>A,load_image:()=>h});var n=r(/*! ./core.js */"./src/utils/core.js"),a=r(/*! ./hub.js */"./src/utils/hub.js"),o=r(/*! ../env.js */"./src/env.js"),i=r(/*! ./tensor.js */"./src/utils/tensor.js"),s=r(/*! sharp */"?2b25");let l,d,u;const c=o.apis.IS_BROWSER_ENV||o.apis.IS_WEBWORKER_ENV;if(c)l=(e,t)=>{if(!self.OffscreenCanvas)throw new Error("OffscreenCanvas not supported by this browser.");return new self.OffscreenCanvas(e,t)},u=self.createImageBitmap,d=self.ImageData;else{if(!s)throw new Error("Unable to load image processing library.");u=async e=>{const t=(await e.metadata()).channels,{data:r,info:n}=await e.rotate().raw().toBuffer({resolveWithObject:!0}),a=new A(new Uint8ClampedArray(r),n.width,n.height,n.channels);return void 0!==t&&t!==n.channels&&a.convert(t),a}}const p={0:"nearest",1:"lanczos",2:"bilinear",3:"bicubic",4:"box",5:"hamming"},g=new Map([["png","image/png"],["jpg","image/jpeg"],["jpeg","image/jpeg"],["gif","image/gif"]]);class A{constructor(e,t,r,n){this.data=e,this.width=t,this.height=r,this.channels=n}get size(){return[this.width,this.height]}static async read(e){if(e instanceof A)return e;if("string"==typeof e||e instanceof URL)return await this.fromURL(e);throw new Error("Unsupported input type: "+typeof e)}static fromCanvas(e){if(!c)throw new Error("fromCanvas() is only supported in browser environments.");const t=e.getContext("2d").getImageData(0,0,e.width,e.height).data;return new A(t,e.width,e.height,4)}static async fromURL(e){const t=await(0,a.getFile)(e);if(200!==t.status)throw new Error(`Unable to read image from "${e}" (${t.status} ${t.statusText})`);const r=await t.blob();return this.fromBlob(r)}static async fromBlob(e){if(c){const t=await u(e),r=l(t.width,t.height).getContext("2d");return r.drawImage(t,0,0),new this(r.getImageData(0,0,t.width,t.height).data,t.width,t.height,4)}{const t=s(await e.arrayBuffer());return await u(t)}}static fromTensor(e,t="CHW"){if(3!==e.dims.length)throw new Error(`Tensor should have 3 dimensions, but has ${e.dims.length} dimensions.`);if("CHW"===t)e=e.transpose(1,2,0);else if("HWC"!==t)throw new Error(`Unsupported channel format: ${t}`);if(!(e.data instanceof Uint8ClampedArray||e.data instanceof Uint8Array))throw new Error(`Unsupported tensor type: ${e.type}`);switch(e.dims[2]){case 1:case 2:case 3:case 4:return new A(e.data,e.dims[1],e.dims[0],e.dims[2]);default:throw new Error(`Unsupported number of channels: ${e.dims[2]}`)}}grayscale(){if(1===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*1);switch(this.channels){case 3:case 4:for(let t=0,r=0;t<this.data.length;t+=this.channels){const n=this.data[t],a=this.data[t+1],o=this.data[t+2];e[r++]=Math.round(.2989*n+.587*a+.114*o)}break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,1)}rgb(){if(3===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*3);switch(this.channels){case 1:for(let t=0,r=0;t<this.data.length;++t)e[r++]=this.data[t],e[r++]=this.data[t],e[r++]=this.data[t];break;case 4:for(let t=0,r=0;t<this.data.length;t+=4)e[r++]=this.data[t],e[r++]=this.data[t+1],e[r++]=this.data[t+2];break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,3)}rgba(){if(4===this.channels)return this;const e=new Uint8ClampedArray(this.width*this.height*4);switch(this.channels){case 1:for(let t=0,r=0;t<this.data.length;++t)e[r++]=this.data[t],e[r++]=this.data[t],e[r++]=this.data[t],e[r++]=255;break;case 3:for(let t=0,r=0;t<this.data.length;t+=3)e[r++]=this.data[t],e[r++]=this.data[t+1],e[r++]=this.data[t+2],e[r++]=255;break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this._update(e,this.width,this.height,4)}putAlpha(e){if(e.width!==this.width||e.height!==this.height)throw new Error(`Expected mask size to be ${this.width}x${this.height}, but got ${e.width}x${e.height}`);if(1!==e.channels)throw new Error(`Expected mask to have 1 channel, but got ${e.channels}`);const t=this.data,r=e.data,n=this.width*this.height;if(3===this.channels){const e=new Uint8ClampedArray(4*n);for(let a=0,o=0,i=0;a<n;++a)e[i++]=t[o++],e[i++]=t[o++],e[i++]=t[o++],e[i++]=r[a];return this._update(e,this.width,this.height,4)}if(4===this.channels){for(let e=0;e<n;++e)t[4*e+3]=r[e];return this}throw new Error(`Expected image to have 3 or 4 channels, but got ${this.channels}`)}async resize(e,t,{resample:r=2}={}){if(this.width===e&&this.height===t)return this;let a=p[r]??r;const o=(0,n.isNullishDimension)(e),i=(0,n.isNullishDimension)(t);if(o&&i)return this;if(o?e=t/this.height*this.width:i&&(t=e/this.width*this.height),c){const r=this.channels,n=this.toCanvas(),a=l(e,t).getContext("2d");a.drawImage(n,0,0,e,t);return new A(a.getImageData(0,0,e,t).data,e,t,4).convert(r)}{let r=this.toSharp();switch(a){case"box":case"hamming":"box"!==a&&"hamming"!==a||(console.warn(`Resampling method ${a} is not yet supported. Using bilinear instead.`),a="bilinear");case"nearest":case"bilinear":case"bicubic":r=r.affine([e/this.width,0,0,t/this.height],{interpolator:a});break;case"lanczos":r=r.resize({width:e,height:t,fit:"fill",kernel:"lanczos3"});break;default:throw new Error(`Resampling method ${a} is not supported.`)}return await u(r)}}async pad([e,t,r,n]){if(e=Math.max(e,0),t=Math.max(t,0),r=Math.max(r,0),n=Math.max(n,0),0===e&&0===t&&0===r&&0===n)return this;if(c){const a=this.channels,o=this.toCanvas(),i=this.width+e+t,s=this.height+r+n,d=l(i,s).getContext("2d");d.drawImage(o,0,0,this.width,this.height,e,r,this.width,this.height);return new A(d.getImageData(0,0,i,s).data,i,s,4).convert(a)}{const a=this.toSharp().extend({left:e,right:t,top:r,bottom:n});return await u(a)}}async crop([e,t,r,n]){if(e=Math.max(e,0),t=Math.max(t,0),r=Math.min(r,this.width-1),n=Math.min(n,this.height-1),0===e&&0===t&&r===this.width-1&&n===this.height-1)return this;const a=r-e+1,o=n-t+1;if(c){const r=this.channels,n=this.toCanvas(),i=l(a,o).getContext("2d");i.drawImage(n,e,t,a,o,0,0,a,o);return new A(i.getImageData(0,0,a,o).data,a,o,4).convert(r)}{const r=this.toSharp().extract({left:e,top:t,width:a,height:o});return await u(r)}}async center_crop(e,t){if(this.width===e&&this.height===t)return this;const r=(this.width-e)/2,n=(this.height-t)/2;if(c){const a=this.channels,o=this.toCanvas(),i=l(e,t).getContext("2d");let s=0,d=0,u=0,c=0;r>=0?s=r:u=-r,n>=0?d=n:c=-n,i.drawImage(o,s,d,e,t,u,c,e,t);return new A(i.getImageData(0,0,e,t).data,e,t,4).convert(a)}{let a=this.toSharp();if(r>=0&&n>=0)a=a.extract({left:Math.floor(r),top:Math.floor(n),width:e,height:t});else if(r<=0&&n<=0){const o=Math.floor(-n),i=Math.floor(-r);a=a.extend({top:o,left:i,right:e-this.width-i,bottom:t-this.height-o})}else{let o=[0,0],i=0;n<0?(o[0]=Math.floor(-n),o[1]=t-this.height-o[0]):i=Math.floor(n);let s=[0,0],l=0;r<0?(s[0]=Math.floor(-r),s[1]=e-this.width-s[0]):l=Math.floor(r),a=a.extend({top:o[0],bottom:o[1],left:s[0],right:s[1]}).extract({left:l,top:i,width:e,height:t})}return await u(a)}}async toBlob(e="image/png",t=1){if(!c)throw new Error("toBlob() is only supported in browser environments.");const r=this.toCanvas();return await r.convertToBlob({type:e,quality:t})}toTensor(e="CHW"){let t=new i.Tensor("uint8",new Uint8Array(this.data),[this.height,this.width,this.channels]);if("HWC"===e);else{if("CHW"!==e)throw new Error(`Unsupported channel format: ${e}`);t=t.permute(2,0,1)}return t}toCanvas(){if(!c)throw new Error("toCanvas() is only supported in browser environments.");const e=this.clone().rgba(),t=l(e.width,e.height),r=new d(e.data,e.width,e.height);return t.getContext("2d").putImageData(r,0,0),t}split(){const{data:e,width:t,height:r,channels:n}=this,a=e.constructor,o=e.length/n,i=Array.from({length:n},(()=>new a(o)));for(let t=0;t<o;++t){const r=n*t;for(let a=0;a<n;++a)i[a][t]=e[r+a]}return i.map((e=>new A(e,t,r,1)))}_update(e,t,r,n=null){return this.data=e,this.width=t,this.height=r,null!==n&&(this.channels=n),this}clone(){return new A(this.data.slice(),this.width,this.height,this.channels)}convert(e){if(this.channels===e)return this;switch(e){case 1:this.grayscale();break;case 3:this.rgb();break;case 4:this.rgba();break;default:throw new Error(`Conversion failed due to unsupported number of channels: ${this.channels}`)}return this}async save(e){if(!c){if(o.apis.IS_FS_AVAILABLE){const t=this.toSharp();return await t.toFile(e)}throw new Error("Unable to save the image because filesystem is disabled in this environment.")}{if(o.apis.IS_WEBWORKER_ENV)throw new Error("Unable to save an image from a Web Worker.");const t=e.split(".").pop().toLowerCase(),r=g.get(t)??"image/png",a=await this.toBlob(r);(0,n.saveBlob)(e,a)}}toSharp(){if(c)throw new Error("toSharp() is only supported in server-side environments.");return s(this.data,{raw:{width:this.width,height:this.height,channels:this.channels}})}}const h=A.read.bind(A)},"./src/utils/maths.js":
/*!****************************!*\
  !*** ./src/utils/maths.js ***!
  \****************************/(e,t,r)=>{function n(e,[t,r,n],[a,o],i="bilinear",s=!1){const l=o/n,d=a/r,u=new e.constructor(a*o*t),c=r*n,p=a*o;for(let i=0;i<a;++i)for(let a=0;a<o;++a){const s=i*o+a,g=(a+.5)/l-.5,A=(i+.5)/d-.5;let h=Math.floor(g),B=Math.floor(A);const m=Math.min(h+1,n-1),C=Math.min(B+1,r-1);h=Math.max(h,0),B=Math.max(B,0);const w=g-h,b=A-B,K=(1-w)*(1-b),f=w*(1-b),Q=(1-w)*b,W=w*b,F=B*n,_=C*n,y=F+h,v=F+m,E=_+h,G=_+m;for(let r=0;r<t;++r){const t=r*c;u[r*p+s]=K*e[t+y]+f*e[t+v]+Q*e[t+E]+W*e[t+G]}}return u}function a(e,t,r){const n=new Array(r.length),a=new Array(r.length);for(let e=r.length-1,o=1;e>=0;--e)a[e]=o,n[e]=t[r[e]],o*=n[e];const o=r.map(((e,t)=>a[r.indexOf(t)])),i=new e.constructor(e.length);for(let r=0;r<e.length;++r){let n=0;for(let e=t.length-1,a=r;e>=0;--e)n+=a%t[e]*o[e],a=Math.floor(a/t[e]);i[n]=e[r]}return[i,n]}function o(e){const t=c(e)[0],r=e.map((e=>Math.exp(e-t))),n=r.reduce(((e,t)=>e+t),0);return r.map((e=>e/n))}function i(e){const t=c(e)[0];let r=0;for(let n=0;n<e.length;++n)r+=Math.exp(e[n]-t);const n=Math.log(r);return e.map((e=>e-t-n))}function s(e,t){let r=0;for(let n=0;n<e.length;++n)r+=e[n]*t[n];return r}function l(e,t){return s(e,t)/(d(e)*d(t))}function d(e){return Math.sqrt(e.reduce(((e,t)=>e+t*t),0))}function u(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],r=0;for(let n=1;n<e.length;++n)e[n]<t&&(t=e[n],r=n);return[t,r]}function c(e){if(0===e.length)throw Error("Array must not be empty");let t=e[0],r=0;for(let n=1;n<e.length;++n)e[n]>t&&(t=e[n],r=n);return[t,r]}function p(e){return e>0&&!(e&e-1)}r.r(t),r.d(t,{FFT:()=>h,bankers_round:()=>C,cos_sim:()=>l,dot:()=>s,dynamic_time_warping:()=>w,interpolate_data:()=>n,log_softmax:()=>i,magnitude:()=>d,max:()=>c,medianFilter:()=>B,min:()=>u,permute_data:()=>a,round:()=>m,softmax:()=>o});class g{constructor(e){if(this.size=0|e,this.size<=1||!p(this.size))throw new Error("FFT size must be a power of two larger than 1");this._csize=e<<1,this.table=new Float64Array(2*this.size);for(let e=0;e<this.table.length;e+=2){const t=Math.PI*e/this.size;this.table[e]=Math.cos(t),this.table[e+1]=-Math.sin(t)}let t=0;for(let e=1;this.size>e;e<<=1)++t;this._width=t%2==0?t-1:t,this._bitrev=new Int32Array(1<<this._width);for(let e=0;e<this._bitrev.length;++e){this._bitrev[e]=0;for(let t=0;t<this._width;t+=2){const r=this._width-t-2;this._bitrev[e]|=(e>>>t&3)<<r}}}createComplexArray(){return new Float64Array(this._csize)}fromComplexArray(e,t){const r=t||new Array(e.length>>>1);for(let t=0;t<e.length;t+=2)r[t>>>1]=e[t];return r}toComplexArray(e,t){const r=t||this.createComplexArray();for(let t=0;t<r.length;t+=2)r[t]=e[t>>>1],r[t+1]=0;return r}transform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,1)}realTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._realTransform4(e,t,1)}inverseTransform(e,t){if(e===t)throw new Error("Input and output buffers must be different");this._transform4(e,t,-1);for(let t=0;t<e.length;++t)e[t]/=this.size}_transform4(e,t,r){const n=this._csize;let a,o,i=1<<this._width,s=n/i<<1;const l=this._bitrev;if(4===s)for(a=0,o=0;a<n;a+=s,++o){const r=l[o];this._singleTransform2(t,e,a,r,i)}else for(a=0,o=0;a<n;a+=s,++o){const n=l[o];this._singleTransform4(t,e,a,n,i,r)}const d=this.table;for(i>>=2;i>=2;i>>=2){s=n/i<<1;const t=s>>>2;for(a=0;a<n;a+=s){const n=a+t-1;for(let o=a,s=0;o<n;o+=2,s+=i){const n=o,a=n+t,i=a+t,l=i+t,u=e[n],c=e[n+1],p=e[a],g=e[a+1],A=e[i],h=e[i+1],B=e[l],m=e[l+1],C=d[s],w=r*d[s+1],b=p*C-g*w,K=p*w+g*C,f=d[2*s],Q=r*d[2*s+1],W=A*f-h*Q,F=A*Q+h*f,_=d[3*s],y=r*d[3*s+1],v=B*_-m*y,E=B*y+m*_,G=u+W,R=c+F,x=u-W,S=c-F,T=b+v,Z=K+E,X=r*(b-v),V=r*(K-E);e[n]=G+T,e[n+1]=R+Z,e[a]=x+V,e[a+1]=S-X,e[i]=G-T,e[i+1]=R-Z,e[l]=x-V,e[l+1]=S+X}}}}_singleTransform2(e,t,r,n,a){const o=e[n],i=e[n+1],s=e[n+a],l=e[n+a+1];t[r]=o+s,t[r+1]=i+l,t[r+2]=o-s,t[r+3]=i-l}_singleTransform4(e,t,r,n,a,o){const i=2*a,s=3*a,l=e[n],d=e[n+1],u=e[n+a],c=e[n+a+1],p=e[n+i],g=e[n+i+1],A=e[n+s],h=e[n+s+1],B=l+p,m=d+g,C=l-p,w=d-g,b=u+A,K=c+h,f=o*(u-A),Q=o*(c-h);t[r]=B+b,t[r+1]=m+K,t[r+2]=C+Q,t[r+3]=w-f,t[r+4]=B-b,t[r+5]=m-K,t[r+6]=C-Q,t[r+7]=w+f}_realTransform4(e,t,r){const n=this._csize;let a,o,i=1<<this._width,s=n/i<<1;const l=this._bitrev;if(4===s)for(a=0,o=0;a<n;a+=s,++o){const r=l[o];this._singleRealTransform2(t,e,a,r>>>1,i>>>1)}else for(a=0,o=0;a<n;a+=s,++o){const n=l[o];this._singleRealTransform4(t,e,a,n>>>1,i>>>1,r)}const d=this.table;for(i>>=2;i>=2;i>>=2){s=n/i<<1;const t=s>>>1,o=t>>>1,l=o>>>1;for(a=0;a<n;a+=s)for(let n=0,s=0;n<=l;n+=2,s+=i){const i=a+n,u=i+o,c=u+o,p=c+o,g=e[i],A=e[i+1],h=e[u],B=e[u+1],m=e[c],C=e[c+1],w=e[p],b=e[p+1],K=g,f=A,Q=d[s],W=r*d[s+1],F=h*Q-B*W,_=h*W+B*Q,y=d[2*s],v=r*d[2*s+1],E=m*y-C*v,G=m*v+C*y,R=d[3*s],x=r*d[3*s+1],S=w*R-b*x,T=w*x+b*R,Z=K+E,X=f+G,V=K-E,k=f-G,M=F+S,H=_+T,Y=r*(F-S),L=r*(_-T);if(e[i]=Z+M,e[i+1]=X+H,e[u]=V+L,e[u+1]=k-Y,0===n){e[c]=Z-M,e[c+1]=X-H;continue}if(n===l)continue;const N=a+o-n,I=a+t-n;e[N]=V-r*L,e[N+1]=-k-r*Y,e[I]=Z-r*M,e[I+1]=r*H-X}}const u=n>>>1;for(let t=2;t<u;t+=2)e[n-t]=e[t],e[n-t+1]=-e[t+1]}_singleRealTransform2(e,t,r,n,a){const o=e[n],i=e[n+a];t[r]=o+i,t[r+1]=0,t[r+2]=o-i,t[r+3]=0}_singleRealTransform4(e,t,r,n,a,o){const i=2*a,s=3*a,l=e[n],d=e[n+a],u=e[n+i],c=e[n+s],p=l+u,g=l-u,A=d+c,h=o*(d-c);t[r]=p+A,t[r+1]=0,t[r+2]=g,t[r+3]=-h,t[r+4]=p-A,t[r+5]=0,t[r+6]=g,t[r+7]=h}}class A{constructor(e){const t=2*(e-1),r=2*(2*e-1),n=2**Math.ceil(Math.log2(r));this.bufferSize=n,this._a=t;const a=new Float64Array(r),o=new Float64Array(n);this._chirpBuffer=new Float64Array(n),this._buffer1=new Float64Array(n),this._buffer2=new Float64Array(n),this._outBuffer1=new Float64Array(n),this._outBuffer2=new Float64Array(n);const i=-2*Math.PI/e,s=Math.cos(i),l=Math.sin(i);for(let t=0;t<r>>1;++t){const r=(t+1-e)**2/2,n=Math.sqrt(s**2+l**2)**r,i=r*Math.atan2(l,s),d=2*t;a[d]=n*Math.cos(i),a[d+1]=n*Math.sin(i),o[d]=a[d],o[d+1]=-a[d+1]}this._slicedChirpBuffer=a.subarray(t,r),this._f=new g(n>>1),this._f.transform(this._chirpBuffer,o)}_transform(e,t,r){const n=this._buffer1,a=this._buffer2,o=this._outBuffer1,i=this._outBuffer2,s=this._chirpBuffer,l=this._slicedChirpBuffer,d=this._a;if(r)for(let e=0;e<l.length;e+=2){const r=e+1,a=t[e>>1];n[e]=a*l[e],n[r]=a*l[r]}else for(let e=0;e<l.length;e+=2){const r=e+1;n[e]=t[e]*l[e]-t[r]*l[r],n[r]=t[e]*l[r]+t[r]*l[e]}this._f.transform(o,n);for(let e=0;e<s.length;e+=2){const t=e+1;a[e]=o[e]*s[e]-o[t]*s[t],a[t]=o[e]*s[t]+o[t]*s[e]}this._f.inverseTransform(i,a);for(let t=0;t<i.length;t+=2){const r=i[t+d],n=i[t+d+1],a=l[t],o=l[t+1];e[t]=r*a-n*o,e[t+1]=r*o+n*a}}transform(e,t){this._transform(e,t,!1)}realTransform(e,t){this._transform(e,t,!0)}}class h{constructor(e){this.fft_length=e,this.isPowerOfTwo=p(e),this.isPowerOfTwo?(this.fft=new g(e),this.outputBufferSize=2*e):(this.fft=new A(e),this.outputBufferSize=this.fft.bufferSize)}realTransform(e,t){this.fft.realTransform(e,t)}transform(e,t){this.fft.transform(e,t)}}function B(e,t){if(t%2==0||t<=0)throw new Error("Window size must be a positive odd number");const r=new e.constructor(e.length),n=new e.constructor(t),a=Math.floor(t/2);for(let t=0;t<e.length;++t){let o=0;for(let r=-a;r<=a;++r){let a=t+r;a<0?a=Math.abs(a):a>=e.length&&(a=2*(e.length-1)-a),n[o++]=e[a]}n.sort(),r[t]=n[a]}return r}function m(e,t){const r=Math.pow(10,t);return Math.round(e*r)/r}function C(e){const t=Math.round(e);return Math.abs(e)%1==.5?t%2==0?t:t-1:t}function w(e){const t=e.length,r=e[0].length,n=[t+1,r+1],a=Array.from({length:n[0]},(()=>Array(n[1]).fill(1/0)));a[0][0]=0;const o=Array.from({length:n[0]},(()=>Array(n[1]).fill(-1)));for(let t=1;t<n[1];++t)for(let r=1;r<n[0];++r){const n=a[r-1][t-1],i=a[r-1][t],s=a[r][t-1];let l,d;n<i&&n<s?(l=n,d=0):i<n&&i<s?(l=i,d=1):(l=s,d=2),a[r][t]=e[r-1][t-1]+l,o[r][t]=d}for(let e=0;e<n[1];++e)o[0][e]=2;for(let e=0;e<n[0];++e)o[e][0]=1;let i=t,s=r,l=[],d=[];for(;i>0||s>0;)switch(l.push(i-1),d.push(s-1),o[i][s]){case 0:--i,--s;break;case 1:--i;break;case 2:--s;break;default:throw new Error(`Internal error in dynamic time warping. Unexpected trace[${i}, ${s}]. Please file a bug report.`)}return l.reverse(),d.reverse(),[l,d]}},"./src/utils/tensor.js":
/*!*****************************!*\
  !*** ./src/utils/tensor.js ***!
  \*****************************/(e,t,r)=>{r.r(t),r.d(t,{DataTypeMap:()=>i,Tensor:()=>s,cat:()=>K,full:()=>y,full_like:()=>v,interpolate:()=>d,interpolate_4d:()=>u,layer_norm:()=>m,matmul:()=>c,mean:()=>F,mean_pooling:()=>B,ones:()=>E,ones_like:()=>G,permute:()=>l,quantize_embeddings:()=>T,rand:()=>S,rfft:()=>p,slice:()=>h,stack:()=>f,std_mean:()=>W,topk:()=>g,zeros:()=>R,zeros_like:()=>x});var n=r(/*! ./maths.js */"./src/utils/maths.js"),a=r(/*! ../backends/onnx.js */"./src/backends/onnx.js"),o=r(/*! ../ops/registry.js */"./src/ops/registry.js");const i=Object.freeze({float32:Float32Array,float16:"undefined"!=typeof Float16Array?Float16Array:Uint16Array,float64:Float64Array,string:Array,int8:Int8Array,uint8:Uint8Array,int16:Int16Array,uint16:Uint16Array,int32:Int32Array,uint32:Uint32Array,int64:BigInt64Array,uint64:BigUint64Array,bool:Uint8Array,uint4:Uint8Array,int4:Int8Array});class s{get dims(){return this.ort_tensor.dims}set dims(e){this.ort_tensor.dims=e}get type(){return this.ort_tensor.type}get data(){return this.ort_tensor.data}get size(){return this.ort_tensor.size}get location(){return this.ort_tensor.location}ort_tensor;constructor(...e){return(0,a.isONNXTensor)(e[0])?this.ort_tensor=e[0]:this.ort_tensor=new a.Tensor(e[0],e[1],e[2]),new Proxy(this,{get:(e,t)=>{if("string"==typeof t){let r=Number(t);if(Number.isInteger(r))return e._getitem(r)}return e[t]},set:(e,t,r)=>e[t]=r})}dispose(){this.ort_tensor.dispose()}*[Symbol.iterator](){const[e,...t]=this.dims;if(t.length>0){const r=t.reduce(((e,t)=>e*t));for(let n=0;n<e;++n)yield this._subarray(n,r,t)}else yield*this.data}_getitem(e){const[t,...r]=this.dims;if(e=b(e,t),r.length>0){const t=r.reduce(((e,t)=>e*t));return this._subarray(e,t,r)}return new s(this.type,[this.data[e]],r)}indexOf(e){const t=this.data;for(let r=0;r<t.length;++r)if(t[r]==e)return r;return-1}_subarray(e,t,r){const n=e*t,a=(e+1)*t,o="subarray"in this.data?this.data.subarray(n,a):this.data.slice(n,a);return new s(this.type,o,r)}item(){const e=this.data;if(1!==e.length)throw new Error(`a Tensor with ${e.length} elements cannot be converted to Scalar`);return e[0]}tolist(){return function(e,t){const r=e.length,n=t.reduce(((e,t)=>e*t));if(r!==n)throw Error(`cannot reshape array of size ${r} into shape (${t})`);let a=e;for(let e=t.length-1;e>=0;e--)a=a.reduce(((r,n)=>{let a=r[r.length-1];return a.length<t[e]?a.push(n):r.push([n]),r}),[[]]);return a[0]}(this.data,this.dims)}sigmoid(){return this.clone().sigmoid_()}sigmoid_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=1/(1+Math.exp(-e[t]));return this}map(e){return this.clone().map_(e)}map_(e){const t=this.data;for(let r=0;r<t.length;++r)t[r]=e(t[r],r,t);return this}mul(e){return this.clone().mul_(e)}mul_(e){const t=this.data;for(let r=0;r<t.length;++r)t[r]*=e;return this}div(e){return this.clone().div_(e)}div_(e){const t=this.data;for(let r=0;r<t.length;++r)t[r]/=e;return this}add(e){return this.clone().add_(e)}add_(e){const t=this.data;for(let r=0;r<t.length;++r)t[r]+=e;return this}sub(e){return this.clone().sub_(e)}sub_(e){const t=this.data;for(let r=0;r<t.length;++r)t[r]-=e;return this}clone(){return new s(this.type,this.data.slice(),this.dims.slice())}slice(...e){const t=[],r=[];for(let n=0;n<this.dims.length;++n){let a=e[n];if(null==a)r.push([0,this.dims[n]]),t.push(this.dims[n]);else if("number"==typeof a)a=b(a,this.dims[n],n),r.push([a,a+1]);else{if(!Array.isArray(a)||2!==a.length)throw new Error(`Invalid slice: ${a}`);{let[e,o]=a;if(e=null===e?0:b(e,this.dims[n],n,!1),o=null===o?this.dims[n]:b(o,this.dims[n],n,!1),e>o)throw new Error(`Invalid slice: ${a}`);const i=[Math.max(e,0),Math.min(o,this.dims[n])];r.push(i),t.push(i[1]-i[0])}}}const n=r.map((([e,t])=>t-e)),a=n.reduce(((e,t)=>e*t)),o=this.data,i=new o.constructor(a),l=this.stride();for(let e=0;e<a;++e){let t=0;for(let a=n.length-1,o=e;a>=0;--a){const e=n[a];t+=(o%e+r[a][0])*l[a],o=Math.floor(o/e)}i[e]=o[t]}return new s(this.type,i,t)}permute(...e){return l(this,e)}transpose(...e){return this.permute(...e)}sum(e=null,t=!1){return this.norm(1,e,t)}norm(e="fro",t=null,r=!1){if("fro"===e)e=2;else if("string"==typeof e)throw Error(`Unsupported norm: ${e}`);const n=this.data,a=(t,r)=>t+r**e;if(null===t){const t=n.reduce(a,0)**(1/e);return new s(this.type,[t],[])}const[o,i,l]=Q(a,this,t,r);if(1!==e)for(let t=0;t<i.length;++t)i[t]=i[t]**(1/e);return new s(o,i,l)}normalize_(e=2,t=1){t=b(t,this.dims.length);const r=this.norm(e,t,!0),n=this.data,a=r.data;for(let e=0;e<n.length;++e){let r=0;for(let n=this.dims.length-1,a=e,o=1;n>=0;--n){const e=this.dims[n];if(n!==t){r+=a%e*o,o*=this.dims[n]}a=Math.floor(a/e)}n[e]/=a[r]}return this}normalize(e=2,t=1){return this.clone().normalize_(e,t)}stride(){return function(e){const t=new Array(e.length);for(let r=e.length-1,n=1;r>=0;--r)t[r]=n,n*=e[r];return t}(this.dims)}squeeze(e=null){return new s(this.type,this.data,C(this.dims,e))}squeeze_(e=null){return this.dims=C(this.dims,e),this}unsqueeze(e=null){return new s(this.type,this.data,w(this.dims,e))}unsqueeze_(e=null){return this.dims=w(this.dims,e),this}flatten_(e=0,t=-1){t=(t+this.dims.length)%this.dims.length;let r=this.dims.slice(0,e),n=this.dims.slice(e,t+1),a=this.dims.slice(t+1);return this.dims=[...r,n.reduce(((e,t)=>e*t),1),...a],this}flatten(e=0,t=-1){return this.clone().flatten_(e,t)}view(...e){let t=-1;for(let r=0;r<e.length;++r)if(-1===e[r]){if(-1!==t)throw new Error("Only one dimension can be inferred");t=r}const r=this.data;if(-1!==t){const n=e.reduce(((e,r,n)=>n!==t?e*r:e),1);e[t]=r.length/n}return new s(this.type,r,e)}neg_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=-e[t];return this}neg(){return this.clone().neg_()}gt(e){const t=new Uint8Array(this.data.length),r=this.data;for(let n=0;n<r.length;++n)t[n]=r[n]>e?1:0;return new s("bool",t,this.dims)}lt(e){const t=new Uint8Array(this.data.length),r=this.data;for(let n=0;n<r.length;++n)t[n]=r[n]<e?1:0;return new s("bool",t,this.dims)}clamp_(e,t){const r=this.data;for(let n=0;n<r.length;++n)r[n]=Math.min(Math.max(r[n],e),t);return this}clamp(e,t){return this.clone().clamp_(e,t)}round_(){const e=this.data;for(let t=0;t<e.length;++t)e[t]=Math.round(e[t]);return this}round(){return this.clone().round_()}mean(e=null,t=!1){return F(this,e,t)}min(e=null,t=!1){if(null===e){const e=(0,n.min)(this.data)[0];return new s(this.type,[e],[])}const[r,a,o]=Q(((e,t)=>Math.min(e,t)),this,e,t,1/0);return new s(r,a,o)}max(e=null,t=!1){if(null===e){const e=(0,n.max)(this.data)[0];return new s(this.type,[e],[])}const[r,a,o]=Q(((e,t)=>Math.max(e,t)),this,e,t,-1/0);return new s(r,a,o)}argmin(e=null,t=!1){if(null!==e)throw new Error("`dim !== null` not yet implemented.");const r=(0,n.min)(this.data)[1];return new s("int64",[BigInt(r)],[])}argmax(e=null,t=!1){if(null!==e)throw new Error("`dim !== null` not yet implemented.");const r=(0,n.max)(this.data)[1];return new s("int64",[BigInt(r)],[])}to(e){if(this.type===e)return this;if(!i.hasOwnProperty(e))throw new Error(`Unsupported type: ${e}`);let t;const r=["int64","uint64"].includes(this.type),n=["int64","uint64"].includes(e);return r&&!n?t=Number:!r&&n&&(t=BigInt),new s(e,i[e].from(this.data,t),this.dims)}}function l(e,t){const[r,a]=(0,n.permute_data)(e.data,e.dims,t);return new s(e.type,r,a)}function d(e,[t,r],a="bilinear",o=!1){const i=e.dims.at(-3)??1,l=e.dims.at(-2),d=e.dims.at(-1);let u=(0,n.interpolate_data)(e.data,[i,l,d],[t,r],a,o);return new s(e.type,u,[i,t,r])}async function u(e,{size:t=null,mode:r="bilinear"}={}){if(4!==e.dims.length)throw new Error("`interpolate_4d` currently only supports 4D input.");if(!t)throw new Error("`interpolate_4d` requires a `size` argument.");let n,a;if(2===t.length)n=[...e.dims.slice(0,2),...t];else if(3===t.length)n=[e.dims[0],...t];else{if(4!==t.length)throw new Error("`size` must be of length 2, 3, or 4.");n=t}if("nearest"===r)a=await o.TensorOpRegistry.nearest_interpolate_4d;else if("bilinear"===r)a=await o.TensorOpRegistry.bilinear_interpolate_4d;else{if("bicubic"!==r)throw new Error(`Unsupported mode: ${r}`);a=await o.TensorOpRegistry.bicubic_interpolate_4d}const i=new s("int64",new BigInt64Array(n.map(BigInt)),[n.length]);return await a({x:e,s:i})}async function c(e,t){const r=await o.TensorOpRegistry.matmul;return await r({a:e,b:t})}async function p(e,t){const r=await o.TensorOpRegistry.rfft;return await r({x:e,a:t})}async function g(e,t){const r=await o.TensorOpRegistry.top_k;return t=null==t?e.dims.at(-1):Math.min(t,e.dims.at(-1)),await r({x:e,k:new s("int64",[BigInt(t)],[1])})}const A=e=>new s("int64",e,[e.length]);async function h(e,t,r,n,a){const i=await o.TensorOpRegistry.slice;return await i({x:e,s:A(t),e:A(r),a:A(n),t:A(a??new Array(n.length).fill(1))})}function B(e,t){const r=e.data,n=t.data,a=[e.dims[0],e.dims[2]],o=new r.constructor(a[0]*a[1]),[i,l,d]=e.dims;let u=0;for(let e=0;e<i;++e){const t=e*d*l;for(let a=0;a<d;++a){let i=0,s=0;const c=e*l,p=t+a;for(let e=0;e<l;++e){const t=Number(n[c+e]);s+=t,i+=r[p+e*d]*t}const g=i/s;o[u++]=g}}return new s(e.type,o,a)}function m(e,t,{eps:r=1e-5}={}){if(2!==e.dims.length)throw new Error("`layer_norm` currently only supports 2D input.");const[n,a]=e.dims;if(1!==t.length&&t[0]!==a)throw new Error("`normalized_shape` must be a 1D array with shape `[input.dims[1]]`.");const[o,i]=W(e,1,0,!0),l=o.data,d=i.data,u=e.data,c=new u.constructor(u.length);for(let e=0;e<n;++e){const t=e*a;for(let n=0;n<a;++n){const a=t+n;c[a]=(u[a]-d[e])/(l[e]+r)}}return new s(e.type,c,e.dims)}function C(e,t){return e=e.slice(),null===t?e=e.filter((e=>1!==e)):"number"==typeof t?1===e[t]&&e.splice(t,1):Array.isArray(t)&&(e=e.filter(((e,r)=>1!==e||!t.includes(r)))),e}function w(e,t){return t=b(t,e.length+1),(e=e.slice()).splice(t,0,1),e}function b(e,t,r=null,n=!0){if(n&&(e<-t||e>=t))throw new Error(`IndexError: index ${e} is out of bounds for dimension${null===r?"":" "+r} with size ${t}`);return e<0&&(e=(e%t+t)%t),e}function K(e,t=0){t=b(t,e[0].dims.length);const r=e[0].dims.slice();r[t]=e.reduce(((e,r)=>e+r.dims[t]),0);const n=r.reduce(((e,t)=>e*t),1),a=new e[0].data.constructor(n),o=e[0].type;if(0===t){let t=0;for(const r of e){const e=r.data;a.set(e,t),t+=e.length}}else{let n=0;for(let o=0;o<e.length;++o){const{data:i,dims:s}=e[o];for(let e=0;e<i.length;++e){let o=0;for(let a=s.length-1,i=e,l=1;a>=0;--a){const e=s[a];let d=i%e;a===t&&(d+=n),o+=d*l,l*=r[a],i=Math.floor(i/e)}a[o]=i[e]}n+=s[t]}}return new s(o,a,r)}function f(e,t=0){return K(e.map((e=>e.unsqueeze(t))),t)}function Q(e,t,r=null,n=!1,a=null){const o=t.data,i=t.dims;r=b(r,i.length);const s=i.slice();s[r]=1;const l=new o.constructor(o.length/i[r]);null!==a&&l.fill(a);for(let t=0;t<o.length;++t){let n=0;for(let e=i.length-1,a=t,o=1;e>=0;--e){const t=i[e];if(e!==r){n+=a%t*o,o*=s[e]}a=Math.floor(a/t)}l[n]=e(l[n],o[t],t,n)}return n||s.splice(r,1),[t.type,l,s]}function W(e,t=null,r=1,n=!1){const a=e.data,o=e.dims;if(null===t){const t=a.reduce(((e,t)=>e+t),0)/a.length,n=Math.sqrt(a.reduce(((e,r)=>e+(r-t)**2),0)/(a.length-r)),o=new s(e.type,[t],[]);return[new s(e.type,[n],[]),o]}const i=F(e,t=b(t,o.length),n),l=i.data,[d,u,c]=Q(((e,t,r,n)=>e+(t-l[n])**2),e,t,n);for(let e=0;e<u.length;++e)u[e]=Math.sqrt(u[e]/(o[t]-r));return[new s(d,u,c),i]}function F(e,t=null,r=!1){const n=e.dims,a=e.data;if(null===t){const t=a.reduce(((e,t)=>e+t),0);return new s(e.type,[t/a.length],[])}t=b(t,n.length);const[o,i,l]=Q(((e,t)=>e+t),e,t,r);if(1!==n[t])for(let e=0;e<i.length;++e)i[e]/=n[t];return new s(o,i,l)}function _(e,t,r,n){const a=e.reduce(((e,t)=>e*t),1);return new s(r,new n(a).fill(t),e)}function y(e,t){let r,n;if("number"==typeof t)r="float32",n=Float32Array;else if("bigint"==typeof t)r="int64",n=BigInt64Array;else{if("boolean"!=typeof t)throw new Error("Unsupported data type: "+typeof t);r="bool",n=Uint8Array}return _(e,t,r,n)}function v(e,t){return y(e.dims,t)}function E(e){return _(e,1n,"int64",BigInt64Array)}function G(e){return E(e.dims)}function R(e){return _(e,0n,"int64",BigInt64Array)}function x(e){return R(e.dims)}function S(e){const t=e.reduce(((e,t)=>e*t),1);return new s("float32",Float32Array.from({length:t},(()=>Math.random())),e)}function T(e,t){if(2!==e.dims.length)throw new Error("The tensor must have 2 dimensions");if(e.dims.at(-1)%8!=0)throw new Error("The last dimension of the tensor must be a multiple of 8");if(!["binary","ubinary"].includes(t))throw new Error("The precision must be either 'binary' or 'ubinary'");const r="binary"===t,n=r?"int8":"uint8",a=r?Int8Array:Uint8Array,o=e.data,i=new a(o.length/8);for(let e=0;e<o.length;++e){const t=o[e]>0?1:0,n=Math.floor(e/8),a=e%8;i[n]|=t<<7-a,r&&0===a&&(i[n]-=128)}return new s(n,i,[e.dims[0],e.dims[1]/8])}},"./src/utils/video.js":
/*!****************************!*\
  !*** ./src/utils/video.js ***!
  \****************************/(e,t,r)=>{r.r(t),r.d(t,{RawVideo:()=>i,RawVideoFrame:()=>o,load_video:()=>s});var n=r(/*! ./image.js */"./src/utils/image.js"),a=r(/*! ../env.js */"./src/env.js");class o{constructor(e,t){this.image=e,this.timestamp=t}}class i{constructor(e,t){e.length>0&&e[0]instanceof n.RawImage&&(e=e.map(((r,n)=>new o(r,(n+1)/(e.length+1)*t)))),this.frames=e,this.duration=t}get width(){return this.frames[0].image.width}get height(){return this.frames[0].image.height}get fps(){return this.frames.length/this.duration}}async function s(e,{num_frames:t=null,fps:r=null}={}){if(!a.apis.IS_BROWSER_ENV)throw new Error("`load_video` is currently only supported in browser environments.");if(null==t&&null==r)throw new Error("Either num_frames or fps must be provided.");const s=[],l=document.createElement("video");if(l.crossOrigin="anonymous",l.muted=!0,"string"==typeof e)l.src=e;else if(e instanceof Blob)l.src=URL.createObjectURL(e);else{if(!(e instanceof HTMLVideoElement))throw new Error("Invalid URL or video element provided.");l.src=e.src}if(await new Promise((e=>l.onloadedmetadata=e)),l.seekable.start(0)===l.seekable.end(0)){const e=await fetch(l.src),t=await e.blob();l.src=URL.createObjectURL(t),await new Promise((e=>l.onloadedmetadata=e))}const d=l.duration;let u,c;null!=t?(u=t,c=1===t?0:d/(t-1)):(c=1/r,u=Math.floor(d/c));let p=[];for(let e=0;e<u;++e)p.push(1===t?d/2:e*c);const g=document.createElement("canvas");g.width=l.videoWidth,g.height=l.videoHeight;const A=g.getContext("2d",{willReadFrequently:!0});for(const e of p){l.currentTime=e,await new Promise((e=>{l.onseeked=e})),A.drawImage(l,0,0,g.width,g.height);const t=A.getImageData(0,0,g.width,g.height),r=new n.RawImage(t.data,g.width,g.height,4),a=new o(r,e);s.push(a)}return l.remove(),new i(s,d)}}},__webpack_module_cache__={},leafPrototypes,getProto;function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var r=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](r,r.exports,__webpack_require__),r.exports}getProto=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,__webpack_require__.t=function(e,t){if(1&t&&(e=this(e)),8&t)return e;if("object"==typeof e&&e){if(4&t&&e.__esModule)return e;if(16&t&&"function"==typeof e.then)return e}var r=Object.create(null);__webpack_require__.r(r);var n={};leafPrototypes=leafPrototypes||[null,getProto({}),getProto([]),getProto(getProto)];for(var a=2&t&&e;"object"==typeof a&&!~leafPrototypes.indexOf(a);a=getProto(a))Object.getOwnPropertyNames(a).forEach((t=>n[t]=()=>e[t]));return n.default=()=>e,__webpack_require__.d(r,n),r},__webpack_require__.d=(e,t)=>{for(var r in t)__webpack_require__.o(t,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__={};(()=>{
/*!*****************************!*\
  !*** ./src/transformers.js ***!
  \*****************************/
__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{ASTFeatureExtractor:()=>c.ASTFeatureExtractor,ASTForAudioClassification:()=>r.ASTForAudioClassification,ASTModel:()=>r.ASTModel,ASTPreTrainedModel:()=>r.ASTPreTrainedModel,AlbertForMaskedLM:()=>r.AlbertForMaskedLM,AlbertForQuestionAnswering:()=>r.AlbertForQuestionAnswering,AlbertForSequenceClassification:()=>r.AlbertForSequenceClassification,AlbertModel:()=>r.AlbertModel,AlbertPreTrainedModel:()=>r.AlbertPreTrainedModel,AlbertTokenizer:()=>n.AlbertTokenizer,AudioClassificationPipeline:()=>t.AudioClassificationPipeline,AutoConfig:()=>a.AutoConfig,AutoFeatureExtractor:()=>p.AutoFeatureExtractor,AutoImageProcessor:()=>h.AutoImageProcessor,AutoModel:()=>r.AutoModel,AutoModelForAudioClassification:()=>r.AutoModelForAudioClassification,AutoModelForAudioFrameClassification:()=>r.AutoModelForAudioFrameClassification,AutoModelForAudioTextToText:()=>r.AutoModelForAudioTextToText,AutoModelForCTC:()=>r.AutoModelForCTC,AutoModelForCausalLM:()=>r.AutoModelForCausalLM,AutoModelForDepthEstimation:()=>r.AutoModelForDepthEstimation,AutoModelForDocumentQuestionAnswering:()=>r.AutoModelForDocumentQuestionAnswering,AutoModelForImageClassification:()=>r.AutoModelForImageClassification,AutoModelForImageFeatureExtraction:()=>r.AutoModelForImageFeatureExtraction,AutoModelForImageMatting:()=>r.AutoModelForImageMatting,AutoModelForImageSegmentation:()=>r.AutoModelForImageSegmentation,AutoModelForImageTextToText:()=>r.AutoModelForImageTextToText,AutoModelForImageToImage:()=>r.AutoModelForImageToImage,AutoModelForMaskGeneration:()=>r.AutoModelForMaskGeneration,AutoModelForMaskedLM:()=>r.AutoModelForMaskedLM,AutoModelForNormalEstimation:()=>r.AutoModelForNormalEstimation,AutoModelForObjectDetection:()=>r.AutoModelForObjectDetection,AutoModelForPoseEstimation:()=>r.AutoModelForPoseEstimation,AutoModelForQuestionAnswering:()=>r.AutoModelForQuestionAnswering,AutoModelForSemanticSegmentation:()=>r.AutoModelForSemanticSegmentation,AutoModelForSeq2SeqLM:()=>r.AutoModelForSeq2SeqLM,AutoModelForSequenceClassification:()=>r.AutoModelForSequenceClassification,AutoModelForSpeechSeq2Seq:()=>r.AutoModelForSpeechSeq2Seq,AutoModelForTextToSpectrogram:()=>r.AutoModelForTextToSpectrogram,AutoModelForTextToWaveform:()=>r.AutoModelForTextToWaveform,AutoModelForTokenClassification:()=>r.AutoModelForTokenClassification,AutoModelForUniversalSegmentation:()=>r.AutoModelForUniversalSegmentation,AutoModelForVision2Seq:()=>r.AutoModelForVision2Seq,AutoModelForXVector:()=>r.AutoModelForXVector,AutoModelForZeroShotObjectDetection:()=>r.AutoModelForZeroShotObjectDetection,AutoProcessor:()=>C.AutoProcessor,AutoTokenizer:()=>n.AutoTokenizer,AutomaticSpeechRecognitionPipeline:()=>t.AutomaticSpeechRecognitionPipeline,BackgroundRemovalPipeline:()=>t.BackgroundRemovalPipeline,BartForConditionalGeneration:()=>r.BartForConditionalGeneration,BartForSequenceClassification:()=>r.BartForSequenceClassification,BartModel:()=>r.BartModel,BartPretrainedModel:()=>r.BartPretrainedModel,BartTokenizer:()=>n.BartTokenizer,BaseModelOutput:()=>r.BaseModelOutput,BaseStreamer:()=>w.BaseStreamer,BeitFeatureExtractor:()=>A.BeitFeatureExtractor,BeitForImageClassification:()=>r.BeitForImageClassification,BeitModel:()=>r.BeitModel,BeitPreTrainedModel:()=>r.BeitPreTrainedModel,BertForMaskedLM:()=>r.BertForMaskedLM,BertForQuestionAnswering:()=>r.BertForQuestionAnswering,BertForSequenceClassification:()=>r.BertForSequenceClassification,BertForTokenClassification:()=>r.BertForTokenClassification,BertModel:()=>r.BertModel,BertPreTrainedModel:()=>r.BertPreTrainedModel,BertTokenizer:()=>n.BertTokenizer,BitImageProcessor:()=>A.BitImageProcessor,BlenderbotForConditionalGeneration:()=>r.BlenderbotForConditionalGeneration,BlenderbotModel:()=>r.BlenderbotModel,BlenderbotPreTrainedModel:()=>r.BlenderbotPreTrainedModel,BlenderbotSmallForConditionalGeneration:()=>r.BlenderbotSmallForConditionalGeneration,BlenderbotSmallModel:()=>r.BlenderbotSmallModel,BlenderbotSmallPreTrainedModel:()=>r.BlenderbotSmallPreTrainedModel,BlenderbotSmallTokenizer:()=>n.BlenderbotSmallTokenizer,BlenderbotTokenizer:()=>n.BlenderbotTokenizer,BloomForCausalLM:()=>r.BloomForCausalLM,BloomModel:()=>r.BloomModel,BloomPreTrainedModel:()=>r.BloomPreTrainedModel,BloomTokenizer:()=>n.BloomTokenizer,CLIPFeatureExtractor:()=>A.CLIPFeatureExtractor,CLIPImageProcessor:()=>A.CLIPImageProcessor,CLIPModel:()=>r.CLIPModel,CLIPPreTrainedModel:()=>r.CLIPPreTrainedModel,CLIPSegForImageSegmentation:()=>r.CLIPSegForImageSegmentation,CLIPSegModel:()=>r.CLIPSegModel,CLIPSegPreTrainedModel:()=>r.CLIPSegPreTrainedModel,CLIPTextModel:()=>r.CLIPTextModel,CLIPTextModelWithProjection:()=>r.CLIPTextModelWithProjection,CLIPTokenizer:()=>n.CLIPTokenizer,CLIPVisionModel:()=>r.CLIPVisionModel,CLIPVisionModelWithProjection:()=>r.CLIPVisionModelWithProjection,CamembertForMaskedLM:()=>r.CamembertForMaskedLM,CamembertForQuestionAnswering:()=>r.CamembertForQuestionAnswering,CamembertForSequenceClassification:()=>r.CamembertForSequenceClassification,CamembertForTokenClassification:()=>r.CamembertForTokenClassification,CamembertModel:()=>r.CamembertModel,CamembertPreTrainedModel:()=>r.CamembertPreTrainedModel,CamembertTokenizer:()=>n.CamembertTokenizer,CausalLMOutput:()=>r.CausalLMOutput,CausalLMOutputWithPast:()=>r.CausalLMOutputWithPast,ChineseCLIPFeatureExtractor:()=>A.ChineseCLIPFeatureExtractor,ChineseCLIPModel:()=>r.ChineseCLIPModel,ChineseCLIPPreTrainedModel:()=>r.ChineseCLIPPreTrainedModel,ClapAudioModelWithProjection:()=>r.ClapAudioModelWithProjection,ClapFeatureExtractor:()=>c.ClapFeatureExtractor,ClapModel:()=>r.ClapModel,ClapPreTrainedModel:()=>r.ClapPreTrainedModel,ClapTextModelWithProjection:()=>r.ClapTextModelWithProjection,ClassifierFreeGuidanceLogitsProcessor:()=>K.ClassifierFreeGuidanceLogitsProcessor,CodeGenForCausalLM:()=>r.CodeGenForCausalLM,CodeGenModel:()=>r.CodeGenModel,CodeGenPreTrainedModel:()=>r.CodeGenPreTrainedModel,CodeGenTokenizer:()=>n.CodeGenTokenizer,CodeLlamaTokenizer:()=>n.CodeLlamaTokenizer,CohereForCausalLM:()=>r.CohereForCausalLM,CohereModel:()=>r.CohereModel,CoherePreTrainedModel:()=>r.CoherePreTrainedModel,CohereTokenizer:()=>n.CohereTokenizer,ConvBertForMaskedLM:()=>r.ConvBertForMaskedLM,ConvBertForQuestionAnswering:()=>r.ConvBertForQuestionAnswering,ConvBertForSequenceClassification:()=>r.ConvBertForSequenceClassification,ConvBertForTokenClassification:()=>r.ConvBertForTokenClassification,ConvBertModel:()=>r.ConvBertModel,ConvBertPreTrainedModel:()=>r.ConvBertPreTrainedModel,ConvBertTokenizer:()=>n.ConvBertTokenizer,ConvNextFeatureExtractor:()=>A.ConvNextFeatureExtractor,ConvNextForImageClassification:()=>r.ConvNextForImageClassification,ConvNextImageProcessor:()=>A.ConvNextImageProcessor,ConvNextModel:()=>r.ConvNextModel,ConvNextPreTrainedModel:()=>r.ConvNextPreTrainedModel,ConvNextV2ForImageClassification:()=>r.ConvNextV2ForImageClassification,ConvNextV2Model:()=>r.ConvNextV2Model,ConvNextV2PreTrainedModel:()=>r.ConvNextV2PreTrainedModel,DPTFeatureExtractor:()=>A.DPTFeatureExtractor,DPTForDepthEstimation:()=>r.DPTForDepthEstimation,DPTImageProcessor:()=>A.DPTImageProcessor,DPTModel:()=>r.DPTModel,DPTPreTrainedModel:()=>r.DPTPreTrainedModel,DacDecoderModel:()=>r.DacDecoderModel,DacDecoderOutput:()=>r.DacDecoderOutput,DacEncoderModel:()=>r.DacEncoderModel,DacEncoderOutput:()=>r.DacEncoderOutput,DacFeatureExtractor:()=>c.DacFeatureExtractor,DacModel:()=>r.DacModel,DacPreTrainedModel:()=>r.DacPreTrainedModel,DataTypeMap:()=>l.DataTypeMap,DebertaForMaskedLM:()=>r.DebertaForMaskedLM,DebertaForQuestionAnswering:()=>r.DebertaForQuestionAnswering,DebertaForSequenceClassification:()=>r.DebertaForSequenceClassification,DebertaForTokenClassification:()=>r.DebertaForTokenClassification,DebertaModel:()=>r.DebertaModel,DebertaPreTrainedModel:()=>r.DebertaPreTrainedModel,DebertaTokenizer:()=>n.DebertaTokenizer,DebertaV2ForMaskedLM:()=>r.DebertaV2ForMaskedLM,DebertaV2ForQuestionAnswering:()=>r.DebertaV2ForQuestionAnswering,DebertaV2ForSequenceClassification:()=>r.DebertaV2ForSequenceClassification,DebertaV2ForTokenClassification:()=>r.DebertaV2ForTokenClassification,DebertaV2Model:()=>r.DebertaV2Model,DebertaV2PreTrainedModel:()=>r.DebertaV2PreTrainedModel,DebertaV2Tokenizer:()=>n.DebertaV2Tokenizer,DecisionTransformerModel:()=>r.DecisionTransformerModel,DecisionTransformerPreTrainedModel:()=>r.DecisionTransformerPreTrainedModel,DeiTFeatureExtractor:()=>A.DeiTFeatureExtractor,DeiTForImageClassification:()=>r.DeiTForImageClassification,DeiTImageProcessor:()=>A.DeiTImageProcessor,DeiTModel:()=>r.DeiTModel,DeiTPreTrainedModel:()=>r.DeiTPreTrainedModel,DepthAnythingForDepthEstimation:()=>r.DepthAnythingForDepthEstimation,DepthAnythingPreTrainedModel:()=>r.DepthAnythingPreTrainedModel,DepthEstimationPipeline:()=>t.DepthEstimationPipeline,DepthProForDepthEstimation:()=>r.DepthProForDepthEstimation,DepthProPreTrainedModel:()=>r.DepthProPreTrainedModel,DetrFeatureExtractor:()=>A.DetrFeatureExtractor,DetrForObjectDetection:()=>r.DetrForObjectDetection,DetrForSegmentation:()=>r.DetrForSegmentation,DetrImageProcessor:()=>A.DetrImageProcessor,DetrModel:()=>r.DetrModel,DetrObjectDetectionOutput:()=>r.DetrObjectDetectionOutput,DetrPreTrainedModel:()=>r.DetrPreTrainedModel,DetrSegmentationOutput:()=>r.DetrSegmentationOutput,Dinov2ForImageClassification:()=>r.Dinov2ForImageClassification,Dinov2Model:()=>r.Dinov2Model,Dinov2PreTrainedModel:()=>r.Dinov2PreTrainedModel,Dinov2WithRegistersForImageClassification:()=>r.Dinov2WithRegistersForImageClassification,Dinov2WithRegistersModel:()=>r.Dinov2WithRegistersModel,Dinov2WithRegistersPreTrainedModel:()=>r.Dinov2WithRegistersPreTrainedModel,DistilBertForMaskedLM:()=>r.DistilBertForMaskedLM,DistilBertForQuestionAnswering:()=>r.DistilBertForQuestionAnswering,DistilBertForSequenceClassification:()=>r.DistilBertForSequenceClassification,DistilBertForTokenClassification:()=>r.DistilBertForTokenClassification,DistilBertModel:()=>r.DistilBertModel,DistilBertPreTrainedModel:()=>r.DistilBertPreTrainedModel,DistilBertTokenizer:()=>n.DistilBertTokenizer,DocumentQuestionAnsweringPipeline:()=>t.DocumentQuestionAnsweringPipeline,DonutFeatureExtractor:()=>A.DonutFeatureExtractor,DonutImageProcessor:()=>A.DonutImageProcessor,DonutSwinModel:()=>r.DonutSwinModel,DonutSwinPreTrainedModel:()=>r.DonutSwinPreTrainedModel,EfficientNetForImageClassification:()=>r.EfficientNetForImageClassification,EfficientNetImageProcessor:()=>A.EfficientNetImageProcessor,EfficientNetModel:()=>r.EfficientNetModel,EfficientNetPreTrainedModel:()=>r.EfficientNetPreTrainedModel,ElectraForMaskedLM:()=>r.ElectraForMaskedLM,ElectraForQuestionAnswering:()=>r.ElectraForQuestionAnswering,ElectraForSequenceClassification:()=>r.ElectraForSequenceClassification,ElectraForTokenClassification:()=>r.ElectraForTokenClassification,ElectraModel:()=>r.ElectraModel,ElectraPreTrainedModel:()=>r.ElectraPreTrainedModel,ElectraTokenizer:()=>n.ElectraTokenizer,EncodecFeatureExtractor:()=>c.EncodecFeatureExtractor,EosTokenCriteria:()=>b.EosTokenCriteria,EsmForMaskedLM:()=>r.EsmForMaskedLM,EsmForSequenceClassification:()=>r.EsmForSequenceClassification,EsmForTokenClassification:()=>r.EsmForTokenClassification,EsmModel:()=>r.EsmModel,EsmPreTrainedModel:()=>r.EsmPreTrainedModel,EsmTokenizer:()=>n.EsmTokenizer,ExaoneForCausalLM:()=>r.ExaoneForCausalLM,ExaoneModel:()=>r.ExaoneModel,ExaonePreTrainedModel:()=>r.ExaonePreTrainedModel,FFT:()=>d.FFT,FalconForCausalLM:()=>r.FalconForCausalLM,FalconModel:()=>r.FalconModel,FalconPreTrainedModel:()=>r.FalconPreTrainedModel,FalconTokenizer:()=>n.FalconTokenizer,FastViTForImageClassification:()=>r.FastViTForImageClassification,FastViTModel:()=>r.FastViTModel,FastViTPreTrainedModel:()=>r.FastViTPreTrainedModel,FeatureExtractionPipeline:()=>t.FeatureExtractionPipeline,FeatureExtractor:()=>u.FeatureExtractor,FillMaskPipeline:()=>t.FillMaskPipeline,Florence2ForConditionalGeneration:()=>r.Florence2ForConditionalGeneration,Florence2PreTrainedModel:()=>r.Florence2PreTrainedModel,Florence2Processor:()=>m.Florence2Processor,ForcedBOSTokenLogitsProcessor:()=>K.ForcedBOSTokenLogitsProcessor,ForcedEOSTokenLogitsProcessor:()=>K.ForcedEOSTokenLogitsProcessor,GLPNFeatureExtractor:()=>A.GLPNFeatureExtractor,GLPNForDepthEstimation:()=>r.GLPNForDepthEstimation,GLPNModel:()=>r.GLPNModel,GLPNPreTrainedModel:()=>r.GLPNPreTrainedModel,GPT2LMHeadModel:()=>r.GPT2LMHeadModel,GPT2Model:()=>r.GPT2Model,GPT2PreTrainedModel:()=>r.GPT2PreTrainedModel,GPT2Tokenizer:()=>n.GPT2Tokenizer,GPTBigCodeForCausalLM:()=>r.GPTBigCodeForCausalLM,GPTBigCodeModel:()=>r.GPTBigCodeModel,GPTBigCodePreTrainedModel:()=>r.GPTBigCodePreTrainedModel,GPTJForCausalLM:()=>r.GPTJForCausalLM,GPTJModel:()=>r.GPTJModel,GPTJPreTrainedModel:()=>r.GPTJPreTrainedModel,GPTNeoForCausalLM:()=>r.GPTNeoForCausalLM,GPTNeoModel:()=>r.GPTNeoModel,GPTNeoPreTrainedModel:()=>r.GPTNeoPreTrainedModel,GPTNeoXForCausalLM:()=>r.GPTNeoXForCausalLM,GPTNeoXModel:()=>r.GPTNeoXModel,GPTNeoXPreTrainedModel:()=>r.GPTNeoXPreTrainedModel,GPTNeoXTokenizer:()=>n.GPTNeoXTokenizer,Gemma2ForCausalLM:()=>r.Gemma2ForCausalLM,Gemma2Model:()=>r.Gemma2Model,Gemma2PreTrainedModel:()=>r.Gemma2PreTrainedModel,GemmaForCausalLM:()=>r.GemmaForCausalLM,GemmaModel:()=>r.GemmaModel,GemmaPreTrainedModel:()=>r.GemmaPreTrainedModel,GemmaTokenizer:()=>n.GemmaTokenizer,GlmForCausalLM:()=>r.GlmForCausalLM,GlmModel:()=>r.GlmModel,GlmPreTrainedModel:()=>r.GlmPreTrainedModel,GraniteForCausalLM:()=>r.GraniteForCausalLM,GraniteModel:()=>r.GraniteModel,GranitePreTrainedModel:()=>r.GranitePreTrainedModel,Grok1Tokenizer:()=>n.Grok1Tokenizer,GroundingDinoForObjectDetection:()=>r.GroundingDinoForObjectDetection,GroundingDinoImageProcessor:()=>A.GroundingDinoImageProcessor,GroundingDinoPreTrainedModel:()=>r.GroundingDinoPreTrainedModel,GroundingDinoProcessor:()=>m.GroundingDinoProcessor,GroupViTModel:()=>r.GroupViTModel,GroupViTPreTrainedModel:()=>r.GroupViTPreTrainedModel,HeliumForCausalLM:()=>r.HeliumForCausalLM,HeliumModel:()=>r.HeliumModel,HeliumPreTrainedModel:()=>r.HeliumPreTrainedModel,HerbertTokenizer:()=>n.HerbertTokenizer,HieraForImageClassification:()=>r.HieraForImageClassification,HieraModel:()=>r.HieraModel,HieraPreTrainedModel:()=>r.HieraPreTrainedModel,HubertForCTC:()=>r.HubertForCTC,HubertForSequenceClassification:()=>r.HubertForSequenceClassification,HubertModel:()=>r.HubertModel,HubertPreTrainedModel:()=>r.HubertPreTrainedModel,IJepaForImageClassification:()=>r.IJepaForImageClassification,IJepaModel:()=>r.IJepaModel,IJepaPreTrainedModel:()=>r.IJepaPreTrainedModel,Idefics3ForConditionalGeneration:()=>r.Idefics3ForConditionalGeneration,Idefics3ImageProcessor:()=>A.Idefics3ImageProcessor,Idefics3PreTrainedModel:()=>r.Idefics3PreTrainedModel,Idefics3Processor:()=>m.Idefics3Processor,ImageClassificationPipeline:()=>t.ImageClassificationPipeline,ImageFeatureExtractionPipeline:()=>t.ImageFeatureExtractionPipeline,ImageFeatureExtractor:()=>c.ImageFeatureExtractor,ImageMattingOutput:()=>r.ImageMattingOutput,ImageProcessor:()=>g.ImageProcessor,ImageSegmentationPipeline:()=>t.ImageSegmentationPipeline,ImageToImagePipeline:()=>t.ImageToImagePipeline,ImageToTextPipeline:()=>t.ImageToTextPipeline,InterruptableStoppingCriteria:()=>b.InterruptableStoppingCriteria,JAISLMHeadModel:()=>r.JAISLMHeadModel,JAISModel:()=>r.JAISModel,JAISPreTrainedModel:()=>r.JAISPreTrainedModel,JinaCLIPImageProcessor:()=>A.JinaCLIPImageProcessor,JinaCLIPModel:()=>r.JinaCLIPModel,JinaCLIPPreTrainedModel:()=>r.JinaCLIPPreTrainedModel,JinaCLIPProcessor:()=>m.JinaCLIPProcessor,JinaCLIPTextModel:()=>r.JinaCLIPTextModel,JinaCLIPVisionModel:()=>r.JinaCLIPVisionModel,LiteWhisperForConditionalGeneration:()=>r.LiteWhisperForConditionalGeneration,LlamaForCausalLM:()=>r.LlamaForCausalLM,LlamaModel:()=>r.LlamaModel,LlamaPreTrainedModel:()=>r.LlamaPreTrainedModel,LlamaTokenizer:()=>n.LlamaTokenizer,LlavaForConditionalGeneration:()=>r.LlavaForConditionalGeneration,LlavaOnevisionForConditionalGeneration:()=>r.LlavaOnevisionForConditionalGeneration,LlavaOnevisionImageProcessor:()=>A.LlavaOnevisionImageProcessor,LlavaPreTrainedModel:()=>r.LlavaPreTrainedModel,LogitsProcessor:()=>K.LogitsProcessor,LogitsProcessorList:()=>K.LogitsProcessorList,LogitsWarper:()=>K.LogitsWarper,LongT5ForConditionalGeneration:()=>r.LongT5ForConditionalGeneration,LongT5Model:()=>r.LongT5Model,LongT5PreTrainedModel:()=>r.LongT5PreTrainedModel,M2M100ForConditionalGeneration:()=>r.M2M100ForConditionalGeneration,M2M100Model:()=>r.M2M100Model,M2M100PreTrainedModel:()=>r.M2M100PreTrainedModel,M2M100Tokenizer:()=>n.M2M100Tokenizer,MBart50Tokenizer:()=>n.MBart50Tokenizer,MBartForCausalLM:()=>r.MBartForCausalLM,MBartForConditionalGeneration:()=>r.MBartForConditionalGeneration,MBartForSequenceClassification:()=>r.MBartForSequenceClassification,MBartModel:()=>r.MBartModel,MBartPreTrainedModel:()=>r.MBartPreTrainedModel,MBartTokenizer:()=>n.MBartTokenizer,MPNetForMaskedLM:()=>r.MPNetForMaskedLM,MPNetForQuestionAnswering:()=>r.MPNetForQuestionAnswering,MPNetForSequenceClassification:()=>r.MPNetForSequenceClassification,MPNetForTokenClassification:()=>r.MPNetForTokenClassification,MPNetModel:()=>r.MPNetModel,MPNetPreTrainedModel:()=>r.MPNetPreTrainedModel,MPNetTokenizer:()=>n.MPNetTokenizer,MT5ForConditionalGeneration:()=>r.MT5ForConditionalGeneration,MT5Model:()=>r.MT5Model,MT5PreTrainedModel:()=>r.MT5PreTrainedModel,MarianMTModel:()=>r.MarianMTModel,MarianModel:()=>r.MarianModel,MarianPreTrainedModel:()=>r.MarianPreTrainedModel,MarianTokenizer:()=>n.MarianTokenizer,Mask2FormerImageProcessor:()=>A.Mask2FormerImageProcessor,MaskFormerFeatureExtractor:()=>A.MaskFormerFeatureExtractor,MaskFormerForInstanceSegmentation:()=>r.MaskFormerForInstanceSegmentation,MaskFormerImageProcessor:()=>A.MaskFormerImageProcessor,MaskFormerModel:()=>r.MaskFormerModel,MaskFormerPreTrainedModel:()=>r.MaskFormerPreTrainedModel,MaskedLMOutput:()=>r.MaskedLMOutput,MaxLengthCriteria:()=>b.MaxLengthCriteria,MgpstrForSceneTextRecognition:()=>r.MgpstrForSceneTextRecognition,MgpstrModelOutput:()=>r.MgpstrModelOutput,MgpstrPreTrainedModel:()=>r.MgpstrPreTrainedModel,MgpstrProcessor:()=>m.MgpstrProcessor,MgpstrTokenizer:()=>n.MgpstrTokenizer,MimiDecoderModel:()=>r.MimiDecoderModel,MimiDecoderOutput:()=>r.MimiDecoderOutput,MimiEncoderModel:()=>r.MimiEncoderModel,MimiEncoderOutput:()=>r.MimiEncoderOutput,MimiModel:()=>r.MimiModel,MimiPreTrainedModel:()=>r.MimiPreTrainedModel,MinLengthLogitsProcessor:()=>K.MinLengthLogitsProcessor,MinNewTokensLengthLogitsProcessor:()=>K.MinNewTokensLengthLogitsProcessor,MistralForCausalLM:()=>r.MistralForCausalLM,MistralModel:()=>r.MistralModel,MistralPreTrainedModel:()=>r.MistralPreTrainedModel,MobileBertForMaskedLM:()=>r.MobileBertForMaskedLM,MobileBertForQuestionAnswering:()=>r.MobileBertForQuestionAnswering,MobileBertForSequenceClassification:()=>r.MobileBertForSequenceClassification,MobileBertModel:()=>r.MobileBertModel,MobileBertPreTrainedModel:()=>r.MobileBertPreTrainedModel,MobileBertTokenizer:()=>n.MobileBertTokenizer,MobileLLMForCausalLM:()=>r.MobileLLMForCausalLM,MobileLLMModel:()=>r.MobileLLMModel,MobileLLMPreTrainedModel:()=>r.MobileLLMPreTrainedModel,MobileNetV1FeatureExtractor:()=>A.MobileNetV1FeatureExtractor,MobileNetV1ForImageClassification:()=>r.MobileNetV1ForImageClassification,MobileNetV1ForSemanticSegmentation:()=>r.MobileNetV1ForSemanticSegmentation,MobileNetV1ImageProcessor:()=>A.MobileNetV1ImageProcessor,MobileNetV1Model:()=>r.MobileNetV1Model,MobileNetV1PreTrainedModel:()=>r.MobileNetV1PreTrainedModel,MobileNetV2FeatureExtractor:()=>A.MobileNetV2FeatureExtractor,MobileNetV2ForImageClassification:()=>r.MobileNetV2ForImageClassification,MobileNetV2ForSemanticSegmentation:()=>r.MobileNetV2ForSemanticSegmentation,MobileNetV2ImageProcessor:()=>A.MobileNetV2ImageProcessor,MobileNetV2Model:()=>r.MobileNetV2Model,MobileNetV2PreTrainedModel:()=>r.MobileNetV2PreTrainedModel,MobileNetV3FeatureExtractor:()=>A.MobileNetV3FeatureExtractor,MobileNetV3ForImageClassification:()=>r.MobileNetV3ForImageClassification,MobileNetV3ForSemanticSegmentation:()=>r.MobileNetV3ForSemanticSegmentation,MobileNetV3ImageProcessor:()=>A.MobileNetV3ImageProcessor,MobileNetV3Model:()=>r.MobileNetV3Model,MobileNetV3PreTrainedModel:()=>r.MobileNetV3PreTrainedModel,MobileNetV4FeatureExtractor:()=>A.MobileNetV4FeatureExtractor,MobileNetV4ForImageClassification:()=>r.MobileNetV4ForImageClassification,MobileNetV4ForSemanticSegmentation:()=>r.MobileNetV4ForSemanticSegmentation,MobileNetV4ImageProcessor:()=>A.MobileNetV4ImageProcessor,MobileNetV4Model:()=>r.MobileNetV4Model,MobileNetV4PreTrainedModel:()=>r.MobileNetV4PreTrainedModel,MobileViTFeatureExtractor:()=>A.MobileViTFeatureExtractor,MobileViTForImageClassification:()=>r.MobileViTForImageClassification,MobileViTImageProcessor:()=>A.MobileViTImageProcessor,MobileViTModel:()=>r.MobileViTModel,MobileViTPreTrainedModel:()=>r.MobileViTPreTrainedModel,MobileViTV2ForImageClassification:()=>r.MobileViTV2ForImageClassification,MobileViTV2Model:()=>r.MobileViTV2Model,MobileViTV2PreTrainedModel:()=>r.MobileViTV2PreTrainedModel,ModelOutput:()=>r.ModelOutput,ModernBertForMaskedLM:()=>r.ModernBertForMaskedLM,ModernBertForSequenceClassification:()=>r.ModernBertForSequenceClassification,ModernBertForTokenClassification:()=>r.ModernBertForTokenClassification,ModernBertModel:()=>r.ModernBertModel,ModernBertPreTrainedModel:()=>r.ModernBertPreTrainedModel,Moondream1ForConditionalGeneration:()=>r.Moondream1ForConditionalGeneration,MoonshineFeatureExtractor:()=>c.MoonshineFeatureExtractor,MoonshineForConditionalGeneration:()=>r.MoonshineForConditionalGeneration,MoonshineModel:()=>r.MoonshineModel,MoonshinePreTrainedModel:()=>r.MoonshinePreTrainedModel,MoonshineProcessor:()=>m.MoonshineProcessor,MptForCausalLM:()=>r.MptForCausalLM,MptModel:()=>r.MptModel,MptPreTrainedModel:()=>r.MptPreTrainedModel,MultiModalityCausalLM:()=>r.MultiModalityCausalLM,MultiModalityPreTrainedModel:()=>r.MultiModalityPreTrainedModel,MusicgenForCausalLM:()=>r.MusicgenForCausalLM,MusicgenForConditionalGeneration:()=>r.MusicgenForConditionalGeneration,MusicgenModel:()=>r.MusicgenModel,MusicgenPreTrainedModel:()=>r.MusicgenPreTrainedModel,NllbTokenizer:()=>n.NllbTokenizer,NoBadWordsLogitsProcessor:()=>K.NoBadWordsLogitsProcessor,NoRepeatNGramLogitsProcessor:()=>K.NoRepeatNGramLogitsProcessor,NomicBertModel:()=>r.NomicBertModel,NomicBertPreTrainedModel:()=>r.NomicBertPreTrainedModel,NougatImageProcessor:()=>A.NougatImageProcessor,NougatTokenizer:()=>n.NougatTokenizer,OPTForCausalLM:()=>r.OPTForCausalLM,OPTModel:()=>r.OPTModel,OPTPreTrainedModel:()=>r.OPTPreTrainedModel,ObjectDetectionPipeline:()=>t.ObjectDetectionPipeline,Olmo2ForCausalLM:()=>r.Olmo2ForCausalLM,Olmo2Model:()=>r.Olmo2Model,Olmo2PreTrainedModel:()=>r.Olmo2PreTrainedModel,OlmoForCausalLM:()=>r.OlmoForCausalLM,OlmoModel:()=>r.OlmoModel,OlmoPreTrainedModel:()=>r.OlmoPreTrainedModel,OpenELMForCausalLM:()=>r.OpenELMForCausalLM,OpenELMModel:()=>r.OpenELMModel,OpenELMPreTrainedModel:()=>r.OpenELMPreTrainedModel,OwlViTFeatureExtractor:()=>A.OwlViTFeatureExtractor,OwlViTForObjectDetection:()=>r.OwlViTForObjectDetection,OwlViTImageProcessor:()=>A.OwlViTImageProcessor,OwlViTModel:()=>r.OwlViTModel,OwlViTPreTrainedModel:()=>r.OwlViTPreTrainedModel,OwlViTProcessor:()=>m.OwlViTProcessor,Owlv2ForObjectDetection:()=>r.Owlv2ForObjectDetection,Owlv2ImageProcessor:()=>A.Owlv2ImageProcessor,Owlv2Model:()=>r.Owlv2Model,Owlv2PreTrainedModel:()=>r.Owlv2PreTrainedModel,PaliGemmaForConditionalGeneration:()=>r.PaliGemmaForConditionalGeneration,PaliGemmaPreTrainedModel:()=>r.PaliGemmaPreTrainedModel,PaliGemmaProcessor:()=>m.PaliGemmaProcessor,PatchTSMixerForPrediction:()=>r.PatchTSMixerForPrediction,PatchTSMixerModel:()=>r.PatchTSMixerModel,PatchTSMixerPreTrainedModel:()=>r.PatchTSMixerPreTrainedModel,PatchTSTForPrediction:()=>r.PatchTSTForPrediction,PatchTSTModel:()=>r.PatchTSTModel,PatchTSTPreTrainedModel:()=>r.PatchTSTPreTrainedModel,Phi3ForCausalLM:()=>r.Phi3ForCausalLM,Phi3Model:()=>r.Phi3Model,Phi3PreTrainedModel:()=>r.Phi3PreTrainedModel,Phi3VForCausalLM:()=>r.Phi3VForCausalLM,Phi3VImageProcessor:()=>A.Phi3VImageProcessor,Phi3VPreTrainedModel:()=>r.Phi3VPreTrainedModel,Phi3VProcessor:()=>m.Phi3VProcessor,PhiForCausalLM:()=>r.PhiForCausalLM,PhiModel:()=>r.PhiModel,PhiPreTrainedModel:()=>r.PhiPreTrainedModel,Pipeline:()=>t.Pipeline,PreTrainedModel:()=>r.PreTrainedModel,PreTrainedTokenizer:()=>n.PreTrainedTokenizer,PretrainedConfig:()=>a.PretrainedConfig,PretrainedMixin:()=>r.PretrainedMixin,Processor:()=>B.Processor,PvtForImageClassification:()=>r.PvtForImageClassification,PvtImageProcessor:()=>A.PvtImageProcessor,PvtModel:()=>r.PvtModel,PvtPreTrainedModel:()=>r.PvtPreTrainedModel,PyAnnoteFeatureExtractor:()=>c.PyAnnoteFeatureExtractor,PyAnnoteForAudioFrameClassification:()=>r.PyAnnoteForAudioFrameClassification,PyAnnoteModel:()=>r.PyAnnoteModel,PyAnnotePreTrainedModel:()=>r.PyAnnotePreTrainedModel,PyAnnoteProcessor:()=>m.PyAnnoteProcessor,QuestionAnsweringModelOutput:()=>r.QuestionAnsweringModelOutput,QuestionAnsweringPipeline:()=>t.QuestionAnsweringPipeline,Qwen2ForCausalLM:()=>r.Qwen2ForCausalLM,Qwen2Model:()=>r.Qwen2Model,Qwen2PreTrainedModel:()=>r.Qwen2PreTrainedModel,Qwen2Tokenizer:()=>n.Qwen2Tokenizer,Qwen2VLForConditionalGeneration:()=>r.Qwen2VLForConditionalGeneration,Qwen2VLImageProcessor:()=>A.Qwen2VLImageProcessor,Qwen2VLPreTrainedModel:()=>r.Qwen2VLPreTrainedModel,Qwen2VLProcessor:()=>m.Qwen2VLProcessor,RTDetrForObjectDetection:()=>r.RTDetrForObjectDetection,RTDetrImageProcessor:()=>A.RTDetrImageProcessor,RTDetrModel:()=>r.RTDetrModel,RTDetrObjectDetectionOutput:()=>r.RTDetrObjectDetectionOutput,RTDetrPreTrainedModel:()=>r.RTDetrPreTrainedModel,RawAudio:()=>o.RawAudio,RawImage:()=>i.RawImage,RawVideo:()=>s.RawVideo,RawVideoFrame:()=>s.RawVideoFrame,RepetitionPenaltyLogitsProcessor:()=>K.RepetitionPenaltyLogitsProcessor,ResNetForImageClassification:()=>r.ResNetForImageClassification,ResNetModel:()=>r.ResNetModel,ResNetPreTrainedModel:()=>r.ResNetPreTrainedModel,RoFormerForMaskedLM:()=>r.RoFormerForMaskedLM,RoFormerForQuestionAnswering:()=>r.RoFormerForQuestionAnswering,RoFormerForSequenceClassification:()=>r.RoFormerForSequenceClassification,RoFormerForTokenClassification:()=>r.RoFormerForTokenClassification,RoFormerModel:()=>r.RoFormerModel,RoFormerPreTrainedModel:()=>r.RoFormerPreTrainedModel,RoFormerTokenizer:()=>n.RoFormerTokenizer,RobertaForMaskedLM:()=>r.RobertaForMaskedLM,RobertaForQuestionAnswering:()=>r.RobertaForQuestionAnswering,RobertaForSequenceClassification:()=>r.RobertaForSequenceClassification,RobertaForTokenClassification:()=>r.RobertaForTokenClassification,RobertaModel:()=>r.RobertaModel,RobertaPreTrainedModel:()=>r.RobertaPreTrainedModel,RobertaTokenizer:()=>n.RobertaTokenizer,SamImageProcessor:()=>A.SamImageProcessor,SamImageSegmentationOutput:()=>r.SamImageSegmentationOutput,SamModel:()=>r.SamModel,SamPreTrainedModel:()=>r.SamPreTrainedModel,SamProcessor:()=>m.SamProcessor,SapiensForDepthEstimation:()=>r.SapiensForDepthEstimation,SapiensForNormalEstimation:()=>r.SapiensForNormalEstimation,SapiensForSemanticSegmentation:()=>r.SapiensForSemanticSegmentation,SapiensPreTrainedModel:()=>r.SapiensPreTrainedModel,SeamlessM4TFeatureExtractor:()=>c.SeamlessM4TFeatureExtractor,SegformerFeatureExtractor:()=>A.SegformerFeatureExtractor,SegformerForImageClassification:()=>r.SegformerForImageClassification,SegformerForSemanticSegmentation:()=>r.SegformerForSemanticSegmentation,SegformerImageProcessor:()=>A.SegformerImageProcessor,SegformerModel:()=>r.SegformerModel,SegformerPreTrainedModel:()=>r.SegformerPreTrainedModel,Seq2SeqLMOutput:()=>r.Seq2SeqLMOutput,SequenceClassifierOutput:()=>r.SequenceClassifierOutput,SiglipImageProcessor:()=>A.SiglipImageProcessor,SiglipModel:()=>r.SiglipModel,SiglipPreTrainedModel:()=>r.SiglipPreTrainedModel,SiglipTextModel:()=>r.SiglipTextModel,SiglipTokenizer:()=>n.SiglipTokenizer,SiglipVisionModel:()=>r.SiglipVisionModel,SmolVLMForConditionalGeneration:()=>r.SmolVLMForConditionalGeneration,SmolVLMImageProcessor:()=>A.SmolVLMImageProcessor,SmolVLMProcessor:()=>m.SmolVLMProcessor,SpeechT5FeatureExtractor:()=>c.SpeechT5FeatureExtractor,SpeechT5ForSpeechToText:()=>r.SpeechT5ForSpeechToText,SpeechT5ForTextToSpeech:()=>r.SpeechT5ForTextToSpeech,SpeechT5HifiGan:()=>r.SpeechT5HifiGan,SpeechT5Model:()=>r.SpeechT5Model,SpeechT5PreTrainedModel:()=>r.SpeechT5PreTrainedModel,SpeechT5Processor:()=>m.SpeechT5Processor,SpeechT5Tokenizer:()=>n.SpeechT5Tokenizer,SqueezeBertForMaskedLM:()=>r.SqueezeBertForMaskedLM,SqueezeBertForQuestionAnswering:()=>r.SqueezeBertForQuestionAnswering,SqueezeBertForSequenceClassification:()=>r.SqueezeBertForSequenceClassification,SqueezeBertModel:()=>r.SqueezeBertModel,SqueezeBertPreTrainedModel:()=>r.SqueezeBertPreTrainedModel,SqueezeBertTokenizer:()=>n.SqueezeBertTokenizer,StableLmForCausalLM:()=>r.StableLmForCausalLM,StableLmModel:()=>r.StableLmModel,StableLmPreTrainedModel:()=>r.StableLmPreTrainedModel,Starcoder2ForCausalLM:()=>r.Starcoder2ForCausalLM,Starcoder2Model:()=>r.Starcoder2Model,Starcoder2PreTrainedModel:()=>r.Starcoder2PreTrainedModel,StoppingCriteria:()=>b.StoppingCriteria,StoppingCriteriaList:()=>b.StoppingCriteriaList,StyleTextToSpeech2Model:()=>r.StyleTextToSpeech2Model,StyleTextToSpeech2PreTrainedModel:()=>r.StyleTextToSpeech2PreTrainedModel,SummarizationPipeline:()=>t.SummarizationPipeline,SuppressTokensAtBeginLogitsProcessor:()=>K.SuppressTokensAtBeginLogitsProcessor,Swin2SRForImageSuperResolution:()=>r.Swin2SRForImageSuperResolution,Swin2SRImageProcessor:()=>A.Swin2SRImageProcessor,Swin2SRModel:()=>r.Swin2SRModel,Swin2SRPreTrainedModel:()=>r.Swin2SRPreTrainedModel,SwinForImageClassification:()=>r.SwinForImageClassification,SwinForSemanticSegmentation:()=>r.SwinForSemanticSegmentation,SwinModel:()=>r.SwinModel,SwinPreTrainedModel:()=>r.SwinPreTrainedModel,T5ForConditionalGeneration:()=>r.T5ForConditionalGeneration,T5Model:()=>r.T5Model,T5PreTrainedModel:()=>r.T5PreTrainedModel,T5Tokenizer:()=>n.T5Tokenizer,TableTransformerForObjectDetection:()=>r.TableTransformerForObjectDetection,TableTransformerModel:()=>r.TableTransformerModel,TableTransformerObjectDetectionOutput:()=>r.TableTransformerObjectDetectionOutput,TableTransformerPreTrainedModel:()=>r.TableTransformerPreTrainedModel,TemperatureLogitsWarper:()=>K.TemperatureLogitsWarper,Tensor:()=>l.Tensor,Text2TextGenerationPipeline:()=>t.Text2TextGenerationPipeline,TextClassificationPipeline:()=>t.TextClassificationPipeline,TextGenerationPipeline:()=>t.TextGenerationPipeline,TextStreamer:()=>w.TextStreamer,TextToAudioPipeline:()=>t.TextToAudioPipeline,TokenClassificationPipeline:()=>t.TokenClassificationPipeline,TokenClassifierOutput:()=>r.TokenClassifierOutput,TokenizerModel:()=>n.TokenizerModel,TopKLogitsWarper:()=>K.TopKLogitsWarper,TopPLogitsWarper:()=>K.TopPLogitsWarper,TrOCRForCausalLM:()=>r.TrOCRForCausalLM,TrOCRPreTrainedModel:()=>r.TrOCRPreTrainedModel,TranslationPipeline:()=>t.TranslationPipeline,UltravoxModel:()=>r.UltravoxModel,UltravoxPreTrainedModel:()=>r.UltravoxPreTrainedModel,UltravoxProcessor:()=>m.UltravoxProcessor,UniSpeechForCTC:()=>r.UniSpeechForCTC,UniSpeechForSequenceClassification:()=>r.UniSpeechForSequenceClassification,UniSpeechModel:()=>r.UniSpeechModel,UniSpeechPreTrainedModel:()=>r.UniSpeechPreTrainedModel,UniSpeechSatForAudioFrameClassification:()=>r.UniSpeechSatForAudioFrameClassification,UniSpeechSatForCTC:()=>r.UniSpeechSatForCTC,UniSpeechSatForSequenceClassification:()=>r.UniSpeechSatForSequenceClassification,UniSpeechSatModel:()=>r.UniSpeechSatModel,UniSpeechSatPreTrainedModel:()=>r.UniSpeechSatPreTrainedModel,VLChatProcessor:()=>m.VLChatProcessor,VLMImageProcessor:()=>A.VLMImageProcessor,ViTFeatureExtractor:()=>A.ViTFeatureExtractor,ViTForImageClassification:()=>r.ViTForImageClassification,ViTImageProcessor:()=>A.ViTImageProcessor,ViTMAEModel:()=>r.ViTMAEModel,ViTMAEPreTrainedModel:()=>r.ViTMAEPreTrainedModel,ViTMSNForImageClassification:()=>r.ViTMSNForImageClassification,ViTMSNModel:()=>r.ViTMSNModel,ViTMSNPreTrainedModel:()=>r.ViTMSNPreTrainedModel,ViTModel:()=>r.ViTModel,ViTPreTrainedModel:()=>r.ViTPreTrainedModel,VisionEncoderDecoderModel:()=>r.VisionEncoderDecoderModel,VitMatteForImageMatting:()=>r.VitMatteForImageMatting,VitMatteImageProcessor:()=>A.VitMatteImageProcessor,VitMattePreTrainedModel:()=>r.VitMattePreTrainedModel,VitPoseForPoseEstimation:()=>r.VitPoseForPoseEstimation,VitPoseImageProcessor:()=>A.VitPoseImageProcessor,VitPosePreTrainedModel:()=>r.VitPosePreTrainedModel,VitsModel:()=>r.VitsModel,VitsModelOutput:()=>r.VitsModelOutput,VitsPreTrainedModel:()=>r.VitsPreTrainedModel,VitsTokenizer:()=>n.VitsTokenizer,Wav2Vec2BertForCTC:()=>r.Wav2Vec2BertForCTC,Wav2Vec2BertForSequenceClassification:()=>r.Wav2Vec2BertForSequenceClassification,Wav2Vec2BertModel:()=>r.Wav2Vec2BertModel,Wav2Vec2BertPreTrainedModel:()=>r.Wav2Vec2BertPreTrainedModel,Wav2Vec2CTCTokenizer:()=>n.Wav2Vec2CTCTokenizer,Wav2Vec2FeatureExtractor:()=>c.Wav2Vec2FeatureExtractor,Wav2Vec2ForAudioFrameClassification:()=>r.Wav2Vec2ForAudioFrameClassification,Wav2Vec2ForCTC:()=>r.Wav2Vec2ForCTC,Wav2Vec2ForSequenceClassification:()=>r.Wav2Vec2ForSequenceClassification,Wav2Vec2Model:()=>r.Wav2Vec2Model,Wav2Vec2PreTrainedModel:()=>r.Wav2Vec2PreTrainedModel,Wav2Vec2Processor:()=>m.Wav2Vec2Processor,Wav2Vec2ProcessorWithLM:()=>m.Wav2Vec2ProcessorWithLM,WavLMForAudioFrameClassification:()=>r.WavLMForAudioFrameClassification,WavLMForCTC:()=>r.WavLMForCTC,WavLMForSequenceClassification:()=>r.WavLMForSequenceClassification,WavLMForXVector:()=>r.WavLMForXVector,WavLMModel:()=>r.WavLMModel,WavLMPreTrainedModel:()=>r.WavLMPreTrainedModel,WeSpeakerFeatureExtractor:()=>c.WeSpeakerFeatureExtractor,WeSpeakerResNetModel:()=>r.WeSpeakerResNetModel,WeSpeakerResNetPreTrainedModel:()=>r.WeSpeakerResNetPreTrainedModel,WhisperFeatureExtractor:()=>c.WhisperFeatureExtractor,WhisperForConditionalGeneration:()=>r.WhisperForConditionalGeneration,WhisperModel:()=>r.WhisperModel,WhisperPreTrainedModel:()=>r.WhisperPreTrainedModel,WhisperProcessor:()=>m.WhisperProcessor,WhisperTextStreamer:()=>w.WhisperTextStreamer,WhisperTimeStampLogitsProcessor:()=>K.WhisperTimeStampLogitsProcessor,WhisperTokenizer:()=>n.WhisperTokenizer,XLMForQuestionAnswering:()=>r.XLMForQuestionAnswering,XLMForSequenceClassification:()=>r.XLMForSequenceClassification,XLMForTokenClassification:()=>r.XLMForTokenClassification,XLMModel:()=>r.XLMModel,XLMPreTrainedModel:()=>r.XLMPreTrainedModel,XLMRobertaForMaskedLM:()=>r.XLMRobertaForMaskedLM,XLMRobertaForQuestionAnswering:()=>r.XLMRobertaForQuestionAnswering,XLMRobertaForSequenceClassification:()=>r.XLMRobertaForSequenceClassification,XLMRobertaForTokenClassification:()=>r.XLMRobertaForTokenClassification,XLMRobertaModel:()=>r.XLMRobertaModel,XLMRobertaPreTrainedModel:()=>r.XLMRobertaPreTrainedModel,XLMRobertaTokenizer:()=>n.XLMRobertaTokenizer,XLMTokenizer:()=>n.XLMTokenizer,XLMWithLMHeadModel:()=>r.XLMWithLMHeadModel,XVectorOutput:()=>r.XVectorOutput,YolosFeatureExtractor:()=>A.YolosFeatureExtractor,YolosForObjectDetection:()=>r.YolosForObjectDetection,YolosImageProcessor:()=>A.YolosImageProcessor,YolosModel:()=>r.YolosModel,YolosObjectDetectionOutput:()=>r.YolosObjectDetectionOutput,YolosPreTrainedModel:()=>r.YolosPreTrainedModel,ZeroShotAudioClassificationPipeline:()=>t.ZeroShotAudioClassificationPipeline,ZeroShotClassificationPipeline:()=>t.ZeroShotClassificationPipeline,ZeroShotImageClassificationPipeline:()=>t.ZeroShotImageClassificationPipeline,ZeroShotObjectDetectionPipeline:()=>t.ZeroShotObjectDetectionPipeline,bankers_round:()=>d.bankers_round,cat:()=>l.cat,cos_sim:()=>d.cos_sim,dot:()=>d.dot,dynamic_time_warping:()=>d.dynamic_time_warping,env:()=>e.env,full:()=>l.full,full_like:()=>l.full_like,getKeyValueShapes:()=>a.getKeyValueShapes,hamming:()=>o.hamming,hanning:()=>o.hanning,interpolate:()=>l.interpolate,interpolate_4d:()=>l.interpolate_4d,interpolate_data:()=>d.interpolate_data,is_chinese_char:()=>n.is_chinese_char,layer_norm:()=>l.layer_norm,load_image:()=>i.load_image,load_video:()=>s.load_video,log_softmax:()=>d.log_softmax,magnitude:()=>d.magnitude,matmul:()=>l.matmul,max:()=>d.max,mean:()=>l.mean,mean_pooling:()=>l.mean_pooling,medianFilter:()=>d.medianFilter,mel_filter_bank:()=>o.mel_filter_bank,min:()=>d.min,ones:()=>l.ones,ones_like:()=>l.ones_like,permute:()=>l.permute,permute_data:()=>d.permute_data,pipeline:()=>t.pipeline,quantize_embeddings:()=>l.quantize_embeddings,rand:()=>l.rand,read_audio:()=>o.read_audio,rfft:()=>l.rfft,round:()=>d.round,slice:()=>l.slice,softmax:()=>d.softmax,spectrogram:()=>o.spectrogram,stack:()=>l.stack,std_mean:()=>l.std_mean,topk:()=>l.topk,window_function:()=>o.window_function,zeros:()=>l.zeros,zeros_like:()=>l.zeros_like});var e=__webpack_require__(/*! ./env.js */"./src/env.js"),t=__webpack_require__(/*! ./pipelines.js */"./src/pipelines.js"),r=__webpack_require__(/*! ./models.js */"./src/models.js"),n=__webpack_require__(/*! ./tokenizers.js */"./src/tokenizers.js"),a=__webpack_require__(/*! ./configs.js */"./src/configs.js"),o=__webpack_require__(/*! ./utils/audio.js */"./src/utils/audio.js"),i=__webpack_require__(/*! ./utils/image.js */"./src/utils/image.js"),s=__webpack_require__(/*! ./utils/video.js */"./src/utils/video.js"),l=__webpack_require__(/*! ./utils/tensor.js */"./src/utils/tensor.js"),d=__webpack_require__(/*! ./utils/maths.js */"./src/utils/maths.js"),u=__webpack_require__(/*! ./base/feature_extraction_utils.js */"./src/base/feature_extraction_utils.js"),c=__webpack_require__(/*! ./models/feature_extractors.js */"./src/models/feature_extractors.js"),p=__webpack_require__(/*! ./models/auto/feature_extraction_auto.js */"./src/models/auto/feature_extraction_auto.js"),g=__webpack_require__(/*! ./base/image_processors_utils.js */"./src/base/image_processors_utils.js"),A=__webpack_require__(/*! ./models/image_processors.js */"./src/models/image_processors.js"),h=__webpack_require__(/*! ./models/auto/image_processing_auto.js */"./src/models/auto/image_processing_auto.js"),B=__webpack_require__(/*! ./base/processing_utils.js */"./src/base/processing_utils.js"),m=__webpack_require__(/*! ./models/processors.js */"./src/models/processors.js"),C=__webpack_require__(/*! ./models/auto/processing_auto.js */"./src/models/auto/processing_auto.js"),w=__webpack_require__(/*! ./generation/streamers.js */"./src/generation/streamers.js"),b=__webpack_require__(/*! ./generation/stopping_criteria.js */"./src/generation/stopping_criteria.js"),K=__webpack_require__(/*! ./generation/logits_process.js */"./src/generation/logits_process.js")})(),__webpack_exports__.ASTFeatureExtractor,__webpack_exports__.ASTForAudioClassification,__webpack_exports__.ASTModel,__webpack_exports__.ASTPreTrainedModel,__webpack_exports__.AlbertForMaskedLM,__webpack_exports__.AlbertForQuestionAnswering,__webpack_exports__.AlbertForSequenceClassification,__webpack_exports__.AlbertModel,__webpack_exports__.AlbertPreTrainedModel,__webpack_exports__.AlbertTokenizer,__webpack_exports__.AudioClassificationPipeline,__webpack_exports__.AutoConfig,__webpack_exports__.AutoFeatureExtractor,__webpack_exports__.AutoImageProcessor,__webpack_exports__.AutoModel,__webpack_exports__.AutoModelForAudioClassification,__webpack_exports__.AutoModelForAudioFrameClassification,__webpack_exports__.AutoModelForAudioTextToText,__webpack_exports__.AutoModelForCTC,__webpack_exports__.AutoModelForCausalLM,__webpack_exports__.AutoModelForDepthEstimation,__webpack_exports__.AutoModelForDocumentQuestionAnswering,__webpack_exports__.AutoModelForImageClassification,__webpack_exports__.AutoModelForImageFeatureExtraction,__webpack_exports__.AutoModelForImageMatting,__webpack_exports__.AutoModelForImageSegmentation,__webpack_exports__.AutoModelForImageTextToText,__webpack_exports__.AutoModelForImageToImage,__webpack_exports__.AutoModelForMaskGeneration,__webpack_exports__.AutoModelForMaskedLM,__webpack_exports__.AutoModelForNormalEstimation,__webpack_exports__.AutoModelForObjectDetection,__webpack_exports__.AutoModelForPoseEstimation,__webpack_exports__.AutoModelForQuestionAnswering,__webpack_exports__.AutoModelForSemanticSegmentation,__webpack_exports__.AutoModelForSeq2SeqLM,__webpack_exports__.AutoModelForSequenceClassification,__webpack_exports__.AutoModelForSpeechSeq2Seq,__webpack_exports__.AutoModelForTextToSpectrogram,__webpack_exports__.AutoModelForTextToWaveform,__webpack_exports__.AutoModelForTokenClassification,__webpack_exports__.AutoModelForUniversalSegmentation,__webpack_exports__.AutoModelForVision2Seq,__webpack_exports__.AutoModelForXVector,__webpack_exports__.AutoModelForZeroShotObjectDetection,__webpack_exports__.AutoProcessor,__webpack_exports__.AutoTokenizer,__webpack_exports__.AutomaticSpeechRecognitionPipeline,__webpack_exports__.BackgroundRemovalPipeline,__webpack_exports__.BartForConditionalGeneration,__webpack_exports__.BartForSequenceClassification,__webpack_exports__.BartModel,__webpack_exports__.BartPretrainedModel,__webpack_exports__.BartTokenizer,__webpack_exports__.BaseModelOutput,__webpack_exports__.BaseStreamer,__webpack_exports__.BeitFeatureExtractor,__webpack_exports__.BeitForImageClassification,__webpack_exports__.BeitModel,__webpack_exports__.BeitPreTrainedModel,__webpack_exports__.BertForMaskedLM,__webpack_exports__.BertForQuestionAnswering,__webpack_exports__.BertForSequenceClassification,__webpack_exports__.BertForTokenClassification,__webpack_exports__.BertModel,__webpack_exports__.BertPreTrainedModel,__webpack_exports__.BertTokenizer,__webpack_exports__.BitImageProcessor,__webpack_exports__.BlenderbotForConditionalGeneration,__webpack_exports__.BlenderbotModel,__webpack_exports__.BlenderbotPreTrainedModel,__webpack_exports__.BlenderbotSmallForConditionalGeneration,__webpack_exports__.BlenderbotSmallModel,__webpack_exports__.BlenderbotSmallPreTrainedModel,__webpack_exports__.BlenderbotSmallTokenizer,__webpack_exports__.BlenderbotTokenizer,__webpack_exports__.BloomForCausalLM,__webpack_exports__.BloomModel,__webpack_exports__.BloomPreTrainedModel,__webpack_exports__.BloomTokenizer,__webpack_exports__.CLIPFeatureExtractor,__webpack_exports__.CLIPImageProcessor,__webpack_exports__.CLIPModel,__webpack_exports__.CLIPPreTrainedModel,__webpack_exports__.CLIPSegForImageSegmentation,__webpack_exports__.CLIPSegModel,__webpack_exports__.CLIPSegPreTrainedModel,__webpack_exports__.CLIPTextModel,__webpack_exports__.CLIPTextModelWithProjection,__webpack_exports__.CLIPTokenizer,__webpack_exports__.CLIPVisionModel,__webpack_exports__.CLIPVisionModelWithProjection,__webpack_exports__.CamembertForMaskedLM,__webpack_exports__.CamembertForQuestionAnswering,__webpack_exports__.CamembertForSequenceClassification,__webpack_exports__.CamembertForTokenClassification,__webpack_exports__.CamembertModel,__webpack_exports__.CamembertPreTrainedModel,__webpack_exports__.CamembertTokenizer,__webpack_exports__.CausalLMOutput,__webpack_exports__.CausalLMOutputWithPast,__webpack_exports__.ChineseCLIPFeatureExtractor,__webpack_exports__.ChineseCLIPModel,__webpack_exports__.ChineseCLIPPreTrainedModel,__webpack_exports__.ClapAudioModelWithProjection,__webpack_exports__.ClapFeatureExtractor,__webpack_exports__.ClapModel,__webpack_exports__.ClapPreTrainedModel,__webpack_exports__.ClapTextModelWithProjection,__webpack_exports__.ClassifierFreeGuidanceLogitsProcessor,__webpack_exports__.CodeGenForCausalLM,__webpack_exports__.CodeGenModel,__webpack_exports__.CodeGenPreTrainedModel,__webpack_exports__.CodeGenTokenizer,__webpack_exports__.CodeLlamaTokenizer,__webpack_exports__.CohereForCausalLM,__webpack_exports__.CohereModel,__webpack_exports__.CoherePreTrainedModel,__webpack_exports__.CohereTokenizer,__webpack_exports__.ConvBertForMaskedLM,__webpack_exports__.ConvBertForQuestionAnswering,__webpack_exports__.ConvBertForSequenceClassification,__webpack_exports__.ConvBertForTokenClassification,__webpack_exports__.ConvBertModel,__webpack_exports__.ConvBertPreTrainedModel,__webpack_exports__.ConvBertTokenizer,__webpack_exports__.ConvNextFeatureExtractor,__webpack_exports__.ConvNextForImageClassification,__webpack_exports__.ConvNextImageProcessor,__webpack_exports__.ConvNextModel,__webpack_exports__.ConvNextPreTrainedModel,__webpack_exports__.ConvNextV2ForImageClassification,__webpack_exports__.ConvNextV2Model,__webpack_exports__.ConvNextV2PreTrainedModel,__webpack_exports__.DPTFeatureExtractor,__webpack_exports__.DPTForDepthEstimation,__webpack_exports__.DPTImageProcessor,__webpack_exports__.DPTModel,__webpack_exports__.DPTPreTrainedModel,__webpack_exports__.DacDecoderModel,__webpack_exports__.DacDecoderOutput,__webpack_exports__.DacEncoderModel,__webpack_exports__.DacEncoderOutput,__webpack_exports__.DacFeatureExtractor,__webpack_exports__.DacModel,__webpack_exports__.DacPreTrainedModel,__webpack_exports__.DataTypeMap,__webpack_exports__.DebertaForMaskedLM,__webpack_exports__.DebertaForQuestionAnswering,__webpack_exports__.DebertaForSequenceClassification,__webpack_exports__.DebertaForTokenClassification,__webpack_exports__.DebertaModel,__webpack_exports__.DebertaPreTrainedModel,__webpack_exports__.DebertaTokenizer,__webpack_exports__.DebertaV2ForMaskedLM,__webpack_exports__.DebertaV2ForQuestionAnswering,__webpack_exports__.DebertaV2ForSequenceClassification,__webpack_exports__.DebertaV2ForTokenClassification,__webpack_exports__.DebertaV2Model,__webpack_exports__.DebertaV2PreTrainedModel,__webpack_exports__.DebertaV2Tokenizer,__webpack_exports__.DecisionTransformerModel,__webpack_exports__.DecisionTransformerPreTrainedModel,__webpack_exports__.DeiTFeatureExtractor,__webpack_exports__.DeiTForImageClassification,__webpack_exports__.DeiTImageProcessor,__webpack_exports__.DeiTModel,__webpack_exports__.DeiTPreTrainedModel,__webpack_exports__.DepthAnythingForDepthEstimation,__webpack_exports__.DepthAnythingPreTrainedModel,__webpack_exports__.DepthEstimationPipeline,__webpack_exports__.DepthProForDepthEstimation,__webpack_exports__.DepthProPreTrainedModel,__webpack_exports__.DetrFeatureExtractor,__webpack_exports__.DetrForObjectDetection,__webpack_exports__.DetrForSegmentation,__webpack_exports__.DetrImageProcessor,__webpack_exports__.DetrModel,__webpack_exports__.DetrObjectDetectionOutput,__webpack_exports__.DetrPreTrainedModel,__webpack_exports__.DetrSegmentationOutput,__webpack_exports__.Dinov2ForImageClassification,__webpack_exports__.Dinov2Model,__webpack_exports__.Dinov2PreTrainedModel,__webpack_exports__.Dinov2WithRegistersForImageClassification,__webpack_exports__.Dinov2WithRegistersModel,__webpack_exports__.Dinov2WithRegistersPreTrainedModel,__webpack_exports__.DistilBertForMaskedLM,__webpack_exports__.DistilBertForQuestionAnswering,__webpack_exports__.DistilBertForSequenceClassification,__webpack_exports__.DistilBertForTokenClassification,__webpack_exports__.DistilBertModel,__webpack_exports__.DistilBertPreTrainedModel,__webpack_exports__.DistilBertTokenizer,__webpack_exports__.DocumentQuestionAnsweringPipeline,__webpack_exports__.DonutFeatureExtractor,__webpack_exports__.DonutImageProcessor,__webpack_exports__.DonutSwinModel,__webpack_exports__.DonutSwinPreTrainedModel,__webpack_exports__.EfficientNetForImageClassification,__webpack_exports__.EfficientNetImageProcessor,__webpack_exports__.EfficientNetModel,__webpack_exports__.EfficientNetPreTrainedModel,__webpack_exports__.ElectraForMaskedLM,__webpack_exports__.ElectraForQuestionAnswering,__webpack_exports__.ElectraForSequenceClassification,__webpack_exports__.ElectraForTokenClassification,__webpack_exports__.ElectraModel,__webpack_exports__.ElectraPreTrainedModel,__webpack_exports__.ElectraTokenizer,__webpack_exports__.EncodecFeatureExtractor,__webpack_exports__.EosTokenCriteria,__webpack_exports__.EsmForMaskedLM,__webpack_exports__.EsmForSequenceClassification,__webpack_exports__.EsmForTokenClassification,__webpack_exports__.EsmModel,__webpack_exports__.EsmPreTrainedModel,__webpack_exports__.EsmTokenizer,__webpack_exports__.ExaoneForCausalLM,__webpack_exports__.ExaoneModel,__webpack_exports__.ExaonePreTrainedModel,__webpack_exports__.FFT,__webpack_exports__.FalconForCausalLM,__webpack_exports__.FalconModel,__webpack_exports__.FalconPreTrainedModel,__webpack_exports__.FalconTokenizer,__webpack_exports__.FastViTForImageClassification,__webpack_exports__.FastViTModel,__webpack_exports__.FastViTPreTrainedModel,__webpack_exports__.FeatureExtractionPipeline,__webpack_exports__.FeatureExtractor,__webpack_exports__.FillMaskPipeline,__webpack_exports__.Florence2ForConditionalGeneration,__webpack_exports__.Florence2PreTrainedModel,__webpack_exports__.Florence2Processor,__webpack_exports__.ForcedBOSTokenLogitsProcessor,__webpack_exports__.ForcedEOSTokenLogitsProcessor,__webpack_exports__.GLPNFeatureExtractor,__webpack_exports__.GLPNForDepthEstimation,__webpack_exports__.GLPNModel,__webpack_exports__.GLPNPreTrainedModel,__webpack_exports__.GPT2LMHeadModel,__webpack_exports__.GPT2Model,__webpack_exports__.GPT2PreTrainedModel,__webpack_exports__.GPT2Tokenizer,__webpack_exports__.GPTBigCodeForCausalLM,__webpack_exports__.GPTBigCodeModel,__webpack_exports__.GPTBigCodePreTrainedModel,__webpack_exports__.GPTJForCausalLM,__webpack_exports__.GPTJModel,__webpack_exports__.GPTJPreTrainedModel,__webpack_exports__.GPTNeoForCausalLM,__webpack_exports__.GPTNeoModel,__webpack_exports__.GPTNeoPreTrainedModel,__webpack_exports__.GPTNeoXForCausalLM,__webpack_exports__.GPTNeoXModel,__webpack_exports__.GPTNeoXPreTrainedModel,__webpack_exports__.GPTNeoXTokenizer,__webpack_exports__.Gemma2ForCausalLM,__webpack_exports__.Gemma2Model,__webpack_exports__.Gemma2PreTrainedModel,__webpack_exports__.GemmaForCausalLM,__webpack_exports__.GemmaModel,__webpack_exports__.GemmaPreTrainedModel,__webpack_exports__.GemmaTokenizer,__webpack_exports__.GlmForCausalLM,__webpack_exports__.GlmModel,__webpack_exports__.GlmPreTrainedModel,__webpack_exports__.GraniteForCausalLM,__webpack_exports__.GraniteModel,__webpack_exports__.GranitePreTrainedModel,__webpack_exports__.Grok1Tokenizer,__webpack_exports__.GroundingDinoForObjectDetection,__webpack_exports__.GroundingDinoImageProcessor,__webpack_exports__.GroundingDinoPreTrainedModel,__webpack_exports__.GroundingDinoProcessor,__webpack_exports__.GroupViTModel,__webpack_exports__.GroupViTPreTrainedModel,__webpack_exports__.HeliumForCausalLM,__webpack_exports__.HeliumModel,__webpack_exports__.HeliumPreTrainedModel,__webpack_exports__.HerbertTokenizer,__webpack_exports__.HieraForImageClassification,__webpack_exports__.HieraModel,__webpack_exports__.HieraPreTrainedModel,__webpack_exports__.HubertForCTC,__webpack_exports__.HubertForSequenceClassification,__webpack_exports__.HubertModel,__webpack_exports__.HubertPreTrainedModel,__webpack_exports__.IJepaForImageClassification,__webpack_exports__.IJepaModel,__webpack_exports__.IJepaPreTrainedModel,__webpack_exports__.Idefics3ForConditionalGeneration,__webpack_exports__.Idefics3ImageProcessor,__webpack_exports__.Idefics3PreTrainedModel,__webpack_exports__.Idefics3Processor,__webpack_exports__.ImageClassificationPipeline,__webpack_exports__.ImageFeatureExtractionPipeline,__webpack_exports__.ImageFeatureExtractor,__webpack_exports__.ImageMattingOutput,__webpack_exports__.ImageProcessor,__webpack_exports__.ImageSegmentationPipeline,__webpack_exports__.ImageToImagePipeline,__webpack_exports__.ImageToTextPipeline,__webpack_exports__.InterruptableStoppingCriteria,__webpack_exports__.JAISLMHeadModel,__webpack_exports__.JAISModel,__webpack_exports__.JAISPreTrainedModel,__webpack_exports__.JinaCLIPImageProcessor,__webpack_exports__.JinaCLIPModel,__webpack_exports__.JinaCLIPPreTrainedModel,__webpack_exports__.JinaCLIPProcessor,__webpack_exports__.JinaCLIPTextModel,__webpack_exports__.JinaCLIPVisionModel,__webpack_exports__.LiteWhisperForConditionalGeneration,__webpack_exports__.LlamaForCausalLM,__webpack_exports__.LlamaModel,__webpack_exports__.LlamaPreTrainedModel,__webpack_exports__.LlamaTokenizer,__webpack_exports__.LlavaForConditionalGeneration,__webpack_exports__.LlavaOnevisionForConditionalGeneration,__webpack_exports__.LlavaOnevisionImageProcessor,__webpack_exports__.LlavaPreTrainedModel,__webpack_exports__.LogitsProcessor,__webpack_exports__.LogitsProcessorList,__webpack_exports__.LogitsWarper,__webpack_exports__.LongT5ForConditionalGeneration,__webpack_exports__.LongT5Model,__webpack_exports__.LongT5PreTrainedModel,__webpack_exports__.M2M100ForConditionalGeneration,__webpack_exports__.M2M100Model,__webpack_exports__.M2M100PreTrainedModel,__webpack_exports__.M2M100Tokenizer,__webpack_exports__.MBart50Tokenizer,__webpack_exports__.MBartForCausalLM,__webpack_exports__.MBartForConditionalGeneration,__webpack_exports__.MBartForSequenceClassification,__webpack_exports__.MBartModel,__webpack_exports__.MBartPreTrainedModel,__webpack_exports__.MBartTokenizer,__webpack_exports__.MPNetForMaskedLM,__webpack_exports__.MPNetForQuestionAnswering,__webpack_exports__.MPNetForSequenceClassification,__webpack_exports__.MPNetForTokenClassification,__webpack_exports__.MPNetModel,__webpack_exports__.MPNetPreTrainedModel,__webpack_exports__.MPNetTokenizer,__webpack_exports__.MT5ForConditionalGeneration,__webpack_exports__.MT5Model,__webpack_exports__.MT5PreTrainedModel,__webpack_exports__.MarianMTModel,__webpack_exports__.MarianModel,__webpack_exports__.MarianPreTrainedModel,__webpack_exports__.MarianTokenizer,__webpack_exports__.Mask2FormerImageProcessor,__webpack_exports__.MaskFormerFeatureExtractor,__webpack_exports__.MaskFormerForInstanceSegmentation,__webpack_exports__.MaskFormerImageProcessor,__webpack_exports__.MaskFormerModel,__webpack_exports__.MaskFormerPreTrainedModel,__webpack_exports__.MaskedLMOutput,__webpack_exports__.MaxLengthCriteria,__webpack_exports__.MgpstrForSceneTextRecognition,__webpack_exports__.MgpstrModelOutput,__webpack_exports__.MgpstrPreTrainedModel,__webpack_exports__.MgpstrProcessor,__webpack_exports__.MgpstrTokenizer,__webpack_exports__.MimiDecoderModel,__webpack_exports__.MimiDecoderOutput,__webpack_exports__.MimiEncoderModel,__webpack_exports__.MimiEncoderOutput,__webpack_exports__.MimiModel,__webpack_exports__.MimiPreTrainedModel,__webpack_exports__.MinLengthLogitsProcessor,__webpack_exports__.MinNewTokensLengthLogitsProcessor,__webpack_exports__.MistralForCausalLM,__webpack_exports__.MistralModel,__webpack_exports__.MistralPreTrainedModel,__webpack_exports__.MobileBertForMaskedLM,__webpack_exports__.MobileBertForQuestionAnswering,__webpack_exports__.MobileBertForSequenceClassification,__webpack_exports__.MobileBertModel,__webpack_exports__.MobileBertPreTrainedModel,__webpack_exports__.MobileBertTokenizer,__webpack_exports__.MobileLLMForCausalLM,__webpack_exports__.MobileLLMModel,__webpack_exports__.MobileLLMPreTrainedModel,__webpack_exports__.MobileNetV1FeatureExtractor,__webpack_exports__.MobileNetV1ForImageClassification,__webpack_exports__.MobileNetV1ForSemanticSegmentation,__webpack_exports__.MobileNetV1ImageProcessor,__webpack_exports__.MobileNetV1Model,__webpack_exports__.MobileNetV1PreTrainedModel,__webpack_exports__.MobileNetV2FeatureExtractor,__webpack_exports__.MobileNetV2ForImageClassification,__webpack_exports__.MobileNetV2ForSemanticSegmentation,__webpack_exports__.MobileNetV2ImageProcessor,__webpack_exports__.MobileNetV2Model,__webpack_exports__.MobileNetV2PreTrainedModel,__webpack_exports__.MobileNetV3FeatureExtractor,__webpack_exports__.MobileNetV3ForImageClassification,__webpack_exports__.MobileNetV3ForSemanticSegmentation,__webpack_exports__.MobileNetV3ImageProcessor,__webpack_exports__.MobileNetV3Model,__webpack_exports__.MobileNetV3PreTrainedModel,__webpack_exports__.MobileNetV4FeatureExtractor,__webpack_exports__.MobileNetV4ForImageClassification,__webpack_exports__.MobileNetV4ForSemanticSegmentation,__webpack_exports__.MobileNetV4ImageProcessor,__webpack_exports__.MobileNetV4Model,__webpack_exports__.MobileNetV4PreTrainedModel,__webpack_exports__.MobileViTFeatureExtractor,__webpack_exports__.MobileViTForImageClassification,__webpack_exports__.MobileViTImageProcessor,__webpack_exports__.MobileViTModel,__webpack_exports__.MobileViTPreTrainedModel,__webpack_exports__.MobileViTV2ForImageClassification,__webpack_exports__.MobileViTV2Model,__webpack_exports__.MobileViTV2PreTrainedModel,__webpack_exports__.ModelOutput,__webpack_exports__.ModernBertForMaskedLM,__webpack_exports__.ModernBertForSequenceClassification,__webpack_exports__.ModernBertForTokenClassification,__webpack_exports__.ModernBertModel,__webpack_exports__.ModernBertPreTrainedModel,__webpack_exports__.Moondream1ForConditionalGeneration,__webpack_exports__.MoonshineFeatureExtractor,__webpack_exports__.MoonshineForConditionalGeneration,__webpack_exports__.MoonshineModel,__webpack_exports__.MoonshinePreTrainedModel,__webpack_exports__.MoonshineProcessor,__webpack_exports__.MptForCausalLM,__webpack_exports__.MptModel,__webpack_exports__.MptPreTrainedModel,__webpack_exports__.MultiModalityCausalLM,__webpack_exports__.MultiModalityPreTrainedModel,__webpack_exports__.MusicgenForCausalLM,__webpack_exports__.MusicgenForConditionalGeneration,__webpack_exports__.MusicgenModel,__webpack_exports__.MusicgenPreTrainedModel,__webpack_exports__.NllbTokenizer,__webpack_exports__.NoBadWordsLogitsProcessor,__webpack_exports__.NoRepeatNGramLogitsProcessor,__webpack_exports__.NomicBertModel,__webpack_exports__.NomicBertPreTrainedModel,__webpack_exports__.NougatImageProcessor,__webpack_exports__.NougatTokenizer,__webpack_exports__.OPTForCausalLM,__webpack_exports__.OPTModel,__webpack_exports__.OPTPreTrainedModel,__webpack_exports__.ObjectDetectionPipeline,__webpack_exports__.Olmo2ForCausalLM,__webpack_exports__.Olmo2Model,__webpack_exports__.Olmo2PreTrainedModel,__webpack_exports__.OlmoForCausalLM,__webpack_exports__.OlmoModel,__webpack_exports__.OlmoPreTrainedModel,__webpack_exports__.OpenELMForCausalLM,__webpack_exports__.OpenELMModel,__webpack_exports__.OpenELMPreTrainedModel,__webpack_exports__.OwlViTFeatureExtractor,__webpack_exports__.OwlViTForObjectDetection,__webpack_exports__.OwlViTImageProcessor,__webpack_exports__.OwlViTModel,__webpack_exports__.OwlViTPreTrainedModel,__webpack_exports__.OwlViTProcessor,__webpack_exports__.Owlv2ForObjectDetection,__webpack_exports__.Owlv2ImageProcessor,__webpack_exports__.Owlv2Model,__webpack_exports__.Owlv2PreTrainedModel,__webpack_exports__.PaliGemmaForConditionalGeneration,__webpack_exports__.PaliGemmaPreTrainedModel,__webpack_exports__.PaliGemmaProcessor,__webpack_exports__.PatchTSMixerForPrediction,__webpack_exports__.PatchTSMixerModel,__webpack_exports__.PatchTSMixerPreTrainedModel,__webpack_exports__.PatchTSTForPrediction,__webpack_exports__.PatchTSTModel,__webpack_exports__.PatchTSTPreTrainedModel,__webpack_exports__.Phi3ForCausalLM,__webpack_exports__.Phi3Model,__webpack_exports__.Phi3PreTrainedModel,__webpack_exports__.Phi3VForCausalLM,__webpack_exports__.Phi3VImageProcessor,__webpack_exports__.Phi3VPreTrainedModel,__webpack_exports__.Phi3VProcessor,__webpack_exports__.PhiForCausalLM,__webpack_exports__.PhiModel,__webpack_exports__.PhiPreTrainedModel,__webpack_exports__.Pipeline,__webpack_exports__.PreTrainedModel,__webpack_exports__.PreTrainedTokenizer,__webpack_exports__.PretrainedConfig,__webpack_exports__.PretrainedMixin,__webpack_exports__.Processor,__webpack_exports__.PvtForImageClassification,__webpack_exports__.PvtImageProcessor,__webpack_exports__.PvtModel,__webpack_exports__.PvtPreTrainedModel,__webpack_exports__.PyAnnoteFeatureExtractor,__webpack_exports__.PyAnnoteForAudioFrameClassification,__webpack_exports__.PyAnnoteModel,__webpack_exports__.PyAnnotePreTrainedModel,__webpack_exports__.PyAnnoteProcessor,__webpack_exports__.QuestionAnsweringModelOutput,__webpack_exports__.QuestionAnsweringPipeline,__webpack_exports__.Qwen2ForCausalLM,__webpack_exports__.Qwen2Model,__webpack_exports__.Qwen2PreTrainedModel,__webpack_exports__.Qwen2Tokenizer,__webpack_exports__.Qwen2VLForConditionalGeneration,__webpack_exports__.Qwen2VLImageProcessor,__webpack_exports__.Qwen2VLPreTrainedModel,__webpack_exports__.Qwen2VLProcessor,__webpack_exports__.RTDetrForObjectDetection,__webpack_exports__.RTDetrImageProcessor,__webpack_exports__.RTDetrModel,__webpack_exports__.RTDetrObjectDetectionOutput,__webpack_exports__.RTDetrPreTrainedModel,__webpack_exports__.RawAudio,__webpack_exports__.RawImage,__webpack_exports__.RawVideo,__webpack_exports__.RawVideoFrame,__webpack_exports__.RepetitionPenaltyLogitsProcessor,__webpack_exports__.ResNetForImageClassification,__webpack_exports__.ResNetModel,__webpack_exports__.ResNetPreTrainedModel,__webpack_exports__.RoFormerForMaskedLM,__webpack_exports__.RoFormerForQuestionAnswering,__webpack_exports__.RoFormerForSequenceClassification,__webpack_exports__.RoFormerForTokenClassification,__webpack_exports__.RoFormerModel,__webpack_exports__.RoFormerPreTrainedModel,__webpack_exports__.RoFormerTokenizer,__webpack_exports__.RobertaForMaskedLM,__webpack_exports__.RobertaForQuestionAnswering,__webpack_exports__.RobertaForSequenceClassification,__webpack_exports__.RobertaForTokenClassification,__webpack_exports__.RobertaModel,__webpack_exports__.RobertaPreTrainedModel,__webpack_exports__.RobertaTokenizer,__webpack_exports__.SamImageProcessor,__webpack_exports__.SamImageSegmentationOutput,__webpack_exports__.SamModel,__webpack_exports__.SamPreTrainedModel,__webpack_exports__.SamProcessor,__webpack_exports__.SapiensForDepthEstimation,__webpack_exports__.SapiensForNormalEstimation,__webpack_exports__.SapiensForSemanticSegmentation,__webpack_exports__.SapiensPreTrainedModel,__webpack_exports__.SeamlessM4TFeatureExtractor,__webpack_exports__.SegformerFeatureExtractor,__webpack_exports__.SegformerForImageClassification,__webpack_exports__.SegformerForSemanticSegmentation,__webpack_exports__.SegformerImageProcessor,__webpack_exports__.SegformerModel,__webpack_exports__.SegformerPreTrainedModel,__webpack_exports__.Seq2SeqLMOutput,__webpack_exports__.SequenceClassifierOutput,__webpack_exports__.SiglipImageProcessor,__webpack_exports__.SiglipModel,__webpack_exports__.SiglipPreTrainedModel,__webpack_exports__.SiglipTextModel,__webpack_exports__.SiglipTokenizer,__webpack_exports__.SiglipVisionModel,__webpack_exports__.SmolVLMForConditionalGeneration,__webpack_exports__.SmolVLMImageProcessor,__webpack_exports__.SmolVLMProcessor,__webpack_exports__.SpeechT5FeatureExtractor,__webpack_exports__.SpeechT5ForSpeechToText,__webpack_exports__.SpeechT5ForTextToSpeech,__webpack_exports__.SpeechT5HifiGan,__webpack_exports__.SpeechT5Model,__webpack_exports__.SpeechT5PreTrainedModel,__webpack_exports__.SpeechT5Processor,__webpack_exports__.SpeechT5Tokenizer,__webpack_exports__.SqueezeBertForMaskedLM,__webpack_exports__.SqueezeBertForQuestionAnswering,__webpack_exports__.SqueezeBertForSequenceClassification,__webpack_exports__.SqueezeBertModel,__webpack_exports__.SqueezeBertPreTrainedModel,__webpack_exports__.SqueezeBertTokenizer,__webpack_exports__.StableLmForCausalLM,__webpack_exports__.StableLmModel,__webpack_exports__.StableLmPreTrainedModel,__webpack_exports__.Starcoder2ForCausalLM,__webpack_exports__.Starcoder2Model,__webpack_exports__.Starcoder2PreTrainedModel,__webpack_exports__.StoppingCriteria,__webpack_exports__.StoppingCriteriaList,__webpack_exports__.StyleTextToSpeech2Model,__webpack_exports__.StyleTextToSpeech2PreTrainedModel,__webpack_exports__.SummarizationPipeline,__webpack_exports__.SuppressTokensAtBeginLogitsProcessor,__webpack_exports__.Swin2SRForImageSuperResolution,__webpack_exports__.Swin2SRImageProcessor,__webpack_exports__.Swin2SRModel,__webpack_exports__.Swin2SRPreTrainedModel,__webpack_exports__.SwinForImageClassification,__webpack_exports__.SwinForSemanticSegmentation,__webpack_exports__.SwinModel,__webpack_exports__.SwinPreTrainedModel,__webpack_exports__.T5ForConditionalGeneration,__webpack_exports__.T5Model,__webpack_exports__.T5PreTrainedModel,__webpack_exports__.T5Tokenizer,__webpack_exports__.TableTransformerForObjectDetection,__webpack_exports__.TableTransformerModel,__webpack_exports__.TableTransformerObjectDetectionOutput,__webpack_exports__.TableTransformerPreTrainedModel,__webpack_exports__.TemperatureLogitsWarper,__webpack_exports__.Tensor,__webpack_exports__.Text2TextGenerationPipeline,__webpack_exports__.TextClassificationPipeline,__webpack_exports__.TextGenerationPipeline,__webpack_exports__.TextStreamer,__webpack_exports__.TextToAudioPipeline,__webpack_exports__.TokenClassificationPipeline,__webpack_exports__.TokenClassifierOutput,__webpack_exports__.TokenizerModel,__webpack_exports__.TopKLogitsWarper,__webpack_exports__.TopPLogitsWarper,__webpack_exports__.TrOCRForCausalLM,__webpack_exports__.TrOCRPreTrainedModel,__webpack_exports__.TranslationPipeline,__webpack_exports__.UltravoxModel,__webpack_exports__.UltravoxPreTrainedModel,__webpack_exports__.UltravoxProcessor,__webpack_exports__.UniSpeechForCTC,__webpack_exports__.UniSpeechForSequenceClassification,__webpack_exports__.UniSpeechModel,__webpack_exports__.UniSpeechPreTrainedModel,__webpack_exports__.UniSpeechSatForAudioFrameClassification,__webpack_exports__.UniSpeechSatForCTC,__webpack_exports__.UniSpeechSatForSequenceClassification,__webpack_exports__.UniSpeechSatModel,__webpack_exports__.UniSpeechSatPreTrainedModel,__webpack_exports__.VLChatProcessor,__webpack_exports__.VLMImageProcessor,__webpack_exports__.ViTFeatureExtractor,__webpack_exports__.ViTForImageClassification,__webpack_exports__.ViTImageProcessor,__webpack_exports__.ViTMAEModel,__webpack_exports__.ViTMAEPreTrainedModel,__webpack_exports__.ViTMSNForImageClassification,__webpack_exports__.ViTMSNModel,__webpack_exports__.ViTMSNPreTrainedModel,__webpack_exports__.ViTModel,__webpack_exports__.ViTPreTrainedModel,__webpack_exports__.VisionEncoderDecoderModel,__webpack_exports__.VitMatteForImageMatting,__webpack_exports__.VitMatteImageProcessor,__webpack_exports__.VitMattePreTrainedModel,__webpack_exports__.VitPoseForPoseEstimation,__webpack_exports__.VitPoseImageProcessor,__webpack_exports__.VitPosePreTrainedModel,__webpack_exports__.VitsModel,__webpack_exports__.VitsModelOutput,__webpack_exports__.VitsPreTrainedModel,__webpack_exports__.VitsTokenizer,__webpack_exports__.Wav2Vec2BertForCTC,__webpack_exports__.Wav2Vec2BertForSequenceClassification,__webpack_exports__.Wav2Vec2BertModel,__webpack_exports__.Wav2Vec2BertPreTrainedModel,__webpack_exports__.Wav2Vec2CTCTokenizer,__webpack_exports__.Wav2Vec2FeatureExtractor,__webpack_exports__.Wav2Vec2ForAudioFrameClassification,__webpack_exports__.Wav2Vec2ForCTC,__webpack_exports__.Wav2Vec2ForSequenceClassification,__webpack_exports__.Wav2Vec2Model,__webpack_exports__.Wav2Vec2PreTrainedModel,__webpack_exports__.Wav2Vec2Processor,__webpack_exports__.Wav2Vec2ProcessorWithLM,__webpack_exports__.WavLMForAudioFrameClassification,__webpack_exports__.WavLMForCTC,__webpack_exports__.WavLMForSequenceClassification,__webpack_exports__.WavLMForXVector,__webpack_exports__.WavLMModel,__webpack_exports__.WavLMPreTrainedModel,__webpack_exports__.WeSpeakerFeatureExtractor,__webpack_exports__.WeSpeakerResNetModel,__webpack_exports__.WeSpeakerResNetPreTrainedModel,__webpack_exports__.WhisperFeatureExtractor,__webpack_exports__.WhisperForConditionalGeneration,__webpack_exports__.WhisperModel,__webpack_exports__.WhisperPreTrainedModel,__webpack_exports__.WhisperProcessor,__webpack_exports__.WhisperTextStreamer,__webpack_exports__.WhisperTimeStampLogitsProcessor,__webpack_exports__.WhisperTokenizer,__webpack_exports__.XLMForQuestionAnswering,__webpack_exports__.XLMForSequenceClassification,__webpack_exports__.XLMForTokenClassification,__webpack_exports__.XLMModel,__webpack_exports__.XLMPreTrainedModel,__webpack_exports__.XLMRobertaForMaskedLM,__webpack_exports__.XLMRobertaForQuestionAnswering,__webpack_exports__.XLMRobertaForSequenceClassification,__webpack_exports__.XLMRobertaForTokenClassification,__webpack_exports__.XLMRobertaModel,__webpack_exports__.XLMRobertaPreTrainedModel,__webpack_exports__.XLMRobertaTokenizer,__webpack_exports__.XLMTokenizer,__webpack_exports__.XLMWithLMHeadModel,__webpack_exports__.XVectorOutput,__webpack_exports__.YolosFeatureExtractor,__webpack_exports__.YolosForObjectDetection,__webpack_exports__.YolosImageProcessor,__webpack_exports__.YolosModel,__webpack_exports__.YolosObjectDetectionOutput,__webpack_exports__.YolosPreTrainedModel,__webpack_exports__.ZeroShotAudioClassificationPipeline,__webpack_exports__.ZeroShotClassificationPipeline,__webpack_exports__.ZeroShotImageClassificationPipeline,__webpack_exports__.ZeroShotObjectDetectionPipeline,__webpack_exports__.bankers_round,__webpack_exports__.cat,__webpack_exports__.cos_sim,__webpack_exports__.dot,__webpack_exports__.dynamic_time_warping,__webpack_exports__.env,__webpack_exports__.full,__webpack_exports__.full_like,__webpack_exports__.getKeyValueShapes,__webpack_exports__.hamming,__webpack_exports__.hanning,__webpack_exports__.interpolate,__webpack_exports__.interpolate_4d,__webpack_exports__.interpolate_data,__webpack_exports__.is_chinese_char,__webpack_exports__.layer_norm,__webpack_exports__.load_image,__webpack_exports__.load_video,__webpack_exports__.log_softmax,__webpack_exports__.magnitude,__webpack_exports__.matmul,__webpack_exports__.max,__webpack_exports__.mean,__webpack_exports__.mean_pooling,__webpack_exports__.medianFilter,__webpack_exports__.mel_filter_bank,__webpack_exports__.min,__webpack_exports__.ones,__webpack_exports__.ones_like,__webpack_exports__.permute,__webpack_exports__.permute_data;var __webpack_exports__pipeline=__webpack_exports__.pipeline;__webpack_exports__.quantize_embeddings,__webpack_exports__.rand,__webpack_exports__.read_audio,__webpack_exports__.rfft,__webpack_exports__.round,__webpack_exports__.slice,__webpack_exports__.softmax,__webpack_exports__.spectrogram,__webpack_exports__.stack,__webpack_exports__.std_mean,__webpack_exports__.topk,__webpack_exports__.window_function,__webpack_exports__.zeros,__webpack_exports__.zeros_like;var VoiceController=function(){function e(e,t){var r,n,a,o,i;void 0===t&&(t={}),this.commandHandlers=e,this.onModelLoadStarted=null!==(r=t.onModelLoadStarted)&&void 0!==r?r:function(){Log.log("VoiceController.onModelLoadStarted()")},this.onModelLoaded=null!==(n=t.onModelLoaded)&&void 0!==n?n:function(){Log.log("VoiceController.onModelLoaded()")},this.onTranscribeStarted=null!==(a=t.onTranscribeStarted)&&void 0!==a?a:function(){Log.log("VoiceController.onTranscribeStarted()")},this.onTranscribeStopped=null!==(o=t.onTranscribeStopped)&&void 0!==o?o:function(){Log.log("VoiceController.onTranscribeStopped()")},this.onTranscriptionCommitted=null!==(i=t.onTranscriptionCommitted)&&void 0!==i?i:function(){Log.log("VoiceController.onTranscriptionCommitted()")}}return e.normalizeText=function(e){return e.toLowerCase().replace(/[^\w\s]|_/g,"")},e}(),KeywordSpotter=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t.onTranscriptionUpdated=function(e){e&&(Log.log("KeywordSpotter.onTranscriptionUpdated("+e+")"),e=VoiceController.normalizeText(e),void 0!==t.commandHandlers[e]&&t.commandHandlers[e]())},t}return __extends(t,e),t}(VoiceController),IntentClassifier=function(e){function t(t,r,n,a){void 0===r&&(r={}),void 0===n&&(n="Xenova/all-MiniLM-L6-v2"),void 0===a&&(a=void 0);var o=e.call(this,t,r)||this;return o.onTranscriptionUpdated=function(e){e&&o.getIntent(e).then((function(t){o.commandHandlers[t](VoiceController.normalizeText(e),o)}))},__webpack_exports__pipeline("feature-extraction",n).then((function(e){o.featureExtractor=e,void 0===a?o.getAllEmbeddings(Object.keys(t)).then((function(e){o.preComputedEmbeddings=e})):o.preComputedEmbeddings=a})),o}return __extends(t,e),t.cosineSimilarity=function(e,t){for(var r=0,n=0,a=0,o=0;o<e.length;o++)r+=e[o]*t[o],n+=e[o]*e[o],a+=t[o]*t[o];return r/((n=Math.sqrt(n))*(a=Math.sqrt(a)))},t.maxIndex=function(e){if(0===e.length)return-1;for(var t=e[0],r=0,n=1;n<e.length;n++)e[n]>t&&(r=n,t=e[n]);return r},t.prototype.getEmbeddings=function(e){return __awaiter(this,void 0,void 0,(function(){return __generator(this,(function(t){switch(t.label){case 0:return[4,this.featureExtractor(e,{pooling:"mean",normalize:!0})];case 1:return[2,t.sent().ort_tensor.cpuData]}}))}))},t.prototype.getAllEmbeddings=function(e){return __awaiter(this,void 0,void 0,(function(){var t,r,n;return __generator(this,(function(a){switch(a.label){case 0:t=[],r=0,a.label=1;case 1:return r<e.length?[4,this.getEmbeddings(e[r])]:[3,4];case 2:n=a.sent(),t.push(n),a.label=3;case 3:return r++,[3,1];case 4:return[2,t]}}))}))},t.prototype.getCosineSimilarityScores=function(e,r){var n=[];return r.forEach((function(r){n.push(t.cosineSimilarity(e,r))})),n},t.prototype.getMostSimilar=function(e,r){return __awaiter(this,void 0,void 0,(function(){var n,a,o;return __generator(this,(function(i){switch(i.label){case 0:return[4,this.getEmbeddings(e)];case 1:return n=i.sent(),[4,this.getAllEmbeddings(r)];case 2:return a=i.sent(),o=this.getCosineSimilarityScores(n,a),[2,r[t.maxIndex(o)]]}}))}))},t.prototype.getIntent=function(e){return __awaiter(this,void 0,void 0,(function(){var r,n;return __generator(this,(function(a){switch(a.label){case 0:return[4,this.getEmbeddings(e)];case 1:return r=a.sent(),n=this.getCosineSimilarityScores(r,this.preComputedEmbeddings),Log.log("getIntent() => "+e+" "+n),[2,Object.keys(this.commandHandlers)[t.maxIndex(n)]]}}))}))},t}(VoiceController);export{IntentClassifier,KeywordSpotter,MediaElementTranscriber,MicrophoneTranscriber,MoonshineModel,MoonshineSpeechRecognition,Settings,StreamTranscriber,VoiceController};
